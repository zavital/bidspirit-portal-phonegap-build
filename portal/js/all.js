/**
 * @license AngularJS v1.4.7
 * (c) 2010-2015 Google, Inc. http://angularjs.org
 * License: MIT
 */

/**
 * State-based routing for AngularJS
 * @version v0.2.15
 * @link http://angular-ui.github.com/
 * @license MIT License, http://www.opensource.org/licenses/MIT
 */

/**
 * @license Copyright 2013 Logentries.
 * Please view license at https://raw.github.com/logentries/le_js/master/LICENSE
 */

/**
 * @license RequireJS domReady 2.0.1 Copyright (c) 2010-2012, The Dojo Foundation All Rights Reserved.
 * Available via the MIT or new BSD license.
 * see: http://github.com/requirejs/domReady for details
 */

/**
     * @preserve FastClick: polyfill to remove click delays on browsers with touch UIs.
     *
     * @codingstandard ftlabs-jsv2
     * @copyright The Financial Times Limited [All Rights Reserved]
     * @license MIT License (see LICENSE.txt)
     */

function getServiceForDebug(serviceName) {
    return angular.element(document.body).injector().get(serviceName);
}

function getServiceForDebug(serviceName) {
    return angular.element(document.body).injector().get(serviceName);
}

!function(window, document, undefined) {
    function minErr(module, ErrorConstructor) {
        return ErrorConstructor = ErrorConstructor || Error, function() {
            var paramPrefix, i, SKIP_INDEXES = 2, templateArgs = arguments, code = templateArgs[0], message = "[" + (module ? module + ":" : "") + code + "] ", template = templateArgs[1];
            for (message += template.replace(/\{\d+\}/g, function(match) {
                var index = +match.slice(1, -1), shiftedIndex = index + SKIP_INDEXES;
                return shiftedIndex < templateArgs.length ? toDebugString(templateArgs[shiftedIndex]) : match;
            }), message += "\nhttp://errors.angularjs.org/1.4.7/" + (module ? module + "/" : "") + code, 
            i = SKIP_INDEXES, paramPrefix = "?"; i < templateArgs.length; i++, paramPrefix = "&") message += paramPrefix + "p" + (i - SKIP_INDEXES) + "=" + encodeURIComponent(toDebugString(templateArgs[i]));
            return new ErrorConstructor(message);
        };
    }
    function isArrayLike(obj) {
        if (null == obj || isWindow(obj)) return !1;
        var length = "length" in Object(obj) && obj.length;
        return obj.nodeType === NODE_TYPE_ELEMENT && length ? !0 : isString(obj) || isArray(obj) || 0 === length || "number" == typeof length && length > 0 && length - 1 in obj;
    }
    function forEach(obj, iterator, context) {
        var key, length;
        if (obj) if (isFunction(obj)) for (key in obj) "prototype" == key || "length" == key || "name" == key || obj.hasOwnProperty && !obj.hasOwnProperty(key) || iterator.call(context, obj[key], key, obj); else if (isArray(obj) || isArrayLike(obj)) {
            var isPrimitive = "object" != typeof obj;
            for (key = 0, length = obj.length; length > key; key++) (isPrimitive || key in obj) && iterator.call(context, obj[key], key, obj);
        } else if (obj.forEach && obj.forEach !== forEach) obj.forEach(iterator, context, obj); else if (isBlankObject(obj)) for (key in obj) iterator.call(context, obj[key], key, obj); else if ("function" == typeof obj.hasOwnProperty) for (key in obj) obj.hasOwnProperty(key) && iterator.call(context, obj[key], key, obj); else for (key in obj) hasOwnProperty.call(obj, key) && iterator.call(context, obj[key], key, obj);
        return obj;
    }
    function forEachSorted(obj, iterator, context) {
        for (var keys = Object.keys(obj).sort(), i = 0; i < keys.length; i++) iterator.call(context, obj[keys[i]], keys[i]);
        return keys;
    }
    function reverseParams(iteratorFn) {
        return function(value, key) {
            iteratorFn(key, value);
        };
    }
    function nextUid() {
        return ++uid;
    }
    function setHashKey(obj, h) {
        h ? obj.$$hashKey = h : delete obj.$$hashKey;
    }
    function baseExtend(dst, objs, deep) {
        for (var h = dst.$$hashKey, i = 0, ii = objs.length; ii > i; ++i) {
            var obj = objs[i];
            if (isObject(obj) || isFunction(obj)) for (var keys = Object.keys(obj), j = 0, jj = keys.length; jj > j; j++) {
                var key = keys[j], src = obj[key];
                deep && isObject(src) ? isDate(src) ? dst[key] = new Date(src.valueOf()) : isRegExp(src) ? dst[key] = new RegExp(src) : (isObject(dst[key]) || (dst[key] = isArray(src) ? [] : {}), 
                baseExtend(dst[key], [ src ], !0)) : dst[key] = src;
            }
        }
        return setHashKey(dst, h), dst;
    }
    function extend(dst) {
        return baseExtend(dst, slice.call(arguments, 1), !1);
    }
    function merge(dst) {
        return baseExtend(dst, slice.call(arguments, 1), !0);
    }
    function toInt(str) {
        return parseInt(str, 10);
    }
    function inherit(parent, extra) {
        return extend(Object.create(parent), extra);
    }
    function noop() {}
    function identity($) {
        return $;
    }
    function valueFn(value) {
        return function() {
            return value;
        };
    }
    function hasCustomToString(obj) {
        return isFunction(obj.toString) && obj.toString !== Object.prototype.toString;
    }
    function isUndefined(value) {
        return "undefined" == typeof value;
    }
    function isDefined(value) {
        return "undefined" != typeof value;
    }
    function isObject(value) {
        return null !== value && "object" == typeof value;
    }
    function isBlankObject(value) {
        return null !== value && "object" == typeof value && !getPrototypeOf(value);
    }
    function isString(value) {
        return "string" == typeof value;
    }
    function isNumber(value) {
        return "number" == typeof value;
    }
    function isDate(value) {
        return "[object Date]" === toString.call(value);
    }
    function isFunction(value) {
        return "function" == typeof value;
    }
    function isRegExp(value) {
        return "[object RegExp]" === toString.call(value);
    }
    function isWindow(obj) {
        return obj && obj.window === obj;
    }
    function isScope(obj) {
        return obj && obj.$evalAsync && obj.$watch;
    }
    function isFile(obj) {
        return "[object File]" === toString.call(obj);
    }
    function isFormData(obj) {
        return "[object FormData]" === toString.call(obj);
    }
    function isBlob(obj) {
        return "[object Blob]" === toString.call(obj);
    }
    function isBoolean(value) {
        return "boolean" == typeof value;
    }
    function isPromiseLike(obj) {
        return obj && isFunction(obj.then);
    }
    function isTypedArray(value) {
        return TYPED_ARRAY_REGEXP.test(toString.call(value));
    }
    function isElement(node) {
        return !(!node || !(node.nodeName || node.prop && node.attr && node.find));
    }
    function makeMap(str) {
        var i, obj = {}, items = str.split(",");
        for (i = 0; i < items.length; i++) obj[items[i]] = !0;
        return obj;
    }
    function nodeName_(element) {
        return lowercase(element.nodeName || element[0] && element[0].nodeName);
    }
    function arrayRemove(array, value) {
        var index = array.indexOf(value);
        return index >= 0 && array.splice(index, 1), index;
    }
    function copy(source, destination, stackSource, stackDest) {
        if (isWindow(source) || isScope(source)) throw ngMinErr("cpws", "Can't copy! Making copies of Window or Scope instances is not supported.");
        if (isTypedArray(destination)) throw ngMinErr("cpta", "Can't copy! TypedArray destination cannot be mutated.");
        if (destination) {
            if (source === destination) throw ngMinErr("cpi", "Can't copy! Source and destination are identical.");
            stackSource = stackSource || [], stackDest = stackDest || [], isObject(source) && (stackSource.push(source), 
            stackDest.push(destination));
            var key;
            if (isArray(source)) {
                destination.length = 0;
                for (var i = 0; i < source.length; i++) destination.push(copy(source[i], null, stackSource, stackDest));
            } else {
                var h = destination.$$hashKey;
                if (isArray(destination) ? destination.length = 0 : forEach(destination, function(value, key) {
                    delete destination[key];
                }), isBlankObject(source)) for (key in source) destination[key] = copy(source[key], null, stackSource, stackDest); else if (source && "function" == typeof source.hasOwnProperty) for (key in source) source.hasOwnProperty(key) && (destination[key] = copy(source[key], null, stackSource, stackDest)); else for (key in source) hasOwnProperty.call(source, key) && (destination[key] = copy(source[key], null, stackSource, stackDest));
                setHashKey(destination, h);
            }
        } else if (destination = source, isObject(source)) {
            var index;
            if (stackSource && -1 !== (index = stackSource.indexOf(source))) return stackDest[index];
            if (isArray(source)) return copy(source, [], stackSource, stackDest);
            if (isTypedArray(source)) destination = new source.constructor(source); else if (isDate(source)) destination = new Date(source.getTime()); else if (isRegExp(source)) destination = new RegExp(source.source, source.toString().match(/[^\/]*$/)[0]), 
            destination.lastIndex = source.lastIndex; else {
                if (!isFunction(source.cloneNode)) {
                    var emptyObject = Object.create(getPrototypeOf(source));
                    return copy(source, emptyObject, stackSource, stackDest);
                }
                destination = source.cloneNode(!0);
            }
            stackDest && (stackSource.push(source), stackDest.push(destination));
        }
        return destination;
    }
    function shallowCopy(src, dst) {
        if (isArray(src)) {
            dst = dst || [];
            for (var i = 0, ii = src.length; ii > i; i++) dst[i] = src[i];
        } else if (isObject(src)) {
            dst = dst || {};
            for (var key in src) ("$" !== key.charAt(0) || "$" !== key.charAt(1)) && (dst[key] = src[key]);
        }
        return dst || src;
    }
    function equals(o1, o2) {
        if (o1 === o2) return !0;
        if (null === o1 || null === o2) return !1;
        if (o1 !== o1 && o2 !== o2) return !0;
        var length, key, keySet, t1 = typeof o1, t2 = typeof o2;
        if (t1 == t2 && "object" == t1) {
            if (!isArray(o1)) {
                if (isDate(o1)) return isDate(o2) ? equals(o1.getTime(), o2.getTime()) : !1;
                if (isRegExp(o1)) return isRegExp(o2) ? o1.toString() == o2.toString() : !1;
                if (isScope(o1) || isScope(o2) || isWindow(o1) || isWindow(o2) || isArray(o2) || isDate(o2) || isRegExp(o2)) return !1;
                keySet = createMap();
                for (key in o1) if ("$" !== key.charAt(0) && !isFunction(o1[key])) {
                    if (!equals(o1[key], o2[key])) return !1;
                    keySet[key] = !0;
                }
                for (key in o2) if (!(key in keySet) && "$" !== key.charAt(0) && isDefined(o2[key]) && !isFunction(o2[key])) return !1;
                return !0;
            }
            if (!isArray(o2)) return !1;
            if ((length = o1.length) == o2.length) {
                for (key = 0; length > key; key++) if (!equals(o1[key], o2[key])) return !1;
                return !0;
            }
        }
        return !1;
    }
    function concat(array1, array2, index) {
        return array1.concat(slice.call(array2, index));
    }
    function sliceArgs(args, startIndex) {
        return slice.call(args, startIndex || 0);
    }
    function bind(self, fn) {
        var curryArgs = arguments.length > 2 ? sliceArgs(arguments, 2) : [];
        return !isFunction(fn) || fn instanceof RegExp ? fn : curryArgs.length ? function() {
            return arguments.length ? fn.apply(self, concat(curryArgs, arguments, 0)) : fn.apply(self, curryArgs);
        } : function() {
            return arguments.length ? fn.apply(self, arguments) : fn.call(self);
        };
    }
    function toJsonReplacer(key, value) {
        var val = value;
        return "string" == typeof key && "$" === key.charAt(0) && "$" === key.charAt(1) ? val = undefined : isWindow(value) ? val = "$WINDOW" : value && document === value ? val = "$DOCUMENT" : isScope(value) && (val = "$SCOPE"), 
        val;
    }
    function toJson(obj, pretty) {
        return "undefined" == typeof obj ? undefined : (isNumber(pretty) || (pretty = pretty ? 2 : null), 
        JSON.stringify(obj, toJsonReplacer, pretty));
    }
    function fromJson(json) {
        return isString(json) ? JSON.parse(json) : json;
    }
    function timezoneToOffset(timezone, fallback) {
        var requestedTimezoneOffset = Date.parse("Jan 01, 1970 00:00:00 " + timezone) / 6e4;
        return isNaN(requestedTimezoneOffset) ? fallback : requestedTimezoneOffset;
    }
    function addDateMinutes(date, minutes) {
        return date = new Date(date.getTime()), date.setMinutes(date.getMinutes() + minutes), 
        date;
    }
    function convertTimezoneToLocal(date, timezone, reverse) {
        reverse = reverse ? -1 : 1;
        var timezoneOffset = timezoneToOffset(timezone, date.getTimezoneOffset());
        return addDateMinutes(date, reverse * (timezoneOffset - date.getTimezoneOffset()));
    }
    function startingTag(element) {
        element = jqLite(element).clone();
        try {
            element.empty();
        } catch (e) {}
        var elemHtml = jqLite("<div>").append(element).html();
        try {
            return element[0].nodeType === NODE_TYPE_TEXT ? lowercase(elemHtml) : elemHtml.match(/^(<[^>]+>)/)[1].replace(/^<([\w\-]+)/, function(match, nodeName) {
                return "<" + lowercase(nodeName);
            });
        } catch (e) {
            return lowercase(elemHtml);
        }
    }
    function tryDecodeURIComponent(value) {
        try {
            return decodeURIComponent(value);
        } catch (e) {}
    }
    function parseKeyValue(keyValue) {
        var obj = {};
        return forEach((keyValue || "").split("&"), function(keyValue) {
            var splitPoint, key, val;
            keyValue && (key = keyValue = keyValue.replace(/\+/g, "%20"), splitPoint = keyValue.indexOf("="), 
            -1 !== splitPoint && (key = keyValue.substring(0, splitPoint), val = keyValue.substring(splitPoint + 1)), 
            key = tryDecodeURIComponent(key), isDefined(key) && (val = isDefined(val) ? tryDecodeURIComponent(val) : !0, 
            hasOwnProperty.call(obj, key) ? isArray(obj[key]) ? obj[key].push(val) : obj[key] = [ obj[key], val ] : obj[key] = val));
        }), obj;
    }
    function toKeyValue(obj) {
        var parts = [];
        return forEach(obj, function(value, key) {
            isArray(value) ? forEach(value, function(arrayValue) {
                parts.push(encodeUriQuery(key, !0) + (arrayValue === !0 ? "" : "=" + encodeUriQuery(arrayValue, !0)));
            }) : parts.push(encodeUriQuery(key, !0) + (value === !0 ? "" : "=" + encodeUriQuery(value, !0)));
        }), parts.length ? parts.join("&") : "";
    }
    function encodeUriSegment(val) {
        return encodeUriQuery(val, !0).replace(/%26/gi, "&").replace(/%3D/gi, "=").replace(/%2B/gi, "+");
    }
    function encodeUriQuery(val, pctEncodeSpaces) {
        return encodeURIComponent(val).replace(/%40/gi, "@").replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%3B/gi, ";").replace(/%20/g, pctEncodeSpaces ? "%20" : "+");
    }
    function getNgAttribute(element, ngAttr) {
        var attr, i, ii = ngAttrPrefixes.length;
        for (i = 0; ii > i; ++i) if (attr = ngAttrPrefixes[i] + ngAttr, isString(attr = element.getAttribute(attr))) return attr;
        return null;
    }
    function angularInit(element, bootstrap) {
        var appElement, module, config = {};
        forEach(ngAttrPrefixes, function(prefix) {
            var name = prefix + "app";
            !appElement && element.hasAttribute && element.hasAttribute(name) && (appElement = element, 
            module = element.getAttribute(name));
        }), forEach(ngAttrPrefixes, function(prefix) {
            var candidate, name = prefix + "app";
            !appElement && (candidate = element.querySelector("[" + name.replace(":", "\\:") + "]")) && (appElement = candidate, 
            module = candidate.getAttribute(name));
        }), appElement && (config.strictDi = null !== getNgAttribute(appElement, "strict-di"), 
        bootstrap(appElement, module ? [ module ] : [], config));
    }
    function bootstrap(element, modules, config) {
        isObject(config) || (config = {});
        var defaultConfig = {
            strictDi: !1
        };
        config = extend(defaultConfig, config);
        var doBootstrap = function() {
            if (element = jqLite(element), element.injector()) {
                var tag = element[0] === document ? "document" : startingTag(element);
                throw ngMinErr("btstrpd", "App Already Bootstrapped with this Element '{0}'", tag.replace(/</, "&lt;").replace(/>/, "&gt;"));
            }
            modules = modules || [], modules.unshift([ "$provide", function($provide) {
                $provide.value("$rootElement", element);
            } ]), config.debugInfoEnabled && modules.push([ "$compileProvider", function($compileProvider) {
                $compileProvider.debugInfoEnabled(!0);
            } ]), modules.unshift("ng");
            var injector = createInjector(modules, config.strictDi);
            return injector.invoke([ "$rootScope", "$rootElement", "$compile", "$injector", function(scope, element, compile, injector) {
                scope.$apply(function() {
                    element.data("$injector", injector), compile(element)(scope);
                });
            } ]), injector;
        }, NG_ENABLE_DEBUG_INFO = /^NG_ENABLE_DEBUG_INFO!/, NG_DEFER_BOOTSTRAP = /^NG_DEFER_BOOTSTRAP!/;
        return window && NG_ENABLE_DEBUG_INFO.test(window.name) && (config.debugInfoEnabled = !0, 
        window.name = window.name.replace(NG_ENABLE_DEBUG_INFO, "")), window && !NG_DEFER_BOOTSTRAP.test(window.name) ? doBootstrap() : (window.name = window.name.replace(NG_DEFER_BOOTSTRAP, ""), 
        angular.resumeBootstrap = function(extraModules) {
            return forEach(extraModules, function(module) {
                modules.push(module);
            }), doBootstrap();
        }, void (isFunction(angular.resumeDeferredBootstrap) && angular.resumeDeferredBootstrap()));
    }
    function reloadWithDebugInfo() {
        window.name = "NG_ENABLE_DEBUG_INFO!" + window.name, window.location.reload();
    }
    function getTestability(rootElement) {
        var injector = angular.element(rootElement).injector();
        if (!injector) throw ngMinErr("test", "no injector found for element argument to getTestability");
        return injector.get("$$testability");
    }
    function snake_case(name, separator) {
        return separator = separator || "_", name.replace(SNAKE_CASE_REGEXP, function(letter, pos) {
            return (pos ? separator : "") + letter.toLowerCase();
        });
    }
    function bindJQuery() {
        var originalCleanData;
        if (!bindJQueryFired) {
            var jqName = jq();
            jQuery = isUndefined(jqName) ? window.jQuery : jqName ? window[jqName] : undefined, 
            jQuery && jQuery.fn.on ? (jqLite = jQuery, extend(jQuery.fn, {
                scope: JQLitePrototype.scope,
                isolateScope: JQLitePrototype.isolateScope,
                controller: JQLitePrototype.controller,
                injector: JQLitePrototype.injector,
                inheritedData: JQLitePrototype.inheritedData
            }), originalCleanData = jQuery.cleanData, jQuery.cleanData = function(elems) {
                var events;
                if (skipDestroyOnNextJQueryCleanData) skipDestroyOnNextJQueryCleanData = !1; else for (var elem, i = 0; null != (elem = elems[i]); i++) events = jQuery._data(elem, "events"), 
                events && events.$destroy && jQuery(elem).triggerHandler("$destroy");
                originalCleanData(elems);
            }) : jqLite = JQLite, angular.element = jqLite, bindJQueryFired = !0;
        }
    }
    function assertArg(arg, name, reason) {
        if (!arg) throw ngMinErr("areq", "Argument '{0}' is {1}", name || "?", reason || "required");
        return arg;
    }
    function assertArgFn(arg, name, acceptArrayAnnotation) {
        return acceptArrayAnnotation && isArray(arg) && (arg = arg[arg.length - 1]), assertArg(isFunction(arg), name, "not a function, got " + (arg && "object" == typeof arg ? arg.constructor.name || "Object" : typeof arg)), 
        arg;
    }
    function assertNotHasOwnProperty(name, context) {
        if ("hasOwnProperty" === name) throw ngMinErr("badname", "hasOwnProperty is not a valid {0} name", context);
    }
    function getter(obj, path, bindFnToScope) {
        if (!path) return obj;
        for (var key, keys = path.split("."), lastInstance = obj, len = keys.length, i = 0; len > i; i++) key = keys[i], 
        obj && (obj = (lastInstance = obj)[key]);
        return !bindFnToScope && isFunction(obj) ? bind(lastInstance, obj) : obj;
    }
    function getBlockNodes(nodes) {
        for (var blockNodes, node = nodes[0], endNode = nodes[nodes.length - 1], i = 1; node !== endNode && (node = node.nextSibling); i++) (blockNodes || nodes[i] !== node) && (blockNodes || (blockNodes = jqLite(slice.call(nodes, 0, i))), 
        blockNodes.push(node));
        return blockNodes || nodes;
    }
    function createMap() {
        return Object.create(null);
    }
    function setupModuleLoader(window) {
        function ensure(obj, name, factory) {
            return obj[name] || (obj[name] = factory());
        }
        var $injectorMinErr = minErr("$injector"), ngMinErr = minErr("ng"), angular = ensure(window, "angular", Object);
        return angular.$$minErr = angular.$$minErr || minErr, ensure(angular, "module", function() {
            var modules = {};
            return function(name, requires, configFn) {
                var assertNotHasOwnProperty = function(name, context) {
                    if ("hasOwnProperty" === name) throw ngMinErr("badname", "hasOwnProperty is not a valid {0} name", context);
                };
                return assertNotHasOwnProperty(name, "module"), requires && modules.hasOwnProperty(name) && (modules[name] = null), 
                ensure(modules, name, function() {
                    function invokeLater(provider, method, insertMethod, queue) {
                        return queue || (queue = invokeQueue), function() {
                            return queue[insertMethod || "push"]([ provider, method, arguments ]), moduleInstance;
                        };
                    }
                    function invokeLaterAndSetModuleName(provider, method) {
                        return function(recipeName, factoryFunction) {
                            return factoryFunction && isFunction(factoryFunction) && (factoryFunction.$$moduleName = name), 
                            invokeQueue.push([ provider, method, arguments ]), moduleInstance;
                        };
                    }
                    if (!requires) throw $injectorMinErr("nomod", "Module '{0}' is not available! You either misspelled the module name or forgot to load it. If registering a module ensure that you specify the dependencies as the second argument.", name);
                    var invokeQueue = [], configBlocks = [], runBlocks = [], config = invokeLater("$injector", "invoke", "push", configBlocks), moduleInstance = {
                        _invokeQueue: invokeQueue,
                        _configBlocks: configBlocks,
                        _runBlocks: runBlocks,
                        requires: requires,
                        name: name,
                        provider: invokeLaterAndSetModuleName("$provide", "provider"),
                        factory: invokeLaterAndSetModuleName("$provide", "factory"),
                        service: invokeLaterAndSetModuleName("$provide", "service"),
                        value: invokeLater("$provide", "value"),
                        constant: invokeLater("$provide", "constant", "unshift"),
                        decorator: invokeLaterAndSetModuleName("$provide", "decorator"),
                        animation: invokeLaterAndSetModuleName("$animateProvider", "register"),
                        filter: invokeLaterAndSetModuleName("$filterProvider", "register"),
                        controller: invokeLaterAndSetModuleName("$controllerProvider", "register"),
                        directive: invokeLaterAndSetModuleName("$compileProvider", "directive"),
                        config: config,
                        run: function(block) {
                            return runBlocks.push(block), this;
                        }
                    };
                    return configFn && config(configFn), moduleInstance;
                });
            };
        });
    }
    function serializeObject(obj) {
        var seen = [];
        return JSON.stringify(obj, function(key, val) {
            if (val = toJsonReplacer(key, val), isObject(val)) {
                if (seen.indexOf(val) >= 0) return "...";
                seen.push(val);
            }
            return val;
        });
    }
    function toDebugString(obj) {
        return "function" == typeof obj ? obj.toString().replace(/ \{[\s\S]*$/, "") : isUndefined(obj) ? "undefined" : "string" != typeof obj ? serializeObject(obj) : obj;
    }
    function publishExternalAPI(angular) {
        extend(angular, {
            bootstrap: bootstrap,
            copy: copy,
            extend: extend,
            merge: merge,
            equals: equals,
            element: jqLite,
            forEach: forEach,
            injector: createInjector,
            noop: noop,
            bind: bind,
            toJson: toJson,
            fromJson: fromJson,
            identity: identity,
            isUndefined: isUndefined,
            isDefined: isDefined,
            isString: isString,
            isFunction: isFunction,
            isObject: isObject,
            isNumber: isNumber,
            isElement: isElement,
            isArray: isArray,
            version: version,
            isDate: isDate,
            lowercase: lowercase,
            uppercase: uppercase,
            callbacks: {
                counter: 0
            },
            getTestability: getTestability,
            $$minErr: minErr,
            $$csp: csp,
            reloadWithDebugInfo: reloadWithDebugInfo
        }), (angularModule = setupModuleLoader(window))("ng", [ "ngLocale" ], [ "$provide", function($provide) {
            $provide.provider({
                $$sanitizeUri: $$SanitizeUriProvider
            }), $provide.provider("$compile", $CompileProvider).directive({
                a: htmlAnchorDirective,
                input: inputDirective,
                textarea: inputDirective,
                form: formDirective,
                script: scriptDirective,
                select: selectDirective,
                style: styleDirective,
                option: optionDirective,
                ngBind: ngBindDirective,
                ngBindHtml: ngBindHtmlDirective,
                ngBindTemplate: ngBindTemplateDirective,
                ngClass: ngClassDirective,
                ngClassEven: ngClassEvenDirective,
                ngClassOdd: ngClassOddDirective,
                ngCloak: ngCloakDirective,
                ngController: ngControllerDirective,
                ngForm: ngFormDirective,
                ngHide: ngHideDirective,
                ngIf: ngIfDirective,
                ngInclude: ngIncludeDirective,
                ngInit: ngInitDirective,
                ngNonBindable: ngNonBindableDirective,
                ngPluralize: ngPluralizeDirective,
                ngRepeat: ngRepeatDirective,
                ngShow: ngShowDirective,
                ngStyle: ngStyleDirective,
                ngSwitch: ngSwitchDirective,
                ngSwitchWhen: ngSwitchWhenDirective,
                ngSwitchDefault: ngSwitchDefaultDirective,
                ngOptions: ngOptionsDirective,
                ngTransclude: ngTranscludeDirective,
                ngModel: ngModelDirective,
                ngList: ngListDirective,
                ngChange: ngChangeDirective,
                pattern: patternDirective,
                ngPattern: patternDirective,
                required: requiredDirective,
                ngRequired: requiredDirective,
                minlength: minlengthDirective,
                ngMinlength: minlengthDirective,
                maxlength: maxlengthDirective,
                ngMaxlength: maxlengthDirective,
                ngValue: ngValueDirective,
                ngModelOptions: ngModelOptionsDirective
            }).directive({
                ngInclude: ngIncludeFillContentDirective
            }).directive(ngAttributeAliasDirectives).directive(ngEventDirectives), $provide.provider({
                $anchorScroll: $AnchorScrollProvider,
                $animate: $AnimateProvider,
                $animateCss: $CoreAnimateCssProvider,
                $$animateQueue: $$CoreAnimateQueueProvider,
                $$AnimateRunner: $$CoreAnimateRunnerProvider,
                $browser: $BrowserProvider,
                $cacheFactory: $CacheFactoryProvider,
                $controller: $ControllerProvider,
                $document: $DocumentProvider,
                $exceptionHandler: $ExceptionHandlerProvider,
                $filter: $FilterProvider,
                $$forceReflow: $$ForceReflowProvider,
                $interpolate: $InterpolateProvider,
                $interval: $IntervalProvider,
                $http: $HttpProvider,
                $httpParamSerializer: $HttpParamSerializerProvider,
                $httpParamSerializerJQLike: $HttpParamSerializerJQLikeProvider,
                $httpBackend: $HttpBackendProvider,
                $xhrFactory: $xhrFactoryProvider,
                $location: $LocationProvider,
                $log: $LogProvider,
                $parse: $ParseProvider,
                $rootScope: $RootScopeProvider,
                $q: $QProvider,
                $$q: $$QProvider,
                $sce: $SceProvider,
                $sceDelegate: $SceDelegateProvider,
                $sniffer: $SnifferProvider,
                $templateCache: $TemplateCacheProvider,
                $templateRequest: $TemplateRequestProvider,
                $$testability: $$TestabilityProvider,
                $timeout: $TimeoutProvider,
                $window: $WindowProvider,
                $$rAF: $$RAFProvider,
                $$jqLite: $$jqLiteProvider,
                $$HashMap: $$HashMapProvider,
                $$cookieReader: $$CookieReaderProvider
            });
        } ]);
    }
    function jqNextId() {
        return ++jqId;
    }
    function camelCase(name) {
        return name.replace(SPECIAL_CHARS_REGEXP, function(_, separator, letter, offset) {
            return offset ? letter.toUpperCase() : letter;
        }).replace(MOZ_HACK_REGEXP, "Moz$1");
    }
    function jqLiteIsTextNode(html) {
        return !HTML_REGEXP.test(html);
    }
    function jqLiteAcceptsData(node) {
        var nodeType = node.nodeType;
        return nodeType === NODE_TYPE_ELEMENT || !nodeType || nodeType === NODE_TYPE_DOCUMENT;
    }
    function jqLiteHasData(node) {
        for (var key in jqCache[node.ng339]) return !0;
        return !1;
    }
    function jqLiteBuildFragment(html, context) {
        var tmp, tag, wrap, i, fragment = context.createDocumentFragment(), nodes = [];
        if (jqLiteIsTextNode(html)) nodes.push(context.createTextNode(html)); else {
            for (tmp = tmp || fragment.appendChild(context.createElement("div")), tag = (TAG_NAME_REGEXP.exec(html) || [ "", "" ])[1].toLowerCase(), 
            wrap = wrapMap[tag] || wrapMap._default, tmp.innerHTML = wrap[1] + html.replace(XHTML_TAG_REGEXP, "<$1></$2>") + wrap[2], 
            i = wrap[0]; i--; ) tmp = tmp.lastChild;
            nodes = concat(nodes, tmp.childNodes), tmp = fragment.firstChild, tmp.textContent = "";
        }
        return fragment.textContent = "", fragment.innerHTML = "", forEach(nodes, function(node) {
            fragment.appendChild(node);
        }), fragment;
    }
    function jqLiteParseHTML(html, context) {
        context = context || document;
        var parsed;
        return (parsed = SINGLE_TAG_REGEXP.exec(html)) ? [ context.createElement(parsed[1]) ] : (parsed = jqLiteBuildFragment(html, context)) ? parsed.childNodes : [];
    }
    function JQLite(element) {
        if (element instanceof JQLite) return element;
        var argIsString;
        if (isString(element) && (element = trim(element), argIsString = !0), !(this instanceof JQLite)) {
            if (argIsString && "<" != element.charAt(0)) throw jqLiteMinErr("nosel", "Looking up elements via selectors is not supported by jqLite! See: http://docs.angularjs.org/api/angular.element");
            return new JQLite(element);
        }
        argIsString ? jqLiteAddNodes(this, jqLiteParseHTML(element)) : jqLiteAddNodes(this, element);
    }
    function jqLiteClone(element) {
        return element.cloneNode(!0);
    }
    function jqLiteDealoc(element, onlyDescendants) {
        if (onlyDescendants || jqLiteRemoveData(element), element.querySelectorAll) for (var descendants = element.querySelectorAll("*"), i = 0, l = descendants.length; l > i; i++) jqLiteRemoveData(descendants[i]);
    }
    function jqLiteOff(element, type, fn, unsupported) {
        if (isDefined(unsupported)) throw jqLiteMinErr("offargs", "jqLite#off() does not support the `selector` argument");
        var expandoStore = jqLiteExpandoStore(element), events = expandoStore && expandoStore.events, handle = expandoStore && expandoStore.handle;
        if (handle) if (type) forEach(type.split(" "), function(type) {
            if (isDefined(fn)) {
                var listenerFns = events[type];
                if (arrayRemove(listenerFns || [], fn), listenerFns && listenerFns.length > 0) return;
            }
            removeEventListenerFn(element, type, handle), delete events[type];
        }); else for (type in events) "$destroy" !== type && removeEventListenerFn(element, type, handle), 
        delete events[type];
    }
    function jqLiteRemoveData(element, name) {
        var expandoId = element.ng339, expandoStore = expandoId && jqCache[expandoId];
        if (expandoStore) {
            if (name) return void delete expandoStore.data[name];
            expandoStore.handle && (expandoStore.events.$destroy && expandoStore.handle({}, "$destroy"), 
            jqLiteOff(element)), delete jqCache[expandoId], element.ng339 = undefined;
        }
    }
    function jqLiteExpandoStore(element, createIfNecessary) {
        var expandoId = element.ng339, expandoStore = expandoId && jqCache[expandoId];
        return createIfNecessary && !expandoStore && (element.ng339 = expandoId = jqNextId(), 
        expandoStore = jqCache[expandoId] = {
            events: {},
            data: {},
            handle: undefined
        }), expandoStore;
    }
    function jqLiteData(element, key, value) {
        if (jqLiteAcceptsData(element)) {
            var isSimpleSetter = isDefined(value), isSimpleGetter = !isSimpleSetter && key && !isObject(key), massGetter = !key, expandoStore = jqLiteExpandoStore(element, !isSimpleGetter), data = expandoStore && expandoStore.data;
            if (isSimpleSetter) data[key] = value; else {
                if (massGetter) return data;
                if (isSimpleGetter) return data && data[key];
                extend(data, key);
            }
        }
    }
    function jqLiteHasClass(element, selector) {
        return element.getAttribute ? (" " + (element.getAttribute("class") || "") + " ").replace(/[\n\t]/g, " ").indexOf(" " + selector + " ") > -1 : !1;
    }
    function jqLiteRemoveClass(element, cssClasses) {
        cssClasses && element.setAttribute && forEach(cssClasses.split(" "), function(cssClass) {
            element.setAttribute("class", trim((" " + (element.getAttribute("class") || "") + " ").replace(/[\n\t]/g, " ").replace(" " + trim(cssClass) + " ", " ")));
        });
    }
    function jqLiteAddClass(element, cssClasses) {
        if (cssClasses && element.setAttribute) {
            var existingClasses = (" " + (element.getAttribute("class") || "") + " ").replace(/[\n\t]/g, " ");
            forEach(cssClasses.split(" "), function(cssClass) {
                cssClass = trim(cssClass), -1 === existingClasses.indexOf(" " + cssClass + " ") && (existingClasses += cssClass + " ");
            }), element.setAttribute("class", trim(existingClasses));
        }
    }
    function jqLiteAddNodes(root, elements) {
        if (elements) if (elements.nodeType) root[root.length++] = elements; else {
            var length = elements.length;
            if ("number" == typeof length && elements.window !== elements) {
                if (length) for (var i = 0; length > i; i++) root[root.length++] = elements[i];
            } else root[root.length++] = elements;
        }
    }
    function jqLiteController(element, name) {
        return jqLiteInheritedData(element, "$" + (name || "ngController") + "Controller");
    }
    function jqLiteInheritedData(element, name, value) {
        element.nodeType == NODE_TYPE_DOCUMENT && (element = element.documentElement);
        for (var names = isArray(name) ? name : [ name ]; element; ) {
            for (var i = 0, ii = names.length; ii > i; i++) if (isDefined(value = jqLite.data(element, names[i]))) return value;
            element = element.parentNode || element.nodeType === NODE_TYPE_DOCUMENT_FRAGMENT && element.host;
        }
    }
    function jqLiteEmpty(element) {
        for (jqLiteDealoc(element, !0); element.firstChild; ) element.removeChild(element.firstChild);
    }
    function jqLiteRemove(element, keepData) {
        keepData || jqLiteDealoc(element);
        var parent = element.parentNode;
        parent && parent.removeChild(element);
    }
    function jqLiteDocumentLoaded(action, win) {
        win = win || window, "complete" === win.document.readyState ? win.setTimeout(action) : jqLite(win).on("load", action);
    }
    function getBooleanAttrName(element, name) {
        var booleanAttr = BOOLEAN_ATTR[name.toLowerCase()];
        return booleanAttr && BOOLEAN_ELEMENTS[nodeName_(element)] && booleanAttr;
    }
    function getAliasedAttrName(name) {
        return ALIASED_ATTR[name];
    }
    function createEventHandler(element, events) {
        var eventHandler = function(event, type) {
            event.isDefaultPrevented = function() {
                return event.defaultPrevented;
            };
            var eventFns = events[type || event.type], eventFnsLength = eventFns ? eventFns.length : 0;
            if (eventFnsLength) {
                if (isUndefined(event.immediatePropagationStopped)) {
                    var originalStopImmediatePropagation = event.stopImmediatePropagation;
                    event.stopImmediatePropagation = function() {
                        event.immediatePropagationStopped = !0, event.stopPropagation && event.stopPropagation(), 
                        originalStopImmediatePropagation && originalStopImmediatePropagation.call(event);
                    };
                }
                event.isImmediatePropagationStopped = function() {
                    return event.immediatePropagationStopped === !0;
                }, eventFnsLength > 1 && (eventFns = shallowCopy(eventFns));
                for (var i = 0; eventFnsLength > i; i++) event.isImmediatePropagationStopped() || eventFns[i].call(element, event);
            }
        };
        return eventHandler.elem = element, eventHandler;
    }
    function $$jqLiteProvider() {
        this.$get = function() {
            return extend(JQLite, {
                hasClass: function(node, classes) {
                    return node.attr && (node = node[0]), jqLiteHasClass(node, classes);
                },
                addClass: function(node, classes) {
                    return node.attr && (node = node[0]), jqLiteAddClass(node, classes);
                },
                removeClass: function(node, classes) {
                    return node.attr && (node = node[0]), jqLiteRemoveClass(node, classes);
                }
            });
        };
    }
    function hashKey(obj, nextUidFn) {
        var key = obj && obj.$$hashKey;
        if (key) return "function" == typeof key && (key = obj.$$hashKey()), key;
        var objType = typeof obj;
        return key = "function" == objType || "object" == objType && null !== obj ? obj.$$hashKey = objType + ":" + (nextUidFn || nextUid)() : objType + ":" + obj;
    }
    function HashMap(array, isolatedUid) {
        if (isolatedUid) {
            var uid = 0;
            this.nextUid = function() {
                return ++uid;
            };
        }
        forEach(array, this.put, this);
    }
    function anonFn(fn) {
        var fnText = fn.toString().replace(STRIP_COMMENTS, ""), args = fnText.match(FN_ARGS);
        return args ? "function(" + (args[1] || "").replace(/[\s\r\n]+/, " ") + ")" : "fn";
    }
    function annotate(fn, strictDi, name) {
        var $inject, fnText, argDecl, last;
        if ("function" == typeof fn) {
            if (!($inject = fn.$inject)) {
                if ($inject = [], fn.length) {
                    if (strictDi) throw isString(name) && name || (name = fn.name || anonFn(fn)), $injectorMinErr("strictdi", "{0} is not using explicit annotation and cannot be invoked in strict mode", name);
                    fnText = fn.toString().replace(STRIP_COMMENTS, ""), argDecl = fnText.match(FN_ARGS), 
                    forEach(argDecl[1].split(FN_ARG_SPLIT), function(arg) {
                        arg.replace(FN_ARG, function(all, underscore, name) {
                            $inject.push(name);
                        });
                    });
                }
                fn.$inject = $inject;
            }
        } else isArray(fn) ? (last = fn.length - 1, assertArgFn(fn[last], "fn"), $inject = fn.slice(0, last)) : assertArgFn(fn, "fn", !0);
        return $inject;
    }
    function createInjector(modulesToLoad, strictDi) {
        function supportObject(delegate) {
            return function(key, value) {
                return isObject(key) ? void forEach(key, reverseParams(delegate)) : delegate(key, value);
            };
        }
        function provider(name, provider_) {
            if (assertNotHasOwnProperty(name, "service"), (isFunction(provider_) || isArray(provider_)) && (provider_ = providerInjector.instantiate(provider_)), 
            !provider_.$get) throw $injectorMinErr("pget", "Provider '{0}' must define $get factory method.", name);
            return providerCache[name + providerSuffix] = provider_;
        }
        function enforceReturnValue(name, factory) {
            return function() {
                var result = instanceInjector.invoke(factory, this);
                if (isUndefined(result)) throw $injectorMinErr("undef", "Provider '{0}' must return a value from $get factory method.", name);
                return result;
            };
        }
        function factory(name, factoryFn, enforce) {
            return provider(name, {
                $get: enforce !== !1 ? enforceReturnValue(name, factoryFn) : factoryFn
            });
        }
        function service(name, constructor) {
            return factory(name, [ "$injector", function($injector) {
                return $injector.instantiate(constructor);
            } ]);
        }
        function value(name, val) {
            return factory(name, valueFn(val), !1);
        }
        function constant(name, value) {
            assertNotHasOwnProperty(name, "constant"), providerCache[name] = value, instanceCache[name] = value;
        }
        function decorator(serviceName, decorFn) {
            var origProvider = providerInjector.get(serviceName + providerSuffix), orig$get = origProvider.$get;
            origProvider.$get = function() {
                var origInstance = instanceInjector.invoke(orig$get, origProvider);
                return instanceInjector.invoke(decorFn, null, {
                    $delegate: origInstance
                });
            };
        }
        function loadModules(modulesToLoad) {
            assertArg(isUndefined(modulesToLoad) || isArray(modulesToLoad), "modulesToLoad", "not an array");
            var moduleFn, runBlocks = [];
            return forEach(modulesToLoad, function(module) {
                function runInvokeQueue(queue) {
                    var i, ii;
                    for (i = 0, ii = queue.length; ii > i; i++) {
                        var invokeArgs = queue[i], provider = providerInjector.get(invokeArgs[0]);
                        provider[invokeArgs[1]].apply(provider, invokeArgs[2]);
                    }
                }
                if (!loadedModules.get(module)) {
                    loadedModules.put(module, !0);
                    try {
                        isString(module) ? (moduleFn = angularModule(module), runBlocks = runBlocks.concat(loadModules(moduleFn.requires)).concat(moduleFn._runBlocks), 
                        runInvokeQueue(moduleFn._invokeQueue), runInvokeQueue(moduleFn._configBlocks)) : isFunction(module) ? runBlocks.push(providerInjector.invoke(module)) : isArray(module) ? runBlocks.push(providerInjector.invoke(module)) : assertArgFn(module, "module");
                    } catch (e) {
                        throw isArray(module) && (module = module[module.length - 1]), e.message && e.stack && -1 == e.stack.indexOf(e.message) && (e = e.message + "\n" + e.stack), 
                        $injectorMinErr("modulerr", "Failed to instantiate module {0} due to:\n{1}", module, e.stack || e.message || e);
                    }
                }
            }), runBlocks;
        }
        function createInternalInjector(cache, factory) {
            function getService(serviceName, caller) {
                if (cache.hasOwnProperty(serviceName)) {
                    if (cache[serviceName] === INSTANTIATING) throw $injectorMinErr("cdep", "Circular dependency found: {0}", serviceName + " <- " + path.join(" <- "));
                    return cache[serviceName];
                }
                try {
                    return path.unshift(serviceName), cache[serviceName] = INSTANTIATING, cache[serviceName] = factory(serviceName, caller);
                } catch (err) {
                    throw cache[serviceName] === INSTANTIATING && delete cache[serviceName], err;
                } finally {
                    path.shift();
                }
            }
            function invoke(fn, self, locals, serviceName) {
                "string" == typeof locals && (serviceName = locals, locals = null);
                var length, i, key, args = [], $inject = createInjector.$$annotate(fn, strictDi, serviceName);
                for (i = 0, length = $inject.length; length > i; i++) {
                    if (key = $inject[i], "string" != typeof key) throw $injectorMinErr("itkn", "Incorrect injection token! Expected service name as string, got {0}", key);
                    args.push(locals && locals.hasOwnProperty(key) ? locals[key] : getService(key, serviceName));
                }
                return isArray(fn) && (fn = fn[length]), fn.apply(self, args);
            }
            function instantiate(Type, locals, serviceName) {
                var instance = Object.create((isArray(Type) ? Type[Type.length - 1] : Type).prototype || null), returnedValue = invoke(Type, instance, locals, serviceName);
                return isObject(returnedValue) || isFunction(returnedValue) ? returnedValue : instance;
            }
            return {
                invoke: invoke,
                instantiate: instantiate,
                get: getService,
                annotate: createInjector.$$annotate,
                has: function(name) {
                    return providerCache.hasOwnProperty(name + providerSuffix) || cache.hasOwnProperty(name);
                }
            };
        }
        strictDi = strictDi === !0;
        var INSTANTIATING = {}, providerSuffix = "Provider", path = [], loadedModules = new HashMap([], !0), providerCache = {
            $provide: {
                provider: supportObject(provider),
                factory: supportObject(factory),
                service: supportObject(service),
                value: supportObject(value),
                constant: supportObject(constant),
                decorator: decorator
            }
        }, providerInjector = providerCache.$injector = createInternalInjector(providerCache, function(serviceName, caller) {
            throw angular.isString(caller) && path.push(caller), $injectorMinErr("unpr", "Unknown provider: {0}", path.join(" <- "));
        }), instanceCache = {}, instanceInjector = instanceCache.$injector = createInternalInjector(instanceCache, function(serviceName, caller) {
            var provider = providerInjector.get(serviceName + providerSuffix, caller);
            return instanceInjector.invoke(provider.$get, provider, undefined, serviceName);
        });
        return forEach(loadModules(modulesToLoad), function(fn) {
            fn && instanceInjector.invoke(fn);
        }), instanceInjector;
    }
    function $AnchorScrollProvider() {
        var autoScrollingEnabled = !0;
        this.disableAutoScrolling = function() {
            autoScrollingEnabled = !1;
        }, this.$get = [ "$window", "$location", "$rootScope", function($window, $location, $rootScope) {
            function getFirstAnchor(list) {
                var result = null;
                return Array.prototype.some.call(list, function(element) {
                    return "a" === nodeName_(element) ? (result = element, !0) : void 0;
                }), result;
            }
            function getYOffset() {
                var offset = scroll.yOffset;
                if (isFunction(offset)) offset = offset(); else if (isElement(offset)) {
                    var elem = offset[0], style = $window.getComputedStyle(elem);
                    offset = "fixed" !== style.position ? 0 : elem.getBoundingClientRect().bottom;
                } else isNumber(offset) || (offset = 0);
                return offset;
            }
            function scrollTo(elem) {
                if (elem) {
                    elem.scrollIntoView();
                    var offset = getYOffset();
                    if (offset) {
                        var elemTop = elem.getBoundingClientRect().top;
                        $window.scrollBy(0, elemTop - offset);
                    }
                } else $window.scrollTo(0, 0);
            }
            function scroll(hash) {
                hash = isString(hash) ? hash : $location.hash();
                var elm;
                hash ? (elm = document.getElementById(hash)) ? scrollTo(elm) : (elm = getFirstAnchor(document.getElementsByName(hash))) ? scrollTo(elm) : "top" === hash && scrollTo(null) : scrollTo(null);
            }
            var document = $window.document;
            return autoScrollingEnabled && $rootScope.$watch(function() {
                return $location.hash();
            }, function(newVal, oldVal) {
                (newVal !== oldVal || "" !== newVal) && jqLiteDocumentLoaded(function() {
                    $rootScope.$evalAsync(scroll);
                });
            }), scroll;
        } ];
    }
    function mergeClasses(a, b) {
        return a || b ? a ? b ? (isArray(a) && (a = a.join(" ")), isArray(b) && (b = b.join(" ")), 
        a + " " + b) : a : b : "";
    }
    function extractElementNode(element) {
        for (var i = 0; i < element.length; i++) {
            var elm = element[i];
            if (elm.nodeType === ELEMENT_NODE) return elm;
        }
    }
    function splitClasses(classes) {
        isString(classes) && (classes = classes.split(" "));
        var obj = createMap();
        return forEach(classes, function(klass) {
            klass.length && (obj[klass] = !0);
        }), obj;
    }
    function prepareAnimateOptions(options) {
        return isObject(options) ? options : {};
    }
    function Browser(window, document, $log, $sniffer) {
        function completeOutstandingRequest(fn) {
            try {
                fn.apply(null, sliceArgs(arguments, 1));
            } finally {
                if (outstandingRequestCount--, 0 === outstandingRequestCount) for (;outstandingRequestCallbacks.length; ) try {
                    outstandingRequestCallbacks.pop()();
                } catch (e) {
                    $log.error(e);
                }
            }
        }
        function getHash(url) {
            var index = url.indexOf("#");
            return -1 === index ? "" : url.substr(index);
        }
        function cacheStateAndFireUrlChange() {
            pendingLocation = null, cacheState(), fireUrlChange();
        }
        function getCurrentState() {
            try {
                return history.state;
            } catch (e) {}
        }
        function cacheState() {
            cachedState = getCurrentState(), cachedState = isUndefined(cachedState) ? null : cachedState, 
            equals(cachedState, lastCachedState) && (cachedState = lastCachedState), lastCachedState = cachedState;
        }
        function fireUrlChange() {
            (lastBrowserUrl !== self.url() || lastHistoryState !== cachedState) && (lastBrowserUrl = self.url(), 
            lastHistoryState = cachedState, forEach(urlChangeListeners, function(listener) {
                listener(self.url(), cachedState);
            }));
        }
        var self = this, location = (document[0], window.location), history = window.history, setTimeout = window.setTimeout, clearTimeout = window.clearTimeout, pendingDeferIds = {};
        self.isMock = !1;
        var outstandingRequestCount = 0, outstandingRequestCallbacks = [];
        self.$$completeOutstandingRequest = completeOutstandingRequest, self.$$incOutstandingRequestCount = function() {
            outstandingRequestCount++;
        }, self.notifyWhenNoOutstandingRequests = function(callback) {
            0 === outstandingRequestCount ? callback() : outstandingRequestCallbacks.push(callback);
        };
        var cachedState, lastHistoryState, lastBrowserUrl = location.href, baseElement = document.find("base"), pendingLocation = null;
        cacheState(), lastHistoryState = cachedState, self.url = function(url, replace, state) {
            if (isUndefined(state) && (state = null), location !== window.location && (location = window.location), 
            history !== window.history && (history = window.history), url) {
                var sameState = lastHistoryState === state;
                if (lastBrowserUrl === url && (!$sniffer.history || sameState)) return self;
                var sameBase = lastBrowserUrl && stripHash(lastBrowserUrl) === stripHash(url);
                return lastBrowserUrl = url, lastHistoryState = state, !$sniffer.history || sameBase && sameState ? ((!sameBase || pendingLocation) && (pendingLocation = url), 
                replace ? location.replace(url) : sameBase ? location.hash = getHash(url) : location.href = url, 
                location.href !== url && (pendingLocation = url)) : (history[replace ? "replaceState" : "pushState"](state, "", url), 
                cacheState(), lastHistoryState = cachedState), self;
            }
            return pendingLocation || location.href.replace(/%27/g, "'");
        }, self.state = function() {
            return cachedState;
        };
        var urlChangeListeners = [], urlChangeInit = !1, lastCachedState = null;
        self.onUrlChange = function(callback) {
            return urlChangeInit || ($sniffer.history && jqLite(window).on("popstate", cacheStateAndFireUrlChange), 
            jqLite(window).on("hashchange", cacheStateAndFireUrlChange), urlChangeInit = !0), 
            urlChangeListeners.push(callback), callback;
        }, self.$$applicationDestroyed = function() {
            jqLite(window).off("hashchange popstate", cacheStateAndFireUrlChange);
        }, self.$$checkUrlChange = fireUrlChange, self.baseHref = function() {
            var href = baseElement.attr("href");
            return href ? href.replace(/^(https?\:)?\/\/[^\/]*/, "") : "";
        }, self.defer = function(fn, delay) {
            var timeoutId;
            return outstandingRequestCount++, timeoutId = setTimeout(function() {
                delete pendingDeferIds[timeoutId], completeOutstandingRequest(fn);
            }, delay || 0), pendingDeferIds[timeoutId] = !0, timeoutId;
        }, self.defer.cancel = function(deferId) {
            return pendingDeferIds[deferId] ? (delete pendingDeferIds[deferId], clearTimeout(deferId), 
            completeOutstandingRequest(noop), !0) : !1;
        };
    }
    function $BrowserProvider() {
        this.$get = [ "$window", "$log", "$sniffer", "$document", function($window, $log, $sniffer, $document) {
            return new Browser($window, $document, $log, $sniffer);
        } ];
    }
    function $CacheFactoryProvider() {
        this.$get = function() {
            function cacheFactory(cacheId, options) {
                function refresh(entry) {
                    entry != freshEnd && (staleEnd ? staleEnd == entry && (staleEnd = entry.n) : staleEnd = entry, 
                    link(entry.n, entry.p), link(entry, freshEnd), freshEnd = entry, freshEnd.n = null);
                }
                function link(nextEntry, prevEntry) {
                    nextEntry != prevEntry && (nextEntry && (nextEntry.p = prevEntry), prevEntry && (prevEntry.n = nextEntry));
                }
                if (cacheId in caches) throw minErr("$cacheFactory")("iid", "CacheId '{0}' is already taken!", cacheId);
                var size = 0, stats = extend({}, options, {
                    id: cacheId
                }), data = {}, capacity = options && options.capacity || Number.MAX_VALUE, lruHash = {}, freshEnd = null, staleEnd = null;
                return caches[cacheId] = {
                    put: function(key, value) {
                        if (!isUndefined(value)) {
                            if (capacity < Number.MAX_VALUE) {
                                var lruEntry = lruHash[key] || (lruHash[key] = {
                                    key: key
                                });
                                refresh(lruEntry);
                            }
                            return key in data || size++, data[key] = value, size > capacity && this.remove(staleEnd.key), 
                            value;
                        }
                    },
                    get: function(key) {
                        if (capacity < Number.MAX_VALUE) {
                            var lruEntry = lruHash[key];
                            if (!lruEntry) return;
                            refresh(lruEntry);
                        }
                        return data[key];
                    },
                    remove: function(key) {
                        if (capacity < Number.MAX_VALUE) {
                            var lruEntry = lruHash[key];
                            if (!lruEntry) return;
                            lruEntry == freshEnd && (freshEnd = lruEntry.p), lruEntry == staleEnd && (staleEnd = lruEntry.n), 
                            link(lruEntry.n, lruEntry.p), delete lruHash[key];
                        }
                        delete data[key], size--;
                    },
                    removeAll: function() {
                        data = {}, size = 0, lruHash = {}, freshEnd = staleEnd = null;
                    },
                    destroy: function() {
                        data = null, stats = null, lruHash = null, delete caches[cacheId];
                    },
                    info: function() {
                        return extend({}, stats, {
                            size: size
                        });
                    }
                };
            }
            var caches = {};
            return cacheFactory.info = function() {
                var info = {};
                return forEach(caches, function(cache, cacheId) {
                    info[cacheId] = cache.info();
                }), info;
            }, cacheFactory.get = function(cacheId) {
                return caches[cacheId];
            }, cacheFactory;
        };
    }
    function $TemplateCacheProvider() {
        this.$get = [ "$cacheFactory", function($cacheFactory) {
            return $cacheFactory("templates");
        } ];
    }
    function $CompileProvider($provide, $$sanitizeUriProvider) {
        function parseIsolateBindings(scope, directiveName, isController) {
            var LOCAL_REGEXP = /^\s*([@&]|=(\*?))(\??)\s*(\w*)\s*$/, bindings = {};
            return forEach(scope, function(definition, scopeName) {
                var match = definition.match(LOCAL_REGEXP);
                if (!match) throw $compileMinErr("iscp", "Invalid {3} for directive '{0}'. Definition: {... {1}: '{2}' ...}", directiveName, scopeName, definition, isController ? "controller bindings definition" : "isolate scope definition");
                bindings[scopeName] = {
                    mode: match[1][0],
                    collection: "*" === match[2],
                    optional: "?" === match[3],
                    attrName: match[4] || scopeName
                };
            }), bindings;
        }
        function parseDirectiveBindings(directive, directiveName) {
            var bindings = {
                isolateScope: null,
                bindToController: null
            };
            if (isObject(directive.scope) && (directive.bindToController === !0 ? (bindings.bindToController = parseIsolateBindings(directive.scope, directiveName, !0), 
            bindings.isolateScope = {}) : bindings.isolateScope = parseIsolateBindings(directive.scope, directiveName, !1)), 
            isObject(directive.bindToController) && (bindings.bindToController = parseIsolateBindings(directive.bindToController, directiveName, !0)), 
            isObject(bindings.bindToController)) {
                var controller = directive.controller, controllerAs = directive.controllerAs;
                if (!controller) throw $compileMinErr("noctrl", "Cannot bind to controller without directive '{0}'s controller.", directiveName);
                if (!identifierForController(controller, controllerAs)) throw $compileMinErr("noident", "Cannot bind to controller without identifier for directive '{0}'.", directiveName);
            }
            return bindings;
        }
        function assertValidDirectiveName(name) {
            var letter = name.charAt(0);
            if (!letter || letter !== lowercase(letter)) throw $compileMinErr("baddir", "Directive name '{0}' is invalid. The first character must be a lowercase letter", name);
            if (name !== name.trim()) throw $compileMinErr("baddir", "Directive name '{0}' is invalid. The name should not contain leading or trailing whitespaces", name);
        }
        var hasDirectives = {}, Suffix = "Directive", COMMENT_DIRECTIVE_REGEXP = /^\s*directive\:\s*([\w\-]+)\s+(.*)$/, CLASS_DIRECTIVE_REGEXP = /(([\w\-]+)(?:\:([^;]+))?;?)/, ALL_OR_NOTHING_ATTRS = makeMap("ngSrc,ngSrcset,src,srcset"), REQUIRE_PREFIX_REGEXP = /^(?:(\^\^?)?(\?)?(\^\^?)?)?/, EVENT_HANDLER_ATTR_REGEXP = /^(on[a-z]+|formaction)$/;
        this.directive = function registerDirective(name, directiveFactory) {
            return assertNotHasOwnProperty(name, "directive"), isString(name) ? (assertValidDirectiveName(name), 
            assertArg(directiveFactory, "directiveFactory"), hasDirectives.hasOwnProperty(name) || (hasDirectives[name] = [], 
            $provide.factory(name + Suffix, [ "$injector", "$exceptionHandler", function($injector, $exceptionHandler) {
                var directives = [];
                return forEach(hasDirectives[name], function(directiveFactory, index) {
                    try {
                        var directive = $injector.invoke(directiveFactory);
                        isFunction(directive) ? directive = {
                            compile: valueFn(directive)
                        } : !directive.compile && directive.link && (directive.compile = valueFn(directive.link)), 
                        directive.priority = directive.priority || 0, directive.index = index, directive.name = directive.name || name, 
                        directive.require = directive.require || directive.controller && directive.name, 
                        directive.restrict = directive.restrict || "EA";
                        var bindings = directive.$$bindings = parseDirectiveBindings(directive, directive.name);
                        isObject(bindings.isolateScope) && (directive.$$isolateBindings = bindings.isolateScope), 
                        directive.$$moduleName = directiveFactory.$$moduleName, directives.push(directive);
                    } catch (e) {
                        $exceptionHandler(e);
                    }
                }), directives;
            } ])), hasDirectives[name].push(directiveFactory)) : forEach(name, reverseParams(registerDirective)), 
            this;
        }, this.aHrefSanitizationWhitelist = function(regexp) {
            return isDefined(regexp) ? ($$sanitizeUriProvider.aHrefSanitizationWhitelist(regexp), 
            this) : $$sanitizeUriProvider.aHrefSanitizationWhitelist();
        }, this.imgSrcSanitizationWhitelist = function(regexp) {
            return isDefined(regexp) ? ($$sanitizeUriProvider.imgSrcSanitizationWhitelist(regexp), 
            this) : $$sanitizeUriProvider.imgSrcSanitizationWhitelist();
        };
        var debugInfoEnabled = !0;
        this.debugInfoEnabled = function(enabled) {
            return isDefined(enabled) ? (debugInfoEnabled = enabled, this) : debugInfoEnabled;
        }, this.$get = [ "$injector", "$interpolate", "$exceptionHandler", "$templateRequest", "$parse", "$controller", "$rootScope", "$document", "$sce", "$animate", "$$sanitizeUri", function($injector, $interpolate, $exceptionHandler, $templateRequest, $parse, $controller, $rootScope, $document, $sce, $animate, $$sanitizeUri) {
            function safeAddClass($element, className) {
                try {
                    $element.addClass(className);
                } catch (e) {}
            }
            function compile($compileNodes, transcludeFn, maxPriority, ignoreDirective, previousCompileContext) {
                $compileNodes instanceof jqLite || ($compileNodes = jqLite($compileNodes)), forEach($compileNodes, function(node, index) {
                    node.nodeType == NODE_TYPE_TEXT && node.nodeValue.match(/\S+/) && ($compileNodes[index] = jqLite(node).wrap("<span></span>").parent()[0]);
                });
                var compositeLinkFn = compileNodes($compileNodes, transcludeFn, $compileNodes, maxPriority, ignoreDirective, previousCompileContext);
                compile.$$addScopeClass($compileNodes);
                var namespace = null;
                return function(scope, cloneConnectFn, options) {
                    assertArg(scope, "scope"), options = options || {};
                    var parentBoundTranscludeFn = options.parentBoundTranscludeFn, transcludeControllers = options.transcludeControllers, futureParentElement = options.futureParentElement;
                    parentBoundTranscludeFn && parentBoundTranscludeFn.$$boundTransclude && (parentBoundTranscludeFn = parentBoundTranscludeFn.$$boundTransclude), 
                    namespace || (namespace = detectNamespaceForChildElements(futureParentElement));
                    var $linkNode;
                    if ($linkNode = "html" !== namespace ? jqLite(wrapTemplate(namespace, jqLite("<div>").append($compileNodes).html())) : cloneConnectFn ? JQLitePrototype.clone.call($compileNodes) : $compileNodes, 
                    transcludeControllers) for (var controllerName in transcludeControllers) $linkNode.data("$" + controllerName + "Controller", transcludeControllers[controllerName].instance);
                    return compile.$$addScopeInfo($linkNode, scope), cloneConnectFn && cloneConnectFn($linkNode, scope), 
                    compositeLinkFn && compositeLinkFn(scope, $linkNode, $linkNode, parentBoundTranscludeFn), 
                    $linkNode;
                };
            }
            function detectNamespaceForChildElements(parentElement) {
                var node = parentElement && parentElement[0];
                return node && "foreignobject" !== nodeName_(node) && node.toString().match(/SVG/) ? "svg" : "html";
            }
            function compileNodes(nodeList, transcludeFn, $rootElement, maxPriority, ignoreDirective, previousCompileContext) {
                function compositeLinkFn(scope, nodeList, $rootElement, parentBoundTranscludeFn) {
                    var nodeLinkFn, childLinkFn, node, childScope, i, ii, idx, childBoundTranscludeFn, stableNodeList;
                    if (nodeLinkFnFound) {
                        var nodeListLength = nodeList.length;
                        for (stableNodeList = new Array(nodeListLength), i = 0; i < linkFns.length; i += 3) idx = linkFns[i], 
                        stableNodeList[idx] = nodeList[idx];
                    } else stableNodeList = nodeList;
                    for (i = 0, ii = linkFns.length; ii > i; ) if (node = stableNodeList[linkFns[i++]], 
                    nodeLinkFn = linkFns[i++], childLinkFn = linkFns[i++], nodeLinkFn) {
                        if (nodeLinkFn.scope) {
                            childScope = scope.$new(), compile.$$addScopeInfo(jqLite(node), childScope);
                            var destroyBindings = nodeLinkFn.$$destroyBindings;
                            destroyBindings && (nodeLinkFn.$$destroyBindings = null, childScope.$on("$destroyed", destroyBindings));
                        } else childScope = scope;
                        childBoundTranscludeFn = nodeLinkFn.transcludeOnThisElement ? createBoundTranscludeFn(scope, nodeLinkFn.transclude, parentBoundTranscludeFn) : !nodeLinkFn.templateOnThisElement && parentBoundTranscludeFn ? parentBoundTranscludeFn : !parentBoundTranscludeFn && transcludeFn ? createBoundTranscludeFn(scope, transcludeFn) : null, 
                        nodeLinkFn(childLinkFn, childScope, node, $rootElement, childBoundTranscludeFn, nodeLinkFn);
                    } else childLinkFn && childLinkFn(scope, node.childNodes, undefined, parentBoundTranscludeFn);
                }
                for (var attrs, directives, nodeLinkFn, childNodes, childLinkFn, linkFnFound, nodeLinkFnFound, linkFns = [], i = 0; i < nodeList.length; i++) attrs = new Attributes(), 
                directives = collectDirectives(nodeList[i], [], attrs, 0 === i ? maxPriority : undefined, ignoreDirective), 
                nodeLinkFn = directives.length ? applyDirectivesToNode(directives, nodeList[i], attrs, transcludeFn, $rootElement, null, [], [], previousCompileContext) : null, 
                nodeLinkFn && nodeLinkFn.scope && compile.$$addScopeClass(attrs.$$element), childLinkFn = nodeLinkFn && nodeLinkFn.terminal || !(childNodes = nodeList[i].childNodes) || !childNodes.length ? null : compileNodes(childNodes, nodeLinkFn ? (nodeLinkFn.transcludeOnThisElement || !nodeLinkFn.templateOnThisElement) && nodeLinkFn.transclude : transcludeFn), 
                (nodeLinkFn || childLinkFn) && (linkFns.push(i, nodeLinkFn, childLinkFn), linkFnFound = !0, 
                nodeLinkFnFound = nodeLinkFnFound || nodeLinkFn), previousCompileContext = null;
                return linkFnFound ? compositeLinkFn : null;
            }
            function createBoundTranscludeFn(scope, transcludeFn, previousBoundTranscludeFn) {
                var boundTranscludeFn = function(transcludedScope, cloneFn, controllers, futureParentElement, containingScope) {
                    return transcludedScope || (transcludedScope = scope.$new(!1, containingScope), 
                    transcludedScope.$$transcluded = !0), transcludeFn(transcludedScope, cloneFn, {
                        parentBoundTranscludeFn: previousBoundTranscludeFn,
                        transcludeControllers: controllers,
                        futureParentElement: futureParentElement
                    });
                };
                return boundTranscludeFn;
            }
            function collectDirectives(node, directives, attrs, maxPriority, ignoreDirective) {
                var match, className, nodeType = node.nodeType, attrsMap = attrs.$attr;
                switch (nodeType) {
                  case NODE_TYPE_ELEMENT:
                    addDirective(directives, directiveNormalize(nodeName_(node)), "E", maxPriority, ignoreDirective);
                    for (var attr, name, nName, ngAttrName, value, isNgAttr, nAttrs = node.attributes, j = 0, jj = nAttrs && nAttrs.length; jj > j; j++) {
                        var attrStartName = !1, attrEndName = !1;
                        attr = nAttrs[j], name = attr.name, value = trim(attr.value), ngAttrName = directiveNormalize(name), 
                        (isNgAttr = NG_ATTR_BINDING.test(ngAttrName)) && (name = name.replace(PREFIX_REGEXP, "").substr(8).replace(/_(.)/g, function(match, letter) {
                            return letter.toUpperCase();
                        }));
                        var directiveNName = ngAttrName.replace(/(Start|End)$/, "");
                        directiveIsMultiElement(directiveNName) && ngAttrName === directiveNName + "Start" && (attrStartName = name, 
                        attrEndName = name.substr(0, name.length - 5) + "end", name = name.substr(0, name.length - 6)), 
                        nName = directiveNormalize(name.toLowerCase()), attrsMap[nName] = name, (isNgAttr || !attrs.hasOwnProperty(nName)) && (attrs[nName] = value, 
                        getBooleanAttrName(node, nName) && (attrs[nName] = !0)), addAttrInterpolateDirective(node, directives, value, nName, isNgAttr), 
                        addDirective(directives, nName, "A", maxPriority, ignoreDirective, attrStartName, attrEndName);
                    }
                    if (className = node.className, isObject(className) && (className = className.animVal), 
                    isString(className) && "" !== className) for (;match = CLASS_DIRECTIVE_REGEXP.exec(className); ) nName = directiveNormalize(match[2]), 
                    addDirective(directives, nName, "C", maxPriority, ignoreDirective) && (attrs[nName] = trim(match[3])), 
                    className = className.substr(match.index + match[0].length);
                    break;

                  case NODE_TYPE_TEXT:
                    if (11 === msie) for (;node.parentNode && node.nextSibling && node.nextSibling.nodeType === NODE_TYPE_TEXT; ) node.nodeValue = node.nodeValue + node.nextSibling.nodeValue, 
                    node.parentNode.removeChild(node.nextSibling);
                    addTextInterpolateDirective(directives, node.nodeValue);
                    break;

                  case NODE_TYPE_COMMENT:
                    try {
                        match = COMMENT_DIRECTIVE_REGEXP.exec(node.nodeValue), match && (nName = directiveNormalize(match[1]), 
                        addDirective(directives, nName, "M", maxPriority, ignoreDirective) && (attrs[nName] = trim(match[2])));
                    } catch (e) {}
                }
                return directives.sort(byPriority), directives;
            }
            function groupScan(node, attrStart, attrEnd) {
                var nodes = [], depth = 0;
                if (attrStart && node.hasAttribute && node.hasAttribute(attrStart)) {
                    do {
                        if (!node) throw $compileMinErr("uterdir", "Unterminated attribute, found '{0}' but no matching '{1}' found.", attrStart, attrEnd);
                        node.nodeType == NODE_TYPE_ELEMENT && (node.hasAttribute(attrStart) && depth++, 
                        node.hasAttribute(attrEnd) && depth--), nodes.push(node), node = node.nextSibling;
                    } while (depth > 0);
                } else nodes.push(node);
                return jqLite(nodes);
            }
            function groupElementsLinkFnWrapper(linkFn, attrStart, attrEnd) {
                return function(scope, element, attrs, controllers, transcludeFn) {
                    return element = groupScan(element[0], attrStart, attrEnd), linkFn(scope, element, attrs, controllers, transcludeFn);
                };
            }
            function applyDirectivesToNode(directives, compileNode, templateAttrs, transcludeFn, jqCollection, originalReplaceDirective, preLinkFns, postLinkFns, previousCompileContext) {
                function addLinkFns(pre, post, attrStart, attrEnd) {
                    pre && (attrStart && (pre = groupElementsLinkFnWrapper(pre, attrStart, attrEnd)), 
                    pre.require = directive.require, pre.directiveName = directiveName, (newIsolateScopeDirective === directive || directive.$$isolateScope) && (pre = cloneAndAnnotateFn(pre, {
                        isolateScope: !0
                    })), preLinkFns.push(pre)), post && (attrStart && (post = groupElementsLinkFnWrapper(post, attrStart, attrEnd)), 
                    post.require = directive.require, post.directiveName = directiveName, (newIsolateScopeDirective === directive || directive.$$isolateScope) && (post = cloneAndAnnotateFn(post, {
                        isolateScope: !0
                    })), postLinkFns.push(post));
                }
                function getControllers(directiveName, require, $element, elementControllers) {
                    var value;
                    if (isString(require)) {
                        var match = require.match(REQUIRE_PREFIX_REGEXP), name = require.substring(match[0].length), inheritType = match[1] || match[3], optional = "?" === match[2];
                        if ("^^" === inheritType ? $element = $element.parent() : (value = elementControllers && elementControllers[name], 
                        value = value && value.instance), !value) {
                            var dataName = "$" + name + "Controller";
                            value = inheritType ? $element.inheritedData(dataName) : $element.data(dataName);
                        }
                        if (!value && !optional) throw $compileMinErr("ctreq", "Controller '{0}', required by directive '{1}', can't be found!", name, directiveName);
                    } else if (isArray(require)) {
                        value = [];
                        for (var i = 0, ii = require.length; ii > i; i++) value[i] = getControllers(directiveName, require[i], $element, elementControllers);
                    }
                    return value || null;
                }
                function setupControllers($element, attrs, transcludeFn, controllerDirectives, isolateScope, scope) {
                    var elementControllers = createMap();
                    for (var controllerKey in controllerDirectives) {
                        var directive = controllerDirectives[controllerKey], locals = {
                            $scope: directive === newIsolateScopeDirective || directive.$$isolateScope ? isolateScope : scope,
                            $element: $element,
                            $attrs: attrs,
                            $transclude: transcludeFn
                        }, controller = directive.controller;
                        "@" == controller && (controller = attrs[directive.name]);
                        var controllerInstance = $controller(controller, locals, !0, directive.controllerAs);
                        elementControllers[directive.name] = controllerInstance, hasElementTranscludeDirective || $element.data("$" + directive.name + "Controller", controllerInstance.instance);
                    }
                    return elementControllers;
                }
                function nodeLinkFn(childLinkFn, scope, linkNode, $rootElement, boundTranscludeFn, thisLinkFn) {
                    function controllersBoundTransclude(scope, cloneAttachFn, futureParentElement) {
                        var transcludeControllers;
                        return isScope(scope) || (futureParentElement = cloneAttachFn, cloneAttachFn = scope, 
                        scope = undefined), hasElementTranscludeDirective && (transcludeControllers = elementControllers), 
                        futureParentElement || (futureParentElement = hasElementTranscludeDirective ? $element.parent() : $element), 
                        boundTranscludeFn(scope, cloneAttachFn, transcludeControllers, futureParentElement, scopeToChild);
                    }
                    var i, ii, linkFn, controller, isolateScope, elementControllers, transcludeFn, $element, attrs;
                    if (compileNode === linkNode ? (attrs = templateAttrs, $element = templateAttrs.$$element) : ($element = jqLite(linkNode), 
                    attrs = new Attributes($element, templateAttrs)), newIsolateScopeDirective && (isolateScope = scope.$new(!0)), 
                    boundTranscludeFn && (transcludeFn = controllersBoundTransclude, transcludeFn.$$boundTransclude = boundTranscludeFn), 
                    controllerDirectives && (elementControllers = setupControllers($element, attrs, transcludeFn, controllerDirectives, isolateScope, scope)), 
                    newIsolateScopeDirective && (compile.$$addScopeInfo($element, isolateScope, !0, !(templateDirective && (templateDirective === newIsolateScopeDirective || templateDirective === newIsolateScopeDirective.$$originalDirective))), 
                    compile.$$addScopeClass($element, !0), isolateScope.$$isolateBindings = newIsolateScopeDirective.$$isolateBindings, 
                    initializeDirectiveBindings(scope, attrs, isolateScope, isolateScope.$$isolateBindings, newIsolateScopeDirective, isolateScope)), 
                    elementControllers) {
                        var bindings, controllerForBindings, scopeDirective = newIsolateScopeDirective || newScopeDirective;
                        scopeDirective && elementControllers[scopeDirective.name] && (bindings = scopeDirective.$$bindings.bindToController, 
                        controller = elementControllers[scopeDirective.name], controller && controller.identifier && bindings && (controllerForBindings = controller, 
                        thisLinkFn.$$destroyBindings = initializeDirectiveBindings(scope, attrs, controller.instance, bindings, scopeDirective)));
                        for (i in elementControllers) {
                            controller = elementControllers[i];
                            var controllerResult = controller();
                            controllerResult !== controller.instance && (controller.instance = controllerResult, 
                            $element.data("$" + i + "Controller", controllerResult), controller === controllerForBindings && (thisLinkFn.$$destroyBindings(), 
                            thisLinkFn.$$destroyBindings = initializeDirectiveBindings(scope, attrs, controllerResult, bindings, scopeDirective)));
                        }
                    }
                    for (i = 0, ii = preLinkFns.length; ii > i; i++) linkFn = preLinkFns[i], invokeLinkFn(linkFn, linkFn.isolateScope ? isolateScope : scope, $element, attrs, linkFn.require && getControllers(linkFn.directiveName, linkFn.require, $element, elementControllers), transcludeFn);
                    var scopeToChild = scope;
                    for (newIsolateScopeDirective && (newIsolateScopeDirective.template || null === newIsolateScopeDirective.templateUrl) && (scopeToChild = isolateScope), 
                    childLinkFn && childLinkFn(scopeToChild, linkNode.childNodes, undefined, boundTranscludeFn), 
                    i = postLinkFns.length - 1; i >= 0; i--) linkFn = postLinkFns[i], invokeLinkFn(linkFn, linkFn.isolateScope ? isolateScope : scope, $element, attrs, linkFn.require && getControllers(linkFn.directiveName, linkFn.require, $element, elementControllers), transcludeFn);
                }
                previousCompileContext = previousCompileContext || {};
                for (var directive, directiveName, $template, linkFn, directiveValue, terminalPriority = -Number.MAX_VALUE, newScopeDirective = previousCompileContext.newScopeDirective, controllerDirectives = previousCompileContext.controllerDirectives, newIsolateScopeDirective = previousCompileContext.newIsolateScopeDirective, templateDirective = previousCompileContext.templateDirective, nonTlbTranscludeDirective = previousCompileContext.nonTlbTranscludeDirective, hasTranscludeDirective = !1, hasTemplate = !1, hasElementTranscludeDirective = previousCompileContext.hasElementTranscludeDirective, $compileNode = templateAttrs.$$element = jqLite(compileNode), replaceDirective = originalReplaceDirective, childTranscludeFn = transcludeFn, i = 0, ii = directives.length; ii > i; i++) {
                    directive = directives[i];
                    var attrStart = directive.$$start, attrEnd = directive.$$end;
                    if (attrStart && ($compileNode = groupScan(compileNode, attrStart, attrEnd)), $template = undefined, 
                    terminalPriority > directive.priority) break;
                    if ((directiveValue = directive.scope) && (directive.templateUrl || (isObject(directiveValue) ? (assertNoDuplicate("new/isolated scope", newIsolateScopeDirective || newScopeDirective, directive, $compileNode), 
                    newIsolateScopeDirective = directive) : assertNoDuplicate("new/isolated scope", newIsolateScopeDirective, directive, $compileNode)), 
                    newScopeDirective = newScopeDirective || directive), directiveName = directive.name, 
                    !directive.templateUrl && directive.controller && (directiveValue = directive.controller, 
                    controllerDirectives = controllerDirectives || createMap(), assertNoDuplicate("'" + directiveName + "' controller", controllerDirectives[directiveName], directive, $compileNode), 
                    controllerDirectives[directiveName] = directive), (directiveValue = directive.transclude) && (hasTranscludeDirective = !0, 
                    directive.$$tlb || (assertNoDuplicate("transclusion", nonTlbTranscludeDirective, directive, $compileNode), 
                    nonTlbTranscludeDirective = directive), "element" == directiveValue ? (hasElementTranscludeDirective = !0, 
                    terminalPriority = directive.priority, $template = $compileNode, $compileNode = templateAttrs.$$element = jqLite(document.createComment(" " + directiveName + ": " + templateAttrs[directiveName] + " ")), 
                    compileNode = $compileNode[0], replaceWith(jqCollection, sliceArgs($template), compileNode), 
                    childTranscludeFn = compile($template, transcludeFn, terminalPriority, replaceDirective && replaceDirective.name, {
                        nonTlbTranscludeDirective: nonTlbTranscludeDirective
                    })) : ($template = jqLite(jqLiteClone(compileNode)).contents(), $compileNode.empty(), 
                    childTranscludeFn = compile($template, transcludeFn))), directive.template) if (hasTemplate = !0, 
                    assertNoDuplicate("template", templateDirective, directive, $compileNode), templateDirective = directive, 
                    directiveValue = isFunction(directive.template) ? directive.template($compileNode, templateAttrs) : directive.template, 
                    directiveValue = denormalizeTemplate(directiveValue), directive.replace) {
                        if (replaceDirective = directive, $template = jqLiteIsTextNode(directiveValue) ? [] : removeComments(wrapTemplate(directive.templateNamespace, trim(directiveValue))), 
                        compileNode = $template[0], 1 != $template.length || compileNode.nodeType !== NODE_TYPE_ELEMENT) throw $compileMinErr("tplrt", "Template for directive '{0}' must have exactly one root element. {1}", directiveName, "");
                        replaceWith(jqCollection, $compileNode, compileNode);
                        var newTemplateAttrs = {
                            $attr: {}
                        }, templateDirectives = collectDirectives(compileNode, [], newTemplateAttrs), unprocessedDirectives = directives.splice(i + 1, directives.length - (i + 1));
                        newIsolateScopeDirective && markDirectivesAsIsolate(templateDirectives), directives = directives.concat(templateDirectives).concat(unprocessedDirectives), 
                        mergeTemplateAttributes(templateAttrs, newTemplateAttrs), ii = directives.length;
                    } else $compileNode.html(directiveValue);
                    if (directive.templateUrl) hasTemplate = !0, assertNoDuplicate("template", templateDirective, directive, $compileNode), 
                    templateDirective = directive, directive.replace && (replaceDirective = directive), 
                    nodeLinkFn = compileTemplateUrl(directives.splice(i, directives.length - i), $compileNode, templateAttrs, jqCollection, hasTranscludeDirective && childTranscludeFn, preLinkFns, postLinkFns, {
                        controllerDirectives: controllerDirectives,
                        newScopeDirective: newScopeDirective !== directive && newScopeDirective,
                        newIsolateScopeDirective: newIsolateScopeDirective,
                        templateDirective: templateDirective,
                        nonTlbTranscludeDirective: nonTlbTranscludeDirective
                    }), ii = directives.length; else if (directive.compile) try {
                        linkFn = directive.compile($compileNode, templateAttrs, childTranscludeFn), isFunction(linkFn) ? addLinkFns(null, linkFn, attrStart, attrEnd) : linkFn && addLinkFns(linkFn.pre, linkFn.post, attrStart, attrEnd);
                    } catch (e) {
                        $exceptionHandler(e, startingTag($compileNode));
                    }
                    directive.terminal && (nodeLinkFn.terminal = !0, terminalPriority = Math.max(terminalPriority, directive.priority));
                }
                return nodeLinkFn.scope = newScopeDirective && newScopeDirective.scope === !0, nodeLinkFn.transcludeOnThisElement = hasTranscludeDirective, 
                nodeLinkFn.templateOnThisElement = hasTemplate, nodeLinkFn.transclude = childTranscludeFn, 
                previousCompileContext.hasElementTranscludeDirective = hasElementTranscludeDirective, 
                nodeLinkFn;
            }
            function markDirectivesAsIsolate(directives) {
                for (var j = 0, jj = directives.length; jj > j; j++) directives[j] = inherit(directives[j], {
                    $$isolateScope: !0
                });
            }
            function addDirective(tDirectives, name, location, maxPriority, ignoreDirective, startAttrName, endAttrName) {
                if (name === ignoreDirective) return null;
                var match = null;
                if (hasDirectives.hasOwnProperty(name)) for (var directive, directives = $injector.get(name + Suffix), i = 0, ii = directives.length; ii > i; i++) try {
                    directive = directives[i], (isUndefined(maxPriority) || maxPriority > directive.priority) && -1 != directive.restrict.indexOf(location) && (startAttrName && (directive = inherit(directive, {
                        $$start: startAttrName,
                        $$end: endAttrName
                    })), tDirectives.push(directive), match = directive);
                } catch (e) {
                    $exceptionHandler(e);
                }
                return match;
            }
            function directiveIsMultiElement(name) {
                if (hasDirectives.hasOwnProperty(name)) for (var directive, directives = $injector.get(name + Suffix), i = 0, ii = directives.length; ii > i; i++) if (directive = directives[i], 
                directive.multiElement) return !0;
                return !1;
            }
            function mergeTemplateAttributes(dst, src) {
                var srcAttr = src.$attr, dstAttr = dst.$attr, $element = dst.$$element;
                forEach(dst, function(value, key) {
                    "$" != key.charAt(0) && (src[key] && src[key] !== value && (value += ("style" === key ? ";" : " ") + src[key]), 
                    dst.$set(key, value, !0, srcAttr[key]));
                }), forEach(src, function(value, key) {
                    "class" == key ? (safeAddClass($element, value), dst["class"] = (dst["class"] ? dst["class"] + " " : "") + value) : "style" == key ? ($element.attr("style", $element.attr("style") + ";" + value), 
                    dst.style = (dst.style ? dst.style + ";" : "") + value) : "$" == key.charAt(0) || dst.hasOwnProperty(key) || (dst[key] = value, 
                    dstAttr[key] = srcAttr[key]);
                });
            }
            function compileTemplateUrl(directives, $compileNode, tAttrs, $rootElement, childTranscludeFn, preLinkFns, postLinkFns, previousCompileContext) {
                var afterTemplateNodeLinkFn, afterTemplateChildLinkFn, linkQueue = [], beforeTemplateCompileNode = $compileNode[0], origAsyncDirective = directives.shift(), derivedSyncDirective = inherit(origAsyncDirective, {
                    templateUrl: null,
                    transclude: null,
                    replace: null,
                    $$originalDirective: origAsyncDirective
                }), templateUrl = isFunction(origAsyncDirective.templateUrl) ? origAsyncDirective.templateUrl($compileNode, tAttrs) : origAsyncDirective.templateUrl, templateNamespace = origAsyncDirective.templateNamespace;
                return $compileNode.empty(), $templateRequest(templateUrl).then(function(content) {
                    var compileNode, tempTemplateAttrs, $template, childBoundTranscludeFn;
                    if (content = denormalizeTemplate(content), origAsyncDirective.replace) {
                        if ($template = jqLiteIsTextNode(content) ? [] : removeComments(wrapTemplate(templateNamespace, trim(content))), 
                        compileNode = $template[0], 1 != $template.length || compileNode.nodeType !== NODE_TYPE_ELEMENT) throw $compileMinErr("tplrt", "Template for directive '{0}' must have exactly one root element. {1}", origAsyncDirective.name, templateUrl);
                        tempTemplateAttrs = {
                            $attr: {}
                        }, replaceWith($rootElement, $compileNode, compileNode);
                        var templateDirectives = collectDirectives(compileNode, [], tempTemplateAttrs);
                        isObject(origAsyncDirective.scope) && markDirectivesAsIsolate(templateDirectives), 
                        directives = templateDirectives.concat(directives), mergeTemplateAttributes(tAttrs, tempTemplateAttrs);
                    } else compileNode = beforeTemplateCompileNode, $compileNode.html(content);
                    for (directives.unshift(derivedSyncDirective), afterTemplateNodeLinkFn = applyDirectivesToNode(directives, compileNode, tAttrs, childTranscludeFn, $compileNode, origAsyncDirective, preLinkFns, postLinkFns, previousCompileContext), 
                    forEach($rootElement, function(node, i) {
                        node == compileNode && ($rootElement[i] = $compileNode[0]);
                    }), afterTemplateChildLinkFn = compileNodes($compileNode[0].childNodes, childTranscludeFn); linkQueue.length; ) {
                        var scope = linkQueue.shift(), beforeTemplateLinkNode = linkQueue.shift(), linkRootElement = linkQueue.shift(), boundTranscludeFn = linkQueue.shift(), linkNode = $compileNode[0];
                        if (!scope.$$destroyed) {
                            if (beforeTemplateLinkNode !== beforeTemplateCompileNode) {
                                var oldClasses = beforeTemplateLinkNode.className;
                                previousCompileContext.hasElementTranscludeDirective && origAsyncDirective.replace || (linkNode = jqLiteClone(compileNode)), 
                                replaceWith(linkRootElement, jqLite(beforeTemplateLinkNode), linkNode), safeAddClass(jqLite(linkNode), oldClasses);
                            }
                            childBoundTranscludeFn = afterTemplateNodeLinkFn.transcludeOnThisElement ? createBoundTranscludeFn(scope, afterTemplateNodeLinkFn.transclude, boundTranscludeFn) : boundTranscludeFn, 
                            afterTemplateNodeLinkFn(afterTemplateChildLinkFn, scope, linkNode, $rootElement, childBoundTranscludeFn, afterTemplateNodeLinkFn);
                        }
                    }
                    linkQueue = null;
                }), function(ignoreChildLinkFn, scope, node, rootElement, boundTranscludeFn) {
                    var childBoundTranscludeFn = boundTranscludeFn;
                    scope.$$destroyed || (linkQueue ? linkQueue.push(scope, node, rootElement, childBoundTranscludeFn) : (afterTemplateNodeLinkFn.transcludeOnThisElement && (childBoundTranscludeFn = createBoundTranscludeFn(scope, afterTemplateNodeLinkFn.transclude, boundTranscludeFn)), 
                    afterTemplateNodeLinkFn(afterTemplateChildLinkFn, scope, node, rootElement, childBoundTranscludeFn, afterTemplateNodeLinkFn)));
                };
            }
            function byPriority(a, b) {
                var diff = b.priority - a.priority;
                return 0 !== diff ? diff : a.name !== b.name ? a.name < b.name ? -1 : 1 : a.index - b.index;
            }
            function assertNoDuplicate(what, previousDirective, directive, element) {
                function wrapModuleNameIfDefined(moduleName) {
                    return moduleName ? " (module: " + moduleName + ")" : "";
                }
                if (previousDirective) throw $compileMinErr("multidir", "Multiple directives [{0}{1}, {2}{3}] asking for {4} on: {5}", previousDirective.name, wrapModuleNameIfDefined(previousDirective.$$moduleName), directive.name, wrapModuleNameIfDefined(directive.$$moduleName), what, startingTag(element));
            }
            function addTextInterpolateDirective(directives, text) {
                var interpolateFn = $interpolate(text, !0);
                interpolateFn && directives.push({
                    priority: 0,
                    compile: function(templateNode) {
                        var templateNodeParent = templateNode.parent(), hasCompileParent = !!templateNodeParent.length;
                        return hasCompileParent && compile.$$addBindingClass(templateNodeParent), function(scope, node) {
                            var parent = node.parent();
                            hasCompileParent || compile.$$addBindingClass(parent), compile.$$addBindingInfo(parent, interpolateFn.expressions), 
                            scope.$watch(interpolateFn, function(value) {
                                node[0].nodeValue = value;
                            });
                        };
                    }
                });
            }
            function wrapTemplate(type, template) {
                switch (type = lowercase(type || "html")) {
                  case "svg":
                  case "math":
                    var wrapper = document.createElement("div");
                    return wrapper.innerHTML = "<" + type + ">" + template + "</" + type + ">", wrapper.childNodes[0].childNodes;

                  default:
                    return template;
                }
            }
            function getTrustedContext(node, attrNormalizedName) {
                if ("srcdoc" == attrNormalizedName) return $sce.HTML;
                var tag = nodeName_(node);
                return "xlinkHref" == attrNormalizedName || "form" == tag && "action" == attrNormalizedName || "img" != tag && ("src" == attrNormalizedName || "ngSrc" == attrNormalizedName) ? $sce.RESOURCE_URL : void 0;
            }
            function addAttrInterpolateDirective(node, directives, value, name, allOrNothing) {
                var trustedContext = getTrustedContext(node, name);
                allOrNothing = ALL_OR_NOTHING_ATTRS[name] || allOrNothing;
                var interpolateFn = $interpolate(value, !0, trustedContext, allOrNothing);
                if (interpolateFn) {
                    if ("multiple" === name && "select" === nodeName_(node)) throw $compileMinErr("selmulti", "Binding to the 'multiple' attribute is not supported. Element: {0}", startingTag(node));
                    directives.push({
                        priority: 100,
                        compile: function() {
                            return {
                                pre: function(scope, element, attr) {
                                    var $$observers = attr.$$observers || (attr.$$observers = createMap());
                                    if (EVENT_HANDLER_ATTR_REGEXP.test(name)) throw $compileMinErr("nodomevents", "Interpolations for HTML DOM event attributes are disallowed.  Please use the ng- versions (such as ng-click instead of onclick) instead.");
                                    var newValue = attr[name];
                                    newValue !== value && (interpolateFn = newValue && $interpolate(newValue, !0, trustedContext, allOrNothing), 
                                    value = newValue), interpolateFn && (attr[name] = interpolateFn(scope), ($$observers[name] || ($$observers[name] = [])).$$inter = !0, 
                                    (attr.$$observers && attr.$$observers[name].$$scope || scope).$watch(interpolateFn, function(newValue, oldValue) {
                                        "class" === name && newValue != oldValue ? attr.$updateClass(newValue, oldValue) : attr.$set(name, newValue);
                                    }));
                                }
                            };
                        }
                    });
                }
            }
            function replaceWith($rootElement, elementsToRemove, newNode) {
                var i, ii, firstElementToRemove = elementsToRemove[0], removeCount = elementsToRemove.length, parent = firstElementToRemove.parentNode;
                if ($rootElement) for (i = 0, ii = $rootElement.length; ii > i; i++) if ($rootElement[i] == firstElementToRemove) {
                    $rootElement[i++] = newNode;
                    for (var j = i, j2 = j + removeCount - 1, jj = $rootElement.length; jj > j; j++, 
                    j2++) jj > j2 ? $rootElement[j] = $rootElement[j2] : delete $rootElement[j];
                    $rootElement.length -= removeCount - 1, $rootElement.context === firstElementToRemove && ($rootElement.context = newNode);
                    break;
                }
                parent && parent.replaceChild(newNode, firstElementToRemove);
                var fragment = document.createDocumentFragment();
                fragment.appendChild(firstElementToRemove), jqLite.hasData(firstElementToRemove) && (jqLite(newNode).data(jqLite(firstElementToRemove).data()), 
                jQuery ? (skipDestroyOnNextJQueryCleanData = !0, jQuery.cleanData([ firstElementToRemove ])) : delete jqLite.cache[firstElementToRemove[jqLite.expando]]);
                for (var k = 1, kk = elementsToRemove.length; kk > k; k++) {
                    var element = elementsToRemove[k];
                    jqLite(element).remove(), fragment.appendChild(element), delete elementsToRemove[k];
                }
                elementsToRemove[0] = newNode, elementsToRemove.length = 1;
            }
            function cloneAndAnnotateFn(fn, annotation) {
                return extend(function() {
                    return fn.apply(null, arguments);
                }, fn, annotation);
            }
            function invokeLinkFn(linkFn, scope, $element, attrs, controllers, transcludeFn) {
                try {
                    linkFn(scope, $element, attrs, controllers, transcludeFn);
                } catch (e) {
                    $exceptionHandler(e, startingTag($element));
                }
            }
            function initializeDirectiveBindings(scope, attrs, destination, bindings, directive, newScope) {
                var onNewScopeDestroyed;
                forEach(bindings, function(definition, scopeName) {
                    var lastValue, parentGet, parentSet, compare, attrName = definition.attrName, optional = definition.optional, mode = definition.mode;
                    switch (mode) {
                      case "@":
                        optional || hasOwnProperty.call(attrs, attrName) || (destination[scopeName] = attrs[attrName] = void 0), 
                        attrs.$observe(attrName, function(value) {
                            isString(value) && (destination[scopeName] = value);
                        }), attrs.$$observers[attrName].$$scope = scope, isString(attrs[attrName]) && (destination[scopeName] = $interpolate(attrs[attrName])(scope));
                        break;

                      case "=":
                        if (!hasOwnProperty.call(attrs, attrName)) {
                            if (optional) break;
                            attrs[attrName] = void 0;
                        }
                        if (optional && !attrs[attrName]) break;
                        parentGet = $parse(attrs[attrName]), compare = parentGet.literal ? equals : function(a, b) {
                            return a === b || a !== a && b !== b;
                        }, parentSet = parentGet.assign || function() {
                            throw lastValue = destination[scopeName] = parentGet(scope), $compileMinErr("nonassign", "Expression '{0}' used with directive '{1}' is non-assignable!", attrs[attrName], directive.name);
                        }, lastValue = destination[scopeName] = parentGet(scope);
                        var parentValueWatch = function(parentValue) {
                            return compare(parentValue, destination[scopeName]) || (compare(parentValue, lastValue) ? parentSet(scope, parentValue = destination[scopeName]) : destination[scopeName] = parentValue), 
                            lastValue = parentValue;
                        };
                        parentValueWatch.$stateful = !0;
                        var unwatch;
                        unwatch = definition.collection ? scope.$watchCollection(attrs[attrName], parentValueWatch) : scope.$watch($parse(attrs[attrName], parentValueWatch), null, parentGet.literal), 
                        onNewScopeDestroyed = onNewScopeDestroyed || [], onNewScopeDestroyed.push(unwatch);
                        break;

                      case "&":
                        if (parentGet = attrs.hasOwnProperty(attrName) ? $parse(attrs[attrName]) : noop, 
                        parentGet === noop && optional) break;
                        destination[scopeName] = function(locals) {
                            return parentGet(scope, locals);
                        };
                    }
                });
                var destroyBindings = onNewScopeDestroyed ? function() {
                    for (var i = 0, ii = onNewScopeDestroyed.length; ii > i; ++i) onNewScopeDestroyed[i]();
                } : noop;
                return newScope && destroyBindings !== noop ? (newScope.$on("$destroy", destroyBindings), 
                noop) : destroyBindings;
            }
            var Attributes = function(element, attributesToCopy) {
                if (attributesToCopy) {
                    var i, l, key, keys = Object.keys(attributesToCopy);
                    for (i = 0, l = keys.length; l > i; i++) key = keys[i], this[key] = attributesToCopy[key];
                } else this.$attr = {};
                this.$$element = element;
            };
            Attributes.prototype = {
                $normalize: directiveNormalize,
                $addClass: function(classVal) {
                    classVal && classVal.length > 0 && $animate.addClass(this.$$element, classVal);
                },
                $removeClass: function(classVal) {
                    classVal && classVal.length > 0 && $animate.removeClass(this.$$element, classVal);
                },
                $updateClass: function(newClasses, oldClasses) {
                    var toAdd = tokenDifference(newClasses, oldClasses);
                    toAdd && toAdd.length && $animate.addClass(this.$$element, toAdd);
                    var toRemove = tokenDifference(oldClasses, newClasses);
                    toRemove && toRemove.length && $animate.removeClass(this.$$element, toRemove);
                },
                $set: function(key, value, writeAttr, attrName) {
                    var nodeName, node = this.$$element[0], booleanKey = getBooleanAttrName(node, key), aliasedKey = getAliasedAttrName(key), observer = key;
                    if (booleanKey ? (this.$$element.prop(key, value), attrName = booleanKey) : aliasedKey && (this[aliasedKey] = value, 
                    observer = aliasedKey), this[key] = value, attrName ? this.$attr[key] = attrName : (attrName = this.$attr[key], 
                    attrName || (this.$attr[key] = attrName = snake_case(key, "-"))), nodeName = nodeName_(this.$$element), 
                    "a" === nodeName && "href" === key || "img" === nodeName && "src" === key) this[key] = value = $$sanitizeUri(value, "src" === key); else if ("img" === nodeName && "srcset" === key) {
                        for (var result = "", trimmedSrcset = trim(value), srcPattern = /(\s+\d+x\s*,|\s+\d+w\s*,|\s+,|,\s+)/, pattern = /\s/.test(trimmedSrcset) ? srcPattern : /(,)/, rawUris = trimmedSrcset.split(pattern), nbrUrisWith2parts = Math.floor(rawUris.length / 2), i = 0; nbrUrisWith2parts > i; i++) {
                            var innerIdx = 2 * i;
                            result += $$sanitizeUri(trim(rawUris[innerIdx]), !0), result += " " + trim(rawUris[innerIdx + 1]);
                        }
                        var lastTuple = trim(rawUris[2 * i]).split(/\s/);
                        result += $$sanitizeUri(trim(lastTuple[0]), !0), 2 === lastTuple.length && (result += " " + trim(lastTuple[1])), 
                        this[key] = value = result;
                    }
                    writeAttr !== !1 && (null === value || isUndefined(value) ? this.$$element.removeAttr(attrName) : this.$$element.attr(attrName, value));
                    var $$observers = this.$$observers;
                    $$observers && forEach($$observers[observer], function(fn) {
                        try {
                            fn(value);
                        } catch (e) {
                            $exceptionHandler(e);
                        }
                    });
                },
                $observe: function(key, fn) {
                    var attrs = this, $$observers = attrs.$$observers || (attrs.$$observers = createMap()), listeners = $$observers[key] || ($$observers[key] = []);
                    return listeners.push(fn), $rootScope.$evalAsync(function() {
                        listeners.$$inter || !attrs.hasOwnProperty(key) || isUndefined(attrs[key]) || fn(attrs[key]);
                    }), function() {
                        arrayRemove(listeners, fn);
                    };
                }
            };
            var startSymbol = $interpolate.startSymbol(), endSymbol = $interpolate.endSymbol(), denormalizeTemplate = "{{" == startSymbol || "}}" == endSymbol ? identity : function(template) {
                return template.replace(/\{\{/g, startSymbol).replace(/}}/g, endSymbol);
            }, NG_ATTR_BINDING = /^ngAttr[A-Z]/;
            return compile.$$addBindingInfo = debugInfoEnabled ? function($element, binding) {
                var bindings = $element.data("$binding") || [];
                isArray(binding) ? bindings = bindings.concat(binding) : bindings.push(binding), 
                $element.data("$binding", bindings);
            } : noop, compile.$$addBindingClass = debugInfoEnabled ? function($element) {
                safeAddClass($element, "ng-binding");
            } : noop, compile.$$addScopeInfo = debugInfoEnabled ? function($element, scope, isolated, noTemplate) {
                var dataName = isolated ? noTemplate ? "$isolateScopeNoTemplate" : "$isolateScope" : "$scope";
                $element.data(dataName, scope);
            } : noop, compile.$$addScopeClass = debugInfoEnabled ? function($element, isolated) {
                safeAddClass($element, isolated ? "ng-isolate-scope" : "ng-scope");
            } : noop, compile;
        } ];
    }
    function directiveNormalize(name) {
        return camelCase(name.replace(PREFIX_REGEXP, ""));
    }
    function tokenDifference(str1, str2) {
        var values = "", tokens1 = str1.split(/\s+/), tokens2 = str2.split(/\s+/);
        outer: for (var i = 0; i < tokens1.length; i++) {
            for (var token = tokens1[i], j = 0; j < tokens2.length; j++) if (token == tokens2[j]) continue outer;
            values += (values.length > 0 ? " " : "") + token;
        }
        return values;
    }
    function removeComments(jqNodes) {
        jqNodes = jqLite(jqNodes);
        var i = jqNodes.length;
        if (1 >= i) return jqNodes;
        for (;i--; ) {
            var node = jqNodes[i];
            node.nodeType === NODE_TYPE_COMMENT && splice.call(jqNodes, i, 1);
        }
        return jqNodes;
    }
    function identifierForController(controller, ident) {
        if (ident && isString(ident)) return ident;
        if (isString(controller)) {
            var match = CNTRL_REG.exec(controller);
            if (match) return match[3];
        }
    }
    function $ControllerProvider() {
        var controllers = {}, globals = !1;
        this.register = function(name, constructor) {
            assertNotHasOwnProperty(name, "controller"), isObject(name) ? extend(controllers, name) : controllers[name] = constructor;
        }, this.allowGlobals = function() {
            globals = !0;
        }, this.$get = [ "$injector", "$window", function($injector, $window) {
            function addIdentifier(locals, identifier, instance, name) {
                if (!locals || !isObject(locals.$scope)) throw minErr("$controller")("noscp", "Cannot export controller '{0}' as '{1}'! No $scope object provided via `locals`.", name, identifier);
                locals.$scope[identifier] = instance;
            }
            return function(expression, locals, later, ident) {
                var instance, match, constructor, identifier;
                if (later = later === !0, ident && isString(ident) && (identifier = ident), isString(expression)) {
                    if (match = expression.match(CNTRL_REG), !match) throw $controllerMinErr("ctrlfmt", "Badly formed controller string '{0}'. Must match `__name__ as __id__` or `__name__`.", expression);
                    constructor = match[1], identifier = identifier || match[3], expression = controllers.hasOwnProperty(constructor) ? controllers[constructor] : getter(locals.$scope, constructor, !0) || (globals ? getter($window, constructor, !0) : undefined), 
                    assertArgFn(expression, constructor, !0);
                }
                if (later) {
                    var controllerPrototype = (isArray(expression) ? expression[expression.length - 1] : expression).prototype;
                    instance = Object.create(controllerPrototype || null), identifier && addIdentifier(locals, identifier, instance, constructor || expression.name);
                    var instantiate;
                    return instantiate = extend(function() {
                        var result = $injector.invoke(expression, instance, locals, constructor);
                        return result !== instance && (isObject(result) || isFunction(result)) && (instance = result, 
                        identifier && addIdentifier(locals, identifier, instance, constructor || expression.name)), 
                        instance;
                    }, {
                        instance: instance,
                        identifier: identifier
                    });
                }
                return instance = $injector.instantiate(expression, locals, constructor), identifier && addIdentifier(locals, identifier, instance, constructor || expression.name), 
                instance;
            };
        } ];
    }
    function $DocumentProvider() {
        this.$get = [ "$window", function(window) {
            return jqLite(window.document);
        } ];
    }
    function $ExceptionHandlerProvider() {
        this.$get = [ "$log", function($log) {
            return function() {
                $log.error.apply($log, arguments);
            };
        } ];
    }
    function serializeValue(v) {
        return isObject(v) ? isDate(v) ? v.toISOString() : toJson(v) : v;
    }
    function $HttpParamSerializerProvider() {
        this.$get = function() {
            return function(params) {
                if (!params) return "";
                var parts = [];
                return forEachSorted(params, function(value, key) {
                    null === value || isUndefined(value) || (isArray(value) ? forEach(value, function(v) {
                        parts.push(encodeUriQuery(key) + "=" + encodeUriQuery(serializeValue(v)));
                    }) : parts.push(encodeUriQuery(key) + "=" + encodeUriQuery(serializeValue(value))));
                }), parts.join("&");
            };
        };
    }
    function $HttpParamSerializerJQLikeProvider() {
        this.$get = function() {
            return function(params) {
                function serialize(toSerialize, prefix, topLevel) {
                    null === toSerialize || isUndefined(toSerialize) || (isArray(toSerialize) ? forEach(toSerialize, function(value, index) {
                        serialize(value, prefix + "[" + (isObject(value) ? index : "") + "]");
                    }) : isObject(toSerialize) && !isDate(toSerialize) ? forEachSorted(toSerialize, function(value, key) {
                        serialize(value, prefix + (topLevel ? "" : "[") + key + (topLevel ? "" : "]"));
                    }) : parts.push(encodeUriQuery(prefix) + "=" + encodeUriQuery(serializeValue(toSerialize))));
                }
                if (!params) return "";
                var parts = [];
                return serialize(params, "", !0), parts.join("&");
            };
        };
    }
    function defaultHttpResponseTransform(data, headers) {
        if (isString(data)) {
            var tempData = data.replace(JSON_PROTECTION_PREFIX, "").trim();
            if (tempData) {
                var contentType = headers("Content-Type");
                (contentType && 0 === contentType.indexOf(APPLICATION_JSON) || isJsonLike(tempData)) && (data = fromJson(tempData));
            }
        }
        return data;
    }
    function isJsonLike(str) {
        var jsonStart = str.match(JSON_START);
        return jsonStart && JSON_ENDS[jsonStart[0]].test(str);
    }
    function parseHeaders(headers) {
        function fillInParsed(key, val) {
            key && (parsed[key] = parsed[key] ? parsed[key] + ", " + val : val);
        }
        var i, parsed = createMap();
        return isString(headers) ? forEach(headers.split("\n"), function(line) {
            i = line.indexOf(":"), fillInParsed(lowercase(trim(line.substr(0, i))), trim(line.substr(i + 1)));
        }) : isObject(headers) && forEach(headers, function(headerVal, headerKey) {
            fillInParsed(lowercase(headerKey), trim(headerVal));
        }), parsed;
    }
    function headersGetter(headers) {
        var headersObj;
        return function(name) {
            if (headersObj || (headersObj = parseHeaders(headers)), name) {
                var value = headersObj[lowercase(name)];
                return void 0 === value && (value = null), value;
            }
            return headersObj;
        };
    }
    function transformData(data, headers, status, fns) {
        return isFunction(fns) ? fns(data, headers, status) : (forEach(fns, function(fn) {
            data = fn(data, headers, status);
        }), data);
    }
    function isSuccess(status) {
        return status >= 200 && 300 > status;
    }
    function $HttpProvider() {
        var defaults = this.defaults = {
            transformResponse: [ defaultHttpResponseTransform ],
            transformRequest: [ function(d) {
                return !isObject(d) || isFile(d) || isBlob(d) || isFormData(d) ? d : toJson(d);
            } ],
            headers: {
                common: {
                    Accept: "application/json, text/plain, */*"
                },
                post: shallowCopy(CONTENT_TYPE_APPLICATION_JSON),
                put: shallowCopy(CONTENT_TYPE_APPLICATION_JSON),
                patch: shallowCopy(CONTENT_TYPE_APPLICATION_JSON)
            },
            xsrfCookieName: "XSRF-TOKEN",
            xsrfHeaderName: "X-XSRF-TOKEN",
            paramSerializer: "$httpParamSerializer"
        }, useApplyAsync = !1;
        this.useApplyAsync = function(value) {
            return isDefined(value) ? (useApplyAsync = !!value, this) : useApplyAsync;
        };
        var useLegacyPromise = !0;
        this.useLegacyPromiseExtensions = function(value) {
            return isDefined(value) ? (useLegacyPromise = !!value, this) : useLegacyPromise;
        };
        var interceptorFactories = this.interceptors = [];
        this.$get = [ "$httpBackend", "$$cookieReader", "$cacheFactory", "$rootScope", "$q", "$injector", function($httpBackend, $$cookieReader, $cacheFactory, $rootScope, $q, $injector) {
            function $http(requestConfig) {
                function transformResponse(response) {
                    var resp = extend({}, response);
                    return resp.data = response.data ? transformData(response.data, response.headers, response.status, config.transformResponse) : response.data, 
                    isSuccess(response.status) ? resp : $q.reject(resp);
                }
                function executeHeaderFns(headers, config) {
                    var headerContent, processedHeaders = {};
                    return forEach(headers, function(headerFn, header) {
                        isFunction(headerFn) ? (headerContent = headerFn(config), null != headerContent && (processedHeaders[header] = headerContent)) : processedHeaders[header] = headerFn;
                    }), processedHeaders;
                }
                function mergeHeaders(config) {
                    var defHeaderName, lowercaseDefHeaderName, reqHeaderName, defHeaders = defaults.headers, reqHeaders = extend({}, config.headers);
                    defHeaders = extend({}, defHeaders.common, defHeaders[lowercase(config.method)]);
                    defaultHeadersIteration: for (defHeaderName in defHeaders) {
                        lowercaseDefHeaderName = lowercase(defHeaderName);
                        for (reqHeaderName in reqHeaders) if (lowercase(reqHeaderName) === lowercaseDefHeaderName) continue defaultHeadersIteration;
                        reqHeaders[defHeaderName] = defHeaders[defHeaderName];
                    }
                    return executeHeaderFns(reqHeaders, shallowCopy(config));
                }
                if (!angular.isObject(requestConfig)) throw minErr("$http")("badreq", "Http request configuration must be an object.  Received: {0}", requestConfig);
                var config = extend({
                    method: "get",
                    transformRequest: defaults.transformRequest,
                    transformResponse: defaults.transformResponse,
                    paramSerializer: defaults.paramSerializer
                }, requestConfig);
                config.headers = mergeHeaders(requestConfig), config.method = uppercase(config.method), 
                config.paramSerializer = isString(config.paramSerializer) ? $injector.get(config.paramSerializer) : config.paramSerializer;
                var serverRequest = function(config) {
                    var headers = config.headers, reqData = transformData(config.data, headersGetter(headers), undefined, config.transformRequest);
                    return isUndefined(reqData) && forEach(headers, function(value, header) {
                        "content-type" === lowercase(header) && delete headers[header];
                    }), isUndefined(config.withCredentials) && !isUndefined(defaults.withCredentials) && (config.withCredentials = defaults.withCredentials), 
                    sendReq(config, reqData).then(transformResponse, transformResponse);
                }, chain = [ serverRequest, undefined ], promise = $q.when(config);
                for (forEach(reversedInterceptors, function(interceptor) {
                    (interceptor.request || interceptor.requestError) && chain.unshift(interceptor.request, interceptor.requestError), 
                    (interceptor.response || interceptor.responseError) && chain.push(interceptor.response, interceptor.responseError);
                }); chain.length; ) {
                    var thenFn = chain.shift(), rejectFn = chain.shift();
                    promise = promise.then(thenFn, rejectFn);
                }
                return useLegacyPromise ? (promise.success = function(fn) {
                    return assertArgFn(fn, "fn"), promise.then(function(response) {
                        fn(response.data, response.status, response.headers, config);
                    }), promise;
                }, promise.error = function(fn) {
                    return assertArgFn(fn, "fn"), promise.then(null, function(response) {
                        fn(response.data, response.status, response.headers, config);
                    }), promise;
                }) : (promise.success = $httpMinErrLegacyFn("success"), promise.error = $httpMinErrLegacyFn("error")), 
                promise;
            }
            function createShortMethods() {
                forEach(arguments, function(name) {
                    $http[name] = function(url, config) {
                        return $http(extend({}, config || {}, {
                            method: name,
                            url: url
                        }));
                    };
                });
            }
            function createShortMethodsWithData() {
                forEach(arguments, function(name) {
                    $http[name] = function(url, data, config) {
                        return $http(extend({}, config || {}, {
                            method: name,
                            url: url,
                            data: data
                        }));
                    };
                });
            }
            function sendReq(config, reqData) {
                function done(status, response, headersString, statusText) {
                    function resolveHttpPromise() {
                        resolvePromise(response, status, headersString, statusText);
                    }
                    cache && (isSuccess(status) ? cache.put(url, [ status, response, parseHeaders(headersString), statusText ]) : cache.remove(url)), 
                    useApplyAsync ? $rootScope.$applyAsync(resolveHttpPromise) : (resolveHttpPromise(), 
                    $rootScope.$$phase || $rootScope.$apply());
                }
                function resolvePromise(response, status, headers, statusText) {
                    status = status >= -1 ? status : 0, (isSuccess(status) ? deferred.resolve : deferred.reject)({
                        data: response,
                        status: status,
                        headers: headersGetter(headers),
                        config: config,
                        statusText: statusText
                    });
                }
                function resolvePromiseWithResult(result) {
                    resolvePromise(result.data, result.status, shallowCopy(result.headers()), result.statusText);
                }
                function removePendingReq() {
                    var idx = $http.pendingRequests.indexOf(config);
                    -1 !== idx && $http.pendingRequests.splice(idx, 1);
                }
                var cache, cachedResp, deferred = $q.defer(), promise = deferred.promise, reqHeaders = config.headers, url = buildUrl(config.url, config.paramSerializer(config.params));
                if ($http.pendingRequests.push(config), promise.then(removePendingReq, removePendingReq), 
                !config.cache && !defaults.cache || config.cache === !1 || "GET" !== config.method && "JSONP" !== config.method || (cache = isObject(config.cache) ? config.cache : isObject(defaults.cache) ? defaults.cache : defaultCache), 
                cache && (cachedResp = cache.get(url), isDefined(cachedResp) ? isPromiseLike(cachedResp) ? cachedResp.then(resolvePromiseWithResult, resolvePromiseWithResult) : isArray(cachedResp) ? resolvePromise(cachedResp[1], cachedResp[0], shallowCopy(cachedResp[2]), cachedResp[3]) : resolvePromise(cachedResp, 200, {}, "OK") : cache.put(url, promise)), 
                isUndefined(cachedResp)) {
                    var xsrfValue = urlIsSameOrigin(config.url) ? $$cookieReader()[config.xsrfCookieName || defaults.xsrfCookieName] : undefined;
                    xsrfValue && (reqHeaders[config.xsrfHeaderName || defaults.xsrfHeaderName] = xsrfValue), 
                    $httpBackend(config.method, url, reqData, done, reqHeaders, config.timeout, config.withCredentials, config.responseType);
                }
                return promise;
            }
            function buildUrl(url, serializedParams) {
                return serializedParams.length > 0 && (url += (-1 == url.indexOf("?") ? "?" : "&") + serializedParams), 
                url;
            }
            var defaultCache = $cacheFactory("$http");
            defaults.paramSerializer = isString(defaults.paramSerializer) ? $injector.get(defaults.paramSerializer) : defaults.paramSerializer;
            var reversedInterceptors = [];
            return forEach(interceptorFactories, function(interceptorFactory) {
                reversedInterceptors.unshift(isString(interceptorFactory) ? $injector.get(interceptorFactory) : $injector.invoke(interceptorFactory));
            }), $http.pendingRequests = [], createShortMethods("get", "delete", "head", "jsonp"), 
            createShortMethodsWithData("post", "put", "patch"), $http.defaults = defaults, $http;
        } ];
    }
    function $xhrFactoryProvider() {
        this.$get = function() {
            return function() {
                return new window.XMLHttpRequest();
            };
        };
    }
    function $HttpBackendProvider() {
        this.$get = [ "$browser", "$window", "$document", "$xhrFactory", function($browser, $window, $document, $xhrFactory) {
            return createHttpBackend($browser, $xhrFactory, $browser.defer, $window.angular.callbacks, $document[0]);
        } ];
    }
    function createHttpBackend($browser, createXhr, $browserDefer, callbacks, rawDocument) {
        function jsonpReq(url, callbackId, done) {
            var script = rawDocument.createElement("script"), callback = null;
            return script.type = "text/javascript", script.src = url, script.async = !0, callback = function(event) {
                removeEventListenerFn(script, "load", callback), removeEventListenerFn(script, "error", callback), 
                rawDocument.body.removeChild(script), script = null;
                var status = -1, text = "unknown";
                event && ("load" !== event.type || callbacks[callbackId].called || (event = {
                    type: "error"
                }), text = event.type, status = "error" === event.type ? 404 : 200), done && done(status, text);
            }, addEventListenerFn(script, "load", callback), addEventListenerFn(script, "error", callback), 
            rawDocument.body.appendChild(script), callback;
        }
        return function(method, url, post, callback, headers, timeout, withCredentials, responseType) {
            function timeoutRequest() {
                jsonpDone && jsonpDone(), xhr && xhr.abort();
            }
            function completeRequest(callback, status, response, headersString, statusText) {
                isDefined(timeoutId) && $browserDefer.cancel(timeoutId), jsonpDone = xhr = null, 
                callback(status, response, headersString, statusText), $browser.$$completeOutstandingRequest(noop);
            }
            if ($browser.$$incOutstandingRequestCount(), url = url || $browser.url(), "jsonp" == lowercase(method)) {
                var callbackId = "_" + (callbacks.counter++).toString(36);
                callbacks[callbackId] = function(data) {
                    callbacks[callbackId].data = data, callbacks[callbackId].called = !0;
                };
                var jsonpDone = jsonpReq(url.replace("JSON_CALLBACK", "angular.callbacks." + callbackId), callbackId, function(status, text) {
                    completeRequest(callback, status, callbacks[callbackId].data, "", text), callbacks[callbackId] = noop;
                });
            } else {
                var xhr = createXhr(method, url);
                xhr.open(method, url, !0), forEach(headers, function(value, key) {
                    isDefined(value) && xhr.setRequestHeader(key, value);
                }), xhr.onload = function() {
                    var statusText = xhr.statusText || "", response = "response" in xhr ? xhr.response : xhr.responseText, status = 1223 === xhr.status ? 204 : xhr.status;
                    0 === status && (status = response ? 200 : "file" == urlResolve(url).protocol ? 404 : 0), 
                    completeRequest(callback, status, response, xhr.getAllResponseHeaders(), statusText);
                };
                var requestError = function() {
                    completeRequest(callback, -1, null, null, "");
                };
                if (xhr.onerror = requestError, xhr.onabort = requestError, withCredentials && (xhr.withCredentials = !0), 
                responseType) try {
                    xhr.responseType = responseType;
                } catch (e) {
                    if ("json" !== responseType) throw e;
                }
                xhr.send(isUndefined(post) ? null : post);
            }
            if (timeout > 0) var timeoutId = $browserDefer(timeoutRequest, timeout); else isPromiseLike(timeout) && timeout.then(timeoutRequest);
        };
    }
    function $InterpolateProvider() {
        var startSymbol = "{{", endSymbol = "}}";
        this.startSymbol = function(value) {
            return value ? (startSymbol = value, this) : startSymbol;
        }, this.endSymbol = function(value) {
            return value ? (endSymbol = value, this) : endSymbol;
        }, this.$get = [ "$parse", "$exceptionHandler", "$sce", function($parse, $exceptionHandler, $sce) {
            function escape(ch) {
                return "\\\\\\" + ch;
            }
            function unescapeText(text) {
                return text.replace(escapedStartRegexp, startSymbol).replace(escapedEndRegexp, endSymbol);
            }
            function stringify(value) {
                if (null == value) return "";
                switch (typeof value) {
                  case "string":
                    break;

                  case "number":
                    value = "" + value;
                    break;

                  default:
                    value = toJson(value);
                }
                return value;
            }
            function $interpolate(text, mustHaveExpression, trustedContext, allOrNothing) {
                function parseStringifyInterceptor(value) {
                    try {
                        return value = getValue(value), allOrNothing && !isDefined(value) ? value : stringify(value);
                    } catch (err) {
                        $exceptionHandler($interpolateMinErr.interr(text, err));
                    }
                }
                allOrNothing = !!allOrNothing;
                for (var startIndex, endIndex, exp, index = 0, expressions = [], parseFns = [], textLength = text.length, concat = [], expressionPositions = []; textLength > index; ) {
                    if (-1 == (startIndex = text.indexOf(startSymbol, index)) || -1 == (endIndex = text.indexOf(endSymbol, startIndex + startSymbolLength))) {
                        index !== textLength && concat.push(unescapeText(text.substring(index)));
                        break;
                    }
                    index !== startIndex && concat.push(unescapeText(text.substring(index, startIndex))), 
                    exp = text.substring(startIndex + startSymbolLength, endIndex), expressions.push(exp), 
                    parseFns.push($parse(exp, parseStringifyInterceptor)), index = endIndex + endSymbolLength, 
                    expressionPositions.push(concat.length), concat.push("");
                }
                if (trustedContext && concat.length > 1 && $interpolateMinErr.throwNoconcat(text), 
                !mustHaveExpression || expressions.length) {
                    var compute = function(values) {
                        for (var i = 0, ii = expressions.length; ii > i; i++) {
                            if (allOrNothing && isUndefined(values[i])) return;
                            concat[expressionPositions[i]] = values[i];
                        }
                        return concat.join("");
                    }, getValue = function(value) {
                        return trustedContext ? $sce.getTrusted(trustedContext, value) : $sce.valueOf(value);
                    };
                    return extend(function(context) {
                        var i = 0, ii = expressions.length, values = new Array(ii);
                        try {
                            for (;ii > i; i++) values[i] = parseFns[i](context);
                            return compute(values);
                        } catch (err) {
                            $exceptionHandler($interpolateMinErr.interr(text, err));
                        }
                    }, {
                        exp: text,
                        expressions: expressions,
                        $$watchDelegate: function(scope, listener) {
                            var lastValue;
                            return scope.$watchGroup(parseFns, function(values, oldValues) {
                                var currValue = compute(values);
                                isFunction(listener) && listener.call(this, currValue, values !== oldValues ? lastValue : currValue, scope), 
                                lastValue = currValue;
                            });
                        }
                    });
                }
            }
            var startSymbolLength = startSymbol.length, endSymbolLength = endSymbol.length, escapedStartRegexp = new RegExp(startSymbol.replace(/./g, escape), "g"), escapedEndRegexp = new RegExp(endSymbol.replace(/./g, escape), "g");
            return $interpolate.startSymbol = function() {
                return startSymbol;
            }, $interpolate.endSymbol = function() {
                return endSymbol;
            }, $interpolate;
        } ];
    }
    function $IntervalProvider() {
        this.$get = [ "$rootScope", "$window", "$q", "$$q", function($rootScope, $window, $q, $$q) {
            function interval(fn, delay, count, invokeApply) {
                var hasParams = arguments.length > 4, args = hasParams ? sliceArgs(arguments, 4) : [], setInterval = $window.setInterval, clearInterval = $window.clearInterval, iteration = 0, skipApply = isDefined(invokeApply) && !invokeApply, deferred = (skipApply ? $$q : $q).defer(), promise = deferred.promise;
                return count = isDefined(count) ? count : 0, promise.then(null, null, hasParams ? function() {
                    fn.apply(null, args);
                } : fn), promise.$$intervalId = setInterval(function() {
                    deferred.notify(iteration++), count > 0 && iteration >= count && (deferred.resolve(iteration), 
                    clearInterval(promise.$$intervalId), delete intervals[promise.$$intervalId]), skipApply || $rootScope.$apply();
                }, delay), intervals[promise.$$intervalId] = deferred, promise;
            }
            var intervals = {};
            return interval.cancel = function(promise) {
                return promise && promise.$$intervalId in intervals ? (intervals[promise.$$intervalId].reject("canceled"), 
                $window.clearInterval(promise.$$intervalId), delete intervals[promise.$$intervalId], 
                !0) : !1;
            }, interval;
        } ];
    }
    function encodePath(path) {
        for (var segments = path.split("/"), i = segments.length; i--; ) segments[i] = encodeUriSegment(segments[i]);
        return segments.join("/");
    }
    function parseAbsoluteUrl(absoluteUrl, locationObj) {
        var parsedUrl = urlResolve(absoluteUrl);
        locationObj.$$protocol = parsedUrl.protocol, locationObj.$$host = parsedUrl.hostname, 
        locationObj.$$port = toInt(parsedUrl.port) || DEFAULT_PORTS[parsedUrl.protocol] || null;
    }
    function parseAppUrl(relativeUrl, locationObj) {
        var prefixed = "/" !== relativeUrl.charAt(0);
        prefixed && (relativeUrl = "/" + relativeUrl);
        var match = urlResolve(relativeUrl);
        locationObj.$$path = decodeURIComponent(prefixed && "/" === match.pathname.charAt(0) ? match.pathname.substring(1) : match.pathname), 
        locationObj.$$search = parseKeyValue(match.search), locationObj.$$hash = decodeURIComponent(match.hash), 
        locationObj.$$path && "/" != locationObj.$$path.charAt(0) && (locationObj.$$path = "/" + locationObj.$$path);
    }
    function beginsWith(begin, whole) {
        return 0 === whole.indexOf(begin) ? whole.substr(begin.length) : void 0;
    }
    function stripHash(url) {
        var index = url.indexOf("#");
        return -1 == index ? url : url.substr(0, index);
    }
    function trimEmptyHash(url) {
        return url.replace(/(#.+)|#$/, "$1");
    }
    function stripFile(url) {
        return url.substr(0, stripHash(url).lastIndexOf("/") + 1);
    }
    function serverBase(url) {
        return url.substring(0, url.indexOf("/", url.indexOf("//") + 2));
    }
    function LocationHtml5Url(appBase, appBaseNoFile, basePrefix) {
        this.$$html5 = !0, basePrefix = basePrefix || "", parseAbsoluteUrl(appBase, this), 
        this.$$parse = function(url) {
            var pathUrl = beginsWith(appBaseNoFile, url);
            if (!isString(pathUrl)) throw $locationMinErr("ipthprfx", 'Invalid url "{0}", missing path prefix "{1}".', url, appBaseNoFile);
            parseAppUrl(pathUrl, this), this.$$path || (this.$$path = "/"), this.$$compose();
        }, this.$$compose = function() {
            var search = toKeyValue(this.$$search), hash = this.$$hash ? "#" + encodeUriSegment(this.$$hash) : "";
            this.$$url = encodePath(this.$$path) + (search ? "?" + search : "") + hash, this.$$absUrl = appBaseNoFile + this.$$url.substr(1);
        }, this.$$parseLinkUrl = function(url, relHref) {
            if (relHref && "#" === relHref[0]) return this.hash(relHref.slice(1)), !0;
            var appUrl, prevAppUrl, rewrittenUrl;
            return isDefined(appUrl = beginsWith(appBase, url)) ? (prevAppUrl = appUrl, rewrittenUrl = isDefined(appUrl = beginsWith(basePrefix, appUrl)) ? appBaseNoFile + (beginsWith("/", appUrl) || appUrl) : appBase + prevAppUrl) : isDefined(appUrl = beginsWith(appBaseNoFile, url)) ? rewrittenUrl = appBaseNoFile + appUrl : appBaseNoFile == url + "/" && (rewrittenUrl = appBaseNoFile), 
            rewrittenUrl && this.$$parse(rewrittenUrl), !!rewrittenUrl;
        };
    }
    function LocationHashbangUrl(appBase, appBaseNoFile, hashPrefix) {
        parseAbsoluteUrl(appBase, this), this.$$parse = function(url) {
            function removeWindowsDriveName(path, url, base) {
                var firstPathSegmentMatch, windowsFilePathExp = /^\/[A-Z]:(\/.*)/;
                return 0 === url.indexOf(base) && (url = url.replace(base, "")), windowsFilePathExp.exec(url) ? path : (firstPathSegmentMatch = windowsFilePathExp.exec(path), 
                firstPathSegmentMatch ? firstPathSegmentMatch[1] : path);
            }
            var withoutHashUrl, withoutBaseUrl = beginsWith(appBase, url) || beginsWith(appBaseNoFile, url);
            isUndefined(withoutBaseUrl) || "#" !== withoutBaseUrl.charAt(0) ? this.$$html5 ? withoutHashUrl = withoutBaseUrl : (withoutHashUrl = "", 
            isUndefined(withoutBaseUrl) && (appBase = url, this.replace())) : (withoutHashUrl = beginsWith(hashPrefix, withoutBaseUrl), 
            isUndefined(withoutHashUrl) && (withoutHashUrl = withoutBaseUrl)), parseAppUrl(withoutHashUrl, this), 
            this.$$path = removeWindowsDriveName(this.$$path, withoutHashUrl, appBase), this.$$compose();
        }, this.$$compose = function() {
            var search = toKeyValue(this.$$search), hash = this.$$hash ? "#" + encodeUriSegment(this.$$hash) : "";
            this.$$url = encodePath(this.$$path) + (search ? "?" + search : "") + hash, this.$$absUrl = appBase + (this.$$url ? hashPrefix + this.$$url : "");
        }, this.$$parseLinkUrl = function(url) {
            return stripHash(appBase) == stripHash(url) ? (this.$$parse(url), !0) : !1;
        };
    }
    function LocationHashbangInHtml5Url(appBase, appBaseNoFile, hashPrefix) {
        this.$$html5 = !0, LocationHashbangUrl.apply(this, arguments), this.$$parseLinkUrl = function(url, relHref) {
            if (relHref && "#" === relHref[0]) return this.hash(relHref.slice(1)), !0;
            var rewrittenUrl, appUrl;
            return appBase == stripHash(url) ? rewrittenUrl = url : (appUrl = beginsWith(appBaseNoFile, url)) ? rewrittenUrl = appBase + hashPrefix + appUrl : appBaseNoFile === url + "/" && (rewrittenUrl = appBaseNoFile), 
            rewrittenUrl && this.$$parse(rewrittenUrl), !!rewrittenUrl;
        }, this.$$compose = function() {
            var search = toKeyValue(this.$$search), hash = this.$$hash ? "#" + encodeUriSegment(this.$$hash) : "";
            this.$$url = encodePath(this.$$path) + (search ? "?" + search : "") + hash, this.$$absUrl = appBase + hashPrefix + this.$$url;
        };
    }
    function locationGetter(property) {
        return function() {
            return this[property];
        };
    }
    function locationGetterSetter(property, preprocess) {
        return function(value) {
            return isUndefined(value) ? this[property] : (this[property] = preprocess(value), 
            this.$$compose(), this);
        };
    }
    function $LocationProvider() {
        var hashPrefix = "", html5Mode = {
            enabled: !1,
            requireBase: !0,
            rewriteLinks: !0
        };
        this.hashPrefix = function(prefix) {
            return isDefined(prefix) ? (hashPrefix = prefix, this) : hashPrefix;
        }, this.html5Mode = function(mode) {
            return isBoolean(mode) ? (html5Mode.enabled = mode, this) : isObject(mode) ? (isBoolean(mode.enabled) && (html5Mode.enabled = mode.enabled), 
            isBoolean(mode.requireBase) && (html5Mode.requireBase = mode.requireBase), isBoolean(mode.rewriteLinks) && (html5Mode.rewriteLinks = mode.rewriteLinks), 
            this) : html5Mode;
        }, this.$get = [ "$rootScope", "$browser", "$sniffer", "$rootElement", "$window", function($rootScope, $browser, $sniffer, $rootElement, $window) {
            function setBrowserUrlWithFallback(url, replace, state) {
                var oldUrl = $location.url(), oldState = $location.$$state;
                try {
                    $browser.url(url, replace, state), $location.$$state = $browser.state();
                } catch (e) {
                    throw $location.url(oldUrl), $location.$$state = oldState, e;
                }
            }
            function afterLocationChange(oldUrl, oldState) {
                $rootScope.$broadcast("$locationChangeSuccess", $location.absUrl(), oldUrl, $location.$$state, oldState);
            }
            var $location, LocationMode, appBase, baseHref = $browser.baseHref(), initialUrl = $browser.url();
            if (html5Mode.enabled) {
                if (!baseHref && html5Mode.requireBase) throw $locationMinErr("nobase", "$location in HTML5 mode requires a <base> tag to be present!");
                appBase = serverBase(initialUrl) + (baseHref || "/"), LocationMode = $sniffer.history ? LocationHtml5Url : LocationHashbangInHtml5Url;
            } else appBase = stripHash(initialUrl), LocationMode = LocationHashbangUrl;
            var appBaseNoFile = stripFile(appBase);
            $location = new LocationMode(appBase, appBaseNoFile, "#" + hashPrefix), $location.$$parseLinkUrl(initialUrl, initialUrl), 
            $location.$$state = $browser.state();
            var IGNORE_URI_REGEXP = /^\s*(javascript|mailto):/i;
            $rootElement.on("click", function(event) {
                if (html5Mode.rewriteLinks && !event.ctrlKey && !event.metaKey && !event.shiftKey && 2 != event.which && 2 != event.button) {
                    for (var elm = jqLite(event.target); "a" !== nodeName_(elm[0]); ) if (elm[0] === $rootElement[0] || !(elm = elm.parent())[0]) return;
                    var absHref = elm.prop("href"), relHref = elm.attr("href") || elm.attr("xlink:href");
                    isObject(absHref) && "[object SVGAnimatedString]" === absHref.toString() && (absHref = urlResolve(absHref.animVal).href), 
                    IGNORE_URI_REGEXP.test(absHref) || !absHref || elm.attr("target") || event.isDefaultPrevented() || $location.$$parseLinkUrl(absHref, relHref) && (event.preventDefault(), 
                    $location.absUrl() != $browser.url() && ($rootScope.$apply(), $window.angular["ff-684208-preventDefault"] = !0));
                }
            }), trimEmptyHash($location.absUrl()) != trimEmptyHash(initialUrl) && $browser.url($location.absUrl(), !0);
            var initializing = !0;
            return $browser.onUrlChange(function(newUrl, newState) {
                return isUndefined(beginsWith(appBaseNoFile, newUrl)) ? void ($window.location.href = newUrl) : ($rootScope.$evalAsync(function() {
                    var defaultPrevented, oldUrl = $location.absUrl(), oldState = $location.$$state;
                    $location.$$parse(newUrl), $location.$$state = newState, defaultPrevented = $rootScope.$broadcast("$locationChangeStart", newUrl, oldUrl, newState, oldState).defaultPrevented, 
                    $location.absUrl() === newUrl && (defaultPrevented ? ($location.$$parse(oldUrl), 
                    $location.$$state = oldState, setBrowserUrlWithFallback(oldUrl, !1, oldState)) : (initializing = !1, 
                    afterLocationChange(oldUrl, oldState)));
                }), void ($rootScope.$$phase || $rootScope.$digest()));
            }), $rootScope.$watch(function() {
                var oldUrl = trimEmptyHash($browser.url()), newUrl = trimEmptyHash($location.absUrl()), oldState = $browser.state(), currentReplace = $location.$$replace, urlOrStateChanged = oldUrl !== newUrl || $location.$$html5 && $sniffer.history && oldState !== $location.$$state;
                (initializing || urlOrStateChanged) && (initializing = !1, $rootScope.$evalAsync(function() {
                    var newUrl = $location.absUrl(), defaultPrevented = $rootScope.$broadcast("$locationChangeStart", newUrl, oldUrl, $location.$$state, oldState).defaultPrevented;
                    $location.absUrl() === newUrl && (defaultPrevented ? ($location.$$parse(oldUrl), 
                    $location.$$state = oldState) : (urlOrStateChanged && setBrowserUrlWithFallback(newUrl, currentReplace, oldState === $location.$$state ? null : $location.$$state), 
                    afterLocationChange(oldUrl, oldState)));
                })), $location.$$replace = !1;
            }), $location;
        } ];
    }
    function $LogProvider() {
        var debug = !0, self = this;
        this.debugEnabled = function(flag) {
            return isDefined(flag) ? (debug = flag, this) : debug;
        }, this.$get = [ "$window", function($window) {
            function formatError(arg) {
                return arg instanceof Error && (arg.stack ? arg = arg.message && -1 === arg.stack.indexOf(arg.message) ? "Error: " + arg.message + "\n" + arg.stack : arg.stack : arg.sourceURL && (arg = arg.message + "\n" + arg.sourceURL + ":" + arg.line)), 
                arg;
            }
            function consoleLog(type) {
                var console = $window.console || {}, logFn = console[type] || console.log || noop, hasApply = !1;
                try {
                    hasApply = !!logFn.apply;
                } catch (e) {}
                return hasApply ? function() {
                    var args = [];
                    return forEach(arguments, function(arg) {
                        args.push(formatError(arg));
                    }), logFn.apply(console, args);
                } : function(arg1, arg2) {
                    logFn(arg1, null == arg2 ? "" : arg2);
                };
            }
            return {
                log: consoleLog("log"),
                info: consoleLog("info"),
                warn: consoleLog("warn"),
                error: consoleLog("error"),
                debug: function() {
                    var fn = consoleLog("debug");
                    return function() {
                        debug && fn.apply(self, arguments);
                    };
                }()
            };
        } ];
    }
    function ensureSafeMemberName(name, fullExpression) {
        if ("__defineGetter__" === name || "__defineSetter__" === name || "__lookupGetter__" === name || "__lookupSetter__" === name || "__proto__" === name) throw $parseMinErr("isecfld", "Attempting to access a disallowed field in Angular expressions! Expression: {0}", fullExpression);
        return name;
    }
    function getStringValue(name, fullExpression) {
        if (name += "", !isString(name)) throw $parseMinErr("iseccst", "Cannot convert object to primitive value! Expression: {0}", fullExpression);
        return name;
    }
    function ensureSafeObject(obj, fullExpression) {
        if (obj) {
            if (obj.constructor === obj) throw $parseMinErr("isecfn", "Referencing Function in Angular expressions is disallowed! Expression: {0}", fullExpression);
            if (obj.window === obj) throw $parseMinErr("isecwindow", "Referencing the Window in Angular expressions is disallowed! Expression: {0}", fullExpression);
            if (obj.children && (obj.nodeName || obj.prop && obj.attr && obj.find)) throw $parseMinErr("isecdom", "Referencing DOM nodes in Angular expressions is disallowed! Expression: {0}", fullExpression);
            if (obj === Object) throw $parseMinErr("isecobj", "Referencing Object in Angular expressions is disallowed! Expression: {0}", fullExpression);
        }
        return obj;
    }
    function ensureSafeFunction(obj, fullExpression) {
        if (obj) {
            if (obj.constructor === obj) throw $parseMinErr("isecfn", "Referencing Function in Angular expressions is disallowed! Expression: {0}", fullExpression);
            if (obj === CALL || obj === APPLY || obj === BIND) throw $parseMinErr("isecff", "Referencing call, apply or bind in Angular expressions is disallowed! Expression: {0}", fullExpression);
        }
    }
    function ensureSafeAssignContext(obj, fullExpression) {
        if (obj && (obj === 0..constructor || obj === (!1).constructor || obj === "".constructor || obj === {}.constructor || obj === [].constructor || obj === Function.constructor)) throw $parseMinErr("isecaf", "Assigning to a constructor is disallowed! Expression: {0}", fullExpression);
    }
    function ifDefined(v, d) {
        return "undefined" != typeof v ? v : d;
    }
    function plusFn(l, r) {
        return "undefined" == typeof l ? r : "undefined" == typeof r ? l : l + r;
    }
    function isStateless($filter, filterName) {
        var fn = $filter(filterName);
        return !fn.$stateful;
    }
    function findConstantAndWatchExpressions(ast, $filter) {
        var allConstants, argsToWatch;
        switch (ast.type) {
          case AST.Program:
            allConstants = !0, forEach(ast.body, function(expr) {
                findConstantAndWatchExpressions(expr.expression, $filter), allConstants = allConstants && expr.expression.constant;
            }), ast.constant = allConstants;
            break;

          case AST.Literal:
            ast.constant = !0, ast.toWatch = [];
            break;

          case AST.UnaryExpression:
            findConstantAndWatchExpressions(ast.argument, $filter), ast.constant = ast.argument.constant, 
            ast.toWatch = ast.argument.toWatch;
            break;

          case AST.BinaryExpression:
            findConstantAndWatchExpressions(ast.left, $filter), findConstantAndWatchExpressions(ast.right, $filter), 
            ast.constant = ast.left.constant && ast.right.constant, ast.toWatch = ast.left.toWatch.concat(ast.right.toWatch);
            break;

          case AST.LogicalExpression:
            findConstantAndWatchExpressions(ast.left, $filter), findConstantAndWatchExpressions(ast.right, $filter), 
            ast.constant = ast.left.constant && ast.right.constant, ast.toWatch = ast.constant ? [] : [ ast ];
            break;

          case AST.ConditionalExpression:
            findConstantAndWatchExpressions(ast.test, $filter), findConstantAndWatchExpressions(ast.alternate, $filter), 
            findConstantAndWatchExpressions(ast.consequent, $filter), ast.constant = ast.test.constant && ast.alternate.constant && ast.consequent.constant, 
            ast.toWatch = ast.constant ? [] : [ ast ];
            break;

          case AST.Identifier:
            ast.constant = !1, ast.toWatch = [ ast ];
            break;

          case AST.MemberExpression:
            findConstantAndWatchExpressions(ast.object, $filter), ast.computed && findConstantAndWatchExpressions(ast.property, $filter), 
            ast.constant = ast.object.constant && (!ast.computed || ast.property.constant), 
            ast.toWatch = [ ast ];
            break;

          case AST.CallExpression:
            allConstants = ast.filter ? isStateless($filter, ast.callee.name) : !1, argsToWatch = [], 
            forEach(ast.arguments, function(expr) {
                findConstantAndWatchExpressions(expr, $filter), allConstants = allConstants && expr.constant, 
                expr.constant || argsToWatch.push.apply(argsToWatch, expr.toWatch);
            }), ast.constant = allConstants, ast.toWatch = ast.filter && isStateless($filter, ast.callee.name) ? argsToWatch : [ ast ];
            break;

          case AST.AssignmentExpression:
            findConstantAndWatchExpressions(ast.left, $filter), findConstantAndWatchExpressions(ast.right, $filter), 
            ast.constant = ast.left.constant && ast.right.constant, ast.toWatch = [ ast ];
            break;

          case AST.ArrayExpression:
            allConstants = !0, argsToWatch = [], forEach(ast.elements, function(expr) {
                findConstantAndWatchExpressions(expr, $filter), allConstants = allConstants && expr.constant, 
                expr.constant || argsToWatch.push.apply(argsToWatch, expr.toWatch);
            }), ast.constant = allConstants, ast.toWatch = argsToWatch;
            break;

          case AST.ObjectExpression:
            allConstants = !0, argsToWatch = [], forEach(ast.properties, function(property) {
                findConstantAndWatchExpressions(property.value, $filter), allConstants = allConstants && property.value.constant, 
                property.value.constant || argsToWatch.push.apply(argsToWatch, property.value.toWatch);
            }), ast.constant = allConstants, ast.toWatch = argsToWatch;
            break;

          case AST.ThisExpression:
            ast.constant = !1, ast.toWatch = [];
        }
    }
    function getInputs(body) {
        if (1 == body.length) {
            var lastExpression = body[0].expression, candidate = lastExpression.toWatch;
            return 1 !== candidate.length ? candidate : candidate[0] !== lastExpression ? candidate : undefined;
        }
    }
    function isAssignable(ast) {
        return ast.type === AST.Identifier || ast.type === AST.MemberExpression;
    }
    function assignableAST(ast) {
        return 1 === ast.body.length && isAssignable(ast.body[0].expression) ? {
            type: AST.AssignmentExpression,
            left: ast.body[0].expression,
            right: {
                type: AST.NGValueParameter
            },
            operator: "="
        } : void 0;
    }
    function isLiteral(ast) {
        return 0 === ast.body.length || 1 === ast.body.length && (ast.body[0].expression.type === AST.Literal || ast.body[0].expression.type === AST.ArrayExpression || ast.body[0].expression.type === AST.ObjectExpression);
    }
    function isConstant(ast) {
        return ast.constant;
    }
    function ASTCompiler(astBuilder, $filter) {
        this.astBuilder = astBuilder, this.$filter = $filter;
    }
    function ASTInterpreter(astBuilder, $filter) {
        this.astBuilder = astBuilder, this.$filter = $filter;
    }
    function isPossiblyDangerousMemberName(name) {
        return "constructor" == name;
    }
    function getValueOf(value) {
        return isFunction(value.valueOf) ? value.valueOf() : objectValueOf.call(value);
    }
    function $ParseProvider() {
        var cacheDefault = createMap(), cacheExpensive = createMap();
        this.$get = [ "$filter", function($filter) {
            function expressionInputDirtyCheck(newValue, oldValueOfValue) {
                return null == newValue || null == oldValueOfValue ? newValue === oldValueOfValue : "object" == typeof newValue && (newValue = getValueOf(newValue), 
                "object" == typeof newValue) ? !1 : newValue === oldValueOfValue || newValue !== newValue && oldValueOfValue !== oldValueOfValue;
            }
            function inputsWatchDelegate(scope, listener, objectEquality, parsedExpression, prettyPrintExpression) {
                var lastResult, inputExpressions = parsedExpression.inputs;
                if (1 === inputExpressions.length) {
                    var oldInputValueOf = expressionInputDirtyCheck;
                    return inputExpressions = inputExpressions[0], scope.$watch(function(scope) {
                        var newInputValue = inputExpressions(scope);
                        return expressionInputDirtyCheck(newInputValue, oldInputValueOf) || (lastResult = parsedExpression(scope, undefined, undefined, [ newInputValue ]), 
                        oldInputValueOf = newInputValue && getValueOf(newInputValue)), lastResult;
                    }, listener, objectEquality, prettyPrintExpression);
                }
                for (var oldInputValueOfValues = [], oldInputValues = [], i = 0, ii = inputExpressions.length; ii > i; i++) oldInputValueOfValues[i] = expressionInputDirtyCheck, 
                oldInputValues[i] = null;
                return scope.$watch(function(scope) {
                    for (var changed = !1, i = 0, ii = inputExpressions.length; ii > i; i++) {
                        var newInputValue = inputExpressions[i](scope);
                        (changed || (changed = !expressionInputDirtyCheck(newInputValue, oldInputValueOfValues[i]))) && (oldInputValues[i] = newInputValue, 
                        oldInputValueOfValues[i] = newInputValue && getValueOf(newInputValue));
                    }
                    return changed && (lastResult = parsedExpression(scope, undefined, undefined, oldInputValues)), 
                    lastResult;
                }, listener, objectEquality, prettyPrintExpression);
            }
            function oneTimeWatchDelegate(scope, listener, objectEquality, parsedExpression) {
                var unwatch, lastValue;
                return unwatch = scope.$watch(function(scope) {
                    return parsedExpression(scope);
                }, function(value, old, scope) {
                    lastValue = value, isFunction(listener) && listener.apply(this, arguments), isDefined(value) && scope.$$postDigest(function() {
                        isDefined(lastValue) && unwatch();
                    });
                }, objectEquality);
            }
            function oneTimeLiteralWatchDelegate(scope, listener, objectEquality, parsedExpression) {
                function isAllDefined(value) {
                    var allDefined = !0;
                    return forEach(value, function(val) {
                        isDefined(val) || (allDefined = !1);
                    }), allDefined;
                }
                var unwatch, lastValue;
                return unwatch = scope.$watch(function(scope) {
                    return parsedExpression(scope);
                }, function(value, old, scope) {
                    lastValue = value, isFunction(listener) && listener.call(this, value, old, scope), 
                    isAllDefined(value) && scope.$$postDigest(function() {
                        isAllDefined(lastValue) && unwatch();
                    });
                }, objectEquality);
            }
            function constantWatchDelegate(scope, listener, objectEquality, parsedExpression) {
                var unwatch;
                return unwatch = scope.$watch(function(scope) {
                    return parsedExpression(scope);
                }, function() {
                    isFunction(listener) && listener.apply(this, arguments), unwatch();
                }, objectEquality);
            }
            function addInterceptor(parsedExpression, interceptorFn) {
                if (!interceptorFn) return parsedExpression;
                var watchDelegate = parsedExpression.$$watchDelegate, regularWatch = watchDelegate !== oneTimeLiteralWatchDelegate && watchDelegate !== oneTimeWatchDelegate, fn = regularWatch ? function(scope, locals, assign, inputs) {
                    var value = parsedExpression(scope, locals, assign, inputs);
                    return interceptorFn(value, scope, locals);
                } : function(scope, locals, assign, inputs) {
                    var value = parsedExpression(scope, locals, assign, inputs), result = interceptorFn(value, scope, locals);
                    return isDefined(value) ? result : value;
                };
                return parsedExpression.$$watchDelegate && parsedExpression.$$watchDelegate !== inputsWatchDelegate ? fn.$$watchDelegate = parsedExpression.$$watchDelegate : interceptorFn.$stateful || (fn.$$watchDelegate = inputsWatchDelegate, 
                fn.inputs = parsedExpression.inputs ? parsedExpression.inputs : [ parsedExpression ]), 
                fn;
            }
            var noUnsafeEval = csp().noUnsafeEval, $parseOptions = {
                csp: noUnsafeEval,
                expensiveChecks: !1
            }, $parseOptionsExpensive = {
                csp: noUnsafeEval,
                expensiveChecks: !0
            };
            return function(exp, interceptorFn, expensiveChecks) {
                var parsedExpression, oneTime, cacheKey;
                switch (typeof exp) {
                  case "string":
                    exp = exp.trim(), cacheKey = exp;
                    var cache = expensiveChecks ? cacheExpensive : cacheDefault;
                    if (parsedExpression = cache[cacheKey], !parsedExpression) {
                        ":" === exp.charAt(0) && ":" === exp.charAt(1) && (oneTime = !0, exp = exp.substring(2));
                        var parseOptions = expensiveChecks ? $parseOptionsExpensive : $parseOptions, lexer = new Lexer(parseOptions), parser = new Parser(lexer, $filter, parseOptions);
                        parsedExpression = parser.parse(exp), parsedExpression.constant ? parsedExpression.$$watchDelegate = constantWatchDelegate : oneTime ? parsedExpression.$$watchDelegate = parsedExpression.literal ? oneTimeLiteralWatchDelegate : oneTimeWatchDelegate : parsedExpression.inputs && (parsedExpression.$$watchDelegate = inputsWatchDelegate), 
                        cache[cacheKey] = parsedExpression;
                    }
                    return addInterceptor(parsedExpression, interceptorFn);

                  case "function":
                    return addInterceptor(exp, interceptorFn);

                  default:
                    return noop;
                }
            };
        } ];
    }
    function $QProvider() {
        this.$get = [ "$rootScope", "$exceptionHandler", function($rootScope, $exceptionHandler) {
            return qFactory(function(callback) {
                $rootScope.$evalAsync(callback);
            }, $exceptionHandler);
        } ];
    }
    function $$QProvider() {
        this.$get = [ "$browser", "$exceptionHandler", function($browser, $exceptionHandler) {
            return qFactory(function(callback) {
                $browser.defer(callback);
            }, $exceptionHandler);
        } ];
    }
    function qFactory(nextTick, exceptionHandler) {
        function callOnce(self, resolveFn, rejectFn) {
            function wrap(fn) {
                return function(value) {
                    called || (called = !0, fn.call(self, value));
                };
            }
            var called = !1;
            return [ wrap(resolveFn), wrap(rejectFn) ];
        }
        function Promise() {
            this.$$state = {
                status: 0
            };
        }
        function simpleBind(context, fn) {
            return function(value) {
                fn.call(context, value);
            };
        }
        function processQueue(state) {
            var fn, deferred, pending;
            pending = state.pending, state.processScheduled = !1, state.pending = undefined;
            for (var i = 0, ii = pending.length; ii > i; ++i) {
                deferred = pending[i][0], fn = pending[i][state.status];
                try {
                    isFunction(fn) ? deferred.resolve(fn(state.value)) : 1 === state.status ? deferred.resolve(state.value) : deferred.reject(state.value);
                } catch (e) {
                    deferred.reject(e), exceptionHandler(e);
                }
            }
        }
        function scheduleProcessQueue(state) {
            !state.processScheduled && state.pending && (state.processScheduled = !0, nextTick(function() {
                processQueue(state);
            }));
        }
        function Deferred() {
            this.promise = new Promise(), this.resolve = simpleBind(this, this.resolve), this.reject = simpleBind(this, this.reject), 
            this.notify = simpleBind(this, this.notify);
        }
        function all(promises) {
            var deferred = new Deferred(), counter = 0, results = isArray(promises) ? [] : {};
            return forEach(promises, function(promise, key) {
                counter++, when(promise).then(function(value) {
                    results.hasOwnProperty(key) || (results[key] = value, --counter || deferred.resolve(results));
                }, function(reason) {
                    results.hasOwnProperty(key) || deferred.reject(reason);
                });
            }), 0 === counter && deferred.resolve(results), deferred.promise;
        }
        var $qMinErr = minErr("$q", TypeError), defer = function() {
            return new Deferred();
        };
        extend(Promise.prototype, {
            then: function(onFulfilled, onRejected, progressBack) {
                if (isUndefined(onFulfilled) && isUndefined(onRejected) && isUndefined(progressBack)) return this;
                var result = new Deferred();
                return this.$$state.pending = this.$$state.pending || [], this.$$state.pending.push([ result, onFulfilled, onRejected, progressBack ]), 
                this.$$state.status > 0 && scheduleProcessQueue(this.$$state), result.promise;
            },
            "catch": function(callback) {
                return this.then(null, callback);
            },
            "finally": function(callback, progressBack) {
                return this.then(function(value) {
                    return handleCallback(value, !0, callback);
                }, function(error) {
                    return handleCallback(error, !1, callback);
                }, progressBack);
            }
        }), extend(Deferred.prototype, {
            resolve: function(val) {
                this.promise.$$state.status || (val === this.promise ? this.$$reject($qMinErr("qcycle", "Expected promise to be resolved with value other than itself '{0}'", val)) : this.$$resolve(val));
            },
            $$resolve: function(val) {
                var then, fns;
                fns = callOnce(this, this.$$resolve, this.$$reject);
                try {
                    (isObject(val) || isFunction(val)) && (then = val && val.then), isFunction(then) ? (this.promise.$$state.status = -1, 
                    then.call(val, fns[0], fns[1], this.notify)) : (this.promise.$$state.value = val, 
                    this.promise.$$state.status = 1, scheduleProcessQueue(this.promise.$$state));
                } catch (e) {
                    fns[1](e), exceptionHandler(e);
                }
            },
            reject: function(reason) {
                this.promise.$$state.status || this.$$reject(reason);
            },
            $$reject: function(reason) {
                this.promise.$$state.value = reason, this.promise.$$state.status = 2, scheduleProcessQueue(this.promise.$$state);
            },
            notify: function(progress) {
                var callbacks = this.promise.$$state.pending;
                this.promise.$$state.status <= 0 && callbacks && callbacks.length && nextTick(function() {
                    for (var callback, result, i = 0, ii = callbacks.length; ii > i; i++) {
                        result = callbacks[i][0], callback = callbacks[i][3];
                        try {
                            result.notify(isFunction(callback) ? callback(progress) : progress);
                        } catch (e) {
                            exceptionHandler(e);
                        }
                    }
                });
            }
        });
        var reject = function(reason) {
            var result = new Deferred();
            return result.reject(reason), result.promise;
        }, makePromise = function(value, resolved) {
            var result = new Deferred();
            return resolved ? result.resolve(value) : result.reject(value), result.promise;
        }, handleCallback = function(value, isResolved, callback) {
            var callbackOutput = null;
            try {
                isFunction(callback) && (callbackOutput = callback());
            } catch (e) {
                return makePromise(e, !1);
            }
            return isPromiseLike(callbackOutput) ? callbackOutput.then(function() {
                return makePromise(value, isResolved);
            }, function(error) {
                return makePromise(error, !1);
            }) : makePromise(value, isResolved);
        }, when = function(value, callback, errback, progressBack) {
            var result = new Deferred();
            return result.resolve(value), result.promise.then(callback, errback, progressBack);
        }, resolve = when, $Q = function Q(resolver) {
            function resolveFn(value) {
                deferred.resolve(value);
            }
            function rejectFn(reason) {
                deferred.reject(reason);
            }
            if (!isFunction(resolver)) throw $qMinErr("norslvr", "Expected resolverFn, got '{0}'", resolver);
            if (!(this instanceof Q)) return new Q(resolver);
            var deferred = new Deferred();
            return resolver(resolveFn, rejectFn), deferred.promise;
        };
        return $Q.defer = defer, $Q.reject = reject, $Q.when = when, $Q.resolve = resolve, 
        $Q.all = all, $Q;
    }
    function $$RAFProvider() {
        this.$get = [ "$window", "$timeout", function($window, $timeout) {
            var requestAnimationFrame = $window.requestAnimationFrame || $window.webkitRequestAnimationFrame, cancelAnimationFrame = $window.cancelAnimationFrame || $window.webkitCancelAnimationFrame || $window.webkitCancelRequestAnimationFrame, rafSupported = !!requestAnimationFrame, raf = rafSupported ? function(fn) {
                var id = requestAnimationFrame(fn);
                return function() {
                    cancelAnimationFrame(id);
                };
            } : function(fn) {
                var timer = $timeout(fn, 16.66, !1);
                return function() {
                    $timeout.cancel(timer);
                };
            };
            return raf.supported = rafSupported, raf;
        } ];
    }
    function $RootScopeProvider() {
        function createChildScopeClass(parent) {
            function ChildScope() {
                this.$$watchers = this.$$nextSibling = this.$$childHead = this.$$childTail = null, 
                this.$$listeners = {}, this.$$listenerCount = {}, this.$$watchersCount = 0, this.$id = nextUid(), 
                this.$$ChildScope = null;
            }
            return ChildScope.prototype = parent, ChildScope;
        }
        var TTL = 10, $rootScopeMinErr = minErr("$rootScope"), lastDirtyWatch = null, applyAsyncId = null;
        this.digestTtl = function(value) {
            return arguments.length && (TTL = value), TTL;
        }, this.$get = [ "$injector", "$exceptionHandler", "$parse", "$browser", function($injector, $exceptionHandler, $parse, $browser) {
            function destroyChildScope($event) {
                $event.currentScope.$$destroyed = !0;
            }
            function Scope() {
                this.$id = nextUid(), this.$$phase = this.$parent = this.$$watchers = this.$$nextSibling = this.$$prevSibling = this.$$childHead = this.$$childTail = null, 
                this.$root = this, this.$$destroyed = !1, this.$$listeners = {}, this.$$listenerCount = {}, 
                this.$$watchersCount = 0, this.$$isolateBindings = null;
            }
            function beginPhase(phase) {
                if ($rootScope.$$phase) throw $rootScopeMinErr("inprog", "{0} already in progress", $rootScope.$$phase);
                $rootScope.$$phase = phase;
            }
            function clearPhase() {
                $rootScope.$$phase = null;
            }
            function incrementWatchersCount(current, count) {
                do current.$$watchersCount += count; while (current = current.$parent);
            }
            function decrementListenerCount(current, count, name) {
                do current.$$listenerCount[name] -= count, 0 === current.$$listenerCount[name] && delete current.$$listenerCount[name]; while (current = current.$parent);
            }
            function initWatchVal() {}
            function flushApplyAsync() {
                for (;applyAsyncQueue.length; ) try {
                    applyAsyncQueue.shift()();
                } catch (e) {
                    $exceptionHandler(e);
                }
                applyAsyncId = null;
            }
            function scheduleApplyAsync() {
                null === applyAsyncId && (applyAsyncId = $browser.defer(function() {
                    $rootScope.$apply(flushApplyAsync);
                }));
            }
            Scope.prototype = {
                constructor: Scope,
                $new: function(isolate, parent) {
                    var child;
                    return parent = parent || this, isolate ? (child = new Scope(), child.$root = this.$root) : (this.$$ChildScope || (this.$$ChildScope = createChildScopeClass(this)), 
                    child = new this.$$ChildScope()), child.$parent = parent, child.$$prevSibling = parent.$$childTail, 
                    parent.$$childHead ? (parent.$$childTail.$$nextSibling = child, parent.$$childTail = child) : parent.$$childHead = parent.$$childTail = child, 
                    (isolate || parent != this) && child.$on("$destroy", destroyChildScope), child;
                },
                $watch: function(watchExp, listener, objectEquality, prettyPrintExpression) {
                    var get = $parse(watchExp);
                    if (get.$$watchDelegate) return get.$$watchDelegate(this, listener, objectEquality, get, watchExp);
                    var scope = this, array = scope.$$watchers, watcher = {
                        fn: listener,
                        last: initWatchVal,
                        get: get,
                        exp: prettyPrintExpression || watchExp,
                        eq: !!objectEquality
                    };
                    return lastDirtyWatch = null, isFunction(listener) || (watcher.fn = noop), array || (array = scope.$$watchers = []), 
                    array.unshift(watcher), incrementWatchersCount(this, 1), function() {
                        arrayRemove(array, watcher) >= 0 && incrementWatchersCount(scope, -1), lastDirtyWatch = null;
                    };
                },
                $watchGroup: function(watchExpressions, listener) {
                    function watchGroupAction() {
                        changeReactionScheduled = !1, firstRun ? (firstRun = !1, listener(newValues, newValues, self)) : listener(newValues, oldValues, self);
                    }
                    var oldValues = new Array(watchExpressions.length), newValues = new Array(watchExpressions.length), deregisterFns = [], self = this, changeReactionScheduled = !1, firstRun = !0;
                    if (!watchExpressions.length) {
                        var shouldCall = !0;
                        return self.$evalAsync(function() {
                            shouldCall && listener(newValues, newValues, self);
                        }), function() {
                            shouldCall = !1;
                        };
                    }
                    return 1 === watchExpressions.length ? this.$watch(watchExpressions[0], function(value, oldValue, scope) {
                        newValues[0] = value, oldValues[0] = oldValue, listener(newValues, value === oldValue ? newValues : oldValues, scope);
                    }) : (forEach(watchExpressions, function(expr, i) {
                        var unwatchFn = self.$watch(expr, function(value, oldValue) {
                            newValues[i] = value, oldValues[i] = oldValue, changeReactionScheduled || (changeReactionScheduled = !0, 
                            self.$evalAsync(watchGroupAction));
                        });
                        deregisterFns.push(unwatchFn);
                    }), function() {
                        for (;deregisterFns.length; ) deregisterFns.shift()();
                    });
                },
                $watchCollection: function(obj, listener) {
                    function $watchCollectionInterceptor(_value) {
                        newValue = _value;
                        var newLength, key, bothNaN, newItem, oldItem;
                        if (!isUndefined(newValue)) {
                            if (isObject(newValue)) if (isArrayLike(newValue)) {
                                oldValue !== internalArray && (oldValue = internalArray, oldLength = oldValue.length = 0, 
                                changeDetected++), newLength = newValue.length, oldLength !== newLength && (changeDetected++, 
                                oldValue.length = oldLength = newLength);
                                for (var i = 0; newLength > i; i++) oldItem = oldValue[i], newItem = newValue[i], 
                                bothNaN = oldItem !== oldItem && newItem !== newItem, bothNaN || oldItem === newItem || (changeDetected++, 
                                oldValue[i] = newItem);
                            } else {
                                oldValue !== internalObject && (oldValue = internalObject = {}, oldLength = 0, changeDetected++), 
                                newLength = 0;
                                for (key in newValue) hasOwnProperty.call(newValue, key) && (newLength++, newItem = newValue[key], 
                                oldItem = oldValue[key], key in oldValue ? (bothNaN = oldItem !== oldItem && newItem !== newItem, 
                                bothNaN || oldItem === newItem || (changeDetected++, oldValue[key] = newItem)) : (oldLength++, 
                                oldValue[key] = newItem, changeDetected++));
                                if (oldLength > newLength) {
                                    changeDetected++;
                                    for (key in oldValue) hasOwnProperty.call(newValue, key) || (oldLength--, delete oldValue[key]);
                                }
                            } else oldValue !== newValue && (oldValue = newValue, changeDetected++);
                            return changeDetected;
                        }
                    }
                    function $watchCollectionAction() {
                        if (initRun ? (initRun = !1, listener(newValue, newValue, self)) : listener(newValue, veryOldValue, self), 
                        trackVeryOldValue) if (isObject(newValue)) if (isArrayLike(newValue)) {
                            veryOldValue = new Array(newValue.length);
                            for (var i = 0; i < newValue.length; i++) veryOldValue[i] = newValue[i];
                        } else {
                            veryOldValue = {};
                            for (var key in newValue) hasOwnProperty.call(newValue, key) && (veryOldValue[key] = newValue[key]);
                        } else veryOldValue = newValue;
                    }
                    $watchCollectionInterceptor.$stateful = !0;
                    var newValue, oldValue, veryOldValue, self = this, trackVeryOldValue = listener.length > 1, changeDetected = 0, changeDetector = $parse(obj, $watchCollectionInterceptor), internalArray = [], internalObject = {}, initRun = !0, oldLength = 0;
                    return this.$watch(changeDetector, $watchCollectionAction);
                },
                $digest: function() {
                    var watch, value, last, watchers, length, dirty, next, current, logIdx, asyncTask, ttl = TTL, target = this, watchLog = [];
                    beginPhase("$digest"), $browser.$$checkUrlChange(), this === $rootScope && null !== applyAsyncId && ($browser.defer.cancel(applyAsyncId), 
                    flushApplyAsync()), lastDirtyWatch = null;
                    do {
                        for (dirty = !1, current = target; asyncQueue.length; ) {
                            try {
                                asyncTask = asyncQueue.shift(), asyncTask.scope.$eval(asyncTask.expression, asyncTask.locals);
                            } catch (e) {
                                $exceptionHandler(e);
                            }
                            lastDirtyWatch = null;
                        }
                        traverseScopesLoop: do {
                            if (watchers = current.$$watchers) for (length = watchers.length; length--; ) try {
                                if (watch = watchers[length]) if ((value = watch.get(current)) === (last = watch.last) || (watch.eq ? equals(value, last) : "number" == typeof value && "number" == typeof last && isNaN(value) && isNaN(last))) {
                                    if (watch === lastDirtyWatch) {
                                        dirty = !1;
                                        break traverseScopesLoop;
                                    }
                                } else dirty = !0, lastDirtyWatch = watch, watch.last = watch.eq ? copy(value, null) : value, 
                                watch.fn(value, last === initWatchVal ? value : last, current), 5 > ttl && (logIdx = 4 - ttl, 
                                watchLog[logIdx] || (watchLog[logIdx] = []), watchLog[logIdx].push({
                                    msg: isFunction(watch.exp) ? "fn: " + (watch.exp.name || watch.exp.toString()) : watch.exp,
                                    newVal: value,
                                    oldVal: last
                                }));
                            } catch (e) {
                                $exceptionHandler(e);
                            }
                            if (!(next = current.$$watchersCount && current.$$childHead || current !== target && current.$$nextSibling)) for (;current !== target && !(next = current.$$nextSibling); ) current = current.$parent;
                        } while (current = next);
                        if ((dirty || asyncQueue.length) && !ttl--) throw clearPhase(), $rootScopeMinErr("infdig", "{0} $digest() iterations reached. Aborting!\nWatchers fired in the last 5 iterations: {1}", TTL, watchLog);
                    } while (dirty || asyncQueue.length);
                    for (clearPhase(); postDigestQueue.length; ) try {
                        postDigestQueue.shift()();
                    } catch (e) {
                        $exceptionHandler(e);
                    }
                },
                $destroy: function() {
                    if (!this.$$destroyed) {
                        var parent = this.$parent;
                        this.$broadcast("$destroy"), this.$$destroyed = !0, this === $rootScope && $browser.$$applicationDestroyed(), 
                        incrementWatchersCount(this, -this.$$watchersCount);
                        for (var eventName in this.$$listenerCount) decrementListenerCount(this, this.$$listenerCount[eventName], eventName);
                        parent && parent.$$childHead == this && (parent.$$childHead = this.$$nextSibling), 
                        parent && parent.$$childTail == this && (parent.$$childTail = this.$$prevSibling), 
                        this.$$prevSibling && (this.$$prevSibling.$$nextSibling = this.$$nextSibling), this.$$nextSibling && (this.$$nextSibling.$$prevSibling = this.$$prevSibling), 
                        this.$destroy = this.$digest = this.$apply = this.$evalAsync = this.$applyAsync = noop, 
                        this.$on = this.$watch = this.$watchGroup = function() {
                            return noop;
                        }, this.$$listeners = {}, this.$parent = this.$$nextSibling = this.$$prevSibling = this.$$childHead = this.$$childTail = this.$root = this.$$watchers = null;
                    }
                },
                $eval: function(expr, locals) {
                    return $parse(expr)(this, locals);
                },
                $evalAsync: function(expr, locals) {
                    $rootScope.$$phase || asyncQueue.length || $browser.defer(function() {
                        asyncQueue.length && $rootScope.$digest();
                    }), asyncQueue.push({
                        scope: this,
                        expression: expr,
                        locals: locals
                    });
                },
                $$postDigest: function(fn) {
                    postDigestQueue.push(fn);
                },
                $apply: function(expr) {
                    try {
                        beginPhase("$apply");
                        try {
                            return this.$eval(expr);
                        } finally {
                            clearPhase();
                        }
                    } catch (e) {
                        $exceptionHandler(e);
                    } finally {
                        try {
                            $rootScope.$digest();
                        } catch (e) {
                            throw $exceptionHandler(e), e;
                        }
                    }
                },
                $applyAsync: function(expr) {
                    function $applyAsyncExpression() {
                        scope.$eval(expr);
                    }
                    var scope = this;
                    expr && applyAsyncQueue.push($applyAsyncExpression), scheduleApplyAsync();
                },
                $on: function(name, listener) {
                    var namedListeners = this.$$listeners[name];
                    namedListeners || (this.$$listeners[name] = namedListeners = []), namedListeners.push(listener);
                    var current = this;
                    do current.$$listenerCount[name] || (current.$$listenerCount[name] = 0), current.$$listenerCount[name]++; while (current = current.$parent);
                    var self = this;
                    return function() {
                        var indexOfListener = namedListeners.indexOf(listener);
                        -1 !== indexOfListener && (namedListeners[indexOfListener] = null, decrementListenerCount(self, 1, name));
                    };
                },
                $emit: function(name) {
                    var namedListeners, i, length, empty = [], scope = this, stopPropagation = !1, event = {
                        name: name,
                        targetScope: scope,
                        stopPropagation: function() {
                            stopPropagation = !0;
                        },
                        preventDefault: function() {
                            event.defaultPrevented = !0;
                        },
                        defaultPrevented: !1
                    }, listenerArgs = concat([ event ], arguments, 1);
                    do {
                        for (namedListeners = scope.$$listeners[name] || empty, event.currentScope = scope, 
                        i = 0, length = namedListeners.length; length > i; i++) if (namedListeners[i]) try {
                            namedListeners[i].apply(null, listenerArgs);
                        } catch (e) {
                            $exceptionHandler(e);
                        } else namedListeners.splice(i, 1), i--, length--;
                        if (stopPropagation) return event.currentScope = null, event;
                        scope = scope.$parent;
                    } while (scope);
                    return event.currentScope = null, event;
                },
                $broadcast: function(name) {
                    var target = this, current = target, next = target, event = {
                        name: name,
                        targetScope: target,
                        preventDefault: function() {
                            event.defaultPrevented = !0;
                        },
                        defaultPrevented: !1
                    };
                    if (!target.$$listenerCount[name]) return event;
                    for (var listeners, i, length, listenerArgs = concat([ event ], arguments, 1); current = next; ) {
                        for (event.currentScope = current, listeners = current.$$listeners[name] || [], 
                        i = 0, length = listeners.length; length > i; i++) if (listeners[i]) try {
                            listeners[i].apply(null, listenerArgs);
                        } catch (e) {
                            $exceptionHandler(e);
                        } else listeners.splice(i, 1), i--, length--;
                        if (!(next = current.$$listenerCount[name] && current.$$childHead || current !== target && current.$$nextSibling)) for (;current !== target && !(next = current.$$nextSibling); ) current = current.$parent;
                    }
                    return event.currentScope = null, event;
                }
            };
            var $rootScope = new Scope(), asyncQueue = $rootScope.$$asyncQueue = [], postDigestQueue = $rootScope.$$postDigestQueue = [], applyAsyncQueue = $rootScope.$$applyAsyncQueue = [];
            return $rootScope;
        } ];
    }
    function $$SanitizeUriProvider() {
        var aHrefSanitizationWhitelist = /^\s*(https?|ftp|mailto|tel|file):/, imgSrcSanitizationWhitelist = /^\s*((https?|ftp|file|blob):|data:image\/)/;
        this.aHrefSanitizationWhitelist = function(regexp) {
            return isDefined(regexp) ? (aHrefSanitizationWhitelist = regexp, this) : aHrefSanitizationWhitelist;
        }, this.imgSrcSanitizationWhitelist = function(regexp) {
            return isDefined(regexp) ? (imgSrcSanitizationWhitelist = regexp, this) : imgSrcSanitizationWhitelist;
        }, this.$get = function() {
            return function(uri, isImage) {
                var normalizedVal, regex = isImage ? imgSrcSanitizationWhitelist : aHrefSanitizationWhitelist;
                return normalizedVal = urlResolve(uri).href, "" === normalizedVal || normalizedVal.match(regex) ? uri : "unsafe:" + normalizedVal;
            };
        };
    }
    function adjustMatcher(matcher) {
        if ("self" === matcher) return matcher;
        if (isString(matcher)) {
            if (matcher.indexOf("***") > -1) throw $sceMinErr("iwcard", "Illegal sequence *** in string matcher.  String: {0}", matcher);
            return matcher = escapeForRegexp(matcher).replace("\\*\\*", ".*").replace("\\*", "[^:/.?&;]*"), 
            new RegExp("^" + matcher + "$");
        }
        if (isRegExp(matcher)) return new RegExp("^" + matcher.source + "$");
        throw $sceMinErr("imatcher", 'Matchers may only be "self", string patterns or RegExp objects');
    }
    function adjustMatchers(matchers) {
        var adjustedMatchers = [];
        return isDefined(matchers) && forEach(matchers, function(matcher) {
            adjustedMatchers.push(adjustMatcher(matcher));
        }), adjustedMatchers;
    }
    function $SceDelegateProvider() {
        this.SCE_CONTEXTS = SCE_CONTEXTS;
        var resourceUrlWhitelist = [ "self" ], resourceUrlBlacklist = [];
        this.resourceUrlWhitelist = function(value) {
            return arguments.length && (resourceUrlWhitelist = adjustMatchers(value)), resourceUrlWhitelist;
        }, this.resourceUrlBlacklist = function(value) {
            return arguments.length && (resourceUrlBlacklist = adjustMatchers(value)), resourceUrlBlacklist;
        }, this.$get = [ "$injector", function($injector) {
            function matchUrl(matcher, parsedUrl) {
                return "self" === matcher ? urlIsSameOrigin(parsedUrl) : !!matcher.exec(parsedUrl.href);
            }
            function isResourceUrlAllowedByPolicy(url) {
                var i, n, parsedUrl = urlResolve(url.toString()), allowed = !1;
                for (i = 0, n = resourceUrlWhitelist.length; n > i; i++) if (matchUrl(resourceUrlWhitelist[i], parsedUrl)) {
                    allowed = !0;
                    break;
                }
                if (allowed) for (i = 0, n = resourceUrlBlacklist.length; n > i; i++) if (matchUrl(resourceUrlBlacklist[i], parsedUrl)) {
                    allowed = !1;
                    break;
                }
                return allowed;
            }
            function generateHolderType(Base) {
                var holderType = function(trustedValue) {
                    this.$$unwrapTrustedValue = function() {
                        return trustedValue;
                    };
                };
                return Base && (holderType.prototype = new Base()), holderType.prototype.valueOf = function() {
                    return this.$$unwrapTrustedValue();
                }, holderType.prototype.toString = function() {
                    return this.$$unwrapTrustedValue().toString();
                }, holderType;
            }
            function trustAs(type, trustedValue) {
                var Constructor = byType.hasOwnProperty(type) ? byType[type] : null;
                if (!Constructor) throw $sceMinErr("icontext", "Attempted to trust a value in invalid context. Context: {0}; Value: {1}", type, trustedValue);
                if (null === trustedValue || isUndefined(trustedValue) || "" === trustedValue) return trustedValue;
                if ("string" != typeof trustedValue) throw $sceMinErr("itype", "Attempted to trust a non-string value in a content requiring a string: Context: {0}", type);
                return new Constructor(trustedValue);
            }
            function valueOf(maybeTrusted) {
                return maybeTrusted instanceof trustedValueHolderBase ? maybeTrusted.$$unwrapTrustedValue() : maybeTrusted;
            }
            function getTrusted(type, maybeTrusted) {
                if (null === maybeTrusted || isUndefined(maybeTrusted) || "" === maybeTrusted) return maybeTrusted;
                var constructor = byType.hasOwnProperty(type) ? byType[type] : null;
                if (constructor && maybeTrusted instanceof constructor) return maybeTrusted.$$unwrapTrustedValue();
                if (type === SCE_CONTEXTS.RESOURCE_URL) {
                    if (isResourceUrlAllowedByPolicy(maybeTrusted)) return maybeTrusted;
                    throw $sceMinErr("insecurl", "Blocked loading resource from url not allowed by $sceDelegate policy.  URL: {0}", maybeTrusted.toString());
                }
                if (type === SCE_CONTEXTS.HTML) return htmlSanitizer(maybeTrusted);
                throw $sceMinErr("unsafe", "Attempting to use an unsafe value in a safe context.");
            }
            var htmlSanitizer = function() {
                throw $sceMinErr("unsafe", "Attempting to use an unsafe value in a safe context.");
            };
            $injector.has("$sanitize") && (htmlSanitizer = $injector.get("$sanitize"));
            var trustedValueHolderBase = generateHolderType(), byType = {};
            return byType[SCE_CONTEXTS.HTML] = generateHolderType(trustedValueHolderBase), byType[SCE_CONTEXTS.CSS] = generateHolderType(trustedValueHolderBase), 
            byType[SCE_CONTEXTS.URL] = generateHolderType(trustedValueHolderBase), byType[SCE_CONTEXTS.JS] = generateHolderType(trustedValueHolderBase), 
            byType[SCE_CONTEXTS.RESOURCE_URL] = generateHolderType(byType[SCE_CONTEXTS.URL]), 
            {
                trustAs: trustAs,
                getTrusted: getTrusted,
                valueOf: valueOf
            };
        } ];
    }
    function $SceProvider() {
        var enabled = !0;
        this.enabled = function(value) {
            return arguments.length && (enabled = !!value), enabled;
        }, this.$get = [ "$parse", "$sceDelegate", function($parse, $sceDelegate) {
            if (enabled && 8 > msie) throw $sceMinErr("iequirks", "Strict Contextual Escaping does not support Internet Explorer version < 11 in quirks mode.  You can fix this by adding the text <!doctype html> to the top of your HTML document.  See http://docs.angularjs.org/api/ng.$sce for more information.");
            var sce = shallowCopy(SCE_CONTEXTS);
            sce.isEnabled = function() {
                return enabled;
            }, sce.trustAs = $sceDelegate.trustAs, sce.getTrusted = $sceDelegate.getTrusted, 
            sce.valueOf = $sceDelegate.valueOf, enabled || (sce.trustAs = sce.getTrusted = function(type, value) {
                return value;
            }, sce.valueOf = identity), sce.parseAs = function(type, expr) {
                var parsed = $parse(expr);
                return parsed.literal && parsed.constant ? parsed : $parse(expr, function(value) {
                    return sce.getTrusted(type, value);
                });
            };
            var parse = sce.parseAs, getTrusted = sce.getTrusted, trustAs = sce.trustAs;
            return forEach(SCE_CONTEXTS, function(enumValue, name) {
                var lName = lowercase(name);
                sce[camelCase("parse_as_" + lName)] = function(expr) {
                    return parse(enumValue, expr);
                }, sce[camelCase("get_trusted_" + lName)] = function(value) {
                    return getTrusted(enumValue, value);
                }, sce[camelCase("trust_as_" + lName)] = function(value) {
                    return trustAs(enumValue, value);
                };
            }), sce;
        } ];
    }
    function $SnifferProvider() {
        this.$get = [ "$window", "$document", function($window, $document) {
            var vendorPrefix, match, eventSupport = {}, android = toInt((/android (\d+)/.exec(lowercase(($window.navigator || {}).userAgent)) || [])[1]), boxee = /Boxee/i.test(($window.navigator || {}).userAgent), document = $document[0] || {}, vendorRegex = /^(Moz|webkit|ms)(?=[A-Z])/, bodyStyle = document.body && document.body.style, transitions = !1, animations = !1;
            if (bodyStyle) {
                for (var prop in bodyStyle) if (match = vendorRegex.exec(prop)) {
                    vendorPrefix = match[0], vendorPrefix = vendorPrefix.substr(0, 1).toUpperCase() + vendorPrefix.substr(1);
                    break;
                }
                vendorPrefix || (vendorPrefix = "WebkitOpacity" in bodyStyle && "webkit"), transitions = !!("transition" in bodyStyle || vendorPrefix + "Transition" in bodyStyle), 
                animations = !!("animation" in bodyStyle || vendorPrefix + "Animation" in bodyStyle), 
                !android || transitions && animations || (transitions = isString(bodyStyle.webkitTransition), 
                animations = isString(bodyStyle.webkitAnimation));
            }
            return {
                history: !(!$window.history || !$window.history.pushState || 4 > android || boxee),
                hasEvent: function(event) {
                    if ("input" === event && 11 >= msie) return !1;
                    if (isUndefined(eventSupport[event])) {
                        var divElm = document.createElement("div");
                        eventSupport[event] = "on" + event in divElm;
                    }
                    return eventSupport[event];
                },
                csp: csp(),
                vendorPrefix: vendorPrefix,
                transitions: transitions,
                animations: animations,
                android: android
            };
        } ];
    }
    function $TemplateRequestProvider() {
        this.$get = [ "$templateCache", "$http", "$q", "$sce", function($templateCache, $http, $q, $sce) {
            function handleRequestFn(tpl, ignoreRequestError) {
                function handleError(resp) {
                    if (!ignoreRequestError) throw $compileMinErr("tpload", "Failed to load template: {0} (HTTP status: {1} {2})", tpl, resp.status, resp.statusText);
                    return $q.reject(resp);
                }
                handleRequestFn.totalPendingRequests++, isString(tpl) && $templateCache.get(tpl) || (tpl = $sce.getTrustedResourceUrl(tpl));
                var transformResponse = $http.defaults && $http.defaults.transformResponse;
                isArray(transformResponse) ? transformResponse = transformResponse.filter(function(transformer) {
                    return transformer !== defaultHttpResponseTransform;
                }) : transformResponse === defaultHttpResponseTransform && (transformResponse = null);
                var httpOptions = {
                    cache: $templateCache,
                    transformResponse: transformResponse
                };
                return $http.get(tpl, httpOptions)["finally"](function() {
                    handleRequestFn.totalPendingRequests--;
                }).then(function(response) {
                    return $templateCache.put(tpl, response.data), response.data;
                }, handleError);
            }
            return handleRequestFn.totalPendingRequests = 0, handleRequestFn;
        } ];
    }
    function $$TestabilityProvider() {
        this.$get = [ "$rootScope", "$browser", "$location", function($rootScope, $browser, $location) {
            var testability = {};
            return testability.findBindings = function(element, expression, opt_exactMatch) {
                var bindings = element.getElementsByClassName("ng-binding"), matches = [];
                return forEach(bindings, function(binding) {
                    var dataBinding = angular.element(binding).data("$binding");
                    dataBinding && forEach(dataBinding, function(bindingName) {
                        if (opt_exactMatch) {
                            var matcher = new RegExp("(^|\\s)" + escapeForRegexp(expression) + "(\\s|\\||$)");
                            matcher.test(bindingName) && matches.push(binding);
                        } else -1 != bindingName.indexOf(expression) && matches.push(binding);
                    });
                }), matches;
            }, testability.findModels = function(element, expression, opt_exactMatch) {
                for (var prefixes = [ "ng-", "data-ng-", "ng\\:" ], p = 0; p < prefixes.length; ++p) {
                    var attributeEquals = opt_exactMatch ? "=" : "*=", selector = "[" + prefixes[p] + "model" + attributeEquals + '"' + expression + '"]', elements = element.querySelectorAll(selector);
                    if (elements.length) return elements;
                }
            }, testability.getLocation = function() {
                return $location.url();
            }, testability.setLocation = function(url) {
                url !== $location.url() && ($location.url(url), $rootScope.$digest());
            }, testability.whenStable = function(callback) {
                $browser.notifyWhenNoOutstandingRequests(callback);
            }, testability;
        } ];
    }
    function $TimeoutProvider() {
        this.$get = [ "$rootScope", "$browser", "$q", "$$q", "$exceptionHandler", function($rootScope, $browser, $q, $$q, $exceptionHandler) {
            function timeout(fn, delay, invokeApply) {
                isFunction(fn) || (invokeApply = delay, delay = fn, fn = noop);
                var timeoutId, args = sliceArgs(arguments, 3), skipApply = isDefined(invokeApply) && !invokeApply, deferred = (skipApply ? $$q : $q).defer(), promise = deferred.promise;
                return timeoutId = $browser.defer(function() {
                    try {
                        deferred.resolve(fn.apply(null, args));
                    } catch (e) {
                        deferred.reject(e), $exceptionHandler(e);
                    } finally {
                        delete deferreds[promise.$$timeoutId];
                    }
                    skipApply || $rootScope.$apply();
                }, delay), promise.$$timeoutId = timeoutId, deferreds[timeoutId] = deferred, promise;
            }
            var deferreds = {};
            return timeout.cancel = function(promise) {
                return promise && promise.$$timeoutId in deferreds ? (deferreds[promise.$$timeoutId].reject("canceled"), 
                delete deferreds[promise.$$timeoutId], $browser.defer.cancel(promise.$$timeoutId)) : !1;
            }, timeout;
        } ];
    }
    function urlResolve(url) {
        var href = url;
        return msie && (urlParsingNode.setAttribute("href", href), href = urlParsingNode.href), 
        urlParsingNode.setAttribute("href", href), {
            href: urlParsingNode.href,
            protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
            host: urlParsingNode.host,
            search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
            hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
            hostname: urlParsingNode.hostname,
            port: urlParsingNode.port,
            pathname: "/" === urlParsingNode.pathname.charAt(0) ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
        };
    }
    function urlIsSameOrigin(requestUrl) {
        var parsed = isString(requestUrl) ? urlResolve(requestUrl) : requestUrl;
        return parsed.protocol === originUrl.protocol && parsed.host === originUrl.host;
    }
    function $WindowProvider() {
        this.$get = valueFn(window);
    }
    function $$CookieReader($document) {
        function safeDecodeURIComponent(str) {
            try {
                return decodeURIComponent(str);
            } catch (e) {
                return str;
            }
        }
        var rawDocument = $document[0] || {}, lastCookies = {}, lastCookieString = "";
        return function() {
            var cookieArray, cookie, i, index, name, currentCookieString = rawDocument.cookie || "";
            if (currentCookieString !== lastCookieString) for (lastCookieString = currentCookieString, 
            cookieArray = lastCookieString.split("; "), lastCookies = {}, i = 0; i < cookieArray.length; i++) cookie = cookieArray[i], 
            index = cookie.indexOf("="), index > 0 && (name = safeDecodeURIComponent(cookie.substring(0, index)), 
            isUndefined(lastCookies[name]) && (lastCookies[name] = safeDecodeURIComponent(cookie.substring(index + 1))));
            return lastCookies;
        };
    }
    function $$CookieReaderProvider() {
        this.$get = $$CookieReader;
    }
    function $FilterProvider($provide) {
        function register(name, factory) {
            if (isObject(name)) {
                var filters = {};
                return forEach(name, function(filter, key) {
                    filters[key] = register(key, filter);
                }), filters;
            }
            return $provide.factory(name + suffix, factory);
        }
        var suffix = "Filter";
        this.register = register, this.$get = [ "$injector", function($injector) {
            return function(name) {
                return $injector.get(name + suffix);
            };
        } ], register("currency", currencyFilter), register("date", dateFilter), register("filter", filterFilter), 
        register("json", jsonFilter), register("limitTo", limitToFilter), register("lowercase", lowercaseFilter), 
        register("number", numberFilter), register("orderBy", orderByFilter), register("uppercase", uppercaseFilter);
    }
    function filterFilter() {
        return function(array, expression, comparator) {
            if (!isArrayLike(array)) {
                if (null == array) return array;
                throw minErr("filter")("notarray", "Expected array but received: {0}", array);
            }
            var predicateFn, matchAgainstAnyProp, expressionType = getTypeForFilter(expression);
            switch (expressionType) {
              case "function":
                predicateFn = expression;
                break;

              case "boolean":
              case "null":
              case "number":
              case "string":
                matchAgainstAnyProp = !0;

              case "object":
                predicateFn = createPredicateFn(expression, comparator, matchAgainstAnyProp);
                break;

              default:
                return array;
            }
            return Array.prototype.filter.call(array, predicateFn);
        };
    }
    function createPredicateFn(expression, comparator, matchAgainstAnyProp) {
        var predicateFn, shouldMatchPrimitives = isObject(expression) && "$" in expression;
        return comparator === !0 ? comparator = equals : isFunction(comparator) || (comparator = function(actual, expected) {
            return isUndefined(actual) ? !1 : null === actual || null === expected ? actual === expected : isObject(expected) || isObject(actual) && !hasCustomToString(actual) ? !1 : (actual = lowercase("" + actual), 
            expected = lowercase("" + expected), -1 !== actual.indexOf(expected));
        }), predicateFn = function(item) {
            return shouldMatchPrimitives && !isObject(item) ? deepCompare(item, expression.$, comparator, !1) : deepCompare(item, expression, comparator, matchAgainstAnyProp);
        };
    }
    function deepCompare(actual, expected, comparator, matchAgainstAnyProp, dontMatchWholeObject) {
        var actualType = getTypeForFilter(actual), expectedType = getTypeForFilter(expected);
        if ("string" === expectedType && "!" === expected.charAt(0)) return !deepCompare(actual, expected.substring(1), comparator, matchAgainstAnyProp);
        if (isArray(actual)) return actual.some(function(item) {
            return deepCompare(item, expected, comparator, matchAgainstAnyProp);
        });
        switch (actualType) {
          case "object":
            var key;
            if (matchAgainstAnyProp) {
                for (key in actual) if ("$" !== key.charAt(0) && deepCompare(actual[key], expected, comparator, !0)) return !0;
                return dontMatchWholeObject ? !1 : deepCompare(actual, expected, comparator, !1);
            }
            if ("object" === expectedType) {
                for (key in expected) {
                    var expectedVal = expected[key];
                    if (!isFunction(expectedVal) && !isUndefined(expectedVal)) {
                        var matchAnyProperty = "$" === key, actualVal = matchAnyProperty ? actual : actual[key];
                        if (!deepCompare(actualVal, expectedVal, comparator, matchAnyProperty, matchAnyProperty)) return !1;
                    }
                }
                return !0;
            }
            return comparator(actual, expected);

          case "function":
            return !1;

          default:
            return comparator(actual, expected);
        }
    }
    function getTypeForFilter(val) {
        return null === val ? "null" : typeof val;
    }
    function currencyFilter($locale) {
        var formats = $locale.NUMBER_FORMATS;
        return function(amount, currencySymbol, fractionSize) {
            return isUndefined(currencySymbol) && (currencySymbol = formats.CURRENCY_SYM), isUndefined(fractionSize) && (fractionSize = formats.PATTERNS[1].maxFrac), 
            null == amount ? amount : formatNumber(amount, formats.PATTERNS[1], formats.GROUP_SEP, formats.DECIMAL_SEP, fractionSize).replace(/\u00A4/g, currencySymbol);
        };
    }
    function numberFilter($locale) {
        var formats = $locale.NUMBER_FORMATS;
        return function(number, fractionSize) {
            return null == number ? number : formatNumber(number, formats.PATTERNS[0], formats.GROUP_SEP, formats.DECIMAL_SEP, fractionSize);
        };
    }
    function formatNumber(number, pattern, groupSep, decimalSep, fractionSize) {
        if (isObject(number)) return "";
        var isNegative = 0 > number;
        number = Math.abs(number);
        var isInfinity = 1/0 === number;
        if (!isInfinity && !isFinite(number)) return "";
        var numStr = number + "", formatedText = "", hasExponent = !1, parts = [];
        if (isInfinity && (formatedText = ""), !isInfinity && -1 !== numStr.indexOf("e")) {
            var match = numStr.match(/([\d\.]+)e(-?)(\d+)/);
            match && "-" == match[2] && match[3] > fractionSize + 1 ? number = 0 : (formatedText = numStr, 
            hasExponent = !0);
        }
        if (isInfinity || hasExponent) fractionSize > 0 && 1 > number && (formatedText = number.toFixed(fractionSize), 
        number = parseFloat(formatedText), formatedText = formatedText.replace(DECIMAL_SEP, decimalSep)); else {
            var fractionLen = (numStr.split(DECIMAL_SEP)[1] || "").length;
            isUndefined(fractionSize) && (fractionSize = Math.min(Math.max(pattern.minFrac, fractionLen), pattern.maxFrac)), 
            number = +(Math.round(+(number.toString() + "e" + fractionSize)).toString() + "e" + -fractionSize);
            var fraction = ("" + number).split(DECIMAL_SEP), whole = fraction[0];
            fraction = fraction[1] || "";
            var i, pos = 0, lgroup = pattern.lgSize, group = pattern.gSize;
            if (whole.length >= lgroup + group) for (pos = whole.length - lgroup, i = 0; pos > i; i++) (pos - i) % group === 0 && 0 !== i && (formatedText += groupSep), 
            formatedText += whole.charAt(i);
            for (i = pos; i < whole.length; i++) (whole.length - i) % lgroup === 0 && 0 !== i && (formatedText += groupSep), 
            formatedText += whole.charAt(i);
            for (;fraction.length < fractionSize; ) fraction += "0";
            fractionSize && "0" !== fractionSize && (formatedText += decimalSep + fraction.substr(0, fractionSize));
        }
        return 0 === number && (isNegative = !1), parts.push(isNegative ? pattern.negPre : pattern.posPre, formatedText, isNegative ? pattern.negSuf : pattern.posSuf), 
        parts.join("");
    }
    function padNumber(num, digits, trim) {
        var neg = "";
        for (0 > num && (neg = "-", num = -num), num = "" + num; num.length < digits; ) num = "0" + num;
        return trim && (num = num.substr(num.length - digits)), neg + num;
    }
    function dateGetter(name, size, offset, trim) {
        return offset = offset || 0, function(date) {
            var value = date["get" + name]();
            return (offset > 0 || value > -offset) && (value += offset), 0 === value && -12 == offset && (value = 12), 
            padNumber(value, size, trim);
        };
    }
    function dateStrGetter(name, shortForm) {
        return function(date, formats) {
            var value = date["get" + name](), get = uppercase(shortForm ? "SHORT" + name : name);
            return formats[get][value];
        };
    }
    function timeZoneGetter(date, formats, offset) {
        var zone = -1 * offset, paddedZone = zone >= 0 ? "+" : "";
        return paddedZone += padNumber(Math[zone > 0 ? "floor" : "ceil"](zone / 60), 2) + padNumber(Math.abs(zone % 60), 2);
    }
    function getFirstThursdayOfYear(year) {
        var dayOfWeekOnFirst = new Date(year, 0, 1).getDay();
        return new Date(year, 0, (4 >= dayOfWeekOnFirst ? 5 : 12) - dayOfWeekOnFirst);
    }
    function getThursdayThisWeek(datetime) {
        return new Date(datetime.getFullYear(), datetime.getMonth(), datetime.getDate() + (4 - datetime.getDay()));
    }
    function weekGetter(size) {
        return function(date) {
            var firstThurs = getFirstThursdayOfYear(date.getFullYear()), thisThurs = getThursdayThisWeek(date), diff = +thisThurs - +firstThurs, result = 1 + Math.round(diff / 6048e5);
            return padNumber(result, size);
        };
    }
    function ampmGetter(date, formats) {
        return date.getHours() < 12 ? formats.AMPMS[0] : formats.AMPMS[1];
    }
    function eraGetter(date, formats) {
        return date.getFullYear() <= 0 ? formats.ERAS[0] : formats.ERAS[1];
    }
    function longEraGetter(date, formats) {
        return date.getFullYear() <= 0 ? formats.ERANAMES[0] : formats.ERANAMES[1];
    }
    function dateFilter($locale) {
        function jsonStringToDate(string) {
            var match;
            if (match = string.match(R_ISO8601_STR)) {
                var date = new Date(0), tzHour = 0, tzMin = 0, dateSetter = match[8] ? date.setUTCFullYear : date.setFullYear, timeSetter = match[8] ? date.setUTCHours : date.setHours;
                match[9] && (tzHour = toInt(match[9] + match[10]), tzMin = toInt(match[9] + match[11])), 
                dateSetter.call(date, toInt(match[1]), toInt(match[2]) - 1, toInt(match[3]));
                var h = toInt(match[4] || 0) - tzHour, m = toInt(match[5] || 0) - tzMin, s = toInt(match[6] || 0), ms = Math.round(1e3 * parseFloat("0." + (match[7] || 0)));
                return timeSetter.call(date, h, m, s, ms), date;
            }
            return string;
        }
        var R_ISO8601_STR = /^(\d{4})-?(\d\d)-?(\d\d)(?:T(\d\d)(?::?(\d\d)(?::?(\d\d)(?:\.(\d+))?)?)?(Z|([+-])(\d\d):?(\d\d))?)?$/;
        return function(date, format, timezone) {
            var fn, match, text = "", parts = [];
            if (format = format || "mediumDate", format = $locale.DATETIME_FORMATS[format] || format, 
            isString(date) && (date = NUMBER_STRING.test(date) ? toInt(date) : jsonStringToDate(date)), 
            isNumber(date) && (date = new Date(date)), !isDate(date) || !isFinite(date.getTime())) return date;
            for (;format; ) match = DATE_FORMATS_SPLIT.exec(format), match ? (parts = concat(parts, match, 1), 
            format = parts.pop()) : (parts.push(format), format = null);
            var dateTimezoneOffset = date.getTimezoneOffset();
            return timezone && (dateTimezoneOffset = timezoneToOffset(timezone, date.getTimezoneOffset()), 
            date = convertTimezoneToLocal(date, timezone, !0)), forEach(parts, function(value) {
                fn = DATE_FORMATS[value], text += fn ? fn(date, $locale.DATETIME_FORMATS, dateTimezoneOffset) : value.replace(/(^'|'$)/g, "").replace(/''/g, "'");
            }), text;
        };
    }
    function jsonFilter() {
        return function(object, spacing) {
            return isUndefined(spacing) && (spacing = 2), toJson(object, spacing);
        };
    }
    function limitToFilter() {
        return function(input, limit, begin) {
            return limit = 1/0 === Math.abs(Number(limit)) ? Number(limit) : toInt(limit), isNaN(limit) ? input : (isNumber(input) && (input = input.toString()), 
            isArray(input) || isString(input) ? (begin = !begin || isNaN(begin) ? 0 : toInt(begin), 
            begin = 0 > begin && begin >= -input.length ? input.length + begin : begin, limit >= 0 ? input.slice(begin, begin + limit) : 0 === begin ? input.slice(limit, input.length) : input.slice(Math.max(0, begin + limit), begin)) : input);
        };
    }
    function orderByFilter($parse) {
        function processPredicates(sortPredicate, reverseOrder) {
            return reverseOrder = reverseOrder ? -1 : 1, sortPredicate.map(function(predicate) {
                var descending = 1, get = identity;
                if (isFunction(predicate)) get = predicate; else if (isString(predicate) && (("+" == predicate.charAt(0) || "-" == predicate.charAt(0)) && (descending = "-" == predicate.charAt(0) ? -1 : 1, 
                predicate = predicate.substring(1)), "" !== predicate && (get = $parse(predicate), 
                get.constant))) {
                    var key = get();
                    get = function(value) {
                        return value[key];
                    };
                }
                return {
                    get: get,
                    descending: descending * reverseOrder
                };
            });
        }
        function isPrimitive(value) {
            switch (typeof value) {
              case "number":
              case "boolean":
              case "string":
                return !0;

              default:
                return !1;
            }
        }
        function objectValue(value, index) {
            return "function" == typeof value.valueOf && (value = value.valueOf(), isPrimitive(value)) ? value : hasCustomToString(value) && (value = value.toString(), 
            isPrimitive(value)) ? value : index;
        }
        function getPredicateValue(value, index) {
            var type = typeof value;
            return null === value ? (type = "string", value = "null") : "string" === type ? value = value.toLowerCase() : "object" === type && (value = objectValue(value, index)), 
            {
                value: value,
                type: type
            };
        }
        function compare(v1, v2) {
            var result = 0;
            return v1.type === v2.type ? v1.value !== v2.value && (result = v1.value < v2.value ? -1 : 1) : result = v1.type < v2.type ? -1 : 1, 
            result;
        }
        return function(array, sortPredicate, reverseOrder) {
            function getComparisonObject(value, index) {
                return {
                    value: value,
                    predicateValues: predicates.map(function(predicate) {
                        return getPredicateValue(predicate.get(value), index);
                    })
                };
            }
            function doComparison(v1, v2) {
                for (var result = 0, index = 0, length = predicates.length; length > index && !(result = compare(v1.predicateValues[index], v2.predicateValues[index]) * predicates[index].descending); ++index) ;
                return result;
            }
            if (!isArrayLike(array)) return array;
            isArray(sortPredicate) || (sortPredicate = [ sortPredicate ]), 0 === sortPredicate.length && (sortPredicate = [ "+" ]);
            var predicates = processPredicates(sortPredicate, reverseOrder);
            predicates.push({
                get: function() {
                    return {};
                },
                descending: reverseOrder ? -1 : 1
            });
            var compareValues = Array.prototype.map.call(array, getComparisonObject);
            return compareValues.sort(doComparison), array = compareValues.map(function(item) {
                return item.value;
            });
        };
    }
    function ngDirective(directive) {
        return isFunction(directive) && (directive = {
            link: directive
        }), directive.restrict = directive.restrict || "AC", valueFn(directive);
    }
    function nullFormRenameControl(control, name) {
        control.$name = name;
    }
    function FormController(element, attrs, $scope, $animate, $interpolate) {
        var form = this, controls = [];
        form.$error = {}, form.$$success = {}, form.$pending = undefined, form.$name = $interpolate(attrs.name || attrs.ngForm || "")($scope), 
        form.$dirty = !1, form.$pristine = !0, form.$valid = !0, form.$invalid = !1, form.$submitted = !1, 
        form.$$parentForm = nullFormCtrl, form.$rollbackViewValue = function() {
            forEach(controls, function(control) {
                control.$rollbackViewValue();
            });
        }, form.$commitViewValue = function() {
            forEach(controls, function(control) {
                control.$commitViewValue();
            });
        }, form.$addControl = function(control) {
            assertNotHasOwnProperty(control.$name, "input"), controls.push(control), control.$name && (form[control.$name] = control), 
            control.$$parentForm = form;
        }, form.$$renameControl = function(control, newName) {
            var oldName = control.$name;
            form[oldName] === control && delete form[oldName], form[newName] = control, control.$name = newName;
        }, form.$removeControl = function(control) {
            control.$name && form[control.$name] === control && delete form[control.$name], 
            forEach(form.$pending, function(value, name) {
                form.$setValidity(name, null, control);
            }), forEach(form.$error, function(value, name) {
                form.$setValidity(name, null, control);
            }), forEach(form.$$success, function(value, name) {
                form.$setValidity(name, null, control);
            }), arrayRemove(controls, control), control.$$parentForm = nullFormCtrl;
        }, addSetValidityMethod({
            ctrl: this,
            $element: element,
            set: function(object, property, controller) {
                var list = object[property];
                if (list) {
                    var index = list.indexOf(controller);
                    -1 === index && list.push(controller);
                } else object[property] = [ controller ];
            },
            unset: function(object, property, controller) {
                var list = object[property];
                list && (arrayRemove(list, controller), 0 === list.length && delete object[property]);
            },
            $animate: $animate
        }), form.$setDirty = function() {
            $animate.removeClass(element, PRISTINE_CLASS), $animate.addClass(element, DIRTY_CLASS), 
            form.$dirty = !0, form.$pristine = !1, form.$$parentForm.$setDirty();
        }, form.$setPristine = function() {
            $animate.setClass(element, PRISTINE_CLASS, DIRTY_CLASS + " " + SUBMITTED_CLASS), 
            form.$dirty = !1, form.$pristine = !0, form.$submitted = !1, forEach(controls, function(control) {
                control.$setPristine();
            });
        }, form.$setUntouched = function() {
            forEach(controls, function(control) {
                control.$setUntouched();
            });
        }, form.$setSubmitted = function() {
            $animate.addClass(element, SUBMITTED_CLASS), form.$submitted = !0, form.$$parentForm.$setSubmitted();
        };
    }
    function stringBasedInputType(ctrl) {
        ctrl.$formatters.push(function(value) {
            return ctrl.$isEmpty(value) ? value : value.toString();
        });
    }
    function textInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        baseInputType(scope, element, attr, ctrl, $sniffer, $browser), stringBasedInputType(ctrl);
    }
    function baseInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        var type = lowercase(element[0].type);
        if (!$sniffer.android) {
            var composing = !1;
            element.on("compositionstart", function() {
                composing = !0;
            }), element.on("compositionend", function() {
                composing = !1, listener();
            });
        }
        var listener = function(ev) {
            if (timeout && ($browser.defer.cancel(timeout), timeout = null), !composing) {
                var value = element.val(), event = ev && ev.type;
                "password" === type || attr.ngTrim && "false" === attr.ngTrim || (value = trim(value)), 
                (ctrl.$viewValue !== value || "" === value && ctrl.$$hasNativeValidators) && ctrl.$setViewValue(value, event);
            }
        };
        if ($sniffer.hasEvent("input")) element.on("input", listener); else {
            var timeout, deferListener = function(ev, input, origValue) {
                timeout || (timeout = $browser.defer(function() {
                    timeout = null, input && input.value === origValue || listener(ev);
                }));
            };
            element.on("keydown", function(event) {
                var key = event.keyCode;
                91 === key || key > 15 && 19 > key || key >= 37 && 40 >= key || deferListener(event, this, this.value);
            }), $sniffer.hasEvent("paste") && element.on("paste cut", deferListener);
        }
        element.on("change", listener), ctrl.$render = function() {
            var value = ctrl.$isEmpty(ctrl.$viewValue) ? "" : ctrl.$viewValue;
            element.val() !== value && element.val(value);
        };
    }
    function weekParser(isoWeek, existingDate) {
        if (isDate(isoWeek)) return isoWeek;
        if (isString(isoWeek)) {
            WEEK_REGEXP.lastIndex = 0;
            var parts = WEEK_REGEXP.exec(isoWeek);
            if (parts) {
                var year = +parts[1], week = +parts[2], hours = 0, minutes = 0, seconds = 0, milliseconds = 0, firstThurs = getFirstThursdayOfYear(year), addDays = 7 * (week - 1);
                return existingDate && (hours = existingDate.getHours(), minutes = existingDate.getMinutes(), 
                seconds = existingDate.getSeconds(), milliseconds = existingDate.getMilliseconds()), 
                new Date(year, 0, firstThurs.getDate() + addDays, hours, minutes, seconds, milliseconds);
            }
        }
        return 0/0;
    }
    function createDateParser(regexp, mapping) {
        return function(iso, date) {
            var parts, map;
            if (isDate(iso)) return iso;
            if (isString(iso)) {
                if ('"' == iso.charAt(0) && '"' == iso.charAt(iso.length - 1) && (iso = iso.substring(1, iso.length - 1)), 
                ISO_DATE_REGEXP.test(iso)) return new Date(iso);
                if (regexp.lastIndex = 0, parts = regexp.exec(iso)) return parts.shift(), map = date ? {
                    yyyy: date.getFullYear(),
                    MM: date.getMonth() + 1,
                    dd: date.getDate(),
                    HH: date.getHours(),
                    mm: date.getMinutes(),
                    ss: date.getSeconds(),
                    sss: date.getMilliseconds() / 1e3
                } : {
                    yyyy: 1970,
                    MM: 1,
                    dd: 1,
                    HH: 0,
                    mm: 0,
                    ss: 0,
                    sss: 0
                }, forEach(parts, function(part, index) {
                    index < mapping.length && (map[mapping[index]] = +part);
                }), new Date(map.yyyy, map.MM - 1, map.dd, map.HH, map.mm, map.ss || 0, 1e3 * map.sss || 0);
            }
            return 0/0;
        };
    }
    function createDateInputType(type, regexp, parseDate, format) {
        return function(scope, element, attr, ctrl, $sniffer, $browser, $filter) {
            function isValidDate(value) {
                return value && !(value.getTime && value.getTime() !== value.getTime());
            }
            function parseObservedDateValue(val) {
                return isDefined(val) && !isDate(val) ? parseDate(val) || undefined : val;
            }
            badInputChecker(scope, element, attr, ctrl), baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
            var previousDate, timezone = ctrl && ctrl.$options && ctrl.$options.timezone;
            if (ctrl.$$parserName = type, ctrl.$parsers.push(function(value) {
                if (ctrl.$isEmpty(value)) return null;
                if (regexp.test(value)) {
                    var parsedDate = parseDate(value, previousDate);
                    return timezone && (parsedDate = convertTimezoneToLocal(parsedDate, timezone)), 
                    parsedDate;
                }
                return undefined;
            }), ctrl.$formatters.push(function(value) {
                if (value && !isDate(value)) throw ngModelMinErr("datefmt", "Expected `{0}` to be a date", value);
                return isValidDate(value) ? (previousDate = value, previousDate && timezone && (previousDate = convertTimezoneToLocal(previousDate, timezone, !0)), 
                $filter("date")(value, format, timezone)) : (previousDate = null, "");
            }), isDefined(attr.min) || attr.ngMin) {
                var minVal;
                ctrl.$validators.min = function(value) {
                    return !isValidDate(value) || isUndefined(minVal) || parseDate(value) >= minVal;
                }, attr.$observe("min", function(val) {
                    minVal = parseObservedDateValue(val), ctrl.$validate();
                });
            }
            if (isDefined(attr.max) || attr.ngMax) {
                var maxVal;
                ctrl.$validators.max = function(value) {
                    return !isValidDate(value) || isUndefined(maxVal) || parseDate(value) <= maxVal;
                }, attr.$observe("max", function(val) {
                    maxVal = parseObservedDateValue(val), ctrl.$validate();
                });
            }
        };
    }
    function badInputChecker(scope, element, attr, ctrl) {
        var node = element[0], nativeValidation = ctrl.$$hasNativeValidators = isObject(node.validity);
        nativeValidation && ctrl.$parsers.push(function(value) {
            var validity = element.prop(VALIDITY_STATE_PROPERTY) || {};
            return validity.badInput && !validity.typeMismatch ? undefined : value;
        });
    }
    function numberInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        if (badInputChecker(scope, element, attr, ctrl), baseInputType(scope, element, attr, ctrl, $sniffer, $browser), 
        ctrl.$$parserName = "number", ctrl.$parsers.push(function(value) {
            return ctrl.$isEmpty(value) ? null : NUMBER_REGEXP.test(value) ? parseFloat(value) : undefined;
        }), ctrl.$formatters.push(function(value) {
            if (!ctrl.$isEmpty(value)) {
                if (!isNumber(value)) throw ngModelMinErr("numfmt", "Expected `{0}` to be a number", value);
                value = value.toString();
            }
            return value;
        }), isDefined(attr.min) || attr.ngMin) {
            var minVal;
            ctrl.$validators.min = function(value) {
                return ctrl.$isEmpty(value) || isUndefined(minVal) || value >= minVal;
            }, attr.$observe("min", function(val) {
                isDefined(val) && !isNumber(val) && (val = parseFloat(val, 10)), minVal = isNumber(val) && !isNaN(val) ? val : undefined, 
                ctrl.$validate();
            });
        }
        if (isDefined(attr.max) || attr.ngMax) {
            var maxVal;
            ctrl.$validators.max = function(value) {
                return ctrl.$isEmpty(value) || isUndefined(maxVal) || maxVal >= value;
            }, attr.$observe("max", function(val) {
                isDefined(val) && !isNumber(val) && (val = parseFloat(val, 10)), maxVal = isNumber(val) && !isNaN(val) ? val : undefined, 
                ctrl.$validate();
            });
        }
    }
    function urlInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        baseInputType(scope, element, attr, ctrl, $sniffer, $browser), stringBasedInputType(ctrl), 
        ctrl.$$parserName = "url", ctrl.$validators.url = function(modelValue, viewValue) {
            var value = modelValue || viewValue;
            return ctrl.$isEmpty(value) || URL_REGEXP.test(value);
        };
    }
    function emailInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        baseInputType(scope, element, attr, ctrl, $sniffer, $browser), stringBasedInputType(ctrl), 
        ctrl.$$parserName = "email", ctrl.$validators.email = function(modelValue, viewValue) {
            var value = modelValue || viewValue;
            return ctrl.$isEmpty(value) || EMAIL_REGEXP.test(value);
        };
    }
    function radioInputType(scope, element, attr, ctrl) {
        isUndefined(attr.name) && element.attr("name", nextUid());
        var listener = function(ev) {
            element[0].checked && ctrl.$setViewValue(attr.value, ev && ev.type);
        };
        element.on("click", listener), ctrl.$render = function() {
            var value = attr.value;
            element[0].checked = value == ctrl.$viewValue;
        }, attr.$observe("value", ctrl.$render);
    }
    function parseConstantExpr($parse, context, name, expression, fallback) {
        var parseFn;
        if (isDefined(expression)) {
            if (parseFn = $parse(expression), !parseFn.constant) throw ngModelMinErr("constexpr", "Expected constant expression for `{0}`, but saw `{1}`.", name, expression);
            return parseFn(context);
        }
        return fallback;
    }
    function checkboxInputType(scope, element, attr, ctrl, $sniffer, $browser, $filter, $parse) {
        var trueValue = parseConstantExpr($parse, scope, "ngTrueValue", attr.ngTrueValue, !0), falseValue = parseConstantExpr($parse, scope, "ngFalseValue", attr.ngFalseValue, !1), listener = function(ev) {
            ctrl.$setViewValue(element[0].checked, ev && ev.type);
        };
        element.on("click", listener), ctrl.$render = function() {
            element[0].checked = ctrl.$viewValue;
        }, ctrl.$isEmpty = function(value) {
            return value === !1;
        }, ctrl.$formatters.push(function(value) {
            return equals(value, trueValue);
        }), ctrl.$parsers.push(function(value) {
            return value ? trueValue : falseValue;
        });
    }
    function classDirective(name, selector) {
        return name = "ngClass" + name, [ "$animate", function($animate) {
            function arrayDifference(tokens1, tokens2) {
                var values = [];
                outer: for (var i = 0; i < tokens1.length; i++) {
                    for (var token = tokens1[i], j = 0; j < tokens2.length; j++) if (token == tokens2[j]) continue outer;
                    values.push(token);
                }
                return values;
            }
            function arrayClasses(classVal) {
                var classes = [];
                return isArray(classVal) ? (forEach(classVal, function(v) {
                    classes = classes.concat(arrayClasses(v));
                }), classes) : isString(classVal) ? classVal.split(" ") : isObject(classVal) ? (forEach(classVal, function(v, k) {
                    v && (classes = classes.concat(k.split(" ")));
                }), classes) : classVal;
            }
            return {
                restrict: "AC",
                link: function(scope, element, attr) {
                    function addClasses(classes) {
                        var newClasses = digestClassCounts(classes, 1);
                        attr.$addClass(newClasses);
                    }
                    function removeClasses(classes) {
                        var newClasses = digestClassCounts(classes, -1);
                        attr.$removeClass(newClasses);
                    }
                    function digestClassCounts(classes, count) {
                        var classCounts = element.data("$classCounts") || createMap(), classesToUpdate = [];
                        return forEach(classes, function(className) {
                            (count > 0 || classCounts[className]) && (classCounts[className] = (classCounts[className] || 0) + count, 
                            classCounts[className] === +(count > 0) && classesToUpdate.push(className));
                        }), element.data("$classCounts", classCounts), classesToUpdate.join(" ");
                    }
                    function updateClasses(oldClasses, newClasses) {
                        var toAdd = arrayDifference(newClasses, oldClasses), toRemove = arrayDifference(oldClasses, newClasses);
                        toAdd = digestClassCounts(toAdd, 1), toRemove = digestClassCounts(toRemove, -1), 
                        toAdd && toAdd.length && $animate.addClass(element, toAdd), toRemove && toRemove.length && $animate.removeClass(element, toRemove);
                    }
                    function ngClassWatchAction(newVal) {
                        if (selector === !0 || scope.$index % 2 === selector) {
                            var newClasses = arrayClasses(newVal || []);
                            if (oldVal) {
                                if (!equals(newVal, oldVal)) {
                                    var oldClasses = arrayClasses(oldVal);
                                    updateClasses(oldClasses, newClasses);
                                }
                            } else addClasses(newClasses);
                        }
                        oldVal = shallowCopy(newVal);
                    }
                    var oldVal;
                    scope.$watch(attr[name], ngClassWatchAction, !0), attr.$observe("class", function() {
                        ngClassWatchAction(scope.$eval(attr[name]));
                    }), "ngClass" !== name && scope.$watch("$index", function($index, old$index) {
                        var mod = 1 & $index;
                        if (mod !== (1 & old$index)) {
                            var classes = arrayClasses(scope.$eval(attr[name]));
                            mod === selector ? addClasses(classes) : removeClasses(classes);
                        }
                    });
                }
            };
        } ];
    }
    function addSetValidityMethod(context) {
        function setValidity(validationErrorKey, state, controller) {
            isUndefined(state) ? createAndSet("$pending", validationErrorKey, controller) : unsetAndCleanup("$pending", validationErrorKey, controller), 
            isBoolean(state) ? state ? (unset(ctrl.$error, validationErrorKey, controller), 
            set(ctrl.$$success, validationErrorKey, controller)) : (set(ctrl.$error, validationErrorKey, controller), 
            unset(ctrl.$$success, validationErrorKey, controller)) : (unset(ctrl.$error, validationErrorKey, controller), 
            unset(ctrl.$$success, validationErrorKey, controller)), ctrl.$pending ? (cachedToggleClass(PENDING_CLASS, !0), 
            ctrl.$valid = ctrl.$invalid = undefined, toggleValidationCss("", null)) : (cachedToggleClass(PENDING_CLASS, !1), 
            ctrl.$valid = isObjectEmpty(ctrl.$error), ctrl.$invalid = !ctrl.$valid, toggleValidationCss("", ctrl.$valid));
            var combinedState;
            combinedState = ctrl.$pending && ctrl.$pending[validationErrorKey] ? undefined : ctrl.$error[validationErrorKey] ? !1 : ctrl.$$success[validationErrorKey] ? !0 : null, 
            toggleValidationCss(validationErrorKey, combinedState), ctrl.$$parentForm.$setValidity(validationErrorKey, combinedState, ctrl);
        }
        function createAndSet(name, value, controller) {
            ctrl[name] || (ctrl[name] = {}), set(ctrl[name], value, controller);
        }
        function unsetAndCleanup(name, value, controller) {
            ctrl[name] && unset(ctrl[name], value, controller), isObjectEmpty(ctrl[name]) && (ctrl[name] = undefined);
        }
        function cachedToggleClass(className, switchValue) {
            switchValue && !classCache[className] ? ($animate.addClass($element, className), 
            classCache[className] = !0) : !switchValue && classCache[className] && ($animate.removeClass($element, className), 
            classCache[className] = !1);
        }
        function toggleValidationCss(validationErrorKey, isValid) {
            validationErrorKey = validationErrorKey ? "-" + snake_case(validationErrorKey, "-") : "", 
            cachedToggleClass(VALID_CLASS + validationErrorKey, isValid === !0), cachedToggleClass(INVALID_CLASS + validationErrorKey, isValid === !1);
        }
        var ctrl = context.ctrl, $element = context.$element, classCache = {}, set = context.set, unset = context.unset, $animate = context.$animate;
        classCache[INVALID_CLASS] = !(classCache[VALID_CLASS] = $element.hasClass(VALID_CLASS)), 
        ctrl.$setValidity = setValidity;
    }
    function isObjectEmpty(obj) {
        if (obj) for (var prop in obj) if (obj.hasOwnProperty(prop)) return !1;
        return !0;
    }
    var REGEX_STRING_REGEXP = /^\/(.+)\/([a-z]*)$/, VALIDITY_STATE_PROPERTY = "validity", lowercase = function(string) {
        return isString(string) ? string.toLowerCase() : string;
    }, hasOwnProperty = Object.prototype.hasOwnProperty, uppercase = function(string) {
        return isString(string) ? string.toUpperCase() : string;
    }, manualLowercase = function(s) {
        return isString(s) ? s.replace(/[A-Z]/g, function(ch) {
            return String.fromCharCode(32 | ch.charCodeAt(0));
        }) : s;
    }, manualUppercase = function(s) {
        return isString(s) ? s.replace(/[a-z]/g, function(ch) {
            return String.fromCharCode(-33 & ch.charCodeAt(0));
        }) : s;
    };
    "i" !== "I".toLowerCase() && (lowercase = manualLowercase, uppercase = manualUppercase);
    var msie, jqLite, jQuery, angularModule, slice = [].slice, splice = [].splice, push = [].push, toString = Object.prototype.toString, getPrototypeOf = Object.getPrototypeOf, ngMinErr = minErr("ng"), angular = window.angular || (window.angular = {}), uid = 0;
    msie = document.documentMode, noop.$inject = [], identity.$inject = [];
    var skipDestroyOnNextJQueryCleanData, isArray = Array.isArray, TYPED_ARRAY_REGEXP = /^\[object (Uint8(Clamped)?)|(Uint16)|(Uint32)|(Int8)|(Int16)|(Int32)|(Float(32)|(64))Array\]$/, trim = function(value) {
        return isString(value) ? value.trim() : value;
    }, escapeForRegexp = function(s) {
        return s.replace(/([-()\[\]{}+?*.$\^|,:#<!\\])/g, "\\$1").replace(/\x08/g, "\\x08");
    }, csp = function() {
        function noUnsafeEval() {
            try {
                return new Function(""), !1;
            } catch (e) {
                return !0;
            }
        }
        if (!isDefined(csp.rules)) {
            var ngCspElement = document.querySelector("[ng-csp]") || document.querySelector("[data-ng-csp]");
            if (ngCspElement) {
                var ngCspAttribute = ngCspElement.getAttribute("ng-csp") || ngCspElement.getAttribute("data-ng-csp");
                csp.rules = {
                    noUnsafeEval: !ngCspAttribute || -1 !== ngCspAttribute.indexOf("no-unsafe-eval"),
                    noInlineStyle: !ngCspAttribute || -1 !== ngCspAttribute.indexOf("no-inline-style")
                };
            } else csp.rules = {
                noUnsafeEval: noUnsafeEval(),
                noInlineStyle: !1
            };
        }
        return csp.rules;
    }, jq = function() {
        if (isDefined(jq.name_)) return jq.name_;
        var el, i, prefix, name, ii = ngAttrPrefixes.length;
        for (i = 0; ii > i; ++i) if (prefix = ngAttrPrefixes[i], el = document.querySelector("[" + prefix.replace(":", "\\:") + "jq]")) {
            name = el.getAttribute(prefix + "jq");
            break;
        }
        return jq.name_ = name;
    }, ngAttrPrefixes = [ "ng-", "data-ng-", "ng:", "x-ng-" ], SNAKE_CASE_REGEXP = /[A-Z]/g, bindJQueryFired = !1, NODE_TYPE_ELEMENT = 1, NODE_TYPE_ATTRIBUTE = 2, NODE_TYPE_TEXT = 3, NODE_TYPE_COMMENT = 8, NODE_TYPE_DOCUMENT = 9, NODE_TYPE_DOCUMENT_FRAGMENT = 11, version = {
        full: "1.4.7",
        major: 1,
        minor: 4,
        dot: 7,
        codeName: "dark-luminescence"
    };
    JQLite.expando = "ng339";
    var jqCache = JQLite.cache = {}, jqId = 1, addEventListenerFn = function(element, type, fn) {
        element.addEventListener(type, fn, !1);
    }, removeEventListenerFn = function(element, type, fn) {
        element.removeEventListener(type, fn, !1);
    };
    JQLite._data = function(node) {
        return this.cache[node[this.expando]] || {};
    };
    var SPECIAL_CHARS_REGEXP = /([\:\-\_]+(.))/g, MOZ_HACK_REGEXP = /^moz([A-Z])/, MOUSE_EVENT_MAP = {
        mouseleave: "mouseout",
        mouseenter: "mouseover"
    }, jqLiteMinErr = minErr("jqLite"), SINGLE_TAG_REGEXP = /^<([\w-]+)\s*\/?>(?:<\/\1>|)$/, HTML_REGEXP = /<|&#?\w+;/, TAG_NAME_REGEXP = /<([\w:-]+)/, XHTML_TAG_REGEXP = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:-]+)[^>]*)\/>/gi, wrapMap = {
        option: [ 1, '<select multiple="multiple">', "</select>" ],
        thead: [ 1, "<table>", "</table>" ],
        col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
        tr: [ 2, "<table><tbody>", "</tbody></table>" ],
        td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],
        _default: [ 0, "", "" ]
    };
    wrapMap.optgroup = wrapMap.option, wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead, 
    wrapMap.th = wrapMap.td;
    var JQLitePrototype = JQLite.prototype = {
        ready: function(fn) {
            function trigger() {
                fired || (fired = !0, fn());
            }
            var fired = !1;
            "complete" === document.readyState ? setTimeout(trigger) : (this.on("DOMContentLoaded", trigger), 
            JQLite(window).on("load", trigger));
        },
        toString: function() {
            var value = [];
            return forEach(this, function(e) {
                value.push("" + e);
            }), "[" + value.join(", ") + "]";
        },
        eq: function(index) {
            return jqLite(index >= 0 ? this[index] : this[this.length + index]);
        },
        length: 0,
        push: push,
        sort: [].sort,
        splice: [].splice
    }, BOOLEAN_ATTR = {};
    forEach("multiple,selected,checked,disabled,readOnly,required,open".split(","), function(value) {
        BOOLEAN_ATTR[lowercase(value)] = value;
    });
    var BOOLEAN_ELEMENTS = {};
    forEach("input,select,option,textarea,button,form,details".split(","), function(value) {
        BOOLEAN_ELEMENTS[value] = !0;
    });
    var ALIASED_ATTR = {
        ngMinlength: "minlength",
        ngMaxlength: "maxlength",
        ngMin: "min",
        ngMax: "max",
        ngPattern: "pattern"
    };
    forEach({
        data: jqLiteData,
        removeData: jqLiteRemoveData,
        hasData: jqLiteHasData
    }, function(fn, name) {
        JQLite[name] = fn;
    }), forEach({
        data: jqLiteData,
        inheritedData: jqLiteInheritedData,
        scope: function(element) {
            return jqLite.data(element, "$scope") || jqLiteInheritedData(element.parentNode || element, [ "$isolateScope", "$scope" ]);
        },
        isolateScope: function(element) {
            return jqLite.data(element, "$isolateScope") || jqLite.data(element, "$isolateScopeNoTemplate");
        },
        controller: jqLiteController,
        injector: function(element) {
            return jqLiteInheritedData(element, "$injector");
        },
        removeAttr: function(element, name) {
            element.removeAttribute(name);
        },
        hasClass: jqLiteHasClass,
        css: function(element, name, value) {
            return name = camelCase(name), isDefined(value) ? void (element.style[name] = value) : element.style[name];
        },
        attr: function(element, name, value) {
            var nodeType = element.nodeType;
            if (nodeType !== NODE_TYPE_TEXT && nodeType !== NODE_TYPE_ATTRIBUTE && nodeType !== NODE_TYPE_COMMENT) {
                var lowercasedName = lowercase(name);
                if (BOOLEAN_ATTR[lowercasedName]) {
                    if (!isDefined(value)) return element[name] || (element.attributes.getNamedItem(name) || noop).specified ? lowercasedName : undefined;
                    value ? (element[name] = !0, element.setAttribute(name, lowercasedName)) : (element[name] = !1, 
                    element.removeAttribute(lowercasedName));
                } else if (isDefined(value)) element.setAttribute(name, value); else if (element.getAttribute) {
                    var ret = element.getAttribute(name, 2);
                    return null === ret ? undefined : ret;
                }
            }
        },
        prop: function(element, name, value) {
            return isDefined(value) ? void (element[name] = value) : element[name];
        },
        text: function() {
            function getText(element, value) {
                if (isUndefined(value)) {
                    var nodeType = element.nodeType;
                    return nodeType === NODE_TYPE_ELEMENT || nodeType === NODE_TYPE_TEXT ? element.textContent : "";
                }
                element.textContent = value;
            }
            return getText.$dv = "", getText;
        }(),
        val: function(element, value) {
            if (isUndefined(value)) {
                if (element.multiple && "select" === nodeName_(element)) {
                    var result = [];
                    return forEach(element.options, function(option) {
                        option.selected && result.push(option.value || option.text);
                    }), 0 === result.length ? null : result;
                }
                return element.value;
            }
            element.value = value;
        },
        html: function(element, value) {
            return isUndefined(value) ? element.innerHTML : (jqLiteDealoc(element, !0), void (element.innerHTML = value));
        },
        empty: jqLiteEmpty
    }, function(fn, name) {
        JQLite.prototype[name] = function(arg1, arg2) {
            var i, key, nodeCount = this.length;
            if (fn !== jqLiteEmpty && isUndefined(2 == fn.length && fn !== jqLiteHasClass && fn !== jqLiteController ? arg1 : arg2)) {
                if (isObject(arg1)) {
                    for (i = 0; nodeCount > i; i++) if (fn === jqLiteData) fn(this[i], arg1); else for (key in arg1) fn(this[i], key, arg1[key]);
                    return this;
                }
                for (var value = fn.$dv, jj = isUndefined(value) ? Math.min(nodeCount, 1) : nodeCount, j = 0; jj > j; j++) {
                    var nodeValue = fn(this[j], arg1, arg2);
                    value = value ? value + nodeValue : nodeValue;
                }
                return value;
            }
            for (i = 0; nodeCount > i; i++) fn(this[i], arg1, arg2);
            return this;
        };
    }), forEach({
        removeData: jqLiteRemoveData,
        on: function jqLiteOn(element, type, fn, unsupported) {
            if (isDefined(unsupported)) throw jqLiteMinErr("onargs", "jqLite#on() does not support the `selector` or `eventData` parameters");
            if (jqLiteAcceptsData(element)) {
                var expandoStore = jqLiteExpandoStore(element, !0), events = expandoStore.events, handle = expandoStore.handle;
                handle || (handle = expandoStore.handle = createEventHandler(element, events));
                for (var types = type.indexOf(" ") >= 0 ? type.split(" ") : [ type ], i = types.length; i--; ) {
                    type = types[i];
                    var eventFns = events[type];
                    eventFns || (events[type] = [], "mouseenter" === type || "mouseleave" === type ? jqLiteOn(element, MOUSE_EVENT_MAP[type], function(event) {
                        var target = this, related = event.relatedTarget;
                        (!related || related !== target && !target.contains(related)) && handle(event, type);
                    }) : "$destroy" !== type && addEventListenerFn(element, type, handle), eventFns = events[type]), 
                    eventFns.push(fn);
                }
            }
        },
        off: jqLiteOff,
        one: function(element, type, fn) {
            element = jqLite(element), element.on(type, function onFn() {
                element.off(type, fn), element.off(type, onFn);
            }), element.on(type, fn);
        },
        replaceWith: function(element, replaceNode) {
            var index, parent = element.parentNode;
            jqLiteDealoc(element), forEach(new JQLite(replaceNode), function(node) {
                index ? parent.insertBefore(node, index.nextSibling) : parent.replaceChild(node, element), 
                index = node;
            });
        },
        children: function(element) {
            var children = [];
            return forEach(element.childNodes, function(element) {
                element.nodeType === NODE_TYPE_ELEMENT && children.push(element);
            }), children;
        },
        contents: function(element) {
            return element.contentDocument || element.childNodes || [];
        },
        append: function(element, node) {
            var nodeType = element.nodeType;
            if (nodeType === NODE_TYPE_ELEMENT || nodeType === NODE_TYPE_DOCUMENT_FRAGMENT) {
                node = new JQLite(node);
                for (var i = 0, ii = node.length; ii > i; i++) {
                    var child = node[i];
                    element.appendChild(child);
                }
            }
        },
        prepend: function(element, node) {
            if (element.nodeType === NODE_TYPE_ELEMENT) {
                var index = element.firstChild;
                forEach(new JQLite(node), function(child) {
                    element.insertBefore(child, index);
                });
            }
        },
        wrap: function(element, wrapNode) {
            wrapNode = jqLite(wrapNode).eq(0).clone()[0];
            var parent = element.parentNode;
            parent && parent.replaceChild(wrapNode, element), wrapNode.appendChild(element);
        },
        remove: jqLiteRemove,
        detach: function(element) {
            jqLiteRemove(element, !0);
        },
        after: function(element, newElement) {
            var index = element, parent = element.parentNode;
            newElement = new JQLite(newElement);
            for (var i = 0, ii = newElement.length; ii > i; i++) {
                var node = newElement[i];
                parent.insertBefore(node, index.nextSibling), index = node;
            }
        },
        addClass: jqLiteAddClass,
        removeClass: jqLiteRemoveClass,
        toggleClass: function(element, selector, condition) {
            selector && forEach(selector.split(" "), function(className) {
                var classCondition = condition;
                isUndefined(classCondition) && (classCondition = !jqLiteHasClass(element, className)), 
                (classCondition ? jqLiteAddClass : jqLiteRemoveClass)(element, className);
            });
        },
        parent: function(element) {
            var parent = element.parentNode;
            return parent && parent.nodeType !== NODE_TYPE_DOCUMENT_FRAGMENT ? parent : null;
        },
        next: function(element) {
            return element.nextElementSibling;
        },
        find: function(element, selector) {
            return element.getElementsByTagName ? element.getElementsByTagName(selector) : [];
        },
        clone: jqLiteClone,
        triggerHandler: function(element, event, extraParameters) {
            var dummyEvent, eventFnsCopy, handlerArgs, eventName = event.type || event, expandoStore = jqLiteExpandoStore(element), events = expandoStore && expandoStore.events, eventFns = events && events[eventName];
            eventFns && (dummyEvent = {
                preventDefault: function() {
                    this.defaultPrevented = !0;
                },
                isDefaultPrevented: function() {
                    return this.defaultPrevented === !0;
                },
                stopImmediatePropagation: function() {
                    this.immediatePropagationStopped = !0;
                },
                isImmediatePropagationStopped: function() {
                    return this.immediatePropagationStopped === !0;
                },
                stopPropagation: noop,
                type: eventName,
                target: element
            }, event.type && (dummyEvent = extend(dummyEvent, event)), eventFnsCopy = shallowCopy(eventFns), 
            handlerArgs = extraParameters ? [ dummyEvent ].concat(extraParameters) : [ dummyEvent ], 
            forEach(eventFnsCopy, function(fn) {
                dummyEvent.isImmediatePropagationStopped() || fn.apply(element, handlerArgs);
            }));
        }
    }, function(fn, name) {
        JQLite.prototype[name] = function(arg1, arg2, arg3) {
            for (var value, i = 0, ii = this.length; ii > i; i++) isUndefined(value) ? (value = fn(this[i], arg1, arg2, arg3), 
            isDefined(value) && (value = jqLite(value))) : jqLiteAddNodes(value, fn(this[i], arg1, arg2, arg3));
            return isDefined(value) ? value : this;
        }, JQLite.prototype.bind = JQLite.prototype.on, JQLite.prototype.unbind = JQLite.prototype.off;
    }), HashMap.prototype = {
        put: function(key, value) {
            this[hashKey(key, this.nextUid)] = value;
        },
        get: function(key) {
            return this[hashKey(key, this.nextUid)];
        },
        remove: function(key) {
            var value = this[key = hashKey(key, this.nextUid)];
            return delete this[key], value;
        }
    };
    var $$HashMapProvider = [ function() {
        this.$get = [ function() {
            return HashMap;
        } ];
    } ], FN_ARGS = /^[^\(]*\(\s*([^\)]*)\)/m, FN_ARG_SPLIT = /,/, FN_ARG = /^\s*(_?)(\S+?)\1\s*$/, STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/gm, $injectorMinErr = minErr("$injector");
    createInjector.$$annotate = annotate;
    var $animateMinErr = minErr("$animate"), ELEMENT_NODE = 1, NG_ANIMATE_CLASSNAME = "ng-animate", $$CoreAnimateRunnerProvider = function() {
        this.$get = [ "$q", "$$rAF", function($q, $$rAF) {
            function AnimateRunner() {}
            return AnimateRunner.all = noop, AnimateRunner.chain = noop, AnimateRunner.prototype = {
                end: noop,
                cancel: noop,
                resume: noop,
                pause: noop,
                complete: noop,
                then: function(pass, fail) {
                    return $q(function(resolve) {
                        $$rAF(function() {
                            resolve();
                        });
                    }).then(pass, fail);
                }
            }, AnimateRunner;
        } ];
    }, $$CoreAnimateQueueProvider = function() {
        var postDigestQueue = new HashMap(), postDigestElements = [];
        this.$get = [ "$$AnimateRunner", "$rootScope", function($$AnimateRunner, $rootScope) {
            function updateData(data, classes, value) {
                var changed = !1;
                return classes && (classes = isString(classes) ? classes.split(" ") : isArray(classes) ? classes : [], 
                forEach(classes, function(className) {
                    className && (changed = !0, data[className] = value);
                })), changed;
            }
            function handleCSSClassChanges() {
                forEach(postDigestElements, function(element) {
                    var data = postDigestQueue.get(element);
                    if (data) {
                        var existing = splitClasses(element.attr("class")), toAdd = "", toRemove = "";
                        forEach(data, function(status, className) {
                            var hasClass = !!existing[className];
                            status !== hasClass && (status ? toAdd += (toAdd.length ? " " : "") + className : toRemove += (toRemove.length ? " " : "") + className);
                        }), forEach(element, function(elm) {
                            toAdd && jqLiteAddClass(elm, toAdd), toRemove && jqLiteRemoveClass(elm, toRemove);
                        }), postDigestQueue.remove(element);
                    }
                }), postDigestElements.length = 0;
            }
            function addRemoveClassesPostDigest(element, add, remove) {
                var data = postDigestQueue.get(element) || {}, classesAdded = updateData(data, add, !0), classesRemoved = updateData(data, remove, !1);
                (classesAdded || classesRemoved) && (postDigestQueue.put(element, data), postDigestElements.push(element), 
                1 === postDigestElements.length && $rootScope.$$postDigest(handleCSSClassChanges));
            }
            return {
                enabled: noop,
                on: noop,
                off: noop,
                pin: noop,
                push: function(element, event, options, domOperation) {
                    return domOperation && domOperation(), options = options || {}, options.from && element.css(options.from), 
                    options.to && element.css(options.to), (options.addClass || options.removeClass) && addRemoveClassesPostDigest(element, options.addClass, options.removeClass), 
                    new $$AnimateRunner();
                }
            };
        } ];
    }, $AnimateProvider = [ "$provide", function($provide) {
        var provider = this;
        this.$$registeredAnimations = Object.create(null), this.register = function(name, factory) {
            if (name && "." !== name.charAt(0)) throw $animateMinErr("notcsel", "Expecting class selector starting with '.' got '{0}'.", name);
            var key = name + "-animation";
            provider.$$registeredAnimations[name.substr(1)] = key, $provide.factory(key, factory);
        }, this.classNameFilter = function(expression) {
            if (1 === arguments.length && (this.$$classNameFilter = expression instanceof RegExp ? expression : null, 
            this.$$classNameFilter)) {
                var reservedRegex = new RegExp("(\\s+|\\/)" + NG_ANIMATE_CLASSNAME + "(\\s+|\\/)");
                if (reservedRegex.test(this.$$classNameFilter.toString())) throw $animateMinErr("nongcls", '$animateProvider.classNameFilter(regex) prohibits accepting a regex value which matches/contains the "{0}" CSS class.', NG_ANIMATE_CLASSNAME);
            }
            return this.$$classNameFilter;
        }, this.$get = [ "$$animateQueue", function($$animateQueue) {
            function domInsert(element, parentElement, afterElement) {
                if (afterElement) {
                    var afterNode = extractElementNode(afterElement);
                    !afterNode || afterNode.parentNode || afterNode.previousElementSibling || (afterElement = null);
                }
                afterElement ? afterElement.after(element) : parentElement.prepend(element);
            }
            return {
                on: $$animateQueue.on,
                off: $$animateQueue.off,
                pin: $$animateQueue.pin,
                enabled: $$animateQueue.enabled,
                cancel: function(runner) {
                    runner.end && runner.end();
                },
                enter: function(element, parent, after, options) {
                    return parent = parent && jqLite(parent), after = after && jqLite(after), parent = parent || after.parent(), 
                    domInsert(element, parent, after), $$animateQueue.push(element, "enter", prepareAnimateOptions(options));
                },
                move: function(element, parent, after, options) {
                    return parent = parent && jqLite(parent), after = after && jqLite(after), parent = parent || after.parent(), 
                    domInsert(element, parent, after), $$animateQueue.push(element, "move", prepareAnimateOptions(options));
                },
                leave: function(element, options) {
                    return $$animateQueue.push(element, "leave", prepareAnimateOptions(options), function() {
                        element.remove();
                    });
                },
                addClass: function(element, className, options) {
                    return options = prepareAnimateOptions(options), options.addClass = mergeClasses(options.addclass, className), 
                    $$animateQueue.push(element, "addClass", options);
                },
                removeClass: function(element, className, options) {
                    return options = prepareAnimateOptions(options), options.removeClass = mergeClasses(options.removeClass, className), 
                    $$animateQueue.push(element, "removeClass", options);
                },
                setClass: function(element, add, remove, options) {
                    return options = prepareAnimateOptions(options), options.addClass = mergeClasses(options.addClass, add), 
                    options.removeClass = mergeClasses(options.removeClass, remove), $$animateQueue.push(element, "setClass", options);
                },
                animate: function(element, from, to, className, options) {
                    return options = prepareAnimateOptions(options), options.from = options.from ? extend(options.from, from) : from, 
                    options.to = options.to ? extend(options.to, to) : to, className = className || "ng-inline-animate", 
                    options.tempClasses = mergeClasses(options.tempClasses, className), $$animateQueue.push(element, "animate", options);
                }
            };
        } ];
    } ], $CoreAnimateCssProvider = function() {
        this.$get = [ "$$rAF", "$q", function($$rAF, $q) {
            var RAFPromise = function() {};
            return RAFPromise.prototype = {
                done: function(cancel) {
                    this.defer && this.defer[cancel === !0 ? "reject" : "resolve"]();
                },
                end: function() {
                    this.done();
                },
                cancel: function() {
                    this.done(!0);
                },
                getPromise: function() {
                    return this.defer || (this.defer = $q.defer()), this.defer.promise;
                },
                then: function(f1, f2) {
                    return this.getPromise().then(f1, f2);
                },
                "catch": function(f1) {
                    return this.getPromise()["catch"](f1);
                },
                "finally": function(f1) {
                    return this.getPromise()["finally"](f1);
                }
            }, function(element, options) {
                function run() {
                    return $$rAF(function() {
                        close(), closed || runner.done(), closed = !0;
                    }), runner;
                }
                function close() {
                    options.addClass && (element.addClass(options.addClass), options.addClass = null), 
                    options.removeClass && (element.removeClass(options.removeClass), options.removeClass = null), 
                    options.to && (element.css(options.to), options.to = null);
                }
                options.cleanupStyles && (options.from = options.to = null), options.from && (element.css(options.from), 
                options.from = null);
                var closed, runner = new RAFPromise();
                return {
                    start: run,
                    end: run
                };
            };
        } ];
    }, $compileMinErr = minErr("$compile");
    $CompileProvider.$inject = [ "$provide", "$$sanitizeUriProvider" ];
    var PREFIX_REGEXP = /^((?:x|data)[\:\-_])/i, $controllerMinErr = minErr("$controller"), CNTRL_REG = /^(\S+)(\s+as\s+(\w+))?$/, $$ForceReflowProvider = function() {
        this.$get = [ "$document", function($document) {
            return function(domNode) {
                return domNode ? !domNode.nodeType && domNode instanceof jqLite && (domNode = domNode[0]) : domNode = $document[0].body, 
                domNode.offsetWidth + 1;
            };
        } ];
    }, APPLICATION_JSON = "application/json", CONTENT_TYPE_APPLICATION_JSON = {
        "Content-Type": APPLICATION_JSON + ";charset=utf-8"
    }, JSON_START = /^\[|^\{(?!\{)/, JSON_ENDS = {
        "[": /]$/,
        "{": /}$/
    }, JSON_PROTECTION_PREFIX = /^\)\]\}',?\n/, $httpMinErr = minErr("$http"), $httpMinErrLegacyFn = function(method) {
        return function() {
            throw $httpMinErr("legacy", "The method `{0}` on the promise returned from `$http` has been disabled.", method);
        };
    }, $interpolateMinErr = angular.$interpolateMinErr = minErr("$interpolate");
    $interpolateMinErr.throwNoconcat = function(text) {
        throw $interpolateMinErr("noconcat", "Error while interpolating: {0}\nStrict Contextual Escaping disallows interpolations that concatenate multiple expressions when a trusted value is required.  See http://docs.angularjs.org/api/ng.$sce", text);
    }, $interpolateMinErr.interr = function(text, err) {
        return $interpolateMinErr("interr", "Can't interpolate: {0}\n{1}", text, err.toString());
    };
    var PATH_MATCH = /^([^\?#]*)(\?([^#]*))?(#(.*))?$/, DEFAULT_PORTS = {
        http: 80,
        https: 443,
        ftp: 21
    }, $locationMinErr = minErr("$location"), locationPrototype = {
        $$html5: !1,
        $$replace: !1,
        absUrl: locationGetter("$$absUrl"),
        url: function(url) {
            if (isUndefined(url)) return this.$$url;
            var match = PATH_MATCH.exec(url);
            return (match[1] || "" === url) && this.path(decodeURIComponent(match[1])), (match[2] || match[1] || "" === url) && this.search(match[3] || ""), 
            this.hash(match[5] || ""), this;
        },
        protocol: locationGetter("$$protocol"),
        host: locationGetter("$$host"),
        port: locationGetter("$$port"),
        path: locationGetterSetter("$$path", function(path) {
            return path = null !== path ? path.toString() : "", "/" == path.charAt(0) ? path : "/" + path;
        }),
        search: function(search, paramValue) {
            switch (arguments.length) {
              case 0:
                return this.$$search;

              case 1:
                if (isString(search) || isNumber(search)) search = search.toString(), this.$$search = parseKeyValue(search); else {
                    if (!isObject(search)) throw $locationMinErr("isrcharg", "The first argument of the `$location#search()` call must be a string or an object.");
                    search = copy(search, {}), forEach(search, function(value, key) {
                        null == value && delete search[key];
                    }), this.$$search = search;
                }
                break;

              default:
                isUndefined(paramValue) || null === paramValue ? delete this.$$search[search] : this.$$search[search] = paramValue;
            }
            return this.$$compose(), this;
        },
        hash: locationGetterSetter("$$hash", function(hash) {
            return null !== hash ? hash.toString() : "";
        }),
        replace: function() {
            return this.$$replace = !0, this;
        }
    };
    forEach([ LocationHashbangInHtml5Url, LocationHashbangUrl, LocationHtml5Url ], function(Location) {
        Location.prototype = Object.create(locationPrototype), Location.prototype.state = function(state) {
            if (!arguments.length) return this.$$state;
            if (Location !== LocationHtml5Url || !this.$$html5) throw $locationMinErr("nostate", "History API state support is available only in HTML5 mode and only in browsers supporting HTML5 History API");
            return this.$$state = isUndefined(state) ? null : state, this;
        };
    });
    var $parseMinErr = minErr("$parse"), CALL = Function.prototype.call, APPLY = Function.prototype.apply, BIND = Function.prototype.bind, OPERATORS = createMap();
    forEach("+ - * / % === !== == != < > <= >= && || ! = |".split(" "), function(operator) {
        OPERATORS[operator] = !0;
    });
    var ESCAPE = {
        n: "\n",
        f: "\f",
        r: "\r",
        t: "	",
        v: "",
        "'": "'",
        '"': '"'
    }, Lexer = function(options) {
        this.options = options;
    };
    Lexer.prototype = {
        constructor: Lexer,
        lex: function(text) {
            for (this.text = text, this.index = 0, this.tokens = []; this.index < this.text.length; ) {
                var ch = this.text.charAt(this.index);
                if ('"' === ch || "'" === ch) this.readString(ch); else if (this.isNumber(ch) || "." === ch && this.isNumber(this.peek())) this.readNumber(); else if (this.isIdent(ch)) this.readIdent(); else if (this.is(ch, "(){}[].,;:?")) this.tokens.push({
                    index: this.index,
                    text: ch
                }), this.index++; else if (this.isWhitespace(ch)) this.index++; else {
                    var ch2 = ch + this.peek(), ch3 = ch2 + this.peek(2), op1 = OPERATORS[ch], op2 = OPERATORS[ch2], op3 = OPERATORS[ch3];
                    if (op1 || op2 || op3) {
                        var token = op3 ? ch3 : op2 ? ch2 : ch;
                        this.tokens.push({
                            index: this.index,
                            text: token,
                            operator: !0
                        }), this.index += token.length;
                    } else this.throwError("Unexpected next character ", this.index, this.index + 1);
                }
            }
            return this.tokens;
        },
        is: function(ch, chars) {
            return -1 !== chars.indexOf(ch);
        },
        peek: function(i) {
            var num = i || 1;
            return this.index + num < this.text.length ? this.text.charAt(this.index + num) : !1;
        },
        isNumber: function(ch) {
            return ch >= "0" && "9" >= ch && "string" == typeof ch;
        },
        isWhitespace: function(ch) {
            return " " === ch || "\r" === ch || "	" === ch || "\n" === ch || "" === ch || "" === ch;
        },
        isIdent: function(ch) {
            return ch >= "a" && "z" >= ch || ch >= "A" && "Z" >= ch || "_" === ch || "$" === ch;
        },
        isExpOperator: function(ch) {
            return "-" === ch || "+" === ch || this.isNumber(ch);
        },
        throwError: function(error, start, end) {
            end = end || this.index;
            var colStr = isDefined(start) ? "s " + start + "-" + this.index + " [" + this.text.substring(start, end) + "]" : " " + end;
            throw $parseMinErr("lexerr", "Lexer Error: {0} at column{1} in expression [{2}].", error, colStr, this.text);
        },
        readNumber: function() {
            for (var number = "", start = this.index; this.index < this.text.length; ) {
                var ch = lowercase(this.text.charAt(this.index));
                if ("." == ch || this.isNumber(ch)) number += ch; else {
                    var peekCh = this.peek();
                    if ("e" == ch && this.isExpOperator(peekCh)) number += ch; else if (this.isExpOperator(ch) && peekCh && this.isNumber(peekCh) && "e" == number.charAt(number.length - 1)) number += ch; else {
                        if (!this.isExpOperator(ch) || peekCh && this.isNumber(peekCh) || "e" != number.charAt(number.length - 1)) break;
                        this.throwError("Invalid exponent");
                    }
                }
                this.index++;
            }
            this.tokens.push({
                index: start,
                text: number,
                constant: !0,
                value: Number(number)
            });
        },
        readIdent: function() {
            for (var start = this.index; this.index < this.text.length; ) {
                var ch = this.text.charAt(this.index);
                if (!this.isIdent(ch) && !this.isNumber(ch)) break;
                this.index++;
            }
            this.tokens.push({
                index: start,
                text: this.text.slice(start, this.index),
                identifier: !0
            });
        },
        readString: function(quote) {
            var start = this.index;
            this.index++;
            for (var string = "", rawString = quote, escape = !1; this.index < this.text.length; ) {
                var ch = this.text.charAt(this.index);
                if (rawString += ch, escape) {
                    if ("u" === ch) {
                        var hex = this.text.substring(this.index + 1, this.index + 5);
                        hex.match(/[\da-f]{4}/i) || this.throwError("Invalid unicode escape [\\u" + hex + "]"), 
                        this.index += 4, string += String.fromCharCode(parseInt(hex, 16));
                    } else {
                        var rep = ESCAPE[ch];
                        string += rep || ch;
                    }
                    escape = !1;
                } else if ("\\" === ch) escape = !0; else {
                    if (ch === quote) return this.index++, void this.tokens.push({
                        index: start,
                        text: rawString,
                        constant: !0,
                        value: string
                    });
                    string += ch;
                }
                this.index++;
            }
            this.throwError("Unterminated quote", start);
        }
    };
    var AST = function(lexer, options) {
        this.lexer = lexer, this.options = options;
    };
    AST.Program = "Program", AST.ExpressionStatement = "ExpressionStatement", AST.AssignmentExpression = "AssignmentExpression", 
    AST.ConditionalExpression = "ConditionalExpression", AST.LogicalExpression = "LogicalExpression", 
    AST.BinaryExpression = "BinaryExpression", AST.UnaryExpression = "UnaryExpression", 
    AST.CallExpression = "CallExpression", AST.MemberExpression = "MemberExpression", 
    AST.Identifier = "Identifier", AST.Literal = "Literal", AST.ArrayExpression = "ArrayExpression", 
    AST.Property = "Property", AST.ObjectExpression = "ObjectExpression", AST.ThisExpression = "ThisExpression", 
    AST.NGValueParameter = "NGValueParameter", AST.prototype = {
        ast: function(text) {
            this.text = text, this.tokens = this.lexer.lex(text);
            var value = this.program();
            return 0 !== this.tokens.length && this.throwError("is an unexpected token", this.tokens[0]), 
            value;
        },
        program: function() {
            for (var body = []; ;) if (this.tokens.length > 0 && !this.peek("}", ")", ";", "]") && body.push(this.expressionStatement()), 
            !this.expect(";")) return {
                type: AST.Program,
                body: body
            };
        },
        expressionStatement: function() {
            return {
                type: AST.ExpressionStatement,
                expression: this.filterChain()
            };
        },
        filterChain: function() {
            for (var token, left = this.expression(); token = this.expect("|"); ) left = this.filter(left);
            return left;
        },
        expression: function() {
            return this.assignment();
        },
        assignment: function() {
            var result = this.ternary();
            return this.expect("=") && (result = {
                type: AST.AssignmentExpression,
                left: result,
                right: this.assignment(),
                operator: "="
            }), result;
        },
        ternary: function() {
            var alternate, consequent, test = this.logicalOR();
            return this.expect("?") && (alternate = this.expression(), this.consume(":")) ? (consequent = this.expression(), 
            {
                type: AST.ConditionalExpression,
                test: test,
                alternate: alternate,
                consequent: consequent
            }) : test;
        },
        logicalOR: function() {
            for (var left = this.logicalAND(); this.expect("||"); ) left = {
                type: AST.LogicalExpression,
                operator: "||",
                left: left,
                right: this.logicalAND()
            };
            return left;
        },
        logicalAND: function() {
            for (var left = this.equality(); this.expect("&&"); ) left = {
                type: AST.LogicalExpression,
                operator: "&&",
                left: left,
                right: this.equality()
            };
            return left;
        },
        equality: function() {
            for (var token, left = this.relational(); token = this.expect("==", "!=", "===", "!=="); ) left = {
                type: AST.BinaryExpression,
                operator: token.text,
                left: left,
                right: this.relational()
            };
            return left;
        },
        relational: function() {
            for (var token, left = this.additive(); token = this.expect("<", ">", "<=", ">="); ) left = {
                type: AST.BinaryExpression,
                operator: token.text,
                left: left,
                right: this.additive()
            };
            return left;
        },
        additive: function() {
            for (var token, left = this.multiplicative(); token = this.expect("+", "-"); ) left = {
                type: AST.BinaryExpression,
                operator: token.text,
                left: left,
                right: this.multiplicative()
            };
            return left;
        },
        multiplicative: function() {
            for (var token, left = this.unary(); token = this.expect("*", "/", "%"); ) left = {
                type: AST.BinaryExpression,
                operator: token.text,
                left: left,
                right: this.unary()
            };
            return left;
        },
        unary: function() {
            var token;
            return (token = this.expect("+", "-", "!")) ? {
                type: AST.UnaryExpression,
                operator: token.text,
                prefix: !0,
                argument: this.unary()
            } : this.primary();
        },
        primary: function() {
            var primary;
            this.expect("(") ? (primary = this.filterChain(), this.consume(")")) : this.expect("[") ? primary = this.arrayDeclaration() : this.expect("{") ? primary = this.object() : this.constants.hasOwnProperty(this.peek().text) ? primary = copy(this.constants[this.consume().text]) : this.peek().identifier ? primary = this.identifier() : this.peek().constant ? primary = this.constant() : this.throwError("not a primary expression", this.peek());
            for (var next; next = this.expect("(", "[", "."); ) "(" === next.text ? (primary = {
                type: AST.CallExpression,
                callee: primary,
                arguments: this.parseArguments()
            }, this.consume(")")) : "[" === next.text ? (primary = {
                type: AST.MemberExpression,
                object: primary,
                property: this.expression(),
                computed: !0
            }, this.consume("]")) : "." === next.text ? primary = {
                type: AST.MemberExpression,
                object: primary,
                property: this.identifier(),
                computed: !1
            } : this.throwError("IMPOSSIBLE");
            return primary;
        },
        filter: function(baseExpression) {
            for (var args = [ baseExpression ], result = {
                type: AST.CallExpression,
                callee: this.identifier(),
                arguments: args,
                filter: !0
            }; this.expect(":"); ) args.push(this.expression());
            return result;
        },
        parseArguments: function() {
            var args = [];
            if (")" !== this.peekToken().text) do args.push(this.expression()); while (this.expect(","));
            return args;
        },
        identifier: function() {
            var token = this.consume();
            return token.identifier || this.throwError("is not a valid identifier", token), 
            {
                type: AST.Identifier,
                name: token.text
            };
        },
        constant: function() {
            return {
                type: AST.Literal,
                value: this.consume().value
            };
        },
        arrayDeclaration: function() {
            var elements = [];
            if ("]" !== this.peekToken().text) do {
                if (this.peek("]")) break;
                elements.push(this.expression());
            } while (this.expect(","));
            return this.consume("]"), {
                type: AST.ArrayExpression,
                elements: elements
            };
        },
        object: function() {
            var property, properties = [];
            if ("}" !== this.peekToken().text) do {
                if (this.peek("}")) break;
                property = {
                    type: AST.Property,
                    kind: "init"
                }, this.peek().constant ? property.key = this.constant() : this.peek().identifier ? property.key = this.identifier() : this.throwError("invalid key", this.peek()), 
                this.consume(":"), property.value = this.expression(), properties.push(property);
            } while (this.expect(","));
            return this.consume("}"), {
                type: AST.ObjectExpression,
                properties: properties
            };
        },
        throwError: function(msg, token) {
            throw $parseMinErr("syntax", "Syntax Error: Token '{0}' {1} at column {2} of the expression [{3}] starting at [{4}].", token.text, msg, token.index + 1, this.text, this.text.substring(token.index));
        },
        consume: function(e1) {
            if (0 === this.tokens.length) throw $parseMinErr("ueoe", "Unexpected end of expression: {0}", this.text);
            var token = this.expect(e1);
            return token || this.throwError("is unexpected, expecting [" + e1 + "]", this.peek()), 
            token;
        },
        peekToken: function() {
            if (0 === this.tokens.length) throw $parseMinErr("ueoe", "Unexpected end of expression: {0}", this.text);
            return this.tokens[0];
        },
        peek: function(e1, e2, e3, e4) {
            return this.peekAhead(0, e1, e2, e3, e4);
        },
        peekAhead: function(i, e1, e2, e3, e4) {
            if (this.tokens.length > i) {
                var token = this.tokens[i], t = token.text;
                if (t === e1 || t === e2 || t === e3 || t === e4 || !e1 && !e2 && !e3 && !e4) return token;
            }
            return !1;
        },
        expect: function(e1, e2, e3, e4) {
            var token = this.peek(e1, e2, e3, e4);
            return token ? (this.tokens.shift(), token) : !1;
        },
        constants: {
            "true": {
                type: AST.Literal,
                value: !0
            },
            "false": {
                type: AST.Literal,
                value: !1
            },
            "null": {
                type: AST.Literal,
                value: null
            },
            undefined: {
                type: AST.Literal,
                value: undefined
            },
            "this": {
                type: AST.ThisExpression
            }
        }
    }, ASTCompiler.prototype = {
        compile: function(expression, expensiveChecks) {
            var self = this, ast = this.astBuilder.ast(expression);
            this.state = {
                nextId: 0,
                filters: {},
                expensiveChecks: expensiveChecks,
                fn: {
                    vars: [],
                    body: [],
                    own: {}
                },
                assign: {
                    vars: [],
                    body: [],
                    own: {}
                },
                inputs: []
            }, findConstantAndWatchExpressions(ast, self.$filter);
            var assignable, extra = "";
            if (this.stage = "assign", assignable = assignableAST(ast)) {
                this.state.computing = "assign";
                var result = this.nextId();
                this.recurse(assignable, result), this.return_(result), extra = "fn.assign=" + this.generateFunction("assign", "s,v,l");
            }
            var toWatch = getInputs(ast.body);
            self.stage = "inputs", forEach(toWatch, function(watch, key) {
                var fnKey = "fn" + key;
                self.state[fnKey] = {
                    vars: [],
                    body: [],
                    own: {}
                }, self.state.computing = fnKey;
                var intoId = self.nextId();
                self.recurse(watch, intoId), self.return_(intoId), self.state.inputs.push(fnKey), 
                watch.watchId = key;
            }), this.state.computing = "fn", this.stage = "main", this.recurse(ast);
            var fnString = '"' + this.USE + " " + this.STRICT + '";\n' + this.filterPrefix() + "var fn=" + this.generateFunction("fn", "s,l,a,i") + extra + this.watchFns() + "return fn;", fn = new Function("$filter", "ensureSafeMemberName", "ensureSafeObject", "ensureSafeFunction", "getStringValue", "ensureSafeAssignContext", "ifDefined", "plus", "text", fnString)(this.$filter, ensureSafeMemberName, ensureSafeObject, ensureSafeFunction, getStringValue, ensureSafeAssignContext, ifDefined, plusFn, expression);
            return this.state = this.stage = undefined, fn.literal = isLiteral(ast), fn.constant = isConstant(ast), 
            fn;
        },
        USE: "use",
        STRICT: "strict",
        watchFns: function() {
            var result = [], fns = this.state.inputs, self = this;
            return forEach(fns, function(name) {
                result.push("var " + name + "=" + self.generateFunction(name, "s"));
            }), fns.length && result.push("fn.inputs=[" + fns.join(",") + "];"), result.join("");
        },
        generateFunction: function(name, params) {
            return "function(" + params + "){" + this.varsPrefix(name) + this.body(name) + "};";
        },
        filterPrefix: function() {
            var parts = [], self = this;
            return forEach(this.state.filters, function(id, filter) {
                parts.push(id + "=$filter(" + self.escape(filter) + ")");
            }), parts.length ? "var " + parts.join(",") + ";" : "";
        },
        varsPrefix: function(section) {
            return this.state[section].vars.length ? "var " + this.state[section].vars.join(",") + ";" : "";
        },
        body: function(section) {
            return this.state[section].body.join("");
        },
        recurse: function(ast, intoId, nameId, recursionFn, create, skipWatchIdCheck) {
            var left, right, args, expression, self = this;
            if (recursionFn = recursionFn || noop, !skipWatchIdCheck && isDefined(ast.watchId)) return intoId = intoId || this.nextId(), 
            void this.if_("i", this.lazyAssign(intoId, this.computedMember("i", ast.watchId)), this.lazyRecurse(ast, intoId, nameId, recursionFn, create, !0));
            switch (ast.type) {
              case AST.Program:
                forEach(ast.body, function(expression, pos) {
                    self.recurse(expression.expression, undefined, undefined, function(expr) {
                        right = expr;
                    }), pos !== ast.body.length - 1 ? self.current().body.push(right, ";") : self.return_(right);
                });
                break;

              case AST.Literal:
                expression = this.escape(ast.value), this.assign(intoId, expression), recursionFn(expression);
                break;

              case AST.UnaryExpression:
                this.recurse(ast.argument, undefined, undefined, function(expr) {
                    right = expr;
                }), expression = ast.operator + "(" + this.ifDefined(right, 0) + ")", this.assign(intoId, expression), 
                recursionFn(expression);
                break;

              case AST.BinaryExpression:
                this.recurse(ast.left, undefined, undefined, function(expr) {
                    left = expr;
                }), this.recurse(ast.right, undefined, undefined, function(expr) {
                    right = expr;
                }), expression = "+" === ast.operator ? this.plus(left, right) : "-" === ast.operator ? this.ifDefined(left, 0) + ast.operator + this.ifDefined(right, 0) : "(" + left + ")" + ast.operator + "(" + right + ")", 
                this.assign(intoId, expression), recursionFn(expression);
                break;

              case AST.LogicalExpression:
                intoId = intoId || this.nextId(), self.recurse(ast.left, intoId), self.if_("&&" === ast.operator ? intoId : self.not(intoId), self.lazyRecurse(ast.right, intoId)), 
                recursionFn(intoId);
                break;

              case AST.ConditionalExpression:
                intoId = intoId || this.nextId(), self.recurse(ast.test, intoId), self.if_(intoId, self.lazyRecurse(ast.alternate, intoId), self.lazyRecurse(ast.consequent, intoId)), 
                recursionFn(intoId);
                break;

              case AST.Identifier:
                intoId = intoId || this.nextId(), nameId && (nameId.context = "inputs" === self.stage ? "s" : this.assign(this.nextId(), this.getHasOwnProperty("l", ast.name) + "?l:s"), 
                nameId.computed = !1, nameId.name = ast.name), ensureSafeMemberName(ast.name), self.if_("inputs" === self.stage || self.not(self.getHasOwnProperty("l", ast.name)), function() {
                    self.if_("inputs" === self.stage || "s", function() {
                        create && 1 !== create && self.if_(self.not(self.nonComputedMember("s", ast.name)), self.lazyAssign(self.nonComputedMember("s", ast.name), "{}")), 
                        self.assign(intoId, self.nonComputedMember("s", ast.name));
                    });
                }, intoId && self.lazyAssign(intoId, self.nonComputedMember("l", ast.name))), (self.state.expensiveChecks || isPossiblyDangerousMemberName(ast.name)) && self.addEnsureSafeObject(intoId), 
                recursionFn(intoId);
                break;

              case AST.MemberExpression:
                left = nameId && (nameId.context = this.nextId()) || this.nextId(), intoId = intoId || this.nextId(), 
                self.recurse(ast.object, left, undefined, function() {
                    self.if_(self.notNull(left), function() {
                        ast.computed ? (right = self.nextId(), self.recurse(ast.property, right), self.getStringValue(right), 
                        self.addEnsureSafeMemberName(right), create && 1 !== create && self.if_(self.not(self.computedMember(left, right)), self.lazyAssign(self.computedMember(left, right), "{}")), 
                        expression = self.ensureSafeObject(self.computedMember(left, right)), self.assign(intoId, expression), 
                        nameId && (nameId.computed = !0, nameId.name = right)) : (ensureSafeMemberName(ast.property.name), 
                        create && 1 !== create && self.if_(self.not(self.nonComputedMember(left, ast.property.name)), self.lazyAssign(self.nonComputedMember(left, ast.property.name), "{}")), 
                        expression = self.nonComputedMember(left, ast.property.name), (self.state.expensiveChecks || isPossiblyDangerousMemberName(ast.property.name)) && (expression = self.ensureSafeObject(expression)), 
                        self.assign(intoId, expression), nameId && (nameId.computed = !1, nameId.name = ast.property.name));
                    }, function() {
                        self.assign(intoId, "undefined");
                    }), recursionFn(intoId);
                }, !!create);
                break;

              case AST.CallExpression:
                intoId = intoId || this.nextId(), ast.filter ? (right = self.filter(ast.callee.name), 
                args = [], forEach(ast.arguments, function(expr) {
                    var argument = self.nextId();
                    self.recurse(expr, argument), args.push(argument);
                }), expression = right + "(" + args.join(",") + ")", self.assign(intoId, expression), 
                recursionFn(intoId)) : (right = self.nextId(), left = {}, args = [], self.recurse(ast.callee, right, left, function() {
                    self.if_(self.notNull(right), function() {
                        self.addEnsureSafeFunction(right), forEach(ast.arguments, function(expr) {
                            self.recurse(expr, self.nextId(), undefined, function(argument) {
                                args.push(self.ensureSafeObject(argument));
                            });
                        }), left.name ? (self.state.expensiveChecks || self.addEnsureSafeObject(left.context), 
                        expression = self.member(left.context, left.name, left.computed) + "(" + args.join(",") + ")") : expression = right + "(" + args.join(",") + ")", 
                        expression = self.ensureSafeObject(expression), self.assign(intoId, expression);
                    }, function() {
                        self.assign(intoId, "undefined");
                    }), recursionFn(intoId);
                }));
                break;

              case AST.AssignmentExpression:
                if (right = this.nextId(), left = {}, !isAssignable(ast.left)) throw $parseMinErr("lval", "Trying to assing a value to a non l-value");
                this.recurse(ast.left, undefined, left, function() {
                    self.if_(self.notNull(left.context), function() {
                        self.recurse(ast.right, right), self.addEnsureSafeObject(self.member(left.context, left.name, left.computed)), 
                        self.addEnsureSafeAssignContext(left.context), expression = self.member(left.context, left.name, left.computed) + ast.operator + right, 
                        self.assign(intoId, expression), recursionFn(intoId || expression);
                    });
                }, 1);
                break;

              case AST.ArrayExpression:
                args = [], forEach(ast.elements, function(expr) {
                    self.recurse(expr, self.nextId(), undefined, function(argument) {
                        args.push(argument);
                    });
                }), expression = "[" + args.join(",") + "]", this.assign(intoId, expression), recursionFn(expression);
                break;

              case AST.ObjectExpression:
                args = [], forEach(ast.properties, function(property) {
                    self.recurse(property.value, self.nextId(), undefined, function(expr) {
                        args.push(self.escape(property.key.type === AST.Identifier ? property.key.name : "" + property.key.value) + ":" + expr);
                    });
                }), expression = "{" + args.join(",") + "}", this.assign(intoId, expression), recursionFn(expression);
                break;

              case AST.ThisExpression:
                this.assign(intoId, "s"), recursionFn("s");
                break;

              case AST.NGValueParameter:
                this.assign(intoId, "v"), recursionFn("v");
            }
        },
        getHasOwnProperty: function(element, property) {
            var key = element + "." + property, own = this.current().own;
            return own.hasOwnProperty(key) || (own[key] = this.nextId(!1, element + "&&(" + this.escape(property) + " in " + element + ")")), 
            own[key];
        },
        assign: function(id, value) {
            return id ? (this.current().body.push(id, "=", value, ";"), id) : void 0;
        },
        filter: function(filterName) {
            return this.state.filters.hasOwnProperty(filterName) || (this.state.filters[filterName] = this.nextId(!0)), 
            this.state.filters[filterName];
        },
        ifDefined: function(id, defaultValue) {
            return "ifDefined(" + id + "," + this.escape(defaultValue) + ")";
        },
        plus: function(left, right) {
            return "plus(" + left + "," + right + ")";
        },
        return_: function(id) {
            this.current().body.push("return ", id, ";");
        },
        if_: function(test, alternate, consequent) {
            if (test === !0) alternate(); else {
                var body = this.current().body;
                body.push("if(", test, "){"), alternate(), body.push("}"), consequent && (body.push("else{"), 
                consequent(), body.push("}"));
            }
        },
        not: function(expression) {
            return "!(" + expression + ")";
        },
        notNull: function(expression) {
            return expression + "!=null";
        },
        nonComputedMember: function(left, right) {
            return left + "." + right;
        },
        computedMember: function(left, right) {
            return left + "[" + right + "]";
        },
        member: function(left, right, computed) {
            return computed ? this.computedMember(left, right) : this.nonComputedMember(left, right);
        },
        addEnsureSafeObject: function(item) {
            this.current().body.push(this.ensureSafeObject(item), ";");
        },
        addEnsureSafeMemberName: function(item) {
            this.current().body.push(this.ensureSafeMemberName(item), ";");
        },
        addEnsureSafeFunction: function(item) {
            this.current().body.push(this.ensureSafeFunction(item), ";");
        },
        addEnsureSafeAssignContext: function(item) {
            this.current().body.push(this.ensureSafeAssignContext(item), ";");
        },
        ensureSafeObject: function(item) {
            return "ensureSafeObject(" + item + ",text)";
        },
        ensureSafeMemberName: function(item) {
            return "ensureSafeMemberName(" + item + ",text)";
        },
        ensureSafeFunction: function(item) {
            return "ensureSafeFunction(" + item + ",text)";
        },
        getStringValue: function(item) {
            this.assign(item, "getStringValue(" + item + ",text)");
        },
        ensureSafeAssignContext: function(item) {
            return "ensureSafeAssignContext(" + item + ",text)";
        },
        lazyRecurse: function(ast, intoId, nameId, recursionFn, create, skipWatchIdCheck) {
            var self = this;
            return function() {
                self.recurse(ast, intoId, nameId, recursionFn, create, skipWatchIdCheck);
            };
        },
        lazyAssign: function(id, value) {
            var self = this;
            return function() {
                self.assign(id, value);
            };
        },
        stringEscapeRegex: /[^ a-zA-Z0-9]/g,
        stringEscapeFn: function(c) {
            return "\\u" + ("0000" + c.charCodeAt(0).toString(16)).slice(-4);
        },
        escape: function(value) {
            if (isString(value)) return "'" + value.replace(this.stringEscapeRegex, this.stringEscapeFn) + "'";
            if (isNumber(value)) return value.toString();
            if (value === !0) return "true";
            if (value === !1) return "false";
            if (null === value) return "null";
            if ("undefined" == typeof value) return "undefined";
            throw $parseMinErr("esc", "IMPOSSIBLE");
        },
        nextId: function(skip, init) {
            var id = "v" + this.state.nextId++;
            return skip || this.current().vars.push(id + (init ? "=" + init : "")), id;
        },
        current: function() {
            return this.state[this.state.computing];
        }
    }, ASTInterpreter.prototype = {
        compile: function(expression, expensiveChecks) {
            var self = this, ast = this.astBuilder.ast(expression);
            this.expression = expression, this.expensiveChecks = expensiveChecks, findConstantAndWatchExpressions(ast, self.$filter);
            var assignable, assign;
            (assignable = assignableAST(ast)) && (assign = this.recurse(assignable));
            var inputs, toWatch = getInputs(ast.body);
            toWatch && (inputs = [], forEach(toWatch, function(watch, key) {
                var input = self.recurse(watch);
                watch.input = input, inputs.push(input), watch.watchId = key;
            }));
            var expressions = [];
            forEach(ast.body, function(expression) {
                expressions.push(self.recurse(expression.expression));
            });
            var fn = 0 === ast.body.length ? function() {} : 1 === ast.body.length ? expressions[0] : function(scope, locals) {
                var lastValue;
                return forEach(expressions, function(exp) {
                    lastValue = exp(scope, locals);
                }), lastValue;
            };
            return assign && (fn.assign = function(scope, value, locals) {
                return assign(scope, locals, value);
            }), inputs && (fn.inputs = inputs), fn.literal = isLiteral(ast), fn.constant = isConstant(ast), 
            fn;
        },
        recurse: function(ast, context, create) {
            var left, right, args, self = this;
            if (ast.input) return this.inputs(ast.input, ast.watchId);
            switch (ast.type) {
              case AST.Literal:
                return this.value(ast.value, context);

              case AST.UnaryExpression:
                return right = this.recurse(ast.argument), this["unary" + ast.operator](right, context);

              case AST.BinaryExpression:
                return left = this.recurse(ast.left), right = this.recurse(ast.right), this["binary" + ast.operator](left, right, context);

              case AST.LogicalExpression:
                return left = this.recurse(ast.left), right = this.recurse(ast.right), this["binary" + ast.operator](left, right, context);

              case AST.ConditionalExpression:
                return this["ternary?:"](this.recurse(ast.test), this.recurse(ast.alternate), this.recurse(ast.consequent), context);

              case AST.Identifier:
                return ensureSafeMemberName(ast.name, self.expression), self.identifier(ast.name, self.expensiveChecks || isPossiblyDangerousMemberName(ast.name), context, create, self.expression);

              case AST.MemberExpression:
                return left = this.recurse(ast.object, !1, !!create), ast.computed || (ensureSafeMemberName(ast.property.name, self.expression), 
                right = ast.property.name), ast.computed && (right = this.recurse(ast.property)), 
                ast.computed ? this.computedMember(left, right, context, create, self.expression) : this.nonComputedMember(left, right, self.expensiveChecks, context, create, self.expression);

              case AST.CallExpression:
                return args = [], forEach(ast.arguments, function(expr) {
                    args.push(self.recurse(expr));
                }), ast.filter && (right = this.$filter(ast.callee.name)), ast.filter || (right = this.recurse(ast.callee, !0)), 
                ast.filter ? function(scope, locals, assign, inputs) {
                    for (var values = [], i = 0; i < args.length; ++i) values.push(args[i](scope, locals, assign, inputs));
                    var value = right.apply(undefined, values, inputs);
                    return context ? {
                        context: undefined,
                        name: undefined,
                        value: value
                    } : value;
                } : function(scope, locals, assign, inputs) {
                    var value, rhs = right(scope, locals, assign, inputs);
                    if (null != rhs.value) {
                        ensureSafeObject(rhs.context, self.expression), ensureSafeFunction(rhs.value, self.expression);
                        for (var values = [], i = 0; i < args.length; ++i) values.push(ensureSafeObject(args[i](scope, locals, assign, inputs), self.expression));
                        value = ensureSafeObject(rhs.value.apply(rhs.context, values), self.expression);
                    }
                    return context ? {
                        value: value
                    } : value;
                };

              case AST.AssignmentExpression:
                return left = this.recurse(ast.left, !0, 1), right = this.recurse(ast.right), function(scope, locals, assign, inputs) {
                    var lhs = left(scope, locals, assign, inputs), rhs = right(scope, locals, assign, inputs);
                    return ensureSafeObject(lhs.value, self.expression), ensureSafeAssignContext(lhs.context), 
                    lhs.context[lhs.name] = rhs, context ? {
                        value: rhs
                    } : rhs;
                };

              case AST.ArrayExpression:
                return args = [], forEach(ast.elements, function(expr) {
                    args.push(self.recurse(expr));
                }), function(scope, locals, assign, inputs) {
                    for (var value = [], i = 0; i < args.length; ++i) value.push(args[i](scope, locals, assign, inputs));
                    return context ? {
                        value: value
                    } : value;
                };

              case AST.ObjectExpression:
                return args = [], forEach(ast.properties, function(property) {
                    args.push({
                        key: property.key.type === AST.Identifier ? property.key.name : "" + property.key.value,
                        value: self.recurse(property.value)
                    });
                }), function(scope, locals, assign, inputs) {
                    for (var value = {}, i = 0; i < args.length; ++i) value[args[i].key] = args[i].value(scope, locals, assign, inputs);
                    return context ? {
                        value: value
                    } : value;
                };

              case AST.ThisExpression:
                return function(scope) {
                    return context ? {
                        value: scope
                    } : scope;
                };

              case AST.NGValueParameter:
                return function(scope, locals, assign) {
                    return context ? {
                        value: assign
                    } : assign;
                };
            }
        },
        "unary+": function(argument, context) {
            return function(scope, locals, assign, inputs) {
                var arg = argument(scope, locals, assign, inputs);
                return arg = isDefined(arg) ? +arg : 0, context ? {
                    value: arg
                } : arg;
            };
        },
        "unary-": function(argument, context) {
            return function(scope, locals, assign, inputs) {
                var arg = argument(scope, locals, assign, inputs);
                return arg = isDefined(arg) ? -arg : 0, context ? {
                    value: arg
                } : arg;
            };
        },
        "unary!": function(argument, context) {
            return function(scope, locals, assign, inputs) {
                var arg = !argument(scope, locals, assign, inputs);
                return context ? {
                    value: arg
                } : arg;
            };
        },
        "binary+": function(left, right, context) {
            return function(scope, locals, assign, inputs) {
                var lhs = left(scope, locals, assign, inputs), rhs = right(scope, locals, assign, inputs), arg = plusFn(lhs, rhs);
                return context ? {
                    value: arg
                } : arg;
            };
        },
        "binary-": function(left, right, context) {
            return function(scope, locals, assign, inputs) {
                var lhs = left(scope, locals, assign, inputs), rhs = right(scope, locals, assign, inputs), arg = (isDefined(lhs) ? lhs : 0) - (isDefined(rhs) ? rhs : 0);
                return context ? {
                    value: arg
                } : arg;
            };
        },
        "binary*": function(left, right, context) {
            return function(scope, locals, assign, inputs) {
                var arg = left(scope, locals, assign, inputs) * right(scope, locals, assign, inputs);
                return context ? {
                    value: arg
                } : arg;
            };
        },
        "binary/": function(left, right, context) {
            return function(scope, locals, assign, inputs) {
                var arg = left(scope, locals, assign, inputs) / right(scope, locals, assign, inputs);
                return context ? {
                    value: arg
                } : arg;
            };
        },
        "binary%": function(left, right, context) {
            return function(scope, locals, assign, inputs) {
                var arg = left(scope, locals, assign, inputs) % right(scope, locals, assign, inputs);
                return context ? {
                    value: arg
                } : arg;
            };
        },
        "binary===": function(left, right, context) {
            return function(scope, locals, assign, inputs) {
                var arg = left(scope, locals, assign, inputs) === right(scope, locals, assign, inputs);
                return context ? {
                    value: arg
                } : arg;
            };
        },
        "binary!==": function(left, right, context) {
            return function(scope, locals, assign, inputs) {
                var arg = left(scope, locals, assign, inputs) !== right(scope, locals, assign, inputs);
                return context ? {
                    value: arg
                } : arg;
            };
        },
        "binary==": function(left, right, context) {
            return function(scope, locals, assign, inputs) {
                var arg = left(scope, locals, assign, inputs) == right(scope, locals, assign, inputs);
                return context ? {
                    value: arg
                } : arg;
            };
        },
        "binary!=": function(left, right, context) {
            return function(scope, locals, assign, inputs) {
                var arg = left(scope, locals, assign, inputs) != right(scope, locals, assign, inputs);
                return context ? {
                    value: arg
                } : arg;
            };
        },
        "binary<": function(left, right, context) {
            return function(scope, locals, assign, inputs) {
                var arg = left(scope, locals, assign, inputs) < right(scope, locals, assign, inputs);
                return context ? {
                    value: arg
                } : arg;
            };
        },
        "binary>": function(left, right, context) {
            return function(scope, locals, assign, inputs) {
                var arg = left(scope, locals, assign, inputs) > right(scope, locals, assign, inputs);
                return context ? {
                    value: arg
                } : arg;
            };
        },
        "binary<=": function(left, right, context) {
            return function(scope, locals, assign, inputs) {
                var arg = left(scope, locals, assign, inputs) <= right(scope, locals, assign, inputs);
                return context ? {
                    value: arg
                } : arg;
            };
        },
        "binary>=": function(left, right, context) {
            return function(scope, locals, assign, inputs) {
                var arg = left(scope, locals, assign, inputs) >= right(scope, locals, assign, inputs);
                return context ? {
                    value: arg
                } : arg;
            };
        },
        "binary&&": function(left, right, context) {
            return function(scope, locals, assign, inputs) {
                var arg = left(scope, locals, assign, inputs) && right(scope, locals, assign, inputs);
                return context ? {
                    value: arg
                } : arg;
            };
        },
        "binary||": function(left, right, context) {
            return function(scope, locals, assign, inputs) {
                var arg = left(scope, locals, assign, inputs) || right(scope, locals, assign, inputs);
                return context ? {
                    value: arg
                } : arg;
            };
        },
        "ternary?:": function(test, alternate, consequent, context) {
            return function(scope, locals, assign, inputs) {
                var arg = test(scope, locals, assign, inputs) ? alternate(scope, locals, assign, inputs) : consequent(scope, locals, assign, inputs);
                return context ? {
                    value: arg
                } : arg;
            };
        },
        value: function(value, context) {
            return function() {
                return context ? {
                    context: undefined,
                    name: undefined,
                    value: value
                } : value;
            };
        },
        identifier: function(name, expensiveChecks, context, create, expression) {
            return function(scope, locals) {
                var base = locals && name in locals ? locals : scope;
                create && 1 !== create && base && !base[name] && (base[name] = {});
                var value = base ? base[name] : undefined;
                return expensiveChecks && ensureSafeObject(value, expression), context ? {
                    context: base,
                    name: name,
                    value: value
                } : value;
            };
        },
        computedMember: function(left, right, context, create, expression) {
            return function(scope, locals, assign, inputs) {
                var rhs, value, lhs = left(scope, locals, assign, inputs);
                return null != lhs && (rhs = right(scope, locals, assign, inputs), rhs = getStringValue(rhs), 
                ensureSafeMemberName(rhs, expression), create && 1 !== create && lhs && !lhs[rhs] && (lhs[rhs] = {}), 
                value = lhs[rhs], ensureSafeObject(value, expression)), context ? {
                    context: lhs,
                    name: rhs,
                    value: value
                } : value;
            };
        },
        nonComputedMember: function(left, right, expensiveChecks, context, create, expression) {
            return function(scope, locals, assign, inputs) {
                var lhs = left(scope, locals, assign, inputs);
                create && 1 !== create && lhs && !lhs[right] && (lhs[right] = {});
                var value = null != lhs ? lhs[right] : undefined;
                return (expensiveChecks || isPossiblyDangerousMemberName(right)) && ensureSafeObject(value, expression), 
                context ? {
                    context: lhs,
                    name: right,
                    value: value
                } : value;
            };
        },
        inputs: function(input, watchId) {
            return function(scope, value, locals, inputs) {
                return inputs ? inputs[watchId] : input(scope, value, locals);
            };
        }
    };
    var Parser = function(lexer, $filter, options) {
        this.lexer = lexer, this.$filter = $filter, this.options = options, this.ast = new AST(this.lexer), 
        this.astCompiler = options.csp ? new ASTInterpreter(this.ast, $filter) : new ASTCompiler(this.ast, $filter);
    };
    Parser.prototype = {
        constructor: Parser,
        parse: function(text) {
            return this.astCompiler.compile(text, this.options.expensiveChecks);
        }
    };
    var objectValueOf = (createMap(), createMap(), Object.prototype.valueOf), $sceMinErr = minErr("$sce"), SCE_CONTEXTS = {
        HTML: "html",
        CSS: "css",
        URL: "url",
        RESOURCE_URL: "resourceUrl",
        JS: "js"
    }, $compileMinErr = minErr("$compile"), urlParsingNode = document.createElement("a"), originUrl = urlResolve(window.location.href);
    $$CookieReader.$inject = [ "$document" ], $FilterProvider.$inject = [ "$provide" ], 
    currencyFilter.$inject = [ "$locale" ], numberFilter.$inject = [ "$locale" ];
    var DECIMAL_SEP = ".", DATE_FORMATS = {
        yyyy: dateGetter("FullYear", 4),
        yy: dateGetter("FullYear", 2, 0, !0),
        y: dateGetter("FullYear", 1),
        MMMM: dateStrGetter("Month"),
        MMM: dateStrGetter("Month", !0),
        MM: dateGetter("Month", 2, 1),
        M: dateGetter("Month", 1, 1),
        dd: dateGetter("Date", 2),
        d: dateGetter("Date", 1),
        HH: dateGetter("Hours", 2),
        H: dateGetter("Hours", 1),
        hh: dateGetter("Hours", 2, -12),
        h: dateGetter("Hours", 1, -12),
        mm: dateGetter("Minutes", 2),
        m: dateGetter("Minutes", 1),
        ss: dateGetter("Seconds", 2),
        s: dateGetter("Seconds", 1),
        sss: dateGetter("Milliseconds", 3),
        EEEE: dateStrGetter("Day"),
        EEE: dateStrGetter("Day", !0),
        a: ampmGetter,
        Z: timeZoneGetter,
        ww: weekGetter(2),
        w: weekGetter(1),
        G: eraGetter,
        GG: eraGetter,
        GGG: eraGetter,
        GGGG: longEraGetter
    }, DATE_FORMATS_SPLIT = /((?:[^yMdHhmsaZEwG']+)|(?:'(?:[^']|'')*')|(?:E+|y+|M+|d+|H+|h+|m+|s+|a|Z|G+|w+))(.*)/, NUMBER_STRING = /^\-?\d+$/;
    dateFilter.$inject = [ "$locale" ];
    var lowercaseFilter = valueFn(lowercase), uppercaseFilter = valueFn(uppercase);
    orderByFilter.$inject = [ "$parse" ];
    var htmlAnchorDirective = valueFn({
        restrict: "E",
        compile: function(element, attr) {
            return attr.href || attr.xlinkHref ? void 0 : function(scope, element) {
                if ("a" === element[0].nodeName.toLowerCase()) {
                    var href = "[object SVGAnimatedString]" === toString.call(element.prop("href")) ? "xlink:href" : "href";
                    element.on("click", function(event) {
                        element.attr(href) || event.preventDefault();
                    });
                }
            };
        }
    }), ngAttributeAliasDirectives = {};
    forEach(BOOLEAN_ATTR, function(propName, attrName) {
        function defaultLinkFn(scope, element, attr) {
            scope.$watch(attr[normalized], function(value) {
                attr.$set(attrName, !!value);
            });
        }
        if ("multiple" != propName) {
            var normalized = directiveNormalize("ng-" + attrName), linkFn = defaultLinkFn;
            "checked" === propName && (linkFn = function(scope, element, attr) {
                attr.ngModel !== attr[normalized] && defaultLinkFn(scope, element, attr);
            }), ngAttributeAliasDirectives[normalized] = function() {
                return {
                    restrict: "A",
                    priority: 100,
                    link: linkFn
                };
            };
        }
    }), forEach(ALIASED_ATTR, function(htmlAttr, ngAttr) {
        ngAttributeAliasDirectives[ngAttr] = function() {
            return {
                priority: 100,
                link: function(scope, element, attr) {
                    if ("ngPattern" === ngAttr && "/" == attr.ngPattern.charAt(0)) {
                        var match = attr.ngPattern.match(REGEX_STRING_REGEXP);
                        if (match) return void attr.$set("ngPattern", new RegExp(match[1], match[2]));
                    }
                    scope.$watch(attr[ngAttr], function(value) {
                        attr.$set(ngAttr, value);
                    });
                }
            };
        };
    }), forEach([ "src", "srcset", "href" ], function(attrName) {
        var normalized = directiveNormalize("ng-" + attrName);
        ngAttributeAliasDirectives[normalized] = function() {
            return {
                priority: 99,
                link: function(scope, element, attr) {
                    var propName = attrName, name = attrName;
                    "href" === attrName && "[object SVGAnimatedString]" === toString.call(element.prop("href")) && (name = "xlinkHref", 
                    attr.$attr[name] = "xlink:href", propName = null), attr.$observe(normalized, function(value) {
                        return value ? (attr.$set(name, value), void (msie && propName && element.prop(propName, attr[name]))) : void ("href" === attrName && attr.$set(name, null));
                    });
                }
            };
        };
    });
    var nullFormCtrl = {
        $addControl: noop,
        $$renameControl: nullFormRenameControl,
        $removeControl: noop,
        $setValidity: noop,
        $setDirty: noop,
        $setPristine: noop,
        $setSubmitted: noop
    }, SUBMITTED_CLASS = "ng-submitted";
    FormController.$inject = [ "$element", "$attrs", "$scope", "$animate", "$interpolate" ];
    var formDirectiveFactory = function(isNgForm) {
        return [ "$timeout", "$parse", function($timeout, $parse) {
            function getSetter(expression) {
                return "" === expression ? $parse('this[""]').assign : $parse(expression).assign || noop;
            }
            var formDirective = {
                name: "form",
                restrict: isNgForm ? "EAC" : "E",
                require: [ "form", "^^?form" ],
                controller: FormController,
                compile: function(formElement, attr) {
                    formElement.addClass(PRISTINE_CLASS).addClass(VALID_CLASS);
                    var nameAttr = attr.name ? "name" : isNgForm && attr.ngForm ? "ngForm" : !1;
                    return {
                        pre: function(scope, formElement, attr, ctrls) {
                            var controller = ctrls[0];
                            if (!("action" in attr)) {
                                var handleFormSubmission = function(event) {
                                    scope.$apply(function() {
                                        controller.$commitViewValue(), controller.$setSubmitted();
                                    }), event.preventDefault();
                                };
                                addEventListenerFn(formElement[0], "submit", handleFormSubmission), formElement.on("$destroy", function() {
                                    $timeout(function() {
                                        removeEventListenerFn(formElement[0], "submit", handleFormSubmission);
                                    }, 0, !1);
                                });
                            }
                            var parentFormCtrl = ctrls[1] || controller.$$parentForm;
                            parentFormCtrl.$addControl(controller);
                            var setter = nameAttr ? getSetter(controller.$name) : noop;
                            nameAttr && (setter(scope, controller), attr.$observe(nameAttr, function(newValue) {
                                controller.$name !== newValue && (setter(scope, undefined), controller.$$parentForm.$$renameControl(controller, newValue), 
                                (setter = getSetter(controller.$name))(scope, controller));
                            })), formElement.on("$destroy", function() {
                                controller.$$parentForm.$removeControl(controller), setter(scope, undefined), extend(controller, nullFormCtrl);
                            });
                        }
                    };
                }
            };
            return formDirective;
        } ];
    }, formDirective = formDirectiveFactory(), ngFormDirective = formDirectiveFactory(!0), ISO_DATE_REGEXP = /\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+([+-][0-2]\d:[0-5]\d|Z)/, URL_REGEXP = /^(ftp|http|https):\/\/(\w+:{0,1}\w*@)?(\S+)(:[0-9]+)?(\/|\/([\w#!:.?+=&%@!\-\/]))?$/, EMAIL_REGEXP = /^[a-z0-9!#$%&'*+\/=?^_`{|}~.-]+@[a-z0-9]([a-z0-9-]*[a-z0-9])?(\.[a-z0-9]([a-z0-9-]*[a-z0-9])?)*$/i, NUMBER_REGEXP = /^\s*(\-|\+)?(\d+|(\d*(\.\d*)))([eE][+-]?\d+)?\s*$/, DATE_REGEXP = /^(\d{4})-(\d{2})-(\d{2})$/, DATETIMELOCAL_REGEXP = /^(\d{4})-(\d\d)-(\d\d)T(\d\d):(\d\d)(?::(\d\d)(\.\d{1,3})?)?$/, WEEK_REGEXP = /^(\d{4})-W(\d\d)$/, MONTH_REGEXP = /^(\d{4})-(\d\d)$/, TIME_REGEXP = /^(\d\d):(\d\d)(?::(\d\d)(\.\d{1,3})?)?$/, inputType = {
        text: textInputType,
        date: createDateInputType("date", DATE_REGEXP, createDateParser(DATE_REGEXP, [ "yyyy", "MM", "dd" ]), "yyyy-MM-dd"),
        "datetime-local": createDateInputType("datetimelocal", DATETIMELOCAL_REGEXP, createDateParser(DATETIMELOCAL_REGEXP, [ "yyyy", "MM", "dd", "HH", "mm", "ss", "sss" ]), "yyyy-MM-ddTHH:mm:ss.sss"),
        time: createDateInputType("time", TIME_REGEXP, createDateParser(TIME_REGEXP, [ "HH", "mm", "ss", "sss" ]), "HH:mm:ss.sss"),
        week: createDateInputType("week", WEEK_REGEXP, weekParser, "yyyy-Www"),
        month: createDateInputType("month", MONTH_REGEXP, createDateParser(MONTH_REGEXP, [ "yyyy", "MM" ]), "yyyy-MM"),
        number: numberInputType,
        url: urlInputType,
        email: emailInputType,
        radio: radioInputType,
        checkbox: checkboxInputType,
        hidden: noop,
        button: noop,
        submit: noop,
        reset: noop,
        file: noop
    }, inputDirective = [ "$browser", "$sniffer", "$filter", "$parse", function($browser, $sniffer, $filter, $parse) {
        return {
            restrict: "E",
            require: [ "?ngModel" ],
            link: {
                pre: function(scope, element, attr, ctrls) {
                    ctrls[0] && (inputType[lowercase(attr.type)] || inputType.text)(scope, element, attr, ctrls[0], $sniffer, $browser, $filter, $parse);
                }
            }
        };
    } ], CONSTANT_VALUE_REGEXP = /^(true|false|\d+)$/, ngValueDirective = function() {
        return {
            restrict: "A",
            priority: 100,
            compile: function(tpl, tplAttr) {
                return CONSTANT_VALUE_REGEXP.test(tplAttr.ngValue) ? function(scope, elm, attr) {
                    attr.$set("value", scope.$eval(attr.ngValue));
                } : function(scope, elm, attr) {
                    scope.$watch(attr.ngValue, function(value) {
                        attr.$set("value", value);
                    });
                };
            }
        };
    }, ngBindDirective = [ "$compile", function($compile) {
        return {
            restrict: "AC",
            compile: function(templateElement) {
                return $compile.$$addBindingClass(templateElement), function(scope, element, attr) {
                    $compile.$$addBindingInfo(element, attr.ngBind), element = element[0], scope.$watch(attr.ngBind, function(value) {
                        element.textContent = isUndefined(value) ? "" : value;
                    });
                };
            }
        };
    } ], ngBindTemplateDirective = [ "$interpolate", "$compile", function($interpolate, $compile) {
        return {
            compile: function(templateElement) {
                return $compile.$$addBindingClass(templateElement), function(scope, element, attr) {
                    var interpolateFn = $interpolate(element.attr(attr.$attr.ngBindTemplate));
                    $compile.$$addBindingInfo(element, interpolateFn.expressions), element = element[0], 
                    attr.$observe("ngBindTemplate", function(value) {
                        element.textContent = isUndefined(value) ? "" : value;
                    });
                };
            }
        };
    } ], ngBindHtmlDirective = [ "$sce", "$parse", "$compile", function($sce, $parse, $compile) {
        return {
            restrict: "A",
            compile: function(tElement, tAttrs) {
                var ngBindHtmlGetter = $parse(tAttrs.ngBindHtml), ngBindHtmlWatch = $parse(tAttrs.ngBindHtml, function(value) {
                    return (value || "").toString();
                });
                return $compile.$$addBindingClass(tElement), function(scope, element, attr) {
                    $compile.$$addBindingInfo(element, attr.ngBindHtml), scope.$watch(ngBindHtmlWatch, function() {
                        element.html($sce.getTrustedHtml(ngBindHtmlGetter(scope)) || "");
                    });
                };
            }
        };
    } ], ngChangeDirective = valueFn({
        restrict: "A",
        require: "ngModel",
        link: function(scope, element, attr, ctrl) {
            ctrl.$viewChangeListeners.push(function() {
                scope.$eval(attr.ngChange);
            });
        }
    }), ngClassDirective = classDirective("", !0), ngClassOddDirective = classDirective("Odd", 0), ngClassEvenDirective = classDirective("Even", 1), ngCloakDirective = ngDirective({
        compile: function(element, attr) {
            attr.$set("ngCloak", undefined), element.removeClass("ng-cloak");
        }
    }), ngControllerDirective = [ function() {
        return {
            restrict: "A",
            scope: !0,
            controller: "@",
            priority: 500
        };
    } ], ngEventDirectives = {}, forceAsyncEvents = {
        blur: !0,
        focus: !0
    };
    forEach("click dblclick mousedown mouseup mouseover mouseout mousemove mouseenter mouseleave keydown keyup keypress submit focus blur copy cut paste".split(" "), function(eventName) {
        var directiveName = directiveNormalize("ng-" + eventName);
        ngEventDirectives[directiveName] = [ "$parse", "$rootScope", function($parse, $rootScope) {
            return {
                restrict: "A",
                compile: function($element, attr) {
                    var fn = $parse(attr[directiveName], null, !0);
                    return function(scope, element) {
                        element.on(eventName, function(event) {
                            var callback = function() {
                                fn(scope, {
                                    $event: event
                                });
                            };
                            forceAsyncEvents[eventName] && $rootScope.$$phase ? scope.$evalAsync(callback) : scope.$apply(callback);
                        });
                    };
                }
            };
        } ];
    });
    var ngIfDirective = [ "$animate", function($animate) {
        return {
            multiElement: !0,
            transclude: "element",
            priority: 600,
            terminal: !0,
            restrict: "A",
            $$tlb: !0,
            link: function($scope, $element, $attr, ctrl, $transclude) {
                var block, childScope, previousElements;
                $scope.$watch($attr.ngIf, function(value) {
                    value ? childScope || $transclude(function(clone, newScope) {
                        childScope = newScope, clone[clone.length++] = document.createComment(" end ngIf: " + $attr.ngIf + " "), 
                        block = {
                            clone: clone
                        }, $animate.enter(clone, $element.parent(), $element);
                    }) : (previousElements && (previousElements.remove(), previousElements = null), 
                    childScope && (childScope.$destroy(), childScope = null), block && (previousElements = getBlockNodes(block.clone), 
                    $animate.leave(previousElements).then(function() {
                        previousElements = null;
                    }), block = null));
                });
            }
        };
    } ], ngIncludeDirective = [ "$templateRequest", "$anchorScroll", "$animate", function($templateRequest, $anchorScroll, $animate) {
        return {
            restrict: "ECA",
            priority: 400,
            terminal: !0,
            transclude: "element",
            controller: angular.noop,
            compile: function(element, attr) {
                var srcExp = attr.ngInclude || attr.src, onloadExp = attr.onload || "", autoScrollExp = attr.autoscroll;
                return function(scope, $element, $attr, ctrl, $transclude) {
                    var currentScope, previousElement, currentElement, changeCounter = 0, cleanupLastIncludeContent = function() {
                        previousElement && (previousElement.remove(), previousElement = null), currentScope && (currentScope.$destroy(), 
                        currentScope = null), currentElement && ($animate.leave(currentElement).then(function() {
                            previousElement = null;
                        }), previousElement = currentElement, currentElement = null);
                    };
                    scope.$watch(srcExp, function(src) {
                        var afterAnimation = function() {
                            !isDefined(autoScrollExp) || autoScrollExp && !scope.$eval(autoScrollExp) || $anchorScroll();
                        }, thisChangeId = ++changeCounter;
                        src ? ($templateRequest(src, !0).then(function(response) {
                            if (thisChangeId === changeCounter) {
                                var newScope = scope.$new();
                                ctrl.template = response;
                                var clone = $transclude(newScope, function(clone) {
                                    cleanupLastIncludeContent(), $animate.enter(clone, null, $element).then(afterAnimation);
                                });
                                currentScope = newScope, currentElement = clone, currentScope.$emit("$includeContentLoaded", src), 
                                scope.$eval(onloadExp);
                            }
                        }, function() {
                            thisChangeId === changeCounter && (cleanupLastIncludeContent(), scope.$emit("$includeContentError", src));
                        }), scope.$emit("$includeContentRequested", src)) : (cleanupLastIncludeContent(), 
                        ctrl.template = null);
                    });
                };
            }
        };
    } ], ngIncludeFillContentDirective = [ "$compile", function($compile) {
        return {
            restrict: "ECA",
            priority: -400,
            require: "ngInclude",
            link: function(scope, $element, $attr, ctrl) {
                return /SVG/.test($element[0].toString()) ? ($element.empty(), void $compile(jqLiteBuildFragment(ctrl.template, document).childNodes)(scope, function(clone) {
                    $element.append(clone);
                }, {
                    futureParentElement: $element
                })) : ($element.html(ctrl.template), void $compile($element.contents())(scope));
            }
        };
    } ], ngInitDirective = ngDirective({
        priority: 450,
        compile: function() {
            return {
                pre: function(scope, element, attrs) {
                    scope.$eval(attrs.ngInit);
                }
            };
        }
    }), ngListDirective = function() {
        return {
            restrict: "A",
            priority: 100,
            require: "ngModel",
            link: function(scope, element, attr, ctrl) {
                var ngList = element.attr(attr.$attr.ngList) || ", ", trimValues = "false" !== attr.ngTrim, separator = trimValues ? trim(ngList) : ngList, parse = function(viewValue) {
                    if (!isUndefined(viewValue)) {
                        var list = [];
                        return viewValue && forEach(viewValue.split(separator), function(value) {
                            value && list.push(trimValues ? trim(value) : value);
                        }), list;
                    }
                };
                ctrl.$parsers.push(parse), ctrl.$formatters.push(function(value) {
                    return isArray(value) ? value.join(ngList) : undefined;
                }), ctrl.$isEmpty = function(value) {
                    return !value || !value.length;
                };
            }
        };
    }, VALID_CLASS = "ng-valid", INVALID_CLASS = "ng-invalid", PRISTINE_CLASS = "ng-pristine", DIRTY_CLASS = "ng-dirty", UNTOUCHED_CLASS = "ng-untouched", TOUCHED_CLASS = "ng-touched", PENDING_CLASS = "ng-pending", ngModelMinErr = minErr("ngModel"), NgModelController = [ "$scope", "$exceptionHandler", "$attrs", "$element", "$parse", "$animate", "$timeout", "$rootScope", "$q", "$interpolate", function($scope, $exceptionHandler, $attr, $element, $parse, $animate, $timeout, $rootScope, $q, $interpolate) {
        this.$viewValue = Number.NaN, this.$modelValue = Number.NaN, this.$$rawModelValue = undefined, 
        this.$validators = {}, this.$asyncValidators = {}, this.$parsers = [], this.$formatters = [], 
        this.$viewChangeListeners = [], this.$untouched = !0, this.$touched = !1, this.$pristine = !0, 
        this.$dirty = !1, this.$valid = !0, this.$invalid = !1, this.$error = {}, this.$$success = {}, 
        this.$pending = undefined, this.$name = $interpolate($attr.name || "", !1)($scope), 
        this.$$parentForm = nullFormCtrl;
        var parserValid, parsedNgModel = $parse($attr.ngModel), parsedNgModelAssign = parsedNgModel.assign, ngModelGet = parsedNgModel, ngModelSet = parsedNgModelAssign, pendingDebounce = null, ctrl = this;
        this.$$setOptions = function(options) {
            if (ctrl.$options = options, options && options.getterSetter) {
                var invokeModelGetter = $parse($attr.ngModel + "()"), invokeModelSetter = $parse($attr.ngModel + "($$$p)");
                ngModelGet = function($scope) {
                    var modelValue = parsedNgModel($scope);
                    return isFunction(modelValue) && (modelValue = invokeModelGetter($scope)), modelValue;
                }, ngModelSet = function($scope) {
                    isFunction(parsedNgModel($scope)) ? invokeModelSetter($scope, {
                        $$$p: ctrl.$modelValue
                    }) : parsedNgModelAssign($scope, ctrl.$modelValue);
                };
            } else if (!parsedNgModel.assign) throw ngModelMinErr("nonassign", "Expression '{0}' is non-assignable. Element: {1}", $attr.ngModel, startingTag($element));
        }, this.$render = noop, this.$isEmpty = function(value) {
            return isUndefined(value) || "" === value || null === value || value !== value;
        };
        var currentValidationRunId = 0;
        addSetValidityMethod({
            ctrl: this,
            $element: $element,
            set: function(object, property) {
                object[property] = !0;
            },
            unset: function(object, property) {
                delete object[property];
            },
            $animate: $animate
        }), this.$setPristine = function() {
            ctrl.$dirty = !1, ctrl.$pristine = !0, $animate.removeClass($element, DIRTY_CLASS), 
            $animate.addClass($element, PRISTINE_CLASS);
        }, this.$setDirty = function() {
            ctrl.$dirty = !0, ctrl.$pristine = !1, $animate.removeClass($element, PRISTINE_CLASS), 
            $animate.addClass($element, DIRTY_CLASS), ctrl.$$parentForm.$setDirty();
        }, this.$setUntouched = function() {
            ctrl.$touched = !1, ctrl.$untouched = !0, $animate.setClass($element, UNTOUCHED_CLASS, TOUCHED_CLASS);
        }, this.$setTouched = function() {
            ctrl.$touched = !0, ctrl.$untouched = !1, $animate.setClass($element, TOUCHED_CLASS, UNTOUCHED_CLASS);
        }, this.$rollbackViewValue = function() {
            $timeout.cancel(pendingDebounce), ctrl.$viewValue = ctrl.$$lastCommittedViewValue, 
            ctrl.$render();
        }, this.$validate = function() {
            if (!isNumber(ctrl.$modelValue) || !isNaN(ctrl.$modelValue)) {
                var viewValue = ctrl.$$lastCommittedViewValue, modelValue = ctrl.$$rawModelValue, prevValid = ctrl.$valid, prevModelValue = ctrl.$modelValue, allowInvalid = ctrl.$options && ctrl.$options.allowInvalid;
                ctrl.$$runValidators(modelValue, viewValue, function(allValid) {
                    allowInvalid || prevValid === allValid || (ctrl.$modelValue = allValid ? modelValue : undefined, 
                    ctrl.$modelValue !== prevModelValue && ctrl.$$writeModelToScope());
                });
            }
        }, this.$$runValidators = function(modelValue, viewValue, doneCallback) {
            function processParseErrors() {
                var errorKey = ctrl.$$parserName || "parse";
                return isUndefined(parserValid) ? (setValidity(errorKey, null), !0) : (parserValid || (forEach(ctrl.$validators, function(v, name) {
                    setValidity(name, null);
                }), forEach(ctrl.$asyncValidators, function(v, name) {
                    setValidity(name, null);
                })), setValidity(errorKey, parserValid), parserValid);
            }
            function processSyncValidators() {
                var syncValidatorsValid = !0;
                return forEach(ctrl.$validators, function(validator, name) {
                    var result = validator(modelValue, viewValue);
                    syncValidatorsValid = syncValidatorsValid && result, setValidity(name, result);
                }), syncValidatorsValid ? !0 : (forEach(ctrl.$asyncValidators, function(v, name) {
                    setValidity(name, null);
                }), !1);
            }
            function processAsyncValidators() {
                var validatorPromises = [], allValid = !0;
                forEach(ctrl.$asyncValidators, function(validator, name) {
                    var promise = validator(modelValue, viewValue);
                    if (!isPromiseLike(promise)) throw ngModelMinErr("$asyncValidators", "Expected asynchronous validator to return a promise but got '{0}' instead.", promise);
                    setValidity(name, undefined), validatorPromises.push(promise.then(function() {
                        setValidity(name, !0);
                    }, function() {
                        allValid = !1, setValidity(name, !1);
                    }));
                }), validatorPromises.length ? $q.all(validatorPromises).then(function() {
                    validationDone(allValid);
                }, noop) : validationDone(!0);
            }
            function setValidity(name, isValid) {
                localValidationRunId === currentValidationRunId && ctrl.$setValidity(name, isValid);
            }
            function validationDone(allValid) {
                localValidationRunId === currentValidationRunId && doneCallback(allValid);
            }
            currentValidationRunId++;
            var localValidationRunId = currentValidationRunId;
            return processParseErrors() && processSyncValidators() ? void processAsyncValidators() : void validationDone(!1);
        }, this.$commitViewValue = function() {
            var viewValue = ctrl.$viewValue;
            $timeout.cancel(pendingDebounce), (ctrl.$$lastCommittedViewValue !== viewValue || "" === viewValue && ctrl.$$hasNativeValidators) && (ctrl.$$lastCommittedViewValue = viewValue, 
            ctrl.$pristine && this.$setDirty(), this.$$parseAndValidate());
        }, this.$$parseAndValidate = function() {
            function writeToModelIfNeeded() {
                ctrl.$modelValue !== prevModelValue && ctrl.$$writeModelToScope();
            }
            var viewValue = ctrl.$$lastCommittedViewValue, modelValue = viewValue;
            if (parserValid = isUndefined(modelValue) ? undefined : !0) for (var i = 0; i < ctrl.$parsers.length; i++) if (modelValue = ctrl.$parsers[i](modelValue), 
            isUndefined(modelValue)) {
                parserValid = !1;
                break;
            }
            isNumber(ctrl.$modelValue) && isNaN(ctrl.$modelValue) && (ctrl.$modelValue = ngModelGet($scope));
            var prevModelValue = ctrl.$modelValue, allowInvalid = ctrl.$options && ctrl.$options.allowInvalid;
            ctrl.$$rawModelValue = modelValue, allowInvalid && (ctrl.$modelValue = modelValue, 
            writeToModelIfNeeded()), ctrl.$$runValidators(modelValue, ctrl.$$lastCommittedViewValue, function(allValid) {
                allowInvalid || (ctrl.$modelValue = allValid ? modelValue : undefined, writeToModelIfNeeded());
            });
        }, this.$$writeModelToScope = function() {
            ngModelSet($scope, ctrl.$modelValue), forEach(ctrl.$viewChangeListeners, function(listener) {
                try {
                    listener();
                } catch (e) {
                    $exceptionHandler(e);
                }
            });
        }, this.$setViewValue = function(value, trigger) {
            ctrl.$viewValue = value, (!ctrl.$options || ctrl.$options.updateOnDefault) && ctrl.$$debounceViewValueCommit(trigger);
        }, this.$$debounceViewValueCommit = function(trigger) {
            var debounce, debounceDelay = 0, options = ctrl.$options;
            options && isDefined(options.debounce) && (debounce = options.debounce, isNumber(debounce) ? debounceDelay = debounce : isNumber(debounce[trigger]) ? debounceDelay = debounce[trigger] : isNumber(debounce["default"]) && (debounceDelay = debounce["default"])), 
            $timeout.cancel(pendingDebounce), debounceDelay ? pendingDebounce = $timeout(function() {
                ctrl.$commitViewValue();
            }, debounceDelay) : $rootScope.$$phase ? ctrl.$commitViewValue() : $scope.$apply(function() {
                ctrl.$commitViewValue();
            });
        }, $scope.$watch(function() {
            var modelValue = ngModelGet($scope);
            if (modelValue !== ctrl.$modelValue && (ctrl.$modelValue === ctrl.$modelValue || modelValue === modelValue)) {
                ctrl.$modelValue = ctrl.$$rawModelValue = modelValue, parserValid = undefined;
                for (var formatters = ctrl.$formatters, idx = formatters.length, viewValue = modelValue; idx--; ) viewValue = formatters[idx](viewValue);
                ctrl.$viewValue !== viewValue && (ctrl.$viewValue = ctrl.$$lastCommittedViewValue = viewValue, 
                ctrl.$render(), ctrl.$$runValidators(modelValue, viewValue, noop));
            }
            return modelValue;
        });
    } ], ngModelDirective = [ "$rootScope", function($rootScope) {
        return {
            restrict: "A",
            require: [ "ngModel", "^?form", "^?ngModelOptions" ],
            controller: NgModelController,
            priority: 1,
            compile: function(element) {
                return element.addClass(PRISTINE_CLASS).addClass(UNTOUCHED_CLASS).addClass(VALID_CLASS), 
                {
                    pre: function(scope, element, attr, ctrls) {
                        var modelCtrl = ctrls[0], formCtrl = ctrls[1] || modelCtrl.$$parentForm;
                        modelCtrl.$$setOptions(ctrls[2] && ctrls[2].$options), formCtrl.$addControl(modelCtrl), 
                        attr.$observe("name", function(newValue) {
                            modelCtrl.$name !== newValue && modelCtrl.$$parentForm.$$renameControl(modelCtrl, newValue);
                        }), scope.$on("$destroy", function() {
                            modelCtrl.$$parentForm.$removeControl(modelCtrl);
                        });
                    },
                    post: function(scope, element, attr, ctrls) {
                        var modelCtrl = ctrls[0];
                        modelCtrl.$options && modelCtrl.$options.updateOn && element.on(modelCtrl.$options.updateOn, function(ev) {
                            modelCtrl.$$debounceViewValueCommit(ev && ev.type);
                        }), element.on("blur", function() {
                            modelCtrl.$touched || ($rootScope.$$phase ? scope.$evalAsync(modelCtrl.$setTouched) : scope.$apply(modelCtrl.$setTouched));
                        });
                    }
                };
            }
        };
    } ], DEFAULT_REGEXP = /(\s+|^)default(\s+|$)/, ngModelOptionsDirective = function() {
        return {
            restrict: "A",
            controller: [ "$scope", "$attrs", function($scope, $attrs) {
                var that = this;
                this.$options = copy($scope.$eval($attrs.ngModelOptions)), isDefined(this.$options.updateOn) ? (this.$options.updateOnDefault = !1, 
                this.$options.updateOn = trim(this.$options.updateOn.replace(DEFAULT_REGEXP, function() {
                    return that.$options.updateOnDefault = !0, " ";
                }))) : this.$options.updateOnDefault = !0;
            } ]
        };
    }, ngNonBindableDirective = ngDirective({
        terminal: !0,
        priority: 1e3
    }), ngOptionsMinErr = minErr("ngOptions"), NG_OPTIONS_REGEXP = /^\s*([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+group\s+by\s+([\s\S]+?))?(?:\s+disable\s+when\s+([\s\S]+?))?\s+for\s+(?:([\$\w][\$\w]*)|(?:\(\s*([\$\w][\$\w]*)\s*,\s*([\$\w][\$\w]*)\s*\)))\s+in\s+([\s\S]+?)(?:\s+track\s+by\s+([\s\S]+?))?$/, ngOptionsDirective = [ "$compile", "$parse", function($compile, $parse) {
        function parseOptionsExpression(optionsExp, selectElement, scope) {
            function Option(selectValue, viewValue, label, group, disabled) {
                this.selectValue = selectValue, this.viewValue = viewValue, this.label = label, 
                this.group = group, this.disabled = disabled;
            }
            function getOptionValuesKeys(optionValues) {
                var optionValuesKeys;
                if (!keyName && isArrayLike(optionValues)) optionValuesKeys = optionValues; else {
                    optionValuesKeys = [];
                    for (var itemKey in optionValues) optionValues.hasOwnProperty(itemKey) && "$" !== itemKey.charAt(0) && optionValuesKeys.push(itemKey);
                }
                return optionValuesKeys;
            }
            var match = optionsExp.match(NG_OPTIONS_REGEXP);
            if (!match) throw ngOptionsMinErr("iexp", "Expected expression in form of '_select_ (as _label_)? for (_key_,)?_value_ in _collection_' but got '{0}'. Element: {1}", optionsExp, startingTag(selectElement));
            var valueName = match[5] || match[7], keyName = match[6], selectAs = / as /.test(match[0]) && match[1], trackBy = match[9], valueFn = $parse(match[2] ? match[1] : valueName), selectAsFn = selectAs && $parse(selectAs), viewValueFn = selectAsFn || valueFn, trackByFn = trackBy && $parse(trackBy), getTrackByValueFn = trackBy ? function(value, locals) {
                return trackByFn(scope, locals);
            } : function(value) {
                return hashKey(value);
            }, getTrackByValue = function(value, key) {
                return getTrackByValueFn(value, getLocals(value, key));
            }, displayFn = $parse(match[2] || match[1]), groupByFn = $parse(match[3] || ""), disableWhenFn = $parse(match[4] || ""), valuesFn = $parse(match[8]), locals = {}, getLocals = keyName ? function(value, key) {
                return locals[keyName] = key, locals[valueName] = value, locals;
            } : function(value) {
                return locals[valueName] = value, locals;
            };
            return {
                trackBy: trackBy,
                getTrackByValue: getTrackByValue,
                getWatchables: $parse(valuesFn, function(optionValues) {
                    var watchedArray = [];
                    optionValues = optionValues || [];
                    for (var optionValuesKeys = getOptionValuesKeys(optionValues), optionValuesLength = optionValuesKeys.length, index = 0; optionValuesLength > index; index++) {
                        var key = optionValues === optionValuesKeys ? index : optionValuesKeys[index], locals = (optionValues[key], 
                        getLocals(optionValues[key], key)), selectValue = getTrackByValueFn(optionValues[key], locals);
                        if (watchedArray.push(selectValue), match[2] || match[1]) {
                            var label = displayFn(scope, locals);
                            watchedArray.push(label);
                        }
                        if (match[4]) {
                            var disableWhen = disableWhenFn(scope, locals);
                            watchedArray.push(disableWhen);
                        }
                    }
                    return watchedArray;
                }),
                getOptions: function() {
                    for (var optionItems = [], selectValueMap = {}, optionValues = valuesFn(scope) || [], optionValuesKeys = getOptionValuesKeys(optionValues), optionValuesLength = optionValuesKeys.length, index = 0; optionValuesLength > index; index++) {
                        var key = optionValues === optionValuesKeys ? index : optionValuesKeys[index], value = optionValues[key], locals = getLocals(value, key), viewValue = viewValueFn(scope, locals), selectValue = getTrackByValueFn(viewValue, locals), label = displayFn(scope, locals), group = groupByFn(scope, locals), disabled = disableWhenFn(scope, locals), optionItem = new Option(selectValue, viewValue, label, group, disabled);
                        optionItems.push(optionItem), selectValueMap[selectValue] = optionItem;
                    }
                    return {
                        items: optionItems,
                        selectValueMap: selectValueMap,
                        getOptionFromViewValue: function(value) {
                            return selectValueMap[getTrackByValue(value)];
                        },
                        getViewValueFromOption: function(option) {
                            return trackBy ? angular.copy(option.viewValue) : option.viewValue;
                        }
                    };
                }
            };
        }
        var optionTemplate = document.createElement("option"), optGroupTemplate = document.createElement("optgroup");
        return {
            restrict: "A",
            terminal: !0,
            require: [ "select", "?ngModel" ],
            link: function(scope, selectElement, attr, ctrls) {
                function updateOptionElement(option, element) {
                    option.element = element, element.disabled = option.disabled, option.label !== element.label && (element.label = option.label, 
                    element.textContent = option.label), option.value !== element.value && (element.value = option.selectValue);
                }
                function addOrReuseElement(parent, current, type, templateElement) {
                    var element;
                    return current && lowercase(current.nodeName) === type ? element = current : (element = templateElement.cloneNode(!1), 
                    current ? parent.insertBefore(element, current) : parent.appendChild(element)), 
                    element;
                }
                function removeExcessElements(current) {
                    for (var next; current; ) next = current.nextSibling, jqLiteRemove(current), current = next;
                }
                function skipEmptyAndUnknownOptions(current) {
                    var emptyOption_ = emptyOption && emptyOption[0], unknownOption_ = unknownOption && unknownOption[0];
                    if (emptyOption_ || unknownOption_) for (;current && (current === emptyOption_ || current === unknownOption_ || emptyOption_ && emptyOption_.nodeType === NODE_TYPE_COMMENT); ) current = current.nextSibling;
                    return current;
                }
                function updateOptions() {
                    var previousValue = options && selectCtrl.readValue();
                    options = ngOptions.getOptions();
                    var groupMap = {}, currentElement = selectElement[0].firstChild;
                    if (providedEmptyOption && selectElement.prepend(emptyOption), currentElement = skipEmptyAndUnknownOptions(currentElement), 
                    options.items.forEach(function(option) {
                        var group, groupElement, optionElement;
                        option.group ? (group = groupMap[option.group], group || (groupElement = addOrReuseElement(selectElement[0], currentElement, "optgroup", optGroupTemplate), 
                        currentElement = groupElement.nextSibling, groupElement.label = option.group, group = groupMap[option.group] = {
                            groupElement: groupElement,
                            currentOptionElement: groupElement.firstChild
                        }), optionElement = addOrReuseElement(group.groupElement, group.currentOptionElement, "option", optionTemplate), 
                        updateOptionElement(option, optionElement), group.currentOptionElement = optionElement.nextSibling) : (optionElement = addOrReuseElement(selectElement[0], currentElement, "option", optionTemplate), 
                        updateOptionElement(option, optionElement), currentElement = optionElement.nextSibling);
                    }), Object.keys(groupMap).forEach(function(key) {
                        removeExcessElements(groupMap[key].currentOptionElement);
                    }), removeExcessElements(currentElement), ngModelCtrl.$render(), !ngModelCtrl.$isEmpty(previousValue)) {
                        var nextValue = selectCtrl.readValue();
                        (ngOptions.trackBy ? equals(previousValue, nextValue) : previousValue === nextValue) || (ngModelCtrl.$setViewValue(nextValue), 
                        ngModelCtrl.$render());
                    }
                }
                var ngModelCtrl = ctrls[1];
                if (ngModelCtrl) {
                    for (var emptyOption, selectCtrl = ctrls[0], multiple = attr.multiple, i = 0, children = selectElement.children(), ii = children.length; ii > i; i++) if ("" === children[i].value) {
                        emptyOption = children.eq(i);
                        break;
                    }
                    var providedEmptyOption = !!emptyOption, unknownOption = jqLite(optionTemplate.cloneNode(!1));
                    unknownOption.val("?");
                    var options, ngOptions = parseOptionsExpression(attr.ngOptions, selectElement, scope), renderEmptyOption = function() {
                        providedEmptyOption || selectElement.prepend(emptyOption), selectElement.val(""), 
                        emptyOption.prop("selected", !0), emptyOption.attr("selected", !0);
                    }, removeEmptyOption = function() {
                        providedEmptyOption || emptyOption.remove();
                    }, renderUnknownOption = function() {
                        selectElement.prepend(unknownOption), selectElement.val("?"), unknownOption.prop("selected", !0), 
                        unknownOption.attr("selected", !0);
                    }, removeUnknownOption = function() {
                        unknownOption.remove();
                    };
                    multiple ? (ngModelCtrl.$isEmpty = function(value) {
                        return !value || 0 === value.length;
                    }, selectCtrl.writeValue = function(value) {
                        options.items.forEach(function(option) {
                            option.element.selected = !1;
                        }), value && value.forEach(function(item) {
                            var option = options.getOptionFromViewValue(item);
                            option && !option.disabled && (option.element.selected = !0);
                        });
                    }, selectCtrl.readValue = function() {
                        var selectedValues = selectElement.val() || [], selections = [];
                        return forEach(selectedValues, function(value) {
                            var option = options.selectValueMap[value];
                            option && !option.disabled && selections.push(options.getViewValueFromOption(option));
                        }), selections;
                    }, ngOptions.trackBy && scope.$watchCollection(function() {
                        return isArray(ngModelCtrl.$viewValue) ? ngModelCtrl.$viewValue.map(function(value) {
                            return ngOptions.getTrackByValue(value);
                        }) : void 0;
                    }, function() {
                        ngModelCtrl.$render();
                    })) : (selectCtrl.writeValue = function(value) {
                        var option = options.getOptionFromViewValue(value);
                        option && !option.disabled ? selectElement[0].value !== option.selectValue && (removeUnknownOption(), 
                        removeEmptyOption(), selectElement[0].value = option.selectValue, option.element.selected = !0, 
                        option.element.setAttribute("selected", "selected")) : null === value || providedEmptyOption ? (removeUnknownOption(), 
                        renderEmptyOption()) : (removeEmptyOption(), renderUnknownOption());
                    }, selectCtrl.readValue = function() {
                        var selectedOption = options.selectValueMap[selectElement.val()];
                        return selectedOption && !selectedOption.disabled ? (removeEmptyOption(), removeUnknownOption(), 
                        options.getViewValueFromOption(selectedOption)) : null;
                    }, ngOptions.trackBy && scope.$watch(function() {
                        return ngOptions.getTrackByValue(ngModelCtrl.$viewValue);
                    }, function() {
                        ngModelCtrl.$render();
                    })), providedEmptyOption ? (emptyOption.remove(), $compile(emptyOption)(scope), 
                    emptyOption.removeClass("ng-scope")) : emptyOption = jqLite(optionTemplate.cloneNode(!1)), 
                    updateOptions(), scope.$watchCollection(ngOptions.getWatchables, updateOptions);
                }
            }
        };
    } ], ngPluralizeDirective = [ "$locale", "$interpolate", "$log", function($locale, $interpolate, $log) {
        var BRACE = /{}/g, IS_WHEN = /^when(Minus)?(.+)$/;
        return {
            link: function(scope, element, attr) {
                function updateElementText(newText) {
                    element.text(newText || "");
                }
                var lastCount, numberExp = attr.count, whenExp = attr.$attr.when && element.attr(attr.$attr.when), offset = attr.offset || 0, whens = scope.$eval(whenExp) || {}, whensExpFns = {}, startSymbol = $interpolate.startSymbol(), endSymbol = $interpolate.endSymbol(), braceReplacement = startSymbol + numberExp + "-" + offset + endSymbol, watchRemover = angular.noop;
                forEach(attr, function(expression, attributeName) {
                    var tmpMatch = IS_WHEN.exec(attributeName);
                    if (tmpMatch) {
                        var whenKey = (tmpMatch[1] ? "-" : "") + lowercase(tmpMatch[2]);
                        whens[whenKey] = element.attr(attr.$attr[attributeName]);
                    }
                }), forEach(whens, function(expression, key) {
                    whensExpFns[key] = $interpolate(expression.replace(BRACE, braceReplacement));
                }), scope.$watch(numberExp, function(newVal) {
                    var count = parseFloat(newVal), countIsNaN = isNaN(count);
                    if (countIsNaN || count in whens || (count = $locale.pluralCat(count - offset)), 
                    count !== lastCount && !(countIsNaN && isNumber(lastCount) && isNaN(lastCount))) {
                        watchRemover();
                        var whenExpFn = whensExpFns[count];
                        isUndefined(whenExpFn) ? (null != newVal && $log.debug("ngPluralize: no rule defined for '" + count + "' in " + whenExp), 
                        watchRemover = noop, updateElementText()) : watchRemover = scope.$watch(whenExpFn, updateElementText), 
                        lastCount = count;
                    }
                });
            }
        };
    } ], ngRepeatDirective = [ "$parse", "$animate", function($parse, $animate) {
        var NG_REMOVED = "$$NG_REMOVED", ngRepeatMinErr = minErr("ngRepeat"), updateScope = function(scope, index, valueIdentifier, value, keyIdentifier, key, arrayLength) {
            scope[valueIdentifier] = value, keyIdentifier && (scope[keyIdentifier] = key), scope.$index = index, 
            scope.$first = 0 === index, scope.$last = index === arrayLength - 1, scope.$middle = !(scope.$first || scope.$last), 
            scope.$odd = !(scope.$even = 0 === (1 & index));
        }, getBlockStart = function(block) {
            return block.clone[0];
        }, getBlockEnd = function(block) {
            return block.clone[block.clone.length - 1];
        };
        return {
            restrict: "A",
            multiElement: !0,
            transclude: "element",
            priority: 1e3,
            terminal: !0,
            $$tlb: !0,
            compile: function($element, $attr) {
                var expression = $attr.ngRepeat, ngRepeatEndComment = document.createComment(" end ngRepeat: " + expression + " "), match = expression.match(/^\s*([\s\S]+?)\s+in\s+([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+track\s+by\s+([\s\S]+?))?\s*$/);
                if (!match) throw ngRepeatMinErr("iexp", "Expected expression in form of '_item_ in _collection_[ track by _id_]' but got '{0}'.", expression);
                var lhs = match[1], rhs = match[2], aliasAs = match[3], trackByExp = match[4];
                if (match = lhs.match(/^(?:(\s*[\$\w]+)|\(\s*([\$\w]+)\s*,\s*([\$\w]+)\s*\))$/), 
                !match) throw ngRepeatMinErr("iidexp", "'_item_' in '_item_ in _collection_' should be an identifier or '(_key_, _value_)' expression, but got '{0}'.", lhs);
                var valueIdentifier = match[3] || match[1], keyIdentifier = match[2];
                if (aliasAs && (!/^[$a-zA-Z_][$a-zA-Z0-9_]*$/.test(aliasAs) || /^(null|undefined|this|\$index|\$first|\$middle|\$last|\$even|\$odd|\$parent|\$root|\$id)$/.test(aliasAs))) throw ngRepeatMinErr("badident", "alias '{0}' is invalid --- must be a valid JS identifier which is not a reserved name.", aliasAs);
                var trackByExpGetter, trackByIdExpFn, trackByIdArrayFn, trackByIdObjFn, hashFnLocals = {
                    $id: hashKey
                };
                return trackByExp ? trackByExpGetter = $parse(trackByExp) : (trackByIdArrayFn = function(key, value) {
                    return hashKey(value);
                }, trackByIdObjFn = function(key) {
                    return key;
                }), function($scope, $element, $attr, ctrl, $transclude) {
                    trackByExpGetter && (trackByIdExpFn = function(key, value, index) {
                        return keyIdentifier && (hashFnLocals[keyIdentifier] = key), hashFnLocals[valueIdentifier] = value, 
                        hashFnLocals.$index = index, trackByExpGetter($scope, hashFnLocals);
                    });
                    var lastBlockMap = createMap();
                    $scope.$watchCollection(rhs, function(collection) {
                        var index, length, nextNode, collectionLength, key, value, trackById, trackByIdFn, collectionKeys, block, nextBlockOrder, elementsToRemove, previousNode = $element[0], nextBlockMap = createMap();
                        if (aliasAs && ($scope[aliasAs] = collection), isArrayLike(collection)) collectionKeys = collection, 
                        trackByIdFn = trackByIdExpFn || trackByIdArrayFn; else {
                            trackByIdFn = trackByIdExpFn || trackByIdObjFn, collectionKeys = [];
                            for (var itemKey in collection) hasOwnProperty.call(collection, itemKey) && "$" !== itemKey.charAt(0) && collectionKeys.push(itemKey);
                        }
                        for (collectionLength = collectionKeys.length, nextBlockOrder = new Array(collectionLength), 
                        index = 0; collectionLength > index; index++) if (key = collection === collectionKeys ? index : collectionKeys[index], 
                        value = collection[key], trackById = trackByIdFn(key, value, index), lastBlockMap[trackById]) block = lastBlockMap[trackById], 
                        delete lastBlockMap[trackById], nextBlockMap[trackById] = block, nextBlockOrder[index] = block; else {
                            if (nextBlockMap[trackById]) throw forEach(nextBlockOrder, function(block) {
                                block && block.scope && (lastBlockMap[block.id] = block);
                            }), ngRepeatMinErr("dupes", "Duplicates in a repeater are not allowed. Use 'track by' expression to specify unique keys. Repeater: {0}, Duplicate key: {1}, Duplicate value: {2}", expression, trackById, value);
                            nextBlockOrder[index] = {
                                id: trackById,
                                scope: undefined,
                                clone: undefined
                            }, nextBlockMap[trackById] = !0;
                        }
                        for (var blockKey in lastBlockMap) {
                            if (block = lastBlockMap[blockKey], elementsToRemove = getBlockNodes(block.clone), 
                            $animate.leave(elementsToRemove), elementsToRemove[0].parentNode) for (index = 0, 
                            length = elementsToRemove.length; length > index; index++) elementsToRemove[index][NG_REMOVED] = !0;
                            block.scope.$destroy();
                        }
                        for (index = 0; collectionLength > index; index++) if (key = collection === collectionKeys ? index : collectionKeys[index], 
                        value = collection[key], block = nextBlockOrder[index], block.scope) {
                            nextNode = previousNode;
                            do nextNode = nextNode.nextSibling; while (nextNode && nextNode[NG_REMOVED]);
                            getBlockStart(block) != nextNode && $animate.move(getBlockNodes(block.clone), null, jqLite(previousNode)), 
                            previousNode = getBlockEnd(block), updateScope(block.scope, index, valueIdentifier, value, keyIdentifier, key, collectionLength);
                        } else $transclude(function(clone, scope) {
                            block.scope = scope;
                            var endNode = ngRepeatEndComment.cloneNode(!1);
                            clone[clone.length++] = endNode, $animate.enter(clone, null, jqLite(previousNode)), 
                            previousNode = endNode, block.clone = clone, nextBlockMap[block.id] = block, updateScope(block.scope, index, valueIdentifier, value, keyIdentifier, key, collectionLength);
                        });
                        lastBlockMap = nextBlockMap;
                    });
                };
            }
        };
    } ], NG_HIDE_CLASS = "ng-hide", NG_HIDE_IN_PROGRESS_CLASS = "ng-hide-animate", ngShowDirective = [ "$animate", function($animate) {
        return {
            restrict: "A",
            multiElement: !0,
            link: function(scope, element, attr) {
                scope.$watch(attr.ngShow, function(value) {
                    $animate[value ? "removeClass" : "addClass"](element, NG_HIDE_CLASS, {
                        tempClasses: NG_HIDE_IN_PROGRESS_CLASS
                    });
                });
            }
        };
    } ], ngHideDirective = [ "$animate", function($animate) {
        return {
            restrict: "A",
            multiElement: !0,
            link: function(scope, element, attr) {
                scope.$watch(attr.ngHide, function(value) {
                    $animate[value ? "addClass" : "removeClass"](element, NG_HIDE_CLASS, {
                        tempClasses: NG_HIDE_IN_PROGRESS_CLASS
                    });
                });
            }
        };
    } ], ngStyleDirective = ngDirective(function(scope, element, attr) {
        scope.$watch(attr.ngStyle, function(newStyles, oldStyles) {
            oldStyles && newStyles !== oldStyles && forEach(oldStyles, function(val, style) {
                element.css(style, "");
            }), newStyles && element.css(newStyles);
        }, !0);
    }), ngSwitchDirective = [ "$animate", function($animate) {
        return {
            require: "ngSwitch",
            controller: [ "$scope", function() {
                this.cases = {};
            } ],
            link: function(scope, element, attr, ngSwitchController) {
                var watchExpr = attr.ngSwitch || attr.on, selectedTranscludes = [], selectedElements = [], previousLeaveAnimations = [], selectedScopes = [], spliceFactory = function(array, index) {
                    return function() {
                        array.splice(index, 1);
                    };
                };
                scope.$watch(watchExpr, function(value) {
                    var i, ii;
                    for (i = 0, ii = previousLeaveAnimations.length; ii > i; ++i) $animate.cancel(previousLeaveAnimations[i]);
                    for (previousLeaveAnimations.length = 0, i = 0, ii = selectedScopes.length; ii > i; ++i) {
                        var selected = getBlockNodes(selectedElements[i].clone);
                        selectedScopes[i].$destroy();
                        var promise = previousLeaveAnimations[i] = $animate.leave(selected);
                        promise.then(spliceFactory(previousLeaveAnimations, i));
                    }
                    selectedElements.length = 0, selectedScopes.length = 0, (selectedTranscludes = ngSwitchController.cases["!" + value] || ngSwitchController.cases["?"]) && forEach(selectedTranscludes, function(selectedTransclude) {
                        selectedTransclude.transclude(function(caseElement, selectedScope) {
                            selectedScopes.push(selectedScope);
                            var anchor = selectedTransclude.element;
                            caseElement[caseElement.length++] = document.createComment(" end ngSwitchWhen: ");
                            var block = {
                                clone: caseElement
                            };
                            selectedElements.push(block), $animate.enter(caseElement, anchor.parent(), anchor);
                        });
                    });
                });
            }
        };
    } ], ngSwitchWhenDirective = ngDirective({
        transclude: "element",
        priority: 1200,
        require: "^ngSwitch",
        multiElement: !0,
        link: function(scope, element, attrs, ctrl, $transclude) {
            ctrl.cases["!" + attrs.ngSwitchWhen] = ctrl.cases["!" + attrs.ngSwitchWhen] || [], 
            ctrl.cases["!" + attrs.ngSwitchWhen].push({
                transclude: $transclude,
                element: element
            });
        }
    }), ngSwitchDefaultDirective = ngDirective({
        transclude: "element",
        priority: 1200,
        require: "^ngSwitch",
        multiElement: !0,
        link: function(scope, element, attr, ctrl, $transclude) {
            ctrl.cases["?"] = ctrl.cases["?"] || [], ctrl.cases["?"].push({
                transclude: $transclude,
                element: element
            });
        }
    }), ngTranscludeDirective = ngDirective({
        restrict: "EAC",
        link: function($scope, $element, $attrs, controller, $transclude) {
            if (!$transclude) throw minErr("ngTransclude")("orphan", "Illegal use of ngTransclude directive in the template! No parent directive that requires a transclusion found. Element: {0}", startingTag($element));
            $transclude(function(clone) {
                $element.empty(), $element.append(clone);
            });
        }
    }), scriptDirective = [ "$templateCache", function($templateCache) {
        return {
            restrict: "E",
            terminal: !0,
            compile: function(element, attr) {
                if ("text/ng-template" == attr.type) {
                    var templateUrl = attr.id, text = element[0].text;
                    $templateCache.put(templateUrl, text);
                }
            }
        };
    } ], noopNgModelController = {
        $setViewValue: noop,
        $render: noop
    }, SelectController = [ "$element", "$scope", "$attrs", function($element, $scope) {
        var self = this, optionsMap = new HashMap();
        self.ngModelCtrl = noopNgModelController, self.unknownOption = jqLite(document.createElement("option")), 
        self.renderUnknownOption = function(val) {
            var unknownVal = "? " + hashKey(val) + " ?";
            self.unknownOption.val(unknownVal), $element.prepend(self.unknownOption), $element.val(unknownVal);
        }, $scope.$on("$destroy", function() {
            self.renderUnknownOption = noop;
        }), self.removeUnknownOption = function() {
            self.unknownOption.parent() && self.unknownOption.remove();
        }, self.readValue = function() {
            return self.removeUnknownOption(), $element.val();
        }, self.writeValue = function(value) {
            self.hasOption(value) ? (self.removeUnknownOption(), $element.val(value), "" === value && self.emptyOption.prop("selected", !0)) : null == value && self.emptyOption ? (self.removeUnknownOption(), 
            $element.val("")) : self.renderUnknownOption(value);
        }, self.addOption = function(value, element) {
            assertNotHasOwnProperty(value, '"option value"'), "" === value && (self.emptyOption = element);
            var count = optionsMap.get(value) || 0;
            optionsMap.put(value, count + 1);
        }, self.removeOption = function(value) {
            var count = optionsMap.get(value);
            count && (1 === count ? (optionsMap.remove(value), "" === value && (self.emptyOption = undefined)) : optionsMap.put(value, count - 1));
        }, self.hasOption = function(value) {
            return !!optionsMap.get(value);
        };
    } ], selectDirective = function() {
        return {
            restrict: "E",
            require: [ "select", "?ngModel" ],
            controller: SelectController,
            link: function(scope, element, attr, ctrls) {
                var ngModelCtrl = ctrls[1];
                if (ngModelCtrl) {
                    var selectCtrl = ctrls[0];
                    if (selectCtrl.ngModelCtrl = ngModelCtrl, ngModelCtrl.$render = function() {
                        selectCtrl.writeValue(ngModelCtrl.$viewValue);
                    }, element.on("change", function() {
                        scope.$apply(function() {
                            ngModelCtrl.$setViewValue(selectCtrl.readValue());
                        });
                    }), attr.multiple) {
                        selectCtrl.readValue = function() {
                            var array = [];
                            return forEach(element.find("option"), function(option) {
                                option.selected && array.push(option.value);
                            }), array;
                        }, selectCtrl.writeValue = function(value) {
                            var items = new HashMap(value);
                            forEach(element.find("option"), function(option) {
                                option.selected = isDefined(items.get(option.value));
                            });
                        };
                        var lastView, lastViewRef = 0/0;
                        scope.$watch(function() {
                            lastViewRef !== ngModelCtrl.$viewValue || equals(lastView, ngModelCtrl.$viewValue) || (lastView = shallowCopy(ngModelCtrl.$viewValue), 
                            ngModelCtrl.$render()), lastViewRef = ngModelCtrl.$viewValue;
                        }), ngModelCtrl.$isEmpty = function(value) {
                            return !value || 0 === value.length;
                        };
                    }
                }
            }
        };
    }, optionDirective = [ "$interpolate", function($interpolate) {
        function chromeHack(optionElement) {
            optionElement[0].hasAttribute("selected") && (optionElement[0].selected = !0);
        }
        return {
            restrict: "E",
            priority: 100,
            compile: function(element, attr) {
                if (isDefined(attr.value)) var valueInterpolated = $interpolate(attr.value, !0); else {
                    var interpolateFn = $interpolate(element.text(), !0);
                    interpolateFn || attr.$set("value", element.text());
                }
                return function(scope, element, attr) {
                    function addOption(optionValue) {
                        selectCtrl.addOption(optionValue, element), selectCtrl.ngModelCtrl.$render(), chromeHack(element);
                    }
                    var selectCtrlName = "$selectController", parent = element.parent(), selectCtrl = parent.data(selectCtrlName) || parent.parent().data(selectCtrlName);
                    if (selectCtrl && selectCtrl.ngModelCtrl) {
                        if (valueInterpolated) {
                            var oldVal;
                            attr.$observe("value", function(newVal) {
                                isDefined(oldVal) && selectCtrl.removeOption(oldVal), oldVal = newVal, addOption(newVal);
                            });
                        } else interpolateFn ? scope.$watch(interpolateFn, function(newVal, oldVal) {
                            attr.$set("value", newVal), oldVal !== newVal && selectCtrl.removeOption(oldVal), 
                            addOption(newVal);
                        }) : addOption(attr.value);
                        element.on("$destroy", function() {
                            selectCtrl.removeOption(attr.value), selectCtrl.ngModelCtrl.$render();
                        });
                    }
                };
            }
        };
    } ], styleDirective = valueFn({
        restrict: "E",
        terminal: !1
    }), requiredDirective = function() {
        return {
            restrict: "A",
            require: "?ngModel",
            link: function(scope, elm, attr, ctrl) {
                ctrl && (attr.required = !0, ctrl.$validators.required = function(modelValue, viewValue) {
                    return !attr.required || !ctrl.$isEmpty(viewValue);
                }, attr.$observe("required", function() {
                    ctrl.$validate();
                }));
            }
        };
    }, patternDirective = function() {
        return {
            restrict: "A",
            require: "?ngModel",
            link: function(scope, elm, attr, ctrl) {
                if (ctrl) {
                    var regexp, patternExp = attr.ngPattern || attr.pattern;
                    attr.$observe("pattern", function(regex) {
                        if (isString(regex) && regex.length > 0 && (regex = new RegExp("^" + regex + "$")), 
                        regex && !regex.test) throw minErr("ngPattern")("noregexp", "Expected {0} to be a RegExp but was {1}. Element: {2}", patternExp, regex, startingTag(elm));
                        regexp = regex || undefined, ctrl.$validate();
                    }), ctrl.$validators.pattern = function(modelValue, viewValue) {
                        return ctrl.$isEmpty(viewValue) || isUndefined(regexp) || regexp.test(viewValue);
                    };
                }
            }
        };
    }, maxlengthDirective = function() {
        return {
            restrict: "A",
            require: "?ngModel",
            link: function(scope, elm, attr, ctrl) {
                if (ctrl) {
                    var maxlength = -1;
                    attr.$observe("maxlength", function(value) {
                        var intVal = toInt(value);
                        maxlength = isNaN(intVal) ? -1 : intVal, ctrl.$validate();
                    }), ctrl.$validators.maxlength = function(modelValue, viewValue) {
                        return 0 > maxlength || ctrl.$isEmpty(viewValue) || viewValue.length <= maxlength;
                    };
                }
            }
        };
    }, minlengthDirective = function() {
        return {
            restrict: "A",
            require: "?ngModel",
            link: function(scope, elm, attr, ctrl) {
                if (ctrl) {
                    var minlength = 0;
                    attr.$observe("minlength", function(value) {
                        minlength = toInt(value) || 0, ctrl.$validate();
                    }), ctrl.$validators.minlength = function(modelValue, viewValue) {
                        return ctrl.$isEmpty(viewValue) || viewValue.length >= minlength;
                    };
                }
            }
        };
    };
    return window.angular.bootstrap ? void console.log("WARNING: Tried to load angular more than once.") : (bindJQuery(), 
    publishExternalAPI(angular), angular.module("ngLocale", [], [ "$provide", function($provide) {
        function getDecimals(n) {
            n += "";
            var i = n.indexOf(".");
            return -1 == i ? 0 : n.length - i - 1;
        }
        function getVF(n, opt_precision) {
            var v = opt_precision;
            undefined === v && (v = Math.min(getDecimals(n), 3));
            var base = Math.pow(10, v), f = (n * base | 0) % base;
            return {
                v: v,
                f: f
            };
        }
        var PLURAL_CATEGORY = {
            ZERO: "zero",
            ONE: "one",
            TWO: "two",
            FEW: "few",
            MANY: "many",
            OTHER: "other"
        };
        $provide.value("$locale", {
            DATETIME_FORMATS: {
                AMPMS: [ "AM", "PM" ],
                DAY: [ "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday" ],
                ERANAMES: [ "Before Christ", "Anno Domini" ],
                ERAS: [ "BC", "AD" ],
                FIRSTDAYOFWEEK: 6,
                MONTH: [ "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December" ],
                SHORTDAY: [ "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" ],
                SHORTMONTH: [ "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" ],
                WEEKENDRANGE: [ 5, 6 ],
                fullDate: "EEEE, MMMM d, y",
                longDate: "MMMM d, y",
                medium: "MMM d, y h:mm:ss a",
                mediumDate: "MMM d, y",
                mediumTime: "h:mm:ss a",
                "short": "M/d/yy h:mm a",
                shortDate: "M/d/yy",
                shortTime: "h:mm a"
            },
            NUMBER_FORMATS: {
                CURRENCY_SYM: "$",
                DECIMAL_SEP: ".",
                GROUP_SEP: ",",
                PATTERNS: [ {
                    gSize: 3,
                    lgSize: 3,
                    maxFrac: 3,
                    minFrac: 0,
                    minInt: 1,
                    negPre: "-",
                    negSuf: "",
                    posPre: "",
                    posSuf: ""
                }, {
                    gSize: 3,
                    lgSize: 3,
                    maxFrac: 2,
                    minFrac: 2,
                    minInt: 1,
                    negPre: "-",
                    negSuf: "",
                    posPre: "",
                    posSuf: ""
                } ]
            },
            id: "en-us",
            pluralCat: function(n, opt_precision) {
                var i = 0 | n, vf = getVF(n, opt_precision);
                return 1 == i && 0 == vf.v ? PLURAL_CATEGORY.ONE : PLURAL_CATEGORY.OTHER;
            }
        });
    } ]), void jqLite(document).ready(function() {
        angularInit(document, bootstrap);
    }));
}(window, document), !window.angular.$$csp().noInlineStyle && window.angular.element(document.head).prepend('<style type="text/css">@charset "UTF-8";[ng\\:cloak],[ng-cloak],[data-ng-cloak],[x-ng-cloak],.ng-cloak,.x-ng-cloak,.ng-hide:not(.ng-hide-animate){display:none !important;}ng\\:form{display:block;}.ng-animate-shim{visibility:hidden;}.ng-anchor{position:absolute;}</style>'), 
define("angular", function(global) {
    return function() {
        var ret;
        return ret || global.angular;
    };
}(this)), function(window, angular) {
    function assertArg(arg, name, reason) {
        if (!arg) throw ngMinErr("areq", "Argument '{0}' is {1}", name || "?", reason || "required");
        return arg;
    }
    function mergeClasses(a, b) {
        return a || b ? a ? b ? (isArray(a) && (a = a.join(" ")), isArray(b) && (b = b.join(" ")), 
        a + " " + b) : a : b : "";
    }
    function packageStyles(options) {
        var styles = {};
        return options && (options.to || options.from) && (styles.to = options.to, styles.from = options.from), 
        styles;
    }
    function pendClasses(classes, fix, isPrefix) {
        var className = "";
        return classes = isArray(classes) ? classes : classes && isString(classes) && classes.length ? classes.split(/\s+/) : [], 
        forEach(classes, function(klass, i) {
            klass && klass.length > 0 && (className += i > 0 ? " " : "", className += isPrefix ? fix + klass : klass + fix);
        }), className;
    }
    function removeFromArray(arr, val) {
        var index = arr.indexOf(val);
        val >= 0 && arr.splice(index, 1);
    }
    function stripCommentsFromElement(element) {
        if (element instanceof jqLite) switch (element.length) {
          case 0:
            return [];

          case 1:
            if (element[0].nodeType === ELEMENT_NODE) return element;
            break;

          default:
            return jqLite(extractElementNode(element));
        }
        return element.nodeType === ELEMENT_NODE ? jqLite(element) : void 0;
    }
    function extractElementNode(element) {
        if (!element[0]) return element;
        for (var i = 0; i < element.length; i++) {
            var elm = element[i];
            if (elm.nodeType == ELEMENT_NODE) return elm;
        }
    }
    function $$addClass($$jqLite, element, className) {
        forEach(element, function(elm) {
            $$jqLite.addClass(elm, className);
        });
    }
    function $$removeClass($$jqLite, element, className) {
        forEach(element, function(elm) {
            $$jqLite.removeClass(elm, className);
        });
    }
    function applyAnimationClassesFactory($$jqLite) {
        return function(element, options) {
            options.addClass && ($$addClass($$jqLite, element, options.addClass), options.addClass = null), 
            options.removeClass && ($$removeClass($$jqLite, element, options.removeClass), options.removeClass = null);
        };
    }
    function prepareAnimationOptions(options) {
        if (options = options || {}, !options.$$prepared) {
            var domOperation = options.domOperation || noop;
            options.domOperation = function() {
                options.$$domOperationFired = !0, domOperation(), domOperation = noop;
            }, options.$$prepared = !0;
        }
        return options;
    }
    function applyAnimationStyles(element, options) {
        applyAnimationFromStyles(element, options), applyAnimationToStyles(element, options);
    }
    function applyAnimationFromStyles(element, options) {
        options.from && (element.css(options.from), options.from = null);
    }
    function applyAnimationToStyles(element, options) {
        options.to && (element.css(options.to), options.to = null);
    }
    function mergeAnimationOptions(element, target, newOptions) {
        var toAdd = (target.addClass || "") + " " + (newOptions.addClass || ""), toRemove = (target.removeClass || "") + " " + (newOptions.removeClass || ""), classes = resolveElementClasses(element.attr("class"), toAdd, toRemove);
        newOptions.preparationClasses && (target.preparationClasses = concatWithSpace(newOptions.preparationClasses, target.preparationClasses), 
        delete newOptions.preparationClasses);
        var realDomOperation = target.domOperation !== noop ? target.domOperation : null;
        return extend(target, newOptions), realDomOperation && (target.domOperation = realDomOperation), 
        target.addClass = classes.addClass ? classes.addClass : null, target.removeClass = classes.removeClass ? classes.removeClass : null, 
        target;
    }
    function resolveElementClasses(existing, toAdd, toRemove) {
        function splitClassesToLookup(classes) {
            isString(classes) && (classes = classes.split(" "));
            var obj = {};
            return forEach(classes, function(klass) {
                klass.length && (obj[klass] = !0);
            }), obj;
        }
        var ADD_CLASS = 1, REMOVE_CLASS = -1, flags = {};
        existing = splitClassesToLookup(existing), toAdd = splitClassesToLookup(toAdd), 
        forEach(toAdd, function(value, key) {
            flags[key] = ADD_CLASS;
        }), toRemove = splitClassesToLookup(toRemove), forEach(toRemove, function(value, key) {
            flags[key] = flags[key] === ADD_CLASS ? null : REMOVE_CLASS;
        });
        var classes = {
            addClass: "",
            removeClass: ""
        };
        return forEach(flags, function(val, klass) {
            var prop, allow;
            val === ADD_CLASS ? (prop = "addClass", allow = !existing[klass]) : val === REMOVE_CLASS && (prop = "removeClass", 
            allow = existing[klass]), allow && (classes[prop].length && (classes[prop] += " "), 
            classes[prop] += klass);
        }), classes;
    }
    function getDomNode(element) {
        return element instanceof angular.element ? element[0] : element;
    }
    function applyGeneratedPreparationClasses(element, event, options) {
        var classes = "";
        event && (classes = pendClasses(event, EVENT_CLASS_PREFIX, !0)), options.addClass && (classes = concatWithSpace(classes, pendClasses(options.addClass, ADD_CLASS_SUFFIX))), 
        options.removeClass && (classes = concatWithSpace(classes, pendClasses(options.removeClass, REMOVE_CLASS_SUFFIX))), 
        classes.length && (options.preparationClasses = classes, element.addClass(classes));
    }
    function clearGeneratedClasses(element, options) {
        options.preparationClasses && (element.removeClass(options.preparationClasses), 
        options.preparationClasses = null), options.activeClasses && (element.removeClass(options.activeClasses), 
        options.activeClasses = null);
    }
    function blockTransitions(node, duration) {
        var value = duration ? "-" + duration + "s" : "";
        return applyInlineStyle(node, [ TRANSITION_DELAY_PROP, value ]), [ TRANSITION_DELAY_PROP, value ];
    }
    function blockKeyframeAnimations(node, applyBlock) {
        var value = applyBlock ? "paused" : "", key = ANIMATION_PROP + ANIMATION_PLAYSTATE_KEY;
        return applyInlineStyle(node, [ key, value ]), [ key, value ];
    }
    function applyInlineStyle(node, styleTuple) {
        var prop = styleTuple[0], value = styleTuple[1];
        node.style[prop] = value;
    }
    function concatWithSpace(a, b) {
        return a ? b ? a + " " + b : a : b;
    }
    function getCssKeyframeDurationStyle(duration) {
        return [ ANIMATION_DURATION_PROP, duration + "s" ];
    }
    function getCssDelayStyle(delay, isKeyframeAnimation) {
        var prop = isKeyframeAnimation ? ANIMATION_DELAY_PROP : TRANSITION_DELAY_PROP;
        return [ prop, delay + "s" ];
    }
    function computeCssStyles($window, element, properties) {
        var styles = Object.create(null), detectedStyles = $window.getComputedStyle(element) || {};
        return forEach(properties, function(formalStyleName, actualStyleName) {
            var val = detectedStyles[formalStyleName];
            if (val) {
                var c = val.charAt(0);
                ("-" === c || "+" === c || c >= 0) && (val = parseMaxTime(val)), 0 === val && (val = null), 
                styles[actualStyleName] = val;
            }
        }), styles;
    }
    function parseMaxTime(str) {
        var maxValue = 0, values = str.split(/\s*,\s*/);
        return forEach(values, function(value) {
            "s" == value.charAt(value.length - 1) && (value = value.substring(0, value.length - 1)), 
            value = parseFloat(value) || 0, maxValue = maxValue ? Math.max(value, maxValue) : value;
        }), maxValue;
    }
    function truthyTimingValue(val) {
        return 0 === val || null != val;
    }
    function getCssTransitionDurationStyle(duration, applyOnlyDuration) {
        var style = TRANSITION_PROP, value = duration + "s";
        return applyOnlyDuration ? style += DURATION_KEY : value += " linear all", [ style, value ];
    }
    function createLocalCacheLookup() {
        var cache = Object.create(null);
        return {
            flush: function() {
                cache = Object.create(null);
            },
            count: function(key) {
                var entry = cache[key];
                return entry ? entry.total : 0;
            },
            get: function(key) {
                var entry = cache[key];
                return entry && entry.value;
            },
            put: function(key, value) {
                cache[key] ? cache[key].total++ : cache[key] = {
                    total: 1,
                    value: value
                };
            }
        };
    }
    function registerRestorableStyles(backup, node, properties) {
        forEach(properties, function(prop) {
            backup[prop] = isDefined(backup[prop]) ? backup[prop] : node.style.getPropertyValue(prop);
        });
    }
    var TRANSITION_PROP, TRANSITIONEND_EVENT, ANIMATION_PROP, ANIMATIONEND_EVENT, noop = angular.noop, extend = angular.extend, jqLite = angular.element, forEach = angular.forEach, isArray = angular.isArray, isString = angular.isString, isObject = angular.isObject, isUndefined = angular.isUndefined, isDefined = angular.isDefined, isFunction = angular.isFunction, isElement = angular.isElement, ELEMENT_NODE = 1, ADD_CLASS_SUFFIX = "-add", REMOVE_CLASS_SUFFIX = "-remove", EVENT_CLASS_PREFIX = "ng-", ACTIVE_CLASS_SUFFIX = "-active", NG_ANIMATE_CLASSNAME = "ng-animate", NG_ANIMATE_CHILDREN_DATA = "$$ngAnimateChildren", CSS_PREFIX = "";
    isUndefined(window.ontransitionend) && isDefined(window.onwebkittransitionend) ? (CSS_PREFIX = "-webkit-", 
    TRANSITION_PROP = "WebkitTransition", TRANSITIONEND_EVENT = "webkitTransitionEnd transitionend") : (TRANSITION_PROP = "transition", 
    TRANSITIONEND_EVENT = "transitionend"), isUndefined(window.onanimationend) && isDefined(window.onwebkitanimationend) ? (CSS_PREFIX = "-webkit-", 
    ANIMATION_PROP = "WebkitAnimation", ANIMATIONEND_EVENT = "webkitAnimationEnd animationend") : (ANIMATION_PROP = "animation", 
    ANIMATIONEND_EVENT = "animationend");
    var DURATION_KEY = "Duration", PROPERTY_KEY = "Property", DELAY_KEY = "Delay", TIMING_KEY = "TimingFunction", ANIMATION_ITERATION_COUNT_KEY = "IterationCount", ANIMATION_PLAYSTATE_KEY = "PlayState", SAFE_FAST_FORWARD_DURATION_VALUE = 9999, ANIMATION_DELAY_PROP = ANIMATION_PROP + DELAY_KEY, ANIMATION_DURATION_PROP = ANIMATION_PROP + DURATION_KEY, TRANSITION_DELAY_PROP = TRANSITION_PROP + DELAY_KEY, TRANSITION_DURATION_PROP = TRANSITION_PROP + DURATION_KEY, $$rAFSchedulerFactory = [ "$$rAF", function($$rAF) {
        function scheduler(tasks) {
            queue = queue.concat(tasks), nextTick();
        }
        function nextTick() {
            if (queue.length) {
                for (var items = queue.shift(), i = 0; i < items.length; i++) items[i]();
                cancelFn || $$rAF(function() {
                    cancelFn || nextTick();
                });
            }
        }
        var queue, cancelFn;
        return queue = scheduler.queue = [], scheduler.waitUntilQuiet = function(fn) {
            cancelFn && cancelFn(), cancelFn = $$rAF(function() {
                cancelFn = null, fn(), nextTick();
            });
        }, scheduler;
    } ], $$AnimateChildrenDirective = [ function() {
        return function(scope, element, attrs) {
            var val = attrs.ngAnimateChildren;
            angular.isString(val) && 0 === val.length ? element.data(NG_ANIMATE_CHILDREN_DATA, !0) : attrs.$observe("ngAnimateChildren", function(value) {
                value = "on" === value || "true" === value, element.data(NG_ANIMATE_CHILDREN_DATA, value);
            });
        };
    } ], ANIMATE_TIMER_KEY = "$$animateCss", ONE_SECOND = 1e3, ELAPSED_TIME_MAX_DECIMAL_PLACES = 3, CLOSING_TIME_BUFFER = 1.5, DETECT_CSS_PROPERTIES = {
        transitionDuration: TRANSITION_DURATION_PROP,
        transitionDelay: TRANSITION_DELAY_PROP,
        transitionProperty: TRANSITION_PROP + PROPERTY_KEY,
        animationDuration: ANIMATION_DURATION_PROP,
        animationDelay: ANIMATION_DELAY_PROP,
        animationIterationCount: ANIMATION_PROP + ANIMATION_ITERATION_COUNT_KEY
    }, DETECT_STAGGER_CSS_PROPERTIES = {
        transitionDuration: TRANSITION_DURATION_PROP,
        transitionDelay: TRANSITION_DELAY_PROP,
        animationDuration: ANIMATION_DURATION_PROP,
        animationDelay: ANIMATION_DELAY_PROP
    }, $AnimateCssProvider = [ "$animateProvider", function() {
        var gcsLookup = createLocalCacheLookup(), gcsStaggerLookup = createLocalCacheLookup();
        this.$get = [ "$window", "$$jqLite", "$$AnimateRunner", "$timeout", "$$forceReflow", "$sniffer", "$$rAFScheduler", "$animate", function($window, $$jqLite, $$AnimateRunner, $timeout, $$forceReflow, $sniffer, $$rAFScheduler, $animate) {
            function gcsHashFn(node, extraClasses) {
                var KEY = "$$ngAnimateParentKey", parentNode = node.parentNode, parentID = parentNode[KEY] || (parentNode[KEY] = ++parentCounter);
                return parentID + "-" + node.getAttribute("class") + "-" + extraClasses;
            }
            function computeCachedCssStyles(node, className, cacheKey, properties) {
                var timings = gcsLookup.get(cacheKey);
                return timings || (timings = computeCssStyles($window, node, properties), "infinite" === timings.animationIterationCount && (timings.animationIterationCount = 1)), 
                gcsLookup.put(cacheKey, timings), timings;
            }
            function computeCachedCssStaggerStyles(node, className, cacheKey, properties) {
                var stagger;
                if (gcsLookup.count(cacheKey) > 0 && (stagger = gcsStaggerLookup.get(cacheKey), 
                !stagger)) {
                    var staggerClassName = pendClasses(className, "-stagger");
                    $$jqLite.addClass(node, staggerClassName), stagger = computeCssStyles($window, node, properties), 
                    stagger.animationDuration = Math.max(stagger.animationDuration, 0), stagger.transitionDuration = Math.max(stagger.transitionDuration, 0), 
                    $$jqLite.removeClass(node, staggerClassName), gcsStaggerLookup.put(cacheKey, stagger);
                }
                return stagger || {};
            }
            function waitUntilQuiet(callback) {
                rafWaitQueue.push(callback), $$rAFScheduler.waitUntilQuiet(function() {
                    gcsLookup.flush(), gcsStaggerLookup.flush();
                    for (var pageWidth = $$forceReflow(), i = 0; i < rafWaitQueue.length; i++) rafWaitQueue[i](pageWidth);
                    rafWaitQueue.length = 0;
                });
            }
            function computeTimings(node, className, cacheKey) {
                var timings = computeCachedCssStyles(node, className, cacheKey, DETECT_CSS_PROPERTIES), aD = timings.animationDelay, tD = timings.transitionDelay;
                return timings.maxDelay = aD && tD ? Math.max(aD, tD) : aD || tD, timings.maxDuration = Math.max(timings.animationDuration * timings.animationIterationCount, timings.transitionDuration), 
                timings;
            }
            var applyAnimationClasses = applyAnimationClassesFactory($$jqLite), parentCounter = 0, rafWaitQueue = [];
            return function(element, options) {
                function endFn() {
                    close();
                }
                function cancelFn() {
                    close(!0);
                }
                function close(rejected) {
                    animationClosed || animationCompleted && animationPaused || (animationClosed = !0, 
                    animationPaused = !1, options.$$skipPreparationClasses || $$jqLite.removeClass(element, preparationClasses), 
                    $$jqLite.removeClass(element, activeClasses), blockKeyframeAnimations(node, !1), 
                    blockTransitions(node, !1), forEach(temporaryStyles, function(entry) {
                        node.style[entry[0]] = "";
                    }), applyAnimationClasses(element, options), applyAnimationStyles(element, options), 
                    Object.keys(restoreStyles).length && forEach(restoreStyles, function(value, prop) {
                        value ? node.style.setProperty(prop, value) : node.style.removeProperty(prop);
                    }), options.onDone && options.onDone(), runner && runner.complete(!rejected));
                }
                function applyBlocking(duration) {
                    flags.blockTransition && blockTransitions(node, duration), flags.blockKeyframeAnimation && blockKeyframeAnimations(node, !!duration);
                }
                function closeAndReturnNoopAnimator() {
                    return runner = new $$AnimateRunner({
                        end: endFn,
                        cancel: cancelFn
                    }), waitUntilQuiet(noop), close(), {
                        $$willAnimate: !1,
                        start: function() {
                            return runner;
                        },
                        end: endFn
                    };
                }
                function start() {
                    function triggerAnimationStart() {
                        if (!animationClosed) {
                            if (applyBlocking(!1), forEach(temporaryStyles, function(entry) {
                                var key = entry[0], value = entry[1];
                                node.style[key] = value;
                            }), applyAnimationClasses(element, options), $$jqLite.addClass(element, activeClasses), 
                            flags.recalculateTimingStyles) {
                                if (fullClassName = node.className + " " + preparationClasses, cacheKey = gcsHashFn(node, fullClassName), 
                                timings = computeTimings(node, fullClassName, cacheKey), relativeDelay = timings.maxDelay, 
                                maxDelay = Math.max(relativeDelay, 0), maxDuration = timings.maxDuration, 0 === maxDuration) return void close();
                                flags.hasTransitions = timings.transitionDuration > 0, flags.hasAnimations = timings.animationDuration > 0;
                            }
                            if (flags.applyAnimationDelay && (relativeDelay = "boolean" != typeof options.delay && truthyTimingValue(options.delay) ? parseFloat(options.delay) : relativeDelay, 
                            maxDelay = Math.max(relativeDelay, 0), timings.animationDelay = relativeDelay, delayStyle = getCssDelayStyle(relativeDelay, !0), 
                            temporaryStyles.push(delayStyle), node.style[delayStyle[0]] = delayStyle[1]), maxDelayTime = maxDelay * ONE_SECOND, 
                            maxDurationTime = maxDuration * ONE_SECOND, options.easing) {
                                var easeProp, easeVal = options.easing;
                                flags.hasTransitions && (easeProp = TRANSITION_PROP + TIMING_KEY, temporaryStyles.push([ easeProp, easeVal ]), 
                                node.style[easeProp] = easeVal), flags.hasAnimations && (easeProp = ANIMATION_PROP + TIMING_KEY, 
                                temporaryStyles.push([ easeProp, easeVal ]), node.style[easeProp] = easeVal);
                            }
                            timings.transitionDuration && events.push(TRANSITIONEND_EVENT), timings.animationDuration && events.push(ANIMATIONEND_EVENT), 
                            startTime = Date.now();
                            var timerTime = maxDelayTime + CLOSING_TIME_BUFFER * maxDurationTime, endTime = startTime + timerTime, animationsData = element.data(ANIMATE_TIMER_KEY) || [], setupFallbackTimer = !0;
                            if (animationsData.length) {
                                var currentTimerData = animationsData[0];
                                setupFallbackTimer = endTime > currentTimerData.expectedEndTime, setupFallbackTimer ? $timeout.cancel(currentTimerData.timer) : animationsData.push(close);
                            }
                            if (setupFallbackTimer) {
                                var timer = $timeout(onAnimationExpired, timerTime, !1);
                                animationsData[0] = {
                                    timer: timer,
                                    expectedEndTime: endTime
                                }, animationsData.push(close), element.data(ANIMATE_TIMER_KEY, animationsData);
                            }
                            element.on(events.join(" "), onAnimationProgress), options.to && (options.cleanupStyles && registerRestorableStyles(restoreStyles, node, Object.keys(options.to)), 
                            applyAnimationToStyles(element, options));
                        }
                    }
                    function onAnimationExpired() {
                        var animationsData = element.data(ANIMATE_TIMER_KEY);
                        if (animationsData) {
                            for (var i = 1; i < animationsData.length; i++) animationsData[i]();
                            element.removeData(ANIMATE_TIMER_KEY);
                        }
                    }
                    function onAnimationProgress(event) {
                        event.stopPropagation();
                        var ev = event.originalEvent || event, timeStamp = ev.$manualTimeStamp || ev.timeStamp || Date.now(), elapsedTime = parseFloat(ev.elapsedTime.toFixed(ELAPSED_TIME_MAX_DECIMAL_PLACES));
                        Math.max(timeStamp - startTime, 0) >= maxDelayTime && elapsedTime >= maxDuration && (animationCompleted = !0, 
                        close());
                    }
                    if (!animationClosed) {
                        if (!node.parentNode) return void close();
                        var startTime, events = [], playPause = function(playAnimation) {
                            if (animationCompleted) animationPaused && playAnimation && (animationPaused = !1, 
                            close()); else if (animationPaused = !playAnimation, timings.animationDuration) {
                                var value = blockKeyframeAnimations(node, animationPaused);
                                animationPaused ? temporaryStyles.push(value) : removeFromArray(temporaryStyles, value);
                            }
                        }, maxStagger = itemIndex > 0 && (timings.transitionDuration && 0 === stagger.transitionDuration || timings.animationDuration && 0 === stagger.animationDuration) && Math.max(stagger.animationDelay, stagger.transitionDelay);
                        maxStagger ? $timeout(triggerAnimationStart, Math.floor(maxStagger * itemIndex * ONE_SECOND), !1) : triggerAnimationStart(), 
                        runnerHost.resume = function() {
                            playPause(!0);
                        }, runnerHost.pause = function() {
                            playPause(!1);
                        };
                    }
                }
                var restoreStyles = {}, node = getDomNode(element);
                if (!node || !node.parentNode || !$animate.enabled()) return closeAndReturnNoopAnimator();
                options = prepareAnimationOptions(options);
                var animationClosed, animationPaused, animationCompleted, runner, runnerHost, maxDelay, maxDelayTime, maxDuration, maxDurationTime, temporaryStyles = [], classes = element.attr("class"), styles = packageStyles(options);
                if (0 === options.duration || !$sniffer.animations && !$sniffer.transitions) return closeAndReturnNoopAnimator();
                var method = options.event && isArray(options.event) ? options.event.join(" ") : options.event, isStructural = method && options.structural, structuralClassName = "", addRemoveClassName = "";
                isStructural ? structuralClassName = pendClasses(method, EVENT_CLASS_PREFIX, !0) : method && (structuralClassName = method), 
                options.addClass && (addRemoveClassName += pendClasses(options.addClass, ADD_CLASS_SUFFIX)), 
                options.removeClass && (addRemoveClassName.length && (addRemoveClassName += " "), 
                addRemoveClassName += pendClasses(options.removeClass, REMOVE_CLASS_SUFFIX)), options.applyClassesEarly && addRemoveClassName.length && applyAnimationClasses(element, options);
                var preparationClasses = [ structuralClassName, addRemoveClassName ].join(" ").trim(), fullClassName = classes + " " + preparationClasses, activeClasses = pendClasses(preparationClasses, ACTIVE_CLASS_SUFFIX), hasToStyles = styles.to && Object.keys(styles.to).length > 0, containsKeyframeAnimation = (options.keyframeStyle || "").length > 0;
                if (!containsKeyframeAnimation && !hasToStyles && !preparationClasses) return closeAndReturnNoopAnimator();
                var cacheKey, stagger;
                if (options.stagger > 0) {
                    var staggerVal = parseFloat(options.stagger);
                    stagger = {
                        transitionDelay: staggerVal,
                        animationDelay: staggerVal,
                        transitionDuration: 0,
                        animationDuration: 0
                    };
                } else cacheKey = gcsHashFn(node, fullClassName), stagger = computeCachedCssStaggerStyles(node, preparationClasses, cacheKey, DETECT_STAGGER_CSS_PROPERTIES);
                options.$$skipPreparationClasses || $$jqLite.addClass(element, preparationClasses);
                var applyOnlyDuration;
                if (options.transitionStyle) {
                    var transitionStyle = [ TRANSITION_PROP, options.transitionStyle ];
                    applyInlineStyle(node, transitionStyle), temporaryStyles.push(transitionStyle);
                }
                if (options.duration >= 0) {
                    applyOnlyDuration = node.style[TRANSITION_PROP].length > 0;
                    var durationStyle = getCssTransitionDurationStyle(options.duration, applyOnlyDuration);
                    applyInlineStyle(node, durationStyle), temporaryStyles.push(durationStyle);
                }
                if (options.keyframeStyle) {
                    var keyframeStyle = [ ANIMATION_PROP, options.keyframeStyle ];
                    applyInlineStyle(node, keyframeStyle), temporaryStyles.push(keyframeStyle);
                }
                var itemIndex = stagger ? options.staggerIndex >= 0 ? options.staggerIndex : gcsLookup.count(cacheKey) : 0, isFirst = 0 === itemIndex;
                isFirst && !options.skipBlocking && blockTransitions(node, SAFE_FAST_FORWARD_DURATION_VALUE);
                var timings = computeTimings(node, fullClassName, cacheKey), relativeDelay = timings.maxDelay;
                maxDelay = Math.max(relativeDelay, 0), maxDuration = timings.maxDuration;
                var flags = {};
                if (flags.hasTransitions = timings.transitionDuration > 0, flags.hasAnimations = timings.animationDuration > 0, 
                flags.hasTransitionAll = flags.hasTransitions && "all" == timings.transitionProperty, 
                flags.applyTransitionDuration = hasToStyles && (flags.hasTransitions && !flags.hasTransitionAll || flags.hasAnimations && !flags.hasTransitions), 
                flags.applyAnimationDuration = options.duration && flags.hasAnimations, flags.applyTransitionDelay = truthyTimingValue(options.delay) && (flags.applyTransitionDuration || flags.hasTransitions), 
                flags.applyAnimationDelay = truthyTimingValue(options.delay) && flags.hasAnimations, 
                flags.recalculateTimingStyles = addRemoveClassName.length > 0, (flags.applyTransitionDuration || flags.applyAnimationDuration) && (maxDuration = options.duration ? parseFloat(options.duration) : maxDuration, 
                flags.applyTransitionDuration && (flags.hasTransitions = !0, timings.transitionDuration = maxDuration, 
                applyOnlyDuration = node.style[TRANSITION_PROP + PROPERTY_KEY].length > 0, temporaryStyles.push(getCssTransitionDurationStyle(maxDuration, applyOnlyDuration))), 
                flags.applyAnimationDuration && (flags.hasAnimations = !0, timings.animationDuration = maxDuration, 
                temporaryStyles.push(getCssKeyframeDurationStyle(maxDuration)))), 0 === maxDuration && !flags.recalculateTimingStyles) return closeAndReturnNoopAnimator();
                if (null != options.delay) {
                    var delayStyle = parseFloat(options.delay);
                    flags.applyTransitionDelay && temporaryStyles.push(getCssDelayStyle(delayStyle)), 
                    flags.applyAnimationDelay && temporaryStyles.push(getCssDelayStyle(delayStyle, !0));
                }
                return null == options.duration && timings.transitionDuration > 0 && (flags.recalculateTimingStyles = flags.recalculateTimingStyles || isFirst), 
                maxDelayTime = maxDelay * ONE_SECOND, maxDurationTime = maxDuration * ONE_SECOND, 
                options.skipBlocking || (flags.blockTransition = timings.transitionDuration > 0, 
                flags.blockKeyframeAnimation = timings.animationDuration > 0 && stagger.animationDelay > 0 && 0 === stagger.animationDuration), 
                options.from && (options.cleanupStyles && registerRestorableStyles(restoreStyles, node, Object.keys(options.from)), 
                applyAnimationFromStyles(element, options)), flags.blockTransition || flags.blockKeyframeAnimation ? applyBlocking(maxDuration) : options.skipBlocking || blockTransitions(node, !1), 
                {
                    $$willAnimate: !0,
                    end: endFn,
                    start: function() {
                        return animationClosed ? void 0 : (runnerHost = {
                            end: endFn,
                            cancel: cancelFn,
                            resume: null,
                            pause: null
                        }, runner = new $$AnimateRunner(runnerHost), waitUntilQuiet(start), runner);
                    }
                };
            };
        } ];
    } ], $$AnimateCssDriverProvider = [ "$$animationProvider", function($$animationProvider) {
        function isDocumentFragment(node) {
            return node.parentNode && 11 === node.parentNode.nodeType;
        }
        $$animationProvider.drivers.push("$$animateCssDriver");
        var NG_ANIMATE_SHIM_CLASS_NAME = "ng-animate-shim", NG_ANIMATE_ANCHOR_CLASS_NAME = "ng-anchor", NG_OUT_ANCHOR_CLASS_NAME = "ng-anchor-out", NG_IN_ANCHOR_CLASS_NAME = "ng-anchor-in";
        this.$get = [ "$animateCss", "$rootScope", "$$AnimateRunner", "$rootElement", "$sniffer", "$$jqLite", "$document", function($animateCss, $rootScope, $$AnimateRunner, $rootElement, $sniffer, $$jqLite, $document) {
            function filterCssClasses(classes) {
                return classes.replace(/\bng-\S+\b/g, "");
            }
            function getUniqueValues(a, b) {
                return isString(a) && (a = a.split(" ")), isString(b) && (b = b.split(" ")), a.filter(function(val) {
                    return -1 === b.indexOf(val);
                }).join(" ");
            }
            function prepareAnchoredAnimation(classes, outAnchor, inAnchor) {
                function calculateAnchorStyles(anchor) {
                    var styles = {}, coords = getDomNode(anchor).getBoundingClientRect();
                    return forEach([ "width", "height", "top", "left" ], function(key) {
                        var value = coords[key];
                        switch (key) {
                          case "top":
                            value += bodyNode.scrollTop;
                            break;

                          case "left":
                            value += bodyNode.scrollLeft;
                        }
                        styles[key] = Math.floor(value) + "px";
                    }), styles;
                }
                function prepareOutAnimation() {
                    var animator = $animateCss(clone, {
                        addClass: NG_OUT_ANCHOR_CLASS_NAME,
                        delay: !0,
                        from: calculateAnchorStyles(outAnchor)
                    });
                    return animator.$$willAnimate ? animator : null;
                }
                function getClassVal(element) {
                    return element.attr("class") || "";
                }
                function prepareInAnimation() {
                    var endingClasses = filterCssClasses(getClassVal(inAnchor)), toAdd = getUniqueValues(endingClasses, startingClasses), toRemove = getUniqueValues(startingClasses, endingClasses), animator = $animateCss(clone, {
                        to: calculateAnchorStyles(inAnchor),
                        addClass: NG_IN_ANCHOR_CLASS_NAME + " " + toAdd,
                        removeClass: NG_OUT_ANCHOR_CLASS_NAME + " " + toRemove,
                        delay: !0
                    });
                    return animator.$$willAnimate ? animator : null;
                }
                function end() {
                    clone.remove(), outAnchor.removeClass(NG_ANIMATE_SHIM_CLASS_NAME), inAnchor.removeClass(NG_ANIMATE_SHIM_CLASS_NAME);
                }
                var clone = jqLite(getDomNode(outAnchor).cloneNode(!0)), startingClasses = filterCssClasses(getClassVal(clone));
                outAnchor.addClass(NG_ANIMATE_SHIM_CLASS_NAME), inAnchor.addClass(NG_ANIMATE_SHIM_CLASS_NAME), 
                clone.addClass(NG_ANIMATE_ANCHOR_CLASS_NAME), rootBodyElement.append(clone);
                var animatorIn, animatorOut = prepareOutAnimation();
                if (!animatorOut && (animatorIn = prepareInAnimation(), !animatorIn)) return end();
                var startingAnimator = animatorOut || animatorIn;
                return {
                    start: function() {
                        function endFn() {
                            currentAnimation && currentAnimation.end();
                        }
                        var runner, currentAnimation = startingAnimator.start();
                        return currentAnimation.done(function() {
                            return currentAnimation = null, !animatorIn && (animatorIn = prepareInAnimation()) ? (currentAnimation = animatorIn.start(), 
                            currentAnimation.done(function() {
                                currentAnimation = null, end(), runner.complete();
                            }), currentAnimation) : (end(), void runner.complete());
                        }), runner = new $$AnimateRunner({
                            end: endFn,
                            cancel: endFn
                        });
                    }
                };
            }
            function prepareFromToAnchorAnimation(from, to, classes, anchors) {
                var fromAnimation = prepareRegularAnimation(from, noop), toAnimation = prepareRegularAnimation(to, noop), anchorAnimations = [];
                return forEach(anchors, function(anchor) {
                    var outElement = anchor.out, inElement = anchor["in"], animator = prepareAnchoredAnimation(classes, outElement, inElement);
                    animator && anchorAnimations.push(animator);
                }), fromAnimation || toAnimation || 0 !== anchorAnimations.length ? {
                    start: function() {
                        function endFn() {
                            forEach(animationRunners, function(runner) {
                                runner.end();
                            });
                        }
                        var animationRunners = [];
                        fromAnimation && animationRunners.push(fromAnimation.start()), toAnimation && animationRunners.push(toAnimation.start()), 
                        forEach(anchorAnimations, function(animation) {
                            animationRunners.push(animation.start());
                        });
                        var runner = new $$AnimateRunner({
                            end: endFn,
                            cancel: endFn
                        });
                        return $$AnimateRunner.all(animationRunners, function(status) {
                            runner.complete(status);
                        }), runner;
                    }
                } : void 0;
            }
            function prepareRegularAnimation(animationDetails) {
                var element = animationDetails.element, options = animationDetails.options || {};
                animationDetails.structural && (options.event = animationDetails.event, options.structural = !0, 
                options.applyClassesEarly = !0, "leave" === animationDetails.event && (options.onDone = options.domOperation)), 
                options.preparationClasses && (options.event = concatWithSpace(options.event, options.preparationClasses));
                var animator = $animateCss(element, options);
                return animator.$$willAnimate ? animator : null;
            }
            if (!$sniffer.animations && !$sniffer.transitions) return noop;
            {
                var bodyNode = $document[0].body, rootNode = getDomNode($rootElement), rootBodyElement = jqLite(isDocumentFragment(rootNode) || bodyNode.contains(rootNode) ? rootNode : bodyNode);
                applyAnimationClassesFactory($$jqLite);
            }
            return function(animationDetails) {
                return animationDetails.from && animationDetails.to ? prepareFromToAnchorAnimation(animationDetails.from, animationDetails.to, animationDetails.classes, animationDetails.anchors) : prepareRegularAnimation(animationDetails);
            };
        } ];
    } ], $$AnimateJsProvider = [ "$animateProvider", function($animateProvider) {
        this.$get = [ "$injector", "$$AnimateRunner", "$$jqLite", function($injector, $$AnimateRunner, $$jqLite) {
            function lookupAnimations(classes) {
                classes = isArray(classes) ? classes : classes.split(" ");
                for (var matches = [], flagMap = {}, i = 0; i < classes.length; i++) {
                    var klass = classes[i], animationFactory = $animateProvider.$$registeredAnimations[klass];
                    animationFactory && !flagMap[klass] && (matches.push($injector.get(animationFactory)), 
                    flagMap[klass] = !0);
                }
                return matches;
            }
            var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);
            return function(element, event, classes, options) {
                function applyOptions() {
                    options.domOperation(), applyAnimationClasses(element, options);
                }
                function executeAnimationFn(fn, element, event, options, onDone) {
                    var args;
                    switch (event) {
                      case "animate":
                        args = [ element, options.from, options.to, onDone ];
                        break;

                      case "setClass":
                        args = [ element, classesToAdd, classesToRemove, onDone ];
                        break;

                      case "addClass":
                        args = [ element, classesToAdd, onDone ];
                        break;

                      case "removeClass":
                        args = [ element, classesToRemove, onDone ];
                        break;

                      default:
                        args = [ element, onDone ];
                    }
                    args.push(options);
                    var value = fn.apply(fn, args);
                    if (value) if (isFunction(value.start) && (value = value.start()), value instanceof $$AnimateRunner) value.done(onDone); else if (isFunction(value)) return value;
                    return noop;
                }
                function groupEventedAnimations(element, event, options, animations, fnName) {
                    var operations = [];
                    return forEach(animations, function(ani) {
                        var animation = ani[fnName];
                        animation && operations.push(function() {
                            var runner, endProgressCb, resolved = !1, onAnimationComplete = function(rejected) {
                                resolved || (resolved = !0, (endProgressCb || noop)(rejected), runner.complete(!rejected));
                            };
                            return runner = new $$AnimateRunner({
                                end: function() {
                                    onAnimationComplete();
                                },
                                cancel: function() {
                                    onAnimationComplete(!0);
                                }
                            }), endProgressCb = executeAnimationFn(animation, element, event, options, function(result) {
                                var cancelled = result === !1;
                                onAnimationComplete(cancelled);
                            }), runner;
                        });
                    }), operations;
                }
                function packageAnimations(element, event, options, animations, fnName) {
                    var operations = groupEventedAnimations(element, event, options, animations, fnName);
                    if (0 === operations.length) {
                        var a, b;
                        "beforeSetClass" === fnName ? (a = groupEventedAnimations(element, "removeClass", options, animations, "beforeRemoveClass"), 
                        b = groupEventedAnimations(element, "addClass", options, animations, "beforeAddClass")) : "setClass" === fnName && (a = groupEventedAnimations(element, "removeClass", options, animations, "removeClass"), 
                        b = groupEventedAnimations(element, "addClass", options, animations, "addClass")), 
                        a && (operations = operations.concat(a)), b && (operations = operations.concat(b));
                    }
                    if (0 !== operations.length) return function(callback) {
                        var runners = [];
                        return operations.length && forEach(operations, function(animateFn) {
                            runners.push(animateFn());
                        }), runners.length ? $$AnimateRunner.all(runners, callback) : callback(), function(reject) {
                            forEach(runners, function(runner) {
                                reject ? runner.cancel() : runner.end();
                            });
                        };
                    };
                }
                3 === arguments.length && isObject(classes) && (options = classes, classes = null), 
                options = prepareAnimationOptions(options), classes || (classes = element.attr("class") || "", 
                options.addClass && (classes += " " + options.addClass), options.removeClass && (classes += " " + options.removeClass));
                var before, after, classesToAdd = options.addClass, classesToRemove = options.removeClass, animations = lookupAnimations(classes);
                if (animations.length) {
                    var afterFn, beforeFn;
                    "leave" == event ? (beforeFn = "leave", afterFn = "afterLeave") : (beforeFn = "before" + event.charAt(0).toUpperCase() + event.substr(1), 
                    afterFn = event), "enter" !== event && "move" !== event && (before = packageAnimations(element, event, options, animations, beforeFn)), 
                    after = packageAnimations(element, event, options, animations, afterFn);
                }
                return before || after ? {
                    start: function() {
                        function onComplete(success) {
                            animationClosed = !0, applyOptions(), applyAnimationStyles(element, options), runner.complete(success);
                        }
                        function endAnimations(cancelled) {
                            animationClosed || ((closeActiveAnimations || noop)(cancelled), onComplete(cancelled));
                        }
                        var closeActiveAnimations, chain = [];
                        before && chain.push(function(fn) {
                            closeActiveAnimations = before(fn);
                        }), chain.length ? chain.push(function(fn) {
                            applyOptions(), fn(!0);
                        }) : applyOptions(), after && chain.push(function(fn) {
                            closeActiveAnimations = after(fn);
                        });
                        var animationClosed = !1, runner = new $$AnimateRunner({
                            end: function() {
                                endAnimations();
                            },
                            cancel: function() {
                                endAnimations(!0);
                            }
                        });
                        return $$AnimateRunner.chain(chain, onComplete), runner;
                    }
                } : void 0;
            };
        } ];
    } ], $$AnimateJsDriverProvider = [ "$$animationProvider", function($$animationProvider) {
        $$animationProvider.drivers.push("$$animateJsDriver"), this.$get = [ "$$animateJs", "$$AnimateRunner", function($$animateJs, $$AnimateRunner) {
            function prepareAnimation(animationDetails) {
                var element = animationDetails.element, event = animationDetails.event, options = animationDetails.options, classes = animationDetails.classes;
                return $$animateJs(element, event, classes, options);
            }
            return function(animationDetails) {
                if (animationDetails.from && animationDetails.to) {
                    var fromAnimation = prepareAnimation(animationDetails.from), toAnimation = prepareAnimation(animationDetails.to);
                    if (!fromAnimation && !toAnimation) return;
                    return {
                        start: function() {
                            function endFnFactory() {
                                return function() {
                                    forEach(animationRunners, function(runner) {
                                        runner.end();
                                    });
                                };
                            }
                            function done(status) {
                                runner.complete(status);
                            }
                            var animationRunners = [];
                            fromAnimation && animationRunners.push(fromAnimation.start()), toAnimation && animationRunners.push(toAnimation.start()), 
                            $$AnimateRunner.all(animationRunners, done);
                            var runner = new $$AnimateRunner({
                                end: endFnFactory(),
                                cancel: endFnFactory()
                            });
                            return runner;
                        }
                    };
                }
                return prepareAnimation(animationDetails);
            };
        } ];
    } ], NG_ANIMATE_ATTR_NAME = "data-ng-animate", NG_ANIMATE_PIN_DATA = "$ngAnimatePin", $$AnimateQueueProvider = [ "$animateProvider", function($animateProvider) {
        function isAllowed(ruleType, element, currentAnimation, previousAnimation) {
            return rules[ruleType].some(function(fn) {
                return fn(element, currentAnimation, previousAnimation);
            });
        }
        function hasAnimationClasses(options, and) {
            options = options || {};
            var a = (options.addClass || "").length > 0, b = (options.removeClass || "").length > 0;
            return and ? a && b : a || b;
        }
        var PRE_DIGEST_STATE = 1, RUNNING_STATE = 2, rules = this.rules = {
            skip: [],
            cancel: [],
            join: []
        };
        rules.join.push(function(element, newAnimation) {
            return !newAnimation.structural && hasAnimationClasses(newAnimation.options);
        }), rules.skip.push(function(element, newAnimation) {
            return !newAnimation.structural && !hasAnimationClasses(newAnimation.options);
        }), rules.skip.push(function(element, newAnimation, currentAnimation) {
            return "leave" == currentAnimation.event && newAnimation.structural;
        }), rules.skip.push(function(element, newAnimation, currentAnimation) {
            return currentAnimation.structural && currentAnimation.state === RUNNING_STATE && !newAnimation.structural;
        }), rules.cancel.push(function(element, newAnimation, currentAnimation) {
            return currentAnimation.structural && newAnimation.structural;
        }), rules.cancel.push(function(element, newAnimation, currentAnimation) {
            return currentAnimation.state === RUNNING_STATE && newAnimation.structural;
        }), rules.cancel.push(function(element, newAnimation, currentAnimation) {
            var nO = newAnimation.options, cO = currentAnimation.options;
            return nO.addClass && nO.addClass === cO.removeClass || nO.removeClass && nO.removeClass === cO.addClass;
        }), this.$get = [ "$$rAF", "$rootScope", "$rootElement", "$document", "$$HashMap", "$$animation", "$$AnimateRunner", "$templateRequest", "$$jqLite", "$$forceReflow", function($$rAF, $rootScope, $rootElement, $document, $$HashMap, $$animation, $$AnimateRunner, $templateRequest, $$jqLite) {
            function postDigestTaskFactory() {
                var postDigestCalled = !1;
                return function(fn) {
                    postDigestCalled ? fn() : $rootScope.$$postDigest(function() {
                        postDigestCalled = !0, fn();
                    });
                };
            }
            function normalizeAnimationOptions(element, options) {
                return mergeAnimationOptions(element, options, {});
            }
            function findCallbacks(element, event) {
                var targetNode = getDomNode(element), matches = [], entries = callbackRegistry[event];
                return entries && forEach(entries, function(entry) {
                    entry.node.contains(targetNode) && matches.push(entry.callback);
                }), matches;
            }
            function queueAnimation(element, event, options) {
                function notifyProgress(runner, event, phase, data) {
                    runInNextPostDigestOrNow(function() {
                        var callbacks = findCallbacks(element, event);
                        callbacks.length && $$rAF(function() {
                            forEach(callbacks, function(callback) {
                                callback(element, phase, data);
                            });
                        });
                    }), runner.progress(event, phase, data);
                }
                function close(reject) {
                    clearGeneratedClasses(element, options), applyAnimationClasses(element, options), 
                    applyAnimationStyles(element, options), options.domOperation(), runner.complete(!reject);
                }
                var node, parent;
                element = stripCommentsFromElement(element), element && (node = getDomNode(element), 
                parent = element.parent()), options = prepareAnimationOptions(options);
                var runner = new $$AnimateRunner(), runInNextPostDigestOrNow = postDigestTaskFactory();
                if (isArray(options.addClass) && (options.addClass = options.addClass.join(" ")), 
                options.addClass && !isString(options.addClass) && (options.addClass = null), isArray(options.removeClass) && (options.removeClass = options.removeClass.join(" ")), 
                options.removeClass && !isString(options.removeClass) && (options.removeClass = null), 
                options.from && !isObject(options.from) && (options.from = null), options.to && !isObject(options.to) && (options.to = null), 
                !node) return close(), runner;
                var className = [ node.className, options.addClass, options.removeClass ].join(" ");
                if (!isAnimatableClassName(className)) return close(), runner;
                var isStructural = [ "enter", "move", "leave" ].indexOf(event) >= 0, skipAnimations = !animationsEnabled || disabledElementsLookup.get(node), existingAnimation = !skipAnimations && activeAnimationsLookup.get(node) || {}, hasExistingAnimation = !!existingAnimation.state;
                if (skipAnimations || hasExistingAnimation && existingAnimation.state == PRE_DIGEST_STATE || (skipAnimations = !areAnimationsAllowed(element, parent, event)), 
                skipAnimations) return close(), runner;
                isStructural && closeChildAnimations(element);
                var newAnimation = {
                    structural: isStructural,
                    element: element,
                    event: event,
                    close: close,
                    options: options,
                    runner: runner
                };
                if (hasExistingAnimation) {
                    var skipAnimationFlag = isAllowed("skip", element, newAnimation, existingAnimation);
                    if (skipAnimationFlag) return existingAnimation.state === RUNNING_STATE ? (close(), 
                    runner) : (mergeAnimationOptions(element, existingAnimation.options, options), existingAnimation.runner);
                    var cancelAnimationFlag = isAllowed("cancel", element, newAnimation, existingAnimation);
                    if (cancelAnimationFlag) if (existingAnimation.state === RUNNING_STATE) existingAnimation.runner.end(); else {
                        if (!existingAnimation.structural) return mergeAnimationOptions(element, existingAnimation.options, newAnimation.options), 
                        existingAnimation.runner;
                        existingAnimation.close();
                    } else {
                        var joinAnimationFlag = isAllowed("join", element, newAnimation, existingAnimation);
                        if (joinAnimationFlag) {
                            if (existingAnimation.state !== RUNNING_STATE) return applyGeneratedPreparationClasses(element, isStructural ? event : null, options), 
                            event = newAnimation.event = existingAnimation.event, options = mergeAnimationOptions(element, existingAnimation.options, newAnimation.options), 
                            existingAnimation.runner;
                            normalizeAnimationOptions(element, options);
                        }
                    }
                } else normalizeAnimationOptions(element, options);
                var isValidAnimation = newAnimation.structural;
                if (isValidAnimation || (isValidAnimation = "animate" === newAnimation.event && Object.keys(newAnimation.options.to || {}).length > 0 || hasAnimationClasses(newAnimation.options)), 
                !isValidAnimation) return close(), clearElementAnimationState(element), runner;
                var counter = (existingAnimation.counter || 0) + 1;
                return newAnimation.counter = counter, markElementAnimationState(element, PRE_DIGEST_STATE, newAnimation), 
                $rootScope.$$postDigest(function() {
                    var animationDetails = activeAnimationsLookup.get(node), animationCancelled = !animationDetails;
                    animationDetails = animationDetails || {};
                    var parentElement = element.parent() || [], isValidAnimation = parentElement.length > 0 && ("animate" === animationDetails.event || animationDetails.structural || hasAnimationClasses(animationDetails.options));
                    if (animationCancelled || animationDetails.counter !== counter || !isValidAnimation) return animationCancelled && (applyAnimationClasses(element, options), 
                    applyAnimationStyles(element, options)), (animationCancelled || isStructural && animationDetails.event !== event) && (options.domOperation(), 
                    runner.end()), void (isValidAnimation || clearElementAnimationState(element));
                    event = !animationDetails.structural && hasAnimationClasses(animationDetails.options, !0) ? "setClass" : animationDetails.event, 
                    markElementAnimationState(element, RUNNING_STATE);
                    var realRunner = $$animation(element, event, animationDetails.options);
                    realRunner.done(function(status) {
                        close(!status);
                        var animationDetails = activeAnimationsLookup.get(node);
                        animationDetails && animationDetails.counter === counter && clearElementAnimationState(getDomNode(element)), 
                        notifyProgress(runner, event, "close", {});
                    }), runner.setHost(realRunner), notifyProgress(runner, event, "start", {});
                }), runner;
            }
            function closeChildAnimations(element) {
                var node = getDomNode(element), children = node.querySelectorAll("[" + NG_ANIMATE_ATTR_NAME + "]");
                forEach(children, function(child) {
                    var state = parseInt(child.getAttribute(NG_ANIMATE_ATTR_NAME)), animationDetails = activeAnimationsLookup.get(child);
                    switch (state) {
                      case RUNNING_STATE:
                        animationDetails.runner.end();

                      case PRE_DIGEST_STATE:
                        animationDetails && activeAnimationsLookup.remove(child);
                    }
                });
            }
            function clearElementAnimationState(element) {
                var node = getDomNode(element);
                node.removeAttribute(NG_ANIMATE_ATTR_NAME), activeAnimationsLookup.remove(node);
            }
            function isMatchingElement(nodeOrElmA, nodeOrElmB) {
                return getDomNode(nodeOrElmA) === getDomNode(nodeOrElmB);
            }
            function areAnimationsAllowed(element, parentElement) {
                var animateChildren, bodyElement = jqLite($document[0].body), bodyElementDetected = isMatchingElement(element, bodyElement) || "HTML" === element[0].nodeName, rootElementDetected = isMatchingElement(element, $rootElement), parentAnimationDetected = !1, parentHost = element.data(NG_ANIMATE_PIN_DATA);
                for (parentHost && (parentElement = parentHost); parentElement && parentElement.length; ) {
                    rootElementDetected || (rootElementDetected = isMatchingElement(parentElement, $rootElement));
                    var parentNode = parentElement[0];
                    if (parentNode.nodeType !== ELEMENT_NODE) break;
                    var details = activeAnimationsLookup.get(parentNode) || {};
                    if (parentAnimationDetected || (parentAnimationDetected = details.structural || disabledElementsLookup.get(parentNode)), 
                    isUndefined(animateChildren) || animateChildren === !0) {
                        var value = parentElement.data(NG_ANIMATE_CHILDREN_DATA);
                        isDefined(value) && (animateChildren = value);
                    }
                    if (parentAnimationDetected && animateChildren === !1) break;
                    rootElementDetected || (rootElementDetected = isMatchingElement(parentElement, $rootElement), 
                    rootElementDetected || (parentHost = parentElement.data(NG_ANIMATE_PIN_DATA), parentHost && (parentElement = parentHost))), 
                    bodyElementDetected || (bodyElementDetected = isMatchingElement(parentElement, bodyElement)), 
                    parentElement = parentElement.parent();
                }
                var allowAnimation = !parentAnimationDetected || animateChildren;
                return allowAnimation && rootElementDetected && bodyElementDetected;
            }
            function markElementAnimationState(element, state, details) {
                details = details || {}, details.state = state;
                var node = getDomNode(element);
                node.setAttribute(NG_ANIMATE_ATTR_NAME, state);
                var oldValue = activeAnimationsLookup.get(node), newValue = oldValue ? extend(oldValue, details) : details;
                activeAnimationsLookup.put(node, newValue);
            }
            var activeAnimationsLookup = new $$HashMap(), disabledElementsLookup = new $$HashMap(), animationsEnabled = null, deregisterWatch = $rootScope.$watch(function() {
                return 0 === $templateRequest.totalPendingRequests;
            }, function(isEmpty) {
                isEmpty && (deregisterWatch(), $rootScope.$$postDigest(function() {
                    $rootScope.$$postDigest(function() {
                        null === animationsEnabled && (animationsEnabled = !0);
                    });
                }));
            }), callbackRegistry = {}, classNameFilter = $animateProvider.classNameFilter(), isAnimatableClassName = classNameFilter ? function(className) {
                return classNameFilter.test(className);
            } : function() {
                return !0;
            }, applyAnimationClasses = applyAnimationClassesFactory($$jqLite);
            return {
                on: function(event, container, callback) {
                    var node = extractElementNode(container);
                    callbackRegistry[event] = callbackRegistry[event] || [], callbackRegistry[event].push({
                        node: node,
                        callback: callback
                    });
                },
                off: function(event, container, callback) {
                    function filterFromRegistry(list, matchContainer, matchCallback) {
                        var containerNode = extractElementNode(matchContainer);
                        return list.filter(function(entry) {
                            var isMatch = entry.node === containerNode && (!matchCallback || entry.callback === matchCallback);
                            return !isMatch;
                        });
                    }
                    var entries = callbackRegistry[event];
                    entries && (callbackRegistry[event] = 1 === arguments.length ? null : filterFromRegistry(entries, container, callback));
                },
                pin: function(element, parentElement) {
                    assertArg(isElement(element), "element", "not an element"), assertArg(isElement(parentElement), "parentElement", "not an element"), 
                    element.data(NG_ANIMATE_PIN_DATA, parentElement);
                },
                push: function(element, event, options, domOperation) {
                    return options = options || {}, options.domOperation = domOperation, queueAnimation(element, event, options);
                },
                enabled: function(element, bool) {
                    var argCount = arguments.length;
                    if (0 === argCount) bool = !!animationsEnabled; else {
                        var hasElement = isElement(element);
                        if (hasElement) {
                            var node = getDomNode(element), recordExists = disabledElementsLookup.get(node);
                            1 === argCount ? bool = !recordExists : (bool = !!bool, bool ? recordExists && disabledElementsLookup.remove(node) : disabledElementsLookup.put(node, !0));
                        } else bool = animationsEnabled = !!element;
                    }
                    return bool;
                }
            };
        } ];
    } ], $$AnimateAsyncRunFactory = [ "$$rAF", function($$rAF) {
        function waitForTick(fn) {
            waitQueue.push(fn), waitQueue.length > 1 || $$rAF(function() {
                for (var i = 0; i < waitQueue.length; i++) waitQueue[i]();
                waitQueue = [];
            });
        }
        var waitQueue = [];
        return function() {
            var passed = !1;
            return waitForTick(function() {
                passed = !0;
            }), function(callback) {
                passed ? callback() : waitForTick(callback);
            };
        };
    } ], $$AnimateRunnerFactory = [ "$q", "$sniffer", "$$animateAsyncRun", function($q, $sniffer, $$animateAsyncRun) {
        function AnimateRunner(host) {
            this.setHost(host), this._doneCallbacks = [], this._runInAnimationFrame = $$animateAsyncRun(), 
            this._state = 0;
        }
        var INITIAL_STATE = 0, DONE_PENDING_STATE = 1, DONE_COMPLETE_STATE = 2;
        return AnimateRunner.chain = function(chain, callback) {
            function next() {
                return index === chain.length ? void callback(!0) : void chain[index](function(response) {
                    return response === !1 ? void callback(!1) : (index++, void next());
                });
            }
            var index = 0;
            next();
        }, AnimateRunner.all = function(runners, callback) {
            function onProgress(response) {
                status = status && response, ++count === runners.length && callback(status);
            }
            var count = 0, status = !0;
            forEach(runners, function(runner) {
                runner.done(onProgress);
            });
        }, AnimateRunner.prototype = {
            setHost: function(host) {
                this.host = host || {};
            },
            done: function(fn) {
                this._state === DONE_COMPLETE_STATE ? fn() : this._doneCallbacks.push(fn);
            },
            progress: noop,
            getPromise: function() {
                if (!this.promise) {
                    var self = this;
                    this.promise = $q(function(resolve, reject) {
                        self.done(function(status) {
                            status === !1 ? reject() : resolve();
                        });
                    });
                }
                return this.promise;
            },
            then: function(resolveHandler, rejectHandler) {
                return this.getPromise().then(resolveHandler, rejectHandler);
            },
            "catch": function(handler) {
                return this.getPromise()["catch"](handler);
            },
            "finally": function(handler) {
                return this.getPromise()["finally"](handler);
            },
            pause: function() {
                this.host.pause && this.host.pause();
            },
            resume: function() {
                this.host.resume && this.host.resume();
            },
            end: function() {
                this.host.end && this.host.end(), this._resolve(!0);
            },
            cancel: function() {
                this.host.cancel && this.host.cancel(), this._resolve(!1);
            },
            complete: function(response) {
                var self = this;
                self._state === INITIAL_STATE && (self._state = DONE_PENDING_STATE, self._runInAnimationFrame(function() {
                    self._resolve(response);
                }));
            },
            _resolve: function(response) {
                this._state !== DONE_COMPLETE_STATE && (forEach(this._doneCallbacks, function(fn) {
                    fn(response);
                }), this._doneCallbacks.length = 0, this._state = DONE_COMPLETE_STATE);
            }
        }, AnimateRunner;
    } ], $$AnimationProvider = [ "$animateProvider", function() {
        function setRunner(element, runner) {
            element.data(RUNNER_STORAGE_KEY, runner);
        }
        function removeRunner(element) {
            element.removeData(RUNNER_STORAGE_KEY);
        }
        function getRunner(element) {
            return element.data(RUNNER_STORAGE_KEY);
        }
        var NG_ANIMATE_REF_ATTR = "ng-animate-ref", drivers = this.drivers = [], RUNNER_STORAGE_KEY = "$$animationRunner";
        this.$get = [ "$$jqLite", "$rootScope", "$injector", "$$AnimateRunner", "$$HashMap", "$$rAFScheduler", function($$jqLite, $rootScope, $injector, $$AnimateRunner, $$HashMap, $$rAFScheduler) {
            function sortAnimations(animations) {
                function processNode(entry) {
                    if (entry.processed) return entry;
                    entry.processed = !0;
                    var elementNode = entry.domNode, parentNode = elementNode.parentNode;
                    lookup.put(elementNode, entry);
                    for (var parentEntry; parentNode; ) {
                        if (parentEntry = lookup.get(parentNode)) {
                            parentEntry.processed || (parentEntry = processNode(parentEntry));
                            break;
                        }
                        parentNode = parentNode.parentNode;
                    }
                    return (parentEntry || tree).children.push(entry), entry;
                }
                function flatten(tree) {
                    var i, result = [], queue = [];
                    for (i = 0; i < tree.children.length; i++) queue.push(tree.children[i]);
                    var remainingLevelEntries = queue.length, nextLevelEntries = 0, row = [];
                    for (i = 0; i < queue.length; i++) {
                        var entry = queue[i];
                        0 >= remainingLevelEntries && (remainingLevelEntries = nextLevelEntries, nextLevelEntries = 0, 
                        result.push(row), row = []), row.push(entry.fn), entry.children.forEach(function(childEntry) {
                            nextLevelEntries++, queue.push(childEntry);
                        }), remainingLevelEntries--;
                    }
                    return row.length && result.push(row), result;
                }
                var i, tree = {
                    children: []
                }, lookup = new $$HashMap();
                for (i = 0; i < animations.length; i++) {
                    var animation = animations[i];
                    lookup.put(animation.domNode, animations[i] = {
                        domNode: animation.domNode,
                        fn: animation.fn,
                        children: []
                    });
                }
                for (i = 0; i < animations.length; i++) processNode(animations[i]);
                return flatten(tree);
            }
            var animationQueue = [], applyAnimationClasses = applyAnimationClassesFactory($$jqLite);
            return function(element, event, options) {
                function getAnchorNodes(node) {
                    var SELECTOR = "[" + NG_ANIMATE_REF_ATTR + "]", items = node.hasAttribute(NG_ANIMATE_REF_ATTR) ? [ node ] : node.querySelectorAll(SELECTOR), anchors = [];
                    return forEach(items, function(node) {
                        var attr = node.getAttribute(NG_ANIMATE_REF_ATTR);
                        attr && attr.length && anchors.push(node);
                    }), anchors;
                }
                function groupAnimations(animations) {
                    var preparedAnimations = [], refLookup = {};
                    forEach(animations, function(animation, index) {
                        var element = animation.element, node = getDomNode(element), event = animation.event, enterOrMove = [ "enter", "move" ].indexOf(event) >= 0, anchorNodes = animation.structural ? getAnchorNodes(node) : [];
                        if (anchorNodes.length) {
                            var direction = enterOrMove ? "to" : "from";
                            forEach(anchorNodes, function(anchor) {
                                var key = anchor.getAttribute(NG_ANIMATE_REF_ATTR);
                                refLookup[key] = refLookup[key] || {}, refLookup[key][direction] = {
                                    animationID: index,
                                    element: jqLite(anchor)
                                };
                            });
                        } else preparedAnimations.push(animation);
                    });
                    var usedIndicesLookup = {}, anchorGroups = {};
                    return forEach(refLookup, function(operations) {
                        var from = operations.from, to = operations.to;
                        if (!from || !to) {
                            var index = from ? from.animationID : to.animationID, indexKey = index.toString();
                            return void (usedIndicesLookup[indexKey] || (usedIndicesLookup[indexKey] = !0, preparedAnimations.push(animations[index])));
                        }
                        var fromAnimation = animations[from.animationID], toAnimation = animations[to.animationID], lookupKey = from.animationID.toString();
                        if (!anchorGroups[lookupKey]) {
                            var group = anchorGroups[lookupKey] = {
                                structural: !0,
                                beforeStart: function() {
                                    fromAnimation.beforeStart(), toAnimation.beforeStart();
                                },
                                close: function() {
                                    fromAnimation.close(), toAnimation.close();
                                },
                                classes: cssClassesIntersection(fromAnimation.classes, toAnimation.classes),
                                from: fromAnimation,
                                to: toAnimation,
                                anchors: []
                            };
                            group.classes.length ? preparedAnimations.push(group) : (preparedAnimations.push(fromAnimation), 
                            preparedAnimations.push(toAnimation));
                        }
                        anchorGroups[lookupKey].anchors.push({
                            out: from.element,
                            "in": to.element
                        });
                    }), preparedAnimations;
                }
                function cssClassesIntersection(a, b) {
                    a = a.split(" "), b = b.split(" ");
                    for (var matches = [], i = 0; i < a.length; i++) {
                        var aa = a[i];
                        if ("ng-" !== aa.substring(0, 3)) for (var j = 0; j < b.length; j++) if (aa === b[j]) {
                            matches.push(aa);
                            break;
                        }
                    }
                    return matches.join(" ");
                }
                function invokeFirstDriver(animationDetails) {
                    for (var i = drivers.length - 1; i >= 0; i--) {
                        var driverName = drivers[i];
                        if ($injector.has(driverName)) {
                            var factory = $injector.get(driverName), driver = factory(animationDetails);
                            if (driver) return driver;
                        }
                    }
                }
                function beforeStart() {
                    element.addClass(NG_ANIMATE_CLASSNAME), tempClasses && $$jqLite.addClass(element, tempClasses);
                }
                function updateAnimationRunners(animation, newRunner) {
                    function update(element) {
                        getRunner(element).setHost(newRunner);
                    }
                    animation.from && animation.to ? (update(animation.from.element), update(animation.to.element)) : update(animation.element);
                }
                function handleDestroyedElement() {
                    var runner = getRunner(element);
                    !runner || "leave" === event && options.$$domOperationFired || runner.end();
                }
                function close(rejected) {
                    element.off("$destroy", handleDestroyedElement), removeRunner(element), applyAnimationClasses(element, options), 
                    applyAnimationStyles(element, options), options.domOperation(), tempClasses && $$jqLite.removeClass(element, tempClasses), 
                    element.removeClass(NG_ANIMATE_CLASSNAME), runner.complete(!rejected);
                }
                options = prepareAnimationOptions(options);
                var isStructural = [ "enter", "move", "leave" ].indexOf(event) >= 0, runner = new $$AnimateRunner({
                    end: function() {
                        close();
                    },
                    cancel: function() {
                        close(!0);
                    }
                });
                if (!drivers.length) return close(), runner;
                setRunner(element, runner);
                var classes = mergeClasses(element.attr("class"), mergeClasses(options.addClass, options.removeClass)), tempClasses = options.tempClasses;
                return tempClasses && (classes += " " + tempClasses, options.tempClasses = null), 
                animationQueue.push({
                    element: element,
                    classes: classes,
                    event: event,
                    structural: isStructural,
                    options: options,
                    beforeStart: beforeStart,
                    close: close
                }), element.on("$destroy", handleDestroyedElement), animationQueue.length > 1 ? runner : ($rootScope.$$postDigest(function() {
                    var animations = [];
                    forEach(animationQueue, function(entry) {
                        getRunner(entry.element) ? animations.push(entry) : entry.close();
                    }), animationQueue.length = 0;
                    var groupedAnimations = groupAnimations(animations), toBeSortedAnimations = [];
                    forEach(groupedAnimations, function(animationEntry) {
                        toBeSortedAnimations.push({
                            domNode: getDomNode(animationEntry.from ? animationEntry.from.element : animationEntry.element),
                            fn: function() {
                                animationEntry.beforeStart();
                                var startAnimationFn, closeFn = animationEntry.close, targetElement = animationEntry.anchors ? animationEntry.from.element || animationEntry.to.element : animationEntry.element;
                                if (getRunner(targetElement)) {
                                    var operation = invokeFirstDriver(animationEntry);
                                    operation && (startAnimationFn = operation.start);
                                }
                                if (startAnimationFn) {
                                    var animationRunner = startAnimationFn();
                                    animationRunner.done(function(status) {
                                        closeFn(!status);
                                    }), updateAnimationRunners(animationEntry, animationRunner);
                                } else closeFn();
                            }
                        });
                    }), $$rAFScheduler(sortAnimations(toBeSortedAnimations));
                }), runner);
            };
        } ];
    } ];
    angular.module("ngAnimate", []).directive("ngAnimateChildren", $$AnimateChildrenDirective).factory("$$rAFScheduler", $$rAFSchedulerFactory).factory("$$AnimateRunner", $$AnimateRunnerFactory).factory("$$animateAsyncRun", $$AnimateAsyncRunFactory).provider("$$animateQueue", $$AnimateQueueProvider).provider("$$animation", $$AnimationProvider).provider("$animateCss", $AnimateCssProvider).provider("$$animateCssDriver", $$AnimateCssDriverProvider).provider("$$animateJs", $$AnimateJsProvider).provider("$$animateJsDriver", $$AnimateJsDriverProvider);
}(window, window.angular), define("ngdir/angular-animate", [ "angular" ], function() {}), 
"undefined" != typeof module && "undefined" != typeof exports && module.exports === exports && (module.exports = "ui.router"), 
function(window, angular, undefined) {
    function inherit(parent, extra) {
        return extend(new (extend(function() {}, {
            prototype: parent
        }))(), extra);
    }
    function merge(dst) {
        return forEach(arguments, function(obj) {
            obj !== dst && forEach(obj, function(value, key) {
                dst.hasOwnProperty(key) || (dst[key] = value);
            });
        }), dst;
    }
    function ancestors(first, second) {
        var path = [];
        for (var n in first.path) {
            if (first.path[n] !== second.path[n]) break;
            path.push(first.path[n]);
        }
        return path;
    }
    function objectKeys(object) {
        if (Object.keys) return Object.keys(object);
        var result = [];
        return forEach(object, function(val, key) {
            result.push(key);
        }), result;
    }
    function indexOf(array, value) {
        if (Array.prototype.indexOf) return array.indexOf(value, Number(arguments[2]) || 0);
        var len = array.length >>> 0, from = Number(arguments[2]) || 0;
        for (from = 0 > from ? Math.ceil(from) : Math.floor(from), 0 > from && (from += len); len > from; from++) if (from in array && array[from] === value) return from;
        return -1;
    }
    function inheritParams(currentParams, newParams, $current, $to) {
        var parentParams, parents = ancestors($current, $to), inherited = {}, inheritList = [];
        for (var i in parents) if (parents[i].params && (parentParams = objectKeys(parents[i].params), 
        parentParams.length)) for (var j in parentParams) indexOf(inheritList, parentParams[j]) >= 0 || (inheritList.push(parentParams[j]), 
        inherited[parentParams[j]] = currentParams[parentParams[j]]);
        return extend({}, inherited, newParams);
    }
    function equalForKeys(a, b, keys) {
        if (!keys) {
            keys = [];
            for (var n in a) keys.push(n);
        }
        for (var i = 0; i < keys.length; i++) {
            var k = keys[i];
            if (a[k] != b[k]) return !1;
        }
        return !0;
    }
    function filterByKeys(keys, values) {
        var filtered = {};
        return forEach(keys, function(name) {
            filtered[name] = values[name];
        }), filtered;
    }
    function pick(obj) {
        var copy = {}, keys = Array.prototype.concat.apply(Array.prototype, Array.prototype.slice.call(arguments, 1));
        return forEach(keys, function(key) {
            key in obj && (copy[key] = obj[key]);
        }), copy;
    }
    function omit(obj) {
        var copy = {}, keys = Array.prototype.concat.apply(Array.prototype, Array.prototype.slice.call(arguments, 1));
        for (var key in obj) -1 == indexOf(keys, key) && (copy[key] = obj[key]);
        return copy;
    }
    function filter(collection, callback) {
        var array = isArray(collection), result = array ? [] : {};
        return forEach(collection, function(val, i) {
            callback(val, i) && (result[array ? result.length : i] = val);
        }), result;
    }
    function map(collection, callback) {
        var result = isArray(collection) ? [] : {};
        return forEach(collection, function(val, i) {
            result[i] = callback(val, i);
        }), result;
    }
    function $Resolve($q, $injector) {
        var VISIT_IN_PROGRESS = 1, VISIT_DONE = 2, NOTHING = {}, NO_DEPENDENCIES = [], NO_LOCALS = NOTHING, NO_PARENT = extend($q.when(NOTHING), {
            $$promises: NOTHING,
            $$values: NOTHING
        });
        this.study = function(invocables) {
            function visit(value, key) {
                if (visited[key] !== VISIT_DONE) {
                    if (cycle.push(key), visited[key] === VISIT_IN_PROGRESS) throw cycle.splice(0, indexOf(cycle, key)), 
                    new Error("Cyclic dependency: " + cycle.join(" -> "));
                    if (visited[key] = VISIT_IN_PROGRESS, isString(value)) plan.push(key, [ function() {
                        return $injector.get(value);
                    } ], NO_DEPENDENCIES); else {
                        var params = $injector.annotate(value);
                        forEach(params, function(param) {
                            param !== key && invocables.hasOwnProperty(param) && visit(invocables[param], param);
                        }), plan.push(key, value, params);
                    }
                    cycle.pop(), visited[key] = VISIT_DONE;
                }
            }
            function isResolve(value) {
                return isObject(value) && value.then && value.$$promises;
            }
            if (!isObject(invocables)) throw new Error("'invocables' must be an object");
            var invocableKeys = objectKeys(invocables || {}), plan = [], cycle = [], visited = {};
            return forEach(invocables, visit), invocables = cycle = visited = null, function(locals, parent, self) {
                function done() {
                    --wait || (merged || merge(values, parent.$$values), result.$$values = values, result.$$promises = result.$$promises || !0, 
                    delete result.$$inheritedValues, resolution.resolve(values));
                }
                function fail(reason) {
                    result.$$failure = reason, resolution.reject(reason);
                }
                function invoke(key, invocable, params) {
                    function onfailure(reason) {
                        invocation.reject(reason), fail(reason);
                    }
                    function proceed() {
                        if (!isDefined(result.$$failure)) try {
                            invocation.resolve($injector.invoke(invocable, self, values)), invocation.promise.then(function(result) {
                                values[key] = result, done();
                            }, onfailure);
                        } catch (e) {
                            onfailure(e);
                        }
                    }
                    var invocation = $q.defer(), waitParams = 0;
                    forEach(params, function(dep) {
                        promises.hasOwnProperty(dep) && !locals.hasOwnProperty(dep) && (waitParams++, promises[dep].then(function(result) {
                            values[dep] = result, --waitParams || proceed();
                        }, onfailure));
                    }), waitParams || proceed(), promises[key] = invocation.promise;
                }
                if (isResolve(locals) && self === undefined && (self = parent, parent = locals, 
                locals = null), locals) {
                    if (!isObject(locals)) throw new Error("'locals' must be an object");
                } else locals = NO_LOCALS;
                if (parent) {
                    if (!isResolve(parent)) throw new Error("'parent' must be a promise returned by $resolve.resolve()");
                } else parent = NO_PARENT;
                var resolution = $q.defer(), result = resolution.promise, promises = result.$$promises = {}, values = extend({}, locals), wait = 1 + plan.length / 3, merged = !1;
                if (isDefined(parent.$$failure)) return fail(parent.$$failure), result;
                parent.$$inheritedValues && merge(values, omit(parent.$$inheritedValues, invocableKeys)), 
                extend(promises, parent.$$promises), parent.$$values ? (merged = merge(values, omit(parent.$$values, invocableKeys)), 
                result.$$inheritedValues = omit(parent.$$values, invocableKeys), done()) : (parent.$$inheritedValues && (result.$$inheritedValues = omit(parent.$$inheritedValues, invocableKeys)), 
                parent.then(done, fail));
                for (var i = 0, ii = plan.length; ii > i; i += 3) locals.hasOwnProperty(plan[i]) ? done() : invoke(plan[i], plan[i + 1], plan[i + 2]);
                return result;
            };
        }, this.resolve = function(invocables, locals, parent, self) {
            return this.study(invocables)(locals, parent, self);
        };
    }
    function $TemplateFactory($http, $templateCache, $injector) {
        this.fromConfig = function(config, params, locals) {
            return isDefined(config.template) ? this.fromString(config.template, params) : isDefined(config.templateUrl) ? this.fromUrl(config.templateUrl, params) : isDefined(config.templateProvider) ? this.fromProvider(config.templateProvider, params, locals) : null;
        }, this.fromString = function(template, params) {
            return isFunction(template) ? template(params) : template;
        }, this.fromUrl = function(url, params) {
            return isFunction(url) && (url = url(params)), null == url ? null : $http.get(url, {
                cache: $templateCache,
                headers: {
                    Accept: "text/html"
                }
            }).then(function(response) {
                return response.data;
            });
        }, this.fromProvider = function(provider, params, locals) {
            return $injector.invoke(provider, null, locals || {
                params: params
            });
        };
    }
    function UrlMatcher(pattern, config, parentMatcher) {
        function addParameter(id, type, config, location) {
            if (paramNames.push(id), parentParams[id]) return parentParams[id];
            if (!/^\w+(-+\w+)*(?:\[\])?$/.test(id)) throw new Error("Invalid parameter name '" + id + "' in pattern '" + pattern + "'");
            if (params[id]) throw new Error("Duplicate parameter name '" + id + "' in pattern '" + pattern + "'");
            return params[id] = new $$UMFP.Param(id, type, config, location), params[id];
        }
        function quoteRegExp(string, pattern, squash, optional) {
            var surroundPattern = [ "", "" ], result = string.replace(/[\\\[\]\^$*+?.()|{}]/g, "\\$&");
            if (!pattern) return result;
            switch (squash) {
              case !1:
                surroundPattern = [ "(", ")" + (optional ? "?" : "") ];
                break;

              case !0:
                surroundPattern = [ "?(", ")?" ];
                break;

              default:
                surroundPattern = [ "(" + squash + "|", ")?" ];
            }
            return result + surroundPattern[0] + pattern + surroundPattern[1];
        }
        function matchDetails(m, isSearch) {
            var id, regexp, segment, type, cfg;
            return id = m[2] || m[3], cfg = config.params[id], segment = pattern.substring(last, m.index), 
            regexp = isSearch ? m[4] : m[4] || ("*" == m[1] ? ".*" : null), type = $$UMFP.type(regexp || "string") || inherit($$UMFP.type("string"), {
                pattern: new RegExp(regexp, config.caseInsensitive ? "i" : undefined)
            }), {
                id: id,
                regexp: regexp,
                segment: segment,
                type: type,
                cfg: cfg
            };
        }
        config = extend({
            params: {}
        }, isObject(config) ? config : {});
        var m, placeholder = /([:*])([\w\[\]]+)|\{([\w\[\]]+)(?:\:((?:[^{}\\]+|\\.|\{(?:[^{}\\]+|\\.)*\})+))?\}/g, searchPlaceholder = /([:]?)([\w\[\]-]+)|\{([\w\[\]-]+)(?:\:((?:[^{}\\]+|\\.|\{(?:[^{}\\]+|\\.)*\})+))?\}/g, compiled = "^", last = 0, segments = this.segments = [], parentParams = parentMatcher ? parentMatcher.params : {}, params = this.params = parentMatcher ? parentMatcher.params.$$new() : new $$UMFP.ParamSet(), paramNames = [];
        this.source = pattern;
        for (var p, param, segment; (m = placeholder.exec(pattern)) && (p = matchDetails(m, !1), 
        !(p.segment.indexOf("?") >= 0)); ) param = addParameter(p.id, p.type, p.cfg, "path"), 
        compiled += quoteRegExp(p.segment, param.type.pattern.source, param.squash, param.isOptional), 
        segments.push(p.segment), last = placeholder.lastIndex;
        segment = pattern.substring(last);
        var i = segment.indexOf("?");
        if (i >= 0) {
            var search = this.sourceSearch = segment.substring(i);
            if (segment = segment.substring(0, i), this.sourcePath = pattern.substring(0, last + i), 
            search.length > 0) for (last = 0; m = searchPlaceholder.exec(search); ) p = matchDetails(m, !0), 
            param = addParameter(p.id, p.type, p.cfg, "search"), last = placeholder.lastIndex;
        } else this.sourcePath = pattern, this.sourceSearch = "";
        compiled += quoteRegExp(segment) + (config.strict === !1 ? "/?" : "") + "$", segments.push(segment), 
        this.regexp = new RegExp(compiled, config.caseInsensitive ? "i" : undefined), this.prefix = segments[0], 
        this.$$paramNames = paramNames;
    }
    function Type(config) {
        extend(this, config);
    }
    function $UrlMatcherFactory() {
        function valToString(val) {
            return null != val ? val.toString().replace(/\//g, "%2F") : val;
        }
        function valFromString(val) {
            return null != val ? val.toString().replace(/%2F/g, "/") : val;
        }
        function getDefaultConfig() {
            return {
                strict: isStrictMode,
                caseInsensitive: isCaseInsensitive
            };
        }
        function isInjectable(value) {
            return isFunction(value) || isArray(value) && isFunction(value[value.length - 1]);
        }
        function flushTypeQueue() {
            for (;typeQueue.length; ) {
                var type = typeQueue.shift();
                if (type.pattern) throw new Error("You cannot override a type's .pattern at runtime.");
                angular.extend($types[type.name], injector.invoke(type.def));
            }
        }
        function ParamSet(params) {
            extend(this, params || {});
        }
        $$UMFP = this;
        var injector, isCaseInsensitive = !1, isStrictMode = !0, defaultSquashPolicy = !1, $types = {}, enqueue = !0, typeQueue = [], defaultTypes = {
            string: {
                encode: valToString,
                decode: valFromString,
                is: function(val) {
                    return null == val || !isDefined(val) || "string" == typeof val;
                },
                pattern: /[^\/]*/
            },
            "int": {
                encode: valToString,
                decode: function(val) {
                    return parseInt(val, 10);
                },
                is: function(val) {
                    return isDefined(val) && this.decode(val.toString()) === val;
                },
                pattern: /\d+/
            },
            bool: {
                encode: function(val) {
                    return val ? 1 : 0;
                },
                decode: function(val) {
                    return 0 !== parseInt(val, 10);
                },
                is: function(val) {
                    return val === !0 || val === !1;
                },
                pattern: /0|1/
            },
            date: {
                encode: function(val) {
                    return this.is(val) ? [ val.getFullYear(), ("0" + (val.getMonth() + 1)).slice(-2), ("0" + val.getDate()).slice(-2) ].join("-") : undefined;
                },
                decode: function(val) {
                    if (this.is(val)) return val;
                    var match = this.capture.exec(val);
                    return match ? new Date(match[1], match[2] - 1, match[3]) : undefined;
                },
                is: function(val) {
                    return val instanceof Date && !isNaN(val.valueOf());
                },
                equals: function(a, b) {
                    return this.is(a) && this.is(b) && a.toISOString() === b.toISOString();
                },
                pattern: /[0-9]{4}-(?:0[1-9]|1[0-2])-(?:0[1-9]|[1-2][0-9]|3[0-1])/,
                capture: /([0-9]{4})-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])/
            },
            json: {
                encode: angular.toJson,
                decode: angular.fromJson,
                is: angular.isObject,
                equals: angular.equals,
                pattern: /[^\/]*/
            },
            any: {
                encode: angular.identity,
                decode: angular.identity,
                equals: angular.equals,
                pattern: /.*/
            }
        };
        $UrlMatcherFactory.$$getDefaultValue = function(config) {
            if (!isInjectable(config.value)) return config.value;
            if (!injector) throw new Error("Injectable functions cannot be called at configuration time");
            return injector.invoke(config.value);
        }, this.caseInsensitive = function(value) {
            return isDefined(value) && (isCaseInsensitive = value), isCaseInsensitive;
        }, this.strictMode = function(value) {
            return isDefined(value) && (isStrictMode = value), isStrictMode;
        }, this.defaultSquashPolicy = function(value) {
            if (!isDefined(value)) return defaultSquashPolicy;
            if (value !== !0 && value !== !1 && !isString(value)) throw new Error("Invalid squash policy: " + value + ". Valid policies: false, true, arbitrary-string");
            return defaultSquashPolicy = value, value;
        }, this.compile = function(pattern, config) {
            return new UrlMatcher(pattern, extend(getDefaultConfig(), config));
        }, this.isMatcher = function(o) {
            if (!isObject(o)) return !1;
            var result = !0;
            return forEach(UrlMatcher.prototype, function(val, name) {
                isFunction(val) && (result = result && isDefined(o[name]) && isFunction(o[name]));
            }), result;
        }, this.type = function(name, definition, definitionFn) {
            if (!isDefined(definition)) return $types[name];
            if ($types.hasOwnProperty(name)) throw new Error("A type named '" + name + "' has already been defined.");
            return $types[name] = new Type(extend({
                name: name
            }, definition)), definitionFn && (typeQueue.push({
                name: name,
                def: definitionFn
            }), enqueue || flushTypeQueue()), this;
        }, forEach(defaultTypes, function(type, name) {
            $types[name] = new Type(extend({
                name: name
            }, type));
        }), $types = inherit($types, {}), this.$get = [ "$injector", function($injector) {
            return injector = $injector, enqueue = !1, flushTypeQueue(), forEach(defaultTypes, function(type, name) {
                $types[name] || ($types[name] = new Type(type));
            }), this;
        } ], this.Param = function(id, type, config, location) {
            function unwrapShorthand(config) {
                var keys = isObject(config) ? objectKeys(config) : [], isShorthand = -1 === indexOf(keys, "value") && -1 === indexOf(keys, "type") && -1 === indexOf(keys, "squash") && -1 === indexOf(keys, "array");
                return isShorthand && (config = {
                    value: config
                }), config.$$fn = isInjectable(config.value) ? config.value : function() {
                    return config.value;
                }, config;
            }
            function getType(config, urlType, location) {
                if (config.type && urlType) throw new Error("Param '" + id + "' has two type configurations.");
                return urlType ? urlType : config.type ? config.type instanceof Type ? config.type : new Type(config.type) : "config" === location ? $types.any : $types.string;
            }
            function getArrayMode() {
                var arrayDefaults = {
                    array: "search" === location ? "auto" : !1
                }, arrayParamNomenclature = id.match(/\[\]$/) ? {
                    array: !0
                } : {};
                return extend(arrayDefaults, arrayParamNomenclature, config).array;
            }
            function getSquashPolicy(config, isOptional) {
                var squash = config.squash;
                if (!isOptional || squash === !1) return !1;
                if (!isDefined(squash) || null == squash) return defaultSquashPolicy;
                if (squash === !0 || isString(squash)) return squash;
                throw new Error("Invalid squash policy: '" + squash + "'. Valid policies: false, true, or arbitrary string");
            }
            function getReplace(config, arrayMode, isOptional, squash) {
                var replace, configuredKeys, defaultPolicy = [ {
                    from: "",
                    to: isOptional || arrayMode ? undefined : ""
                }, {
                    from: null,
                    to: isOptional || arrayMode ? undefined : ""
                } ];
                return replace = isArray(config.replace) ? config.replace : [], isString(squash) && replace.push({
                    from: squash,
                    to: undefined
                }), configuredKeys = map(replace, function(item) {
                    return item.from;
                }), filter(defaultPolicy, function(item) {
                    return -1 === indexOf(configuredKeys, item.from);
                }).concat(replace);
            }
            function $$getDefaultValue() {
                if (!injector) throw new Error("Injectable functions cannot be called at configuration time");
                var defaultValue = injector.invoke(config.$$fn);
                if (null !== defaultValue && defaultValue !== undefined && !self.type.is(defaultValue)) throw new Error("Default value (" + defaultValue + ") for parameter '" + self.id + "' is not an instance of Type (" + self.type.name + ")");
                return defaultValue;
            }
            function $value(value) {
                function hasReplaceVal(val) {
                    return function(obj) {
                        return obj.from === val;
                    };
                }
                function $replace(value) {
                    var replacement = map(filter(self.replace, hasReplaceVal(value)), function(obj) {
                        return obj.to;
                    });
                    return replacement.length ? replacement[0] : value;
                }
                return value = $replace(value), isDefined(value) ? self.type.$normalize(value) : $$getDefaultValue();
            }
            function toString() {
                return "{Param:" + id + " " + type + " squash: '" + squash + "' optional: " + isOptional + "}";
            }
            var self = this;
            config = unwrapShorthand(config), type = getType(config, type, location);
            var arrayMode = getArrayMode();
            type = arrayMode ? type.$asArray(arrayMode, "search" === location) : type, "string" !== type.name || arrayMode || "path" !== location || config.value !== undefined || (config.value = "");
            var isOptional = config.value !== undefined, squash = getSquashPolicy(config, isOptional), replace = getReplace(config, arrayMode, isOptional, squash);
            extend(this, {
                id: id,
                type: type,
                location: location,
                array: arrayMode,
                squash: squash,
                replace: replace,
                isOptional: isOptional,
                value: $value,
                dynamic: undefined,
                config: config,
                toString: toString
            });
        }, ParamSet.prototype = {
            $$new: function() {
                return inherit(this, extend(new ParamSet(), {
                    $$parent: this
                }));
            },
            $$keys: function() {
                for (var keys = [], chain = [], parent = this, ignore = objectKeys(ParamSet.prototype); parent; ) chain.push(parent), 
                parent = parent.$$parent;
                return chain.reverse(), forEach(chain, function(paramset) {
                    forEach(objectKeys(paramset), function(key) {
                        -1 === indexOf(keys, key) && -1 === indexOf(ignore, key) && keys.push(key);
                    });
                }), keys;
            },
            $$values: function(paramValues) {
                var values = {}, self = this;
                return forEach(self.$$keys(), function(key) {
                    values[key] = self[key].value(paramValues && paramValues[key]);
                }), values;
            },
            $$equals: function(paramValues1, paramValues2) {
                var equal = !0, self = this;
                return forEach(self.$$keys(), function(key) {
                    var left = paramValues1 && paramValues1[key], right = paramValues2 && paramValues2[key];
                    self[key].type.equals(left, right) || (equal = !1);
                }), equal;
            },
            $$validates: function(paramValues) {
                var i, param, rawVal, normalized, encoded, keys = this.$$keys();
                for (i = 0; i < keys.length && (param = this[keys[i]], rawVal = paramValues[keys[i]], 
                rawVal !== undefined && null !== rawVal || !param.isOptional); i++) {
                    if (normalized = param.type.$normalize(rawVal), !param.type.is(normalized)) return !1;
                    if (encoded = param.type.encode(normalized), angular.isString(encoded) && !param.type.pattern.exec(encoded)) return !1;
                }
                return !0;
            },
            $$parent: undefined
        }, this.ParamSet = ParamSet;
    }
    function $UrlRouterProvider($locationProvider, $urlMatcherFactory) {
        function regExpPrefix(re) {
            var prefix = /^\^((?:\\[^a-zA-Z0-9]|[^\\\[\]\^$*+?.()|{}]+)*)/.exec(re.source);
            return null != prefix ? prefix[1].replace(/\\(.)/g, "$1") : "";
        }
        function interpolate(pattern, match) {
            return pattern.replace(/\$(\$|\d{1,2})/, function(m, what) {
                return match["$" === what ? 0 : Number(what)];
            });
        }
        function handleIfMatch($injector, handler, match) {
            if (!match) return !1;
            var result = $injector.invoke(handler, handler, {
                $match: match
            });
            return isDefined(result) ? result : !0;
        }
        function $get($location, $rootScope, $injector, $browser) {
            function appendBasePath(url, isHtml5, absolute) {
                return "/" === baseHref ? url : isHtml5 ? baseHref.slice(0, -1) + url : absolute ? baseHref.slice(1) + url : url;
            }
            function update(evt) {
                function check(rule) {
                    var handled = rule($injector, $location);
                    return handled ? (isString(handled) && $location.replace().url(handled), !0) : !1;
                }
                if (!evt || !evt.defaultPrevented) {
                    {
                        lastPushedUrl && $location.url() === lastPushedUrl;
                    }
                    lastPushedUrl = undefined;
                    var i, n = rules.length;
                    for (i = 0; n > i; i++) if (check(rules[i])) return;
                    otherwise && check(otherwise);
                }
            }
            function listen() {
                return listener = listener || $rootScope.$on("$locationChangeSuccess", update);
            }
            var lastPushedUrl, baseHref = $browser.baseHref(), location = $location.url();
            return interceptDeferred || listen(), {
                sync: function() {
                    update();
                },
                listen: function() {
                    return listen();
                },
                update: function(read) {
                    return read ? void (location = $location.url()) : void ($location.url() !== location && ($location.url(location), 
                    $location.replace()));
                },
                push: function(urlMatcher, params, options) {
                    var url = urlMatcher.format(params || {});
                    null !== url && params && params["#"] && (url += "#" + params["#"]), $location.url(url), 
                    lastPushedUrl = options && options.$$avoidResync ? $location.url() : undefined, 
                    options && options.replace && $location.replace();
                },
                href: function(urlMatcher, params, options) {
                    if (!urlMatcher.validates(params)) return null;
                    var isHtml5 = $locationProvider.html5Mode();
                    angular.isObject(isHtml5) && (isHtml5 = isHtml5.enabled);
                    var url = urlMatcher.format(params);
                    if (options = options || {}, isHtml5 || null === url || (url = "#" + $locationProvider.hashPrefix() + url), 
                    null !== url && params && params["#"] && (url += "#" + params["#"]), url = appendBasePath(url, isHtml5, options.absolute), 
                    !options.absolute || !url) return url;
                    var slash = !isHtml5 && url ? "/" : "", port = $location.port();
                    return port = 80 === port || 443 === port ? "" : ":" + port, [ $location.protocol(), "://", $location.host(), port, slash, url ].join("");
                }
            };
        }
        var listener, rules = [], otherwise = null, interceptDeferred = !1;
        this.rule = function(rule) {
            if (!isFunction(rule)) throw new Error("'rule' must be a function");
            return rules.push(rule), this;
        }, this.otherwise = function(rule) {
            if (isString(rule)) {
                var redirect = rule;
                rule = function() {
                    return redirect;
                };
            } else if (!isFunction(rule)) throw new Error("'rule' must be a function");
            return otherwise = rule, this;
        }, this.when = function(what, handler) {
            var redirect, handlerIsString = isString(handler);
            if (isString(what) && (what = $urlMatcherFactory.compile(what)), !handlerIsString && !isFunction(handler) && !isArray(handler)) throw new Error("invalid 'handler' in when()");
            var strategies = {
                matcher: function(what, handler) {
                    return handlerIsString && (redirect = $urlMatcherFactory.compile(handler), handler = [ "$match", function($match) {
                        return redirect.format($match);
                    } ]), extend(function($injector, $location) {
                        return handleIfMatch($injector, handler, what.exec($location.path(), $location.search()));
                    }, {
                        prefix: isString(what.prefix) ? what.prefix : ""
                    });
                },
                regex: function(what, handler) {
                    if (what.global || what.sticky) throw new Error("when() RegExp must not be global or sticky");
                    return handlerIsString && (redirect = handler, handler = [ "$match", function($match) {
                        return interpolate(redirect, $match);
                    } ]), extend(function($injector, $location) {
                        return handleIfMatch($injector, handler, what.exec($location.path()));
                    }, {
                        prefix: regExpPrefix(what)
                    });
                }
            }, check = {
                matcher: $urlMatcherFactory.isMatcher(what),
                regex: what instanceof RegExp
            };
            for (var n in check) if (check[n]) return this.rule(strategies[n](what, handler));
            throw new Error("invalid 'what' in when()");
        }, this.deferIntercept = function(defer) {
            defer === undefined && (defer = !0), interceptDeferred = defer;
        }, this.$get = $get, $get.$inject = [ "$location", "$rootScope", "$injector", "$browser" ];
    }
    function $StateProvider($urlRouterProvider, $urlMatcherFactory) {
        function isRelative(stateName) {
            return 0 === stateName.indexOf(".") || 0 === stateName.indexOf("^");
        }
        function findState(stateOrName, base) {
            if (!stateOrName) return undefined;
            var isStr = isString(stateOrName), name = isStr ? stateOrName : stateOrName.name, path = isRelative(name);
            if (path) {
                if (!base) throw new Error("No reference point given for path '" + name + "'");
                base = findState(base);
                for (var rel = name.split("."), i = 0, pathLength = rel.length, current = base; pathLength > i; i++) if ("" !== rel[i] || 0 !== i) {
                    if ("^" !== rel[i]) break;
                    if (!current.parent) throw new Error("Path '" + name + "' not valid for state '" + base.name + "'");
                    current = current.parent;
                } else current = base;
                rel = rel.slice(i).join("."), name = current.name + (current.name && rel ? "." : "") + rel;
            }
            var state = states[name];
            return !state || !isStr && (isStr || state !== stateOrName && state.self !== stateOrName) ? undefined : state;
        }
        function queueState(parentName, state) {
            queue[parentName] || (queue[parentName] = []), queue[parentName].push(state);
        }
        function flushQueuedChildren(parentName) {
            for (var queued = queue[parentName] || []; queued.length; ) registerState(queued.shift());
        }
        function registerState(state) {
            state = inherit(state, {
                self: state,
                resolve: state.resolve || {},
                toString: function() {
                    return this.name;
                }
            });
            var name = state.name;
            if (!isString(name) || name.indexOf("@") >= 0) throw new Error("State must have a valid name");
            if (states.hasOwnProperty(name)) throw new Error("State '" + name + "'' is already defined");
            var parentName = -1 !== name.indexOf(".") ? name.substring(0, name.lastIndexOf(".")) : isString(state.parent) ? state.parent : isObject(state.parent) && isString(state.parent.name) ? state.parent.name : "";
            if (parentName && !states[parentName]) return queueState(parentName, state.self);
            for (var key in stateBuilder) isFunction(stateBuilder[key]) && (state[key] = stateBuilder[key](state, stateBuilder.$delegates[key]));
            return states[name] = state, !state[abstractKey] && state.url && $urlRouterProvider.when(state.url, [ "$match", "$stateParams", function($match, $stateParams) {
                $state.$current.navigable == state && equalForKeys($match, $stateParams) || $state.transitionTo(state, $match, {
                    inherit: !0,
                    location: !1
                });
            } ]), flushQueuedChildren(name), state;
        }
        function isGlob(text) {
            return text.indexOf("*") > -1;
        }
        function doesStateMatchGlob(glob) {
            for (var globSegments = glob.split("."), segments = $state.$current.name.split("."), i = 0, l = globSegments.length; l > i; i++) "*" === globSegments[i] && (segments[i] = "*");
            return "**" === globSegments[0] && (segments = segments.slice(indexOf(segments, globSegments[1])), 
            segments.unshift("**")), "**" === globSegments[globSegments.length - 1] && (segments.splice(indexOf(segments, globSegments[globSegments.length - 2]) + 1, Number.MAX_VALUE), 
            segments.push("**")), globSegments.length != segments.length ? !1 : segments.join("") === globSegments.join("");
        }
        function decorator(name, func) {
            return isString(name) && !isDefined(func) ? stateBuilder[name] : isFunction(func) && isString(name) ? (stateBuilder[name] && !stateBuilder.$delegates[name] && (stateBuilder.$delegates[name] = stateBuilder[name]), 
            stateBuilder[name] = func, this) : this;
        }
        function state(name, definition) {
            return isObject(name) ? definition = name : definition.name = name, registerState(definition), 
            this;
        }
        function $get($rootScope, $q, $view, $injector, $resolve, $stateParams, $urlRouter) {
            function handleRedirect(redirect, state, params, options) {
                var evt = $rootScope.$broadcast("$stateNotFound", redirect, state, params);
                if (evt.defaultPrevented) return $urlRouter.update(), TransitionAborted;
                if (!evt.retry) return null;
                if (options.$retry) return $urlRouter.update(), TransitionFailed;
                var retryTransition = $state.transition = $q.when(evt.retry);
                return retryTransition.then(function() {
                    return retryTransition !== $state.transition ? TransitionSuperseded : (redirect.options.$retry = !0, 
                    $state.transitionTo(redirect.to, redirect.toParams, redirect.options));
                }, function() {
                    return TransitionAborted;
                }), $urlRouter.update(), retryTransition;
            }
            function resolveState(state, params, paramsAreFiltered, inherited, dst, options) {
                function resolveViews() {
                    var viewsPromises = [];
                    return forEach(state.views, function(view, name) {
                        var injectables = view.resolve && view.resolve !== state.resolve ? view.resolve : {};
                        injectables.$template = [ function() {
                            return $view.load(name, {
                                view: view,
                                locals: dst.globals,
                                params: $stateParams,
                                notify: options.notify
                            }) || "";
                        } ], viewsPromises.push($resolve.resolve(injectables, dst.globals, dst.resolve, state).then(function(result) {
                            if (isFunction(view.controllerProvider) || isArray(view.controllerProvider)) {
                                var injectLocals = angular.extend({}, injectables, dst.globals);
                                result.$$controller = $injector.invoke(view.controllerProvider, null, injectLocals);
                            } else result.$$controller = view.controller;
                            result.$$state = state, result.$$controllerAs = view.controllerAs, dst[name] = result;
                        }));
                    }), $q.all(viewsPromises).then(function() {
                        return dst.globals;
                    });
                }
                var $stateParams = paramsAreFiltered ? params : filterByKeys(state.params.$$keys(), params), locals = {
                    $stateParams: $stateParams
                };
                dst.resolve = $resolve.resolve(state.resolve, locals, dst.resolve, state);
                var promises = [ dst.resolve.then(function(globals) {
                    dst.globals = globals;
                }) ];
                return inherited && promises.push(inherited), $q.all(promises).then(resolveViews).then(function() {
                    return dst;
                });
            }
            var TransitionSuperseded = $q.reject(new Error("transition superseded")), TransitionPrevented = $q.reject(new Error("transition prevented")), TransitionAborted = $q.reject(new Error("transition aborted")), TransitionFailed = $q.reject(new Error("transition failed"));
            return root.locals = {
                resolve: null,
                globals: {
                    $stateParams: {}
                }
            }, $state = {
                params: {},
                current: root.self,
                $current: root,
                transition: null
            }, $state.reload = function(state) {
                return $state.transitionTo($state.current, $stateParams, {
                    reload: state || !0,
                    inherit: !1,
                    notify: !0
                });
            }, $state.go = function(to, params, options) {
                return $state.transitionTo(to, params, extend({
                    inherit: !0,
                    relative: $state.$current
                }, options));
            }, $state.transitionTo = function(to, toParams, options) {
                toParams = toParams || {}, options = extend({
                    location: !0,
                    inherit: !1,
                    relative: null,
                    notify: !0,
                    reload: !1,
                    $retry: !1
                }, options || {});
                var evt, from = $state.$current, fromParams = $state.params, fromPath = from.path, toState = findState(to, options.relative), hash = toParams["#"];
                if (!isDefined(toState)) {
                    var redirect = {
                        to: to,
                        toParams: toParams,
                        options: options
                    }, redirectResult = handleRedirect(redirect, from.self, fromParams, options);
                    if (redirectResult) return redirectResult;
                    if (to = redirect.to, toParams = redirect.toParams, options = redirect.options, 
                    toState = findState(to, options.relative), !isDefined(toState)) {
                        if (!options.relative) throw new Error("No such state '" + to + "'");
                        throw new Error("Could not resolve '" + to + "' from state '" + options.relative + "'");
                    }
                }
                if (toState[abstractKey]) throw new Error("Cannot transition to abstract state '" + to + "'");
                if (options.inherit && (toParams = inheritParams($stateParams, toParams || {}, $state.$current, toState)), 
                !toState.params.$$validates(toParams)) return TransitionFailed;
                toParams = toState.params.$$values(toParams), to = toState;
                var toPath = to.path, keep = 0, state = toPath[keep], locals = root.locals, toLocals = [];
                if (options.reload) {
                    if (isString(options.reload) || isObject(options.reload)) {
                        if (isObject(options.reload) && !options.reload.name) throw new Error("Invalid reload state object");
                        var reloadState = options.reload === !0 ? fromPath[0] : findState(options.reload);
                        if (options.reload && !reloadState) throw new Error("No such reload state '" + (isString(options.reload) ? options.reload : options.reload.name) + "'");
                        for (;state && state === fromPath[keep] && state !== reloadState; ) locals = toLocals[keep] = state.locals, 
                        keep++, state = toPath[keep];
                    }
                } else for (;state && state === fromPath[keep] && state.ownParams.$$equals(toParams, fromParams); ) locals = toLocals[keep] = state.locals, 
                keep++, state = toPath[keep];
                if (shouldSkipReload(to, toParams, from, fromParams, locals, options)) return hash && (toParams["#"] = hash), 
                $state.params = toParams, copy($state.params, $stateParams), options.location && to.navigable && to.navigable.url && ($urlRouter.push(to.navigable.url, toParams, {
                    $$avoidResync: !0,
                    replace: "replace" === options.location
                }), $urlRouter.update(!0)), $state.transition = null, $q.when($state.current);
                if (toParams = filterByKeys(to.params.$$keys(), toParams || {}), options.notify && $rootScope.$broadcast("$stateChangeStart", to.self, toParams, from.self, fromParams).defaultPrevented) return $rootScope.$broadcast("$stateChangeCancel", to.self, toParams, from.self, fromParams), 
                $urlRouter.update(), TransitionPrevented;
                for (var resolved = $q.when(locals), l = keep; l < toPath.length; l++, state = toPath[l]) locals = toLocals[l] = inherit(locals), 
                resolved = resolveState(state, toParams, state === to, resolved, locals, options);
                var transition = $state.transition = resolved.then(function() {
                    var l, entering, exiting;
                    if ($state.transition !== transition) return TransitionSuperseded;
                    for (l = fromPath.length - 1; l >= keep; l--) exiting = fromPath[l], exiting.self.onExit && $injector.invoke(exiting.self.onExit, exiting.self, exiting.locals.globals), 
                    exiting.locals = null;
                    for (l = keep; l < toPath.length; l++) entering = toPath[l], entering.locals = toLocals[l], 
                    entering.self.onEnter && $injector.invoke(entering.self.onEnter, entering.self, entering.locals.globals);
                    return hash && (toParams["#"] = hash), $state.transition !== transition ? TransitionSuperseded : ($state.$current = to, 
                    $state.current = to.self, $state.params = toParams, copy($state.params, $stateParams), 
                    $state.transition = null, options.location && to.navigable && $urlRouter.push(to.navigable.url, to.navigable.locals.globals.$stateParams, {
                        $$avoidResync: !0,
                        replace: "replace" === options.location
                    }), options.notify && $rootScope.$broadcast("$stateChangeSuccess", to.self, toParams, from.self, fromParams), 
                    $urlRouter.update(!0), $state.current);
                }, function(error) {
                    return $state.transition !== transition ? TransitionSuperseded : ($state.transition = null, 
                    evt = $rootScope.$broadcast("$stateChangeError", to.self, toParams, from.self, fromParams, error), 
                    evt.defaultPrevented || $urlRouter.update(), $q.reject(error));
                });
                return transition;
            }, $state.is = function(stateOrName, params, options) {
                options = extend({
                    relative: $state.$current
                }, options || {});
                var state = findState(stateOrName, options.relative);
                return isDefined(state) ? $state.$current !== state ? !1 : params ? equalForKeys(state.params.$$values(params), $stateParams) : !0 : undefined;
            }, $state.includes = function(stateOrName, params, options) {
                if (options = extend({
                    relative: $state.$current
                }, options || {}), isString(stateOrName) && isGlob(stateOrName)) {
                    if (!doesStateMatchGlob(stateOrName)) return !1;
                    stateOrName = $state.$current.name;
                }
                var state = findState(stateOrName, options.relative);
                return isDefined(state) ? isDefined($state.$current.includes[state.name]) ? params ? equalForKeys(state.params.$$values(params), $stateParams, objectKeys(params)) : !0 : !1 : undefined;
            }, $state.href = function(stateOrName, params, options) {
                options = extend({
                    lossy: !0,
                    inherit: !0,
                    absolute: !1,
                    relative: $state.$current
                }, options || {});
                var state = findState(stateOrName, options.relative);
                if (!isDefined(state)) return null;
                options.inherit && (params = inheritParams($stateParams, params || {}, $state.$current, state));
                var nav = state && options.lossy ? state.navigable : state;
                return nav && nav.url !== undefined && null !== nav.url ? $urlRouter.href(nav.url, filterByKeys(state.params.$$keys().concat("#"), params || {}), {
                    absolute: options.absolute
                }) : null;
            }, $state.get = function(stateOrName, context) {
                if (0 === arguments.length) return map(objectKeys(states), function(name) {
                    return states[name].self;
                });
                var state = findState(stateOrName, context || $state.$current);
                return state && state.self ? state.self : null;
            }, $state;
        }
        function shouldSkipReload(to, toParams, from, fromParams, locals, options) {
            function nonSearchParamsEqual(fromAndToState, fromParams, toParams) {
                function notSearchParam(key) {
                    return "search" != fromAndToState.params[key].location;
                }
                var nonQueryParamKeys = fromAndToState.params.$$keys().filter(notSearchParam), nonQueryParams = pick.apply({}, [ fromAndToState.params ].concat(nonQueryParamKeys)), nonQueryParamSet = new $$UMFP.ParamSet(nonQueryParams);
                return nonQueryParamSet.$$equals(fromParams, toParams);
            }
            return !options.reload && to === from && (locals === from.locals || to.self.reloadOnSearch === !1 && nonSearchParamsEqual(from, fromParams, toParams)) ? !0 : void 0;
        }
        var root, $state, states = {}, queue = {}, abstractKey = "abstract", stateBuilder = {
            parent: function(state) {
                if (isDefined(state.parent) && state.parent) return findState(state.parent);
                var compositeName = /^(.+)\.[^.]+$/.exec(state.name);
                return compositeName ? findState(compositeName[1]) : root;
            },
            data: function(state) {
                return state.parent && state.parent.data && (state.data = state.self.data = extend({}, state.parent.data, state.data)), 
                state.data;
            },
            url: function(state) {
                var url = state.url, config = {
                    params: state.params || {}
                };
                if (isString(url)) return "^" == url.charAt(0) ? $urlMatcherFactory.compile(url.substring(1), config) : (state.parent.navigable || root).url.concat(url, config);
                if (!url || $urlMatcherFactory.isMatcher(url)) return url;
                throw new Error("Invalid url '" + url + "' in state '" + state + "'");
            },
            navigable: function(state) {
                return state.url ? state : state.parent ? state.parent.navigable : null;
            },
            ownParams: function(state) {
                var params = state.url && state.url.params || new $$UMFP.ParamSet();
                return forEach(state.params || {}, function(config, id) {
                    params[id] || (params[id] = new $$UMFP.Param(id, null, config, "config"));
                }), params;
            },
            params: function(state) {
                return state.parent && state.parent.params ? extend(state.parent.params.$$new(), state.ownParams) : new $$UMFP.ParamSet();
            },
            views: function(state) {
                var views = {};
                return forEach(isDefined(state.views) ? state.views : {
                    "": state
                }, function(view, name) {
                    name.indexOf("@") < 0 && (name += "@" + state.parent.name), views[name] = view;
                }), views;
            },
            path: function(state) {
                return state.parent ? state.parent.path.concat(state) : [];
            },
            includes: function(state) {
                var includes = state.parent ? extend({}, state.parent.includes) : {};
                return includes[state.name] = !0, includes;
            },
            $delegates: {}
        };
        root = registerState({
            name: "",
            url: "^",
            views: null,
            "abstract": !0
        }), root.navigable = null, this.decorator = decorator, this.state = state, this.$get = $get, 
        $get.$inject = [ "$rootScope", "$q", "$view", "$injector", "$resolve", "$stateParams", "$urlRouter", "$location", "$urlMatcherFactory" ];
    }
    function $ViewProvider() {
        function $get($rootScope, $templateFactory) {
            return {
                load: function(name, options) {
                    var result, defaults = {
                        template: null,
                        controller: null,
                        view: null,
                        locals: null,
                        notify: !0,
                        async: !0,
                        params: {}
                    };
                    return options = extend(defaults, options), options.view && (result = $templateFactory.fromConfig(options.view, options.params, options.locals)), 
                    result && options.notify && $rootScope.$broadcast("$viewContentLoading", options), 
                    result;
                }
            };
        }
        this.$get = $get, $get.$inject = [ "$rootScope", "$templateFactory" ];
    }
    function $ViewScrollProvider() {
        var useAnchorScroll = !1;
        this.useAnchorScroll = function() {
            useAnchorScroll = !0;
        }, this.$get = [ "$anchorScroll", "$timeout", function($anchorScroll, $timeout) {
            return useAnchorScroll ? $anchorScroll : function($element) {
                return $timeout(function() {
                    $element[0].scrollIntoView();
                }, 0, !1);
            };
        } ];
    }
    function $ViewDirective($state, $injector, $uiViewScroll, $interpolate) {
        function getService() {
            return $injector.has ? function(service) {
                return $injector.has(service) ? $injector.get(service) : null;
            } : function(service) {
                try {
                    return $injector.get(service);
                } catch (e) {
                    return null;
                }
            };
        }
        function getRenderer(attrs, scope) {
            var statics = function() {
                return {
                    enter: function(element, target, cb) {
                        target.after(element), cb();
                    },
                    leave: function(element, cb) {
                        element.remove(), cb();
                    }
                };
            };
            if ($animate) return {
                enter: function(element, target, cb) {
                    var promise = $animate.enter(element, null, target, cb);
                    promise && promise.then && promise.then(cb);
                },
                leave: function(element, cb) {
                    var promise = $animate.leave(element, cb);
                    promise && promise.then && promise.then(cb);
                }
            };
            if ($animator) {
                var animate = $animator && $animator(scope, attrs);
                return {
                    enter: function(element, target, cb) {
                        animate.enter(element, null, target), cb();
                    },
                    leave: function(element, cb) {
                        animate.leave(element), cb();
                    }
                };
            }
            return statics();
        }
        var service = getService(), $animator = service("$animator"), $animate = service("$animate"), directive = {
            restrict: "ECA",
            terminal: !0,
            priority: 400,
            transclude: "element",
            compile: function(tElement, tAttrs, $transclude) {
                return function(scope, $element, attrs) {
                    function cleanupLastView() {
                        previousEl && (previousEl.remove(), previousEl = null), currentScope && (currentScope.$destroy(), 
                        currentScope = null), currentEl && (renderer.leave(currentEl, function() {
                            previousEl = null;
                        }), previousEl = currentEl, currentEl = null);
                    }
                    function updateView(firstTime) {
                        var newScope, name = getUiViewName(scope, attrs, $element, $interpolate), previousLocals = name && $state.$current && $state.$current.locals[name];
                        if (firstTime || previousLocals !== latestLocals) {
                            newScope = scope.$new(), latestLocals = $state.$current.locals[name];
                            var clone = $transclude(newScope, function(clone) {
                                renderer.enter(clone, $element, function() {
                                    currentScope && currentScope.$emit("$viewContentAnimationEnded"), (angular.isDefined(autoScrollExp) && !autoScrollExp || scope.$eval(autoScrollExp)) && $uiViewScroll(clone);
                                }), cleanupLastView();
                            });
                            currentEl = clone, currentScope = newScope, currentScope.$emit("$viewContentLoaded"), 
                            currentScope.$eval(onloadExp);
                        }
                    }
                    var previousEl, currentEl, currentScope, latestLocals, onloadExp = attrs.onload || "", autoScrollExp = attrs.autoscroll, renderer = getRenderer(attrs, scope);
                    scope.$on("$stateChangeSuccess", function() {
                        updateView(!1);
                    }), scope.$on("$viewContentLoading", function() {
                        updateView(!1);
                    }), updateView(!0);
                };
            }
        };
        return directive;
    }
    function $ViewDirectiveFill($compile, $controller, $state, $interpolate) {
        return {
            restrict: "ECA",
            priority: -400,
            compile: function(tElement) {
                var initial = tElement.html();
                return function(scope, $element, attrs) {
                    var current = $state.$current, name = getUiViewName(scope, attrs, $element, $interpolate), locals = current && current.locals[name];
                    if (locals) {
                        $element.data("$uiView", {
                            name: name,
                            state: locals.$$state
                        }), $element.html(locals.$template ? locals.$template : initial);
                        var link = $compile($element.contents());
                        if (locals.$$controller) {
                            locals.$scope = scope, locals.$element = $element;
                            var controller = $controller(locals.$$controller, locals);
                            locals.$$controllerAs && (scope[locals.$$controllerAs] = controller), $element.data("$ngControllerController", controller), 
                            $element.children().data("$ngControllerController", controller);
                        }
                        link(scope);
                    }
                };
            }
        };
    }
    function getUiViewName(scope, attrs, element, $interpolate) {
        var name = $interpolate(attrs.uiView || attrs.name || "")(scope), inherited = element.inheritedData("$uiView");
        return name.indexOf("@") >= 0 ? name : name + "@" + (inherited ? inherited.state.name : "");
    }
    function parseStateRef(ref, current) {
        var parsed, preparsed = ref.match(/^\s*({[^}]*})\s*$/);
        if (preparsed && (ref = current + "(" + preparsed[1] + ")"), parsed = ref.replace(/\n/g, " ").match(/^([^(]+?)\s*(\((.*)\))?$/), 
        !parsed || 4 !== parsed.length) throw new Error("Invalid state ref '" + ref + "'");
        return {
            state: parsed[1],
            paramExpr: parsed[3] || null
        };
    }
    function stateContext(el) {
        var stateData = el.parent().inheritedData("$uiView");
        return stateData && stateData.state && stateData.state.name ? stateData.state : void 0;
    }
    function $StateRefDirective($state, $timeout) {
        var allowedOptions = [ "location", "inherit", "reload", "absolute" ];
        return {
            restrict: "A",
            require: [ "?^uiSrefActive", "?^uiSrefActiveEq" ],
            link: function(scope, element, attrs, uiSrefActive) {
                var ref = parseStateRef(attrs.uiSref, $state.current.name), params = null, base = stateContext(element) || $state.$current, hrefKind = "[object SVGAnimatedString]" === Object.prototype.toString.call(element.prop("href")) ? "xlink:href" : "href", newHref = null, isAnchor = "A" === element.prop("tagName").toUpperCase(), isForm = "FORM" === element[0].nodeName, attr = isForm ? "action" : hrefKind, nav = !0, options = {
                    relative: base,
                    inherit: !0
                }, optionsOverride = scope.$eval(attrs.uiSrefOpts) || {};
                angular.forEach(allowedOptions, function(option) {
                    option in optionsOverride && (options[option] = optionsOverride[option]);
                });
                var update = function(newVal) {
                    if (newVal && (params = angular.copy(newVal)), nav) {
                        newHref = $state.href(ref.state, params, options);
                        var activeDirective = uiSrefActive[1] || uiSrefActive[0];
                        return activeDirective && activeDirective.$$addStateInfo(ref.state, params), null === newHref ? (nav = !1, 
                        !1) : void attrs.$set(attr, newHref);
                    }
                };
                ref.paramExpr && (scope.$watch(ref.paramExpr, function(newVal) {
                    newVal !== params && update(newVal);
                }, !0), params = angular.copy(scope.$eval(ref.paramExpr))), update(), isForm || element.bind("click", function(e) {
                    var button = e.which || e.button;
                    if (!(button > 1 || e.ctrlKey || e.metaKey || e.shiftKey || element.attr("target"))) {
                        var transition = $timeout(function() {
                            $state.go(ref.state, params, options);
                        });
                        e.preventDefault();
                        var ignorePreventDefaultCount = isAnchor && !newHref ? 1 : 0;
                        e.preventDefault = function() {
                            ignorePreventDefaultCount-- <= 0 && $timeout.cancel(transition);
                        };
                    }
                });
            }
        };
    }
    function $StateRefActiveDirective($state, $stateParams, $interpolate) {
        return {
            restrict: "A",
            controller: [ "$scope", "$element", "$attrs", function($scope, $element, $attrs) {
                function update() {
                    anyMatch() ? $element.addClass(activeClass) : $element.removeClass(activeClass);
                }
                function anyMatch() {
                    for (var i = 0; i < states.length; i++) if (isMatch(states[i].state, states[i].params)) return !0;
                    return !1;
                }
                function isMatch(state, params) {
                    return "undefined" != typeof $attrs.uiSrefActiveEq ? $state.is(state.name, params) : $state.includes(state.name, params);
                }
                var activeClass, states = [];
                activeClass = $interpolate($attrs.uiSrefActiveEq || $attrs.uiSrefActive || "", !1)($scope), 
                this.$$addStateInfo = function(newState, newParams) {
                    var state = $state.get(newState, stateContext($element));
                    states.push({
                        state: state || {
                            name: newState
                        },
                        params: newParams
                    }), update();
                }, $scope.$on("$stateChangeSuccess", update);
            } ]
        };
    }
    function $IsStateFilter($state) {
        var isFilter = function(state) {
            return $state.is(state);
        };
        return isFilter.$stateful = !0, isFilter;
    }
    function $IncludedByStateFilter($state) {
        var includesFilter = function(state) {
            return $state.includes(state);
        };
        return includesFilter.$stateful = !0, includesFilter;
    }
    var isDefined = angular.isDefined, isFunction = angular.isFunction, isString = angular.isString, isObject = angular.isObject, isArray = angular.isArray, forEach = angular.forEach, extend = angular.extend, copy = angular.copy;
    angular.module("ui.router.util", [ "ng" ]), angular.module("ui.router.router", [ "ui.router.util" ]), 
    angular.module("ui.router.state", [ "ui.router.router", "ui.router.util" ]), angular.module("ui.router", [ "ui.router.state" ]), 
    angular.module("ui.router.compat", [ "ui.router" ]), $Resolve.$inject = [ "$q", "$injector" ], 
    angular.module("ui.router.util").service("$resolve", $Resolve), $TemplateFactory.$inject = [ "$http", "$templateCache", "$injector" ], 
    angular.module("ui.router.util").service("$templateFactory", $TemplateFactory);
    var $$UMFP;
    UrlMatcher.prototype.concat = function(pattern, config) {
        var defaultConfig = {
            caseInsensitive: $$UMFP.caseInsensitive(),
            strict: $$UMFP.strictMode(),
            squash: $$UMFP.defaultSquashPolicy()
        };
        return new UrlMatcher(this.sourcePath + pattern + this.sourceSearch, extend(defaultConfig, config), this);
    }, UrlMatcher.prototype.toString = function() {
        return this.source;
    }, UrlMatcher.prototype.exec = function(path, searchParams) {
        function decodePathArray(string) {
            function reverseString(str) {
                return str.split("").reverse().join("");
            }
            function unquoteDashes(str) {
                return str.replace(/\\-/g, "-");
            }
            var split = reverseString(string).split(/-(?!\\)/), allReversed = map(split, reverseString);
            return map(allReversed, unquoteDashes).reverse();
        }
        var m = this.regexp.exec(path);
        if (!m) return null;
        searchParams = searchParams || {};
        var i, j, paramName, paramNames = this.parameters(), nTotal = paramNames.length, nPath = this.segments.length - 1, values = {};
        if (nPath !== m.length - 1) throw new Error("Unbalanced capture group in route '" + this.source + "'");
        for (i = 0; nPath > i; i++) {
            paramName = paramNames[i];
            var param = this.params[paramName], paramVal = m[i + 1];
            for (j = 0; j < param.replace; j++) param.replace[j].from === paramVal && (paramVal = param.replace[j].to);
            paramVal && param.array === !0 && (paramVal = decodePathArray(paramVal)), values[paramName] = param.value(paramVal);
        }
        for (;nTotal > i; i++) paramName = paramNames[i], values[paramName] = this.params[paramName].value(searchParams[paramName]);
        return values;
    }, UrlMatcher.prototype.parameters = function(param) {
        return isDefined(param) ? this.params[param] || null : this.$$paramNames;
    }, UrlMatcher.prototype.validates = function(params) {
        return this.params.$$validates(params);
    }, UrlMatcher.prototype.format = function(values) {
        function encodeDashes(str) {
            return encodeURIComponent(str).replace(/-/g, function(c) {
                return "%5C%" + c.charCodeAt(0).toString(16).toUpperCase();
            });
        }
        values = values || {};
        var segments = this.segments, params = this.parameters(), paramset = this.params;
        if (!this.validates(values)) return null;
        var i, search = !1, nPath = segments.length - 1, nTotal = params.length, result = segments[0];
        for (i = 0; nTotal > i; i++) {
            var isPathParam = nPath > i, name = params[i], param = paramset[name], value = param.value(values[name]), isDefaultValue = param.isOptional && param.type.equals(param.value(), value), squash = isDefaultValue ? param.squash : !1, encoded = param.type.encode(value);
            if (isPathParam) {
                var nextSegment = segments[i + 1];
                if (squash === !1) null != encoded && (result += isArray(encoded) ? map(encoded, encodeDashes).join("-") : encodeURIComponent(encoded)), 
                result += nextSegment; else if (squash === !0) {
                    var capture = result.match(/\/$/) ? /\/?(.*)/ : /(.*)/;
                    result += nextSegment.match(capture)[1];
                } else isString(squash) && (result += squash + nextSegment);
            } else {
                if (null == encoded || isDefaultValue && squash !== !1) continue;
                isArray(encoded) || (encoded = [ encoded ]), encoded = map(encoded, encodeURIComponent).join("&" + name + "="), 
                result += (search ? "&" : "?") + (name + "=" + encoded), search = !0;
            }
        }
        return result;
    }, Type.prototype.is = function() {
        return !0;
    }, Type.prototype.encode = function(val) {
        return val;
    }, Type.prototype.decode = function(val) {
        return val;
    }, Type.prototype.equals = function(a, b) {
        return a == b;
    }, Type.prototype.$subPattern = function() {
        var sub = this.pattern.toString();
        return sub.substr(1, sub.length - 2);
    }, Type.prototype.pattern = /.*/, Type.prototype.toString = function() {
        return "{Type:" + this.name + "}";
    }, Type.prototype.$normalize = function(val) {
        return this.is(val) ? val : this.decode(val);
    }, Type.prototype.$asArray = function(mode, isSearch) {
        function ArrayType(type, mode) {
            function bindTo(type, callbackName) {
                return function() {
                    return type[callbackName].apply(type, arguments);
                };
            }
            function arrayWrap(val) {
                return isArray(val) ? val : isDefined(val) ? [ val ] : [];
            }
            function arrayUnwrap(val) {
                switch (val.length) {
                  case 0:
                    return undefined;

                  case 1:
                    return "auto" === mode ? val[0] : val;

                  default:
                    return val;
                }
            }
            function falsey(val) {
                return !val;
            }
            function arrayHandler(callback, allTruthyMode) {
                return function(val) {
                    val = arrayWrap(val);
                    var result = map(val, callback);
                    return allTruthyMode === !0 ? 0 === filter(result, falsey).length : arrayUnwrap(result);
                };
            }
            function arrayEqualsHandler(callback) {
                return function(val1, val2) {
                    var left = arrayWrap(val1), right = arrayWrap(val2);
                    if (left.length !== right.length) return !1;
                    for (var i = 0; i < left.length; i++) if (!callback(left[i], right[i])) return !1;
                    return !0;
                };
            }
            this.encode = arrayHandler(bindTo(type, "encode")), this.decode = arrayHandler(bindTo(type, "decode")), 
            this.is = arrayHandler(bindTo(type, "is"), !0), this.equals = arrayEqualsHandler(bindTo(type, "equals")), 
            this.pattern = type.pattern, this.$normalize = arrayHandler(bindTo(type, "$normalize")), 
            this.name = type.name, this.$arrayMode = mode;
        }
        if (!mode) return this;
        if ("auto" === mode && !isSearch) throw new Error("'auto' array mode is for query parameters only");
        return new ArrayType(this, mode);
    }, angular.module("ui.router.util").provider("$urlMatcherFactory", $UrlMatcherFactory), 
    angular.module("ui.router.util").run([ "$urlMatcherFactory", function() {} ]), $UrlRouterProvider.$inject = [ "$locationProvider", "$urlMatcherFactoryProvider" ], 
    angular.module("ui.router.router").provider("$urlRouter", $UrlRouterProvider), $StateProvider.$inject = [ "$urlRouterProvider", "$urlMatcherFactoryProvider" ], 
    angular.module("ui.router.state").value("$stateParams", {}).provider("$state", $StateProvider), 
    $ViewProvider.$inject = [], angular.module("ui.router.state").provider("$view", $ViewProvider), 
    angular.module("ui.router.state").provider("$uiViewScroll", $ViewScrollProvider), 
    $ViewDirective.$inject = [ "$state", "$injector", "$uiViewScroll", "$interpolate" ], 
    $ViewDirectiveFill.$inject = [ "$compile", "$controller", "$state", "$interpolate" ], 
    angular.module("ui.router.state").directive("uiView", $ViewDirective), angular.module("ui.router.state").directive("uiView", $ViewDirectiveFill), 
    $StateRefDirective.$inject = [ "$state", "$timeout" ], $StateRefActiveDirective.$inject = [ "$state", "$stateParams", "$interpolate" ], 
    angular.module("ui.router.state").directive("uiSref", $StateRefDirective).directive("uiSrefActive", $StateRefActiveDirective).directive("uiSrefActiveEq", $StateRefActiveDirective), 
    $IsStateFilter.$inject = [ "$state" ], $IncludedByStateFilter.$inject = [ "$state" ], 
    angular.module("ui.router.state").filter("isState", $IsStateFilter).filter("includedByState", $IncludedByStateFilter);
}(window, window.angular), define("ngdir/angular-ui-router", [ "angular" ], function() {}), 
angular.module("ui.bootstrap", [ "ui.bootstrap.tpls", "ui.bootstrap.collapse", "ui.bootstrap.accordion", "ui.bootstrap.alert", "ui.bootstrap.buttons", "ui.bootstrap.carousel", "ui.bootstrap.dateparser", "ui.bootstrap.position", "ui.bootstrap.datepicker", "ui.bootstrap.dropdown", "ui.bootstrap.stackedMap", "ui.bootstrap.modal", "ui.bootstrap.pagination", "ui.bootstrap.tooltip", "ui.bootstrap.popover", "ui.bootstrap.progressbar", "ui.bootstrap.rating", "ui.bootstrap.tabs", "ui.bootstrap.timepicker", "ui.bootstrap.typeahead" ]), 
angular.module("ui.bootstrap.tpls", [ "template/accordion/accordion-group.html", "template/accordion/accordion.html", "template/alert/alert.html", "template/carousel/carousel.html", "template/carousel/slide.html", "template/datepicker/datepicker.html", "template/datepicker/day.html", "template/datepicker/month.html", "template/datepicker/popup.html", "template/datepicker/year.html", "template/modal/backdrop.html", "template/modal/window.html", "template/pagination/pager.html", "template/pagination/pagination.html", "template/tooltip/tooltip-html-popup.html", "template/tooltip/tooltip-popup.html", "template/tooltip/tooltip-template-popup.html", "template/popover/popover-html.html", "template/popover/popover-template.html", "template/popover/popover.html", "template/progressbar/bar.html", "template/progressbar/progress.html", "template/progressbar/progressbar.html", "template/rating/rating.html", "template/tabs/tab.html", "template/tabs/tabset.html", "template/timepicker/timepicker.html", "template/typeahead/typeahead-match.html", "template/typeahead/typeahead-popup.html" ]), 
angular.module("ui.bootstrap.collapse", []).directive("uibCollapse", [ "$animate", "$injector", function($animate, $injector) {
    var $animateCss = $injector.has("$animateCss") ? $injector.get("$animateCss") : null;
    return {
        link: function(scope, element, attrs) {
            function expand() {
                element.removeClass("collapse").addClass("collapsing").attr("aria-expanded", !0).attr("aria-hidden", !1), 
                $animateCss ? $animateCss(element, {
                    addClass: "in",
                    easing: "ease",
                    to: {
                        height: element[0].scrollHeight + "px"
                    }
                }).start().finally(expandDone) : $animate.addClass(element, "in", {
                    to: {
                        height: element[0].scrollHeight + "px"
                    }
                }).then(expandDone);
            }
            function expandDone() {
                element.removeClass("collapsing").addClass("collapse").css({
                    height: "auto"
                });
            }
            function collapse() {
                return element.hasClass("collapse") || element.hasClass("in") ? (element.css({
                    height: element[0].scrollHeight + "px"
                }).removeClass("collapse").addClass("collapsing").attr("aria-expanded", !1).attr("aria-hidden", !0), 
                void ($animateCss ? $animateCss(element, {
                    removeClass: "in",
                    to: {
                        height: "0"
                    }
                }).start().finally(collapseDone) : $animate.removeClass(element, "in", {
                    to: {
                        height: "0"
                    }
                }).then(collapseDone))) : collapseDone();
            }
            function collapseDone() {
                element.css({
                    height: "0"
                }), element.removeClass("collapsing").addClass("collapse");
            }
            scope.$watch(attrs.uibCollapse, function(shouldCollapse) {
                shouldCollapse ? collapse() : expand();
            });
        }
    };
} ]), angular.module("ui.bootstrap.collapse").value("$collapseSuppressWarning", !1).directive("collapse", [ "$animate", "$injector", "$log", "$collapseSuppressWarning", function($animate, $injector, $log, $collapseSuppressWarning) {
    var $animateCss = $injector.has("$animateCss") ? $injector.get("$animateCss") : null;
    return {
        link: function(scope, element, attrs) {
            function expand() {
                element.removeClass("collapse").addClass("collapsing").attr("aria-expanded", !0).attr("aria-hidden", !1), 
                $animateCss ? $animateCss(element, {
                    easing: "ease",
                    to: {
                        height: element[0].scrollHeight + "px"
                    }
                }).start().done(expandDone) : $animate.animate(element, {}, {
                    height: element[0].scrollHeight + "px"
                }).then(expandDone);
            }
            function expandDone() {
                element.removeClass("collapsing").addClass("collapse in").css({
                    height: "auto"
                });
            }
            function collapse() {
                return element.hasClass("collapse") || element.hasClass("in") ? (element.css({
                    height: element[0].scrollHeight + "px"
                }).removeClass("collapse in").addClass("collapsing").attr("aria-expanded", !1).attr("aria-hidden", !0), 
                void ($animateCss ? $animateCss(element, {
                    to: {
                        height: "0"
                    }
                }).start().done(collapseDone) : $animate.animate(element, {}, {
                    height: "0"
                }).then(collapseDone))) : collapseDone();
            }
            function collapseDone() {
                element.css({
                    height: "0"
                }), element.removeClass("collapsing").addClass("collapse");
            }
            $collapseSuppressWarning || $log.warn("collapse is now deprecated. Use uib-collapse instead."), 
            scope.$watch(attrs.collapse, function(shouldCollapse) {
                shouldCollapse ? collapse() : expand();
            });
        }
    };
} ]), angular.module("ui.bootstrap.accordion", [ "ui.bootstrap.collapse" ]).constant("uibAccordionConfig", {
    closeOthers: !0
}).controller("UibAccordionController", [ "$scope", "$attrs", "uibAccordionConfig", function($scope, $attrs, accordionConfig) {
    this.groups = [], this.closeOthers = function(openGroup) {
        var closeOthers = angular.isDefined($attrs.closeOthers) ? $scope.$eval($attrs.closeOthers) : accordionConfig.closeOthers;
        closeOthers && angular.forEach(this.groups, function(group) {
            group !== openGroup && (group.isOpen = !1);
        });
    }, this.addGroup = function(groupScope) {
        var that = this;
        this.groups.push(groupScope), groupScope.$on("$destroy", function() {
            that.removeGroup(groupScope);
        });
    }, this.removeGroup = function(group) {
        var index = this.groups.indexOf(group);
        -1 !== index && this.groups.splice(index, 1);
    };
} ]).directive("uibAccordion", function() {
    return {
        controller: "UibAccordionController",
        controllerAs: "accordion",
        transclude: !0,
        templateUrl: function(element, attrs) {
            return attrs.templateUrl || "template/accordion/accordion.html";
        }
    };
}).directive("uibAccordionGroup", function() {
    return {
        require: "^uibAccordion",
        transclude: !0,
        replace: !0,
        templateUrl: function(element, attrs) {
            return attrs.templateUrl || "template/accordion/accordion-group.html";
        },
        scope: {
            heading: "@",
            isOpen: "=?",
            isDisabled: "=?"
        },
        controller: function() {
            this.setHeading = function(element) {
                this.heading = element;
            };
        },
        link: function(scope, element, attrs, accordionCtrl) {
            accordionCtrl.addGroup(scope), scope.openClass = attrs.openClass || "panel-open", 
            scope.panelClass = attrs.panelClass, scope.$watch("isOpen", function(value) {
                element.toggleClass(scope.openClass, !!value), value && accordionCtrl.closeOthers(scope);
            }), scope.toggleOpen = function($event) {
                scope.isDisabled || $event && 32 !== $event.which || (scope.isOpen = !scope.isOpen);
            };
        }
    };
}).directive("uibAccordionHeading", function() {
    return {
        transclude: !0,
        template: "",
        replace: !0,
        require: "^uibAccordionGroup",
        link: function(scope, element, attrs, accordionGroupCtrl, transclude) {
            accordionGroupCtrl.setHeading(transclude(scope, angular.noop));
        }
    };
}).directive("uibAccordionTransclude", function() {
    return {
        require: [ "?^uibAccordionGroup", "?^accordionGroup" ],
        link: function(scope, element, attrs, controller) {
            controller = controller[0] ? controller[0] : controller[1], scope.$watch(function() {
                return controller[attrs.uibAccordionTransclude];
            }, function(heading) {
                heading && (element.find("span").html(""), element.find("span").append(heading));
            });
        }
    };
}), angular.module("ui.bootstrap.accordion").value("$accordionSuppressWarning", !1).controller("AccordionController", [ "$scope", "$attrs", "$controller", "$log", "$accordionSuppressWarning", function($scope, $attrs, $controller, $log, $accordionSuppressWarning) {
    $accordionSuppressWarning || $log.warn("AccordionController is now deprecated. Use UibAccordionController instead."), 
    angular.extend(this, $controller("UibAccordionController", {
        $scope: $scope,
        $attrs: $attrs
    }));
} ]).directive("accordion", [ "$log", "$accordionSuppressWarning", function($log, $accordionSuppressWarning) {
    return {
        restrict: "EA",
        controller: "AccordionController",
        controllerAs: "accordion",
        transclude: !0,
        replace: !1,
        templateUrl: function(element, attrs) {
            return attrs.templateUrl || "template/accordion/accordion.html";
        },
        link: function() {
            $accordionSuppressWarning || $log.warn("accordion is now deprecated. Use uib-accordion instead.");
        }
    };
} ]).directive("accordionGroup", [ "$log", "$accordionSuppressWarning", function($log, $accordionSuppressWarning) {
    return {
        require: "^accordion",
        restrict: "EA",
        transclude: !0,
        replace: !0,
        templateUrl: function(element, attrs) {
            return attrs.templateUrl || "template/accordion/accordion-group.html";
        },
        scope: {
            heading: "@",
            isOpen: "=?",
            isDisabled: "=?"
        },
        controller: function() {
            this.setHeading = function(element) {
                this.heading = element;
            };
        },
        link: function(scope, element, attrs, accordionCtrl) {
            $accordionSuppressWarning || $log.warn("accordion-group is now deprecated. Use uib-accordion-group instead."), 
            accordionCtrl.addGroup(scope), scope.openClass = attrs.openClass || "panel-open", 
            scope.panelClass = attrs.panelClass, scope.$watch("isOpen", function(value) {
                element.toggleClass(scope.openClass, !!value), value && accordionCtrl.closeOthers(scope);
            }), scope.toggleOpen = function($event) {
                scope.isDisabled || $event && 32 !== $event.which || (scope.isOpen = !scope.isOpen);
            };
        }
    };
} ]).directive("accordionHeading", [ "$log", "$accordionSuppressWarning", function($log, $accordionSuppressWarning) {
    return {
        restrict: "EA",
        transclude: !0,
        template: "",
        replace: !0,
        require: "^accordionGroup",
        link: function(scope, element, attr, accordionGroupCtrl, transclude) {
            $accordionSuppressWarning || $log.warn("accordion-heading is now deprecated. Use uib-accordion-heading instead."), 
            accordionGroupCtrl.setHeading(transclude(scope, angular.noop));
        }
    };
} ]).directive("accordionTransclude", [ "$log", "$accordionSuppressWarning", function($log, $accordionSuppressWarning) {
    return {
        require: "^accordionGroup",
        link: function(scope, element, attr, controller) {
            $accordionSuppressWarning || $log.warn("accordion-transclude is now deprecated. Use uib-accordion-transclude instead."), 
            scope.$watch(function() {
                return controller[attr.accordionTransclude];
            }, function(heading) {
                heading && (element.find("span").html(""), element.find("span").append(heading));
            });
        }
    };
} ]), angular.module("ui.bootstrap.alert", []).controller("UibAlertController", [ "$scope", "$attrs", "$interpolate", "$timeout", function($scope, $attrs, $interpolate, $timeout) {
    $scope.closeable = !!$attrs.close;
    var dismissOnTimeout = angular.isDefined($attrs.dismissOnTimeout) ? $interpolate($attrs.dismissOnTimeout)($scope.$parent) : null;
    dismissOnTimeout && $timeout(function() {
        $scope.close();
    }, parseInt(dismissOnTimeout, 10));
} ]).directive("uibAlert", function() {
    return {
        controller: "UibAlertController",
        controllerAs: "alert",
        templateUrl: function(element, attrs) {
            return attrs.templateUrl || "template/alert/alert.html";
        },
        transclude: !0,
        replace: !0,
        scope: {
            type: "@",
            close: "&"
        }
    };
}), angular.module("ui.bootstrap.alert").value("$alertSuppressWarning", !1).controller("AlertController", [ "$scope", "$attrs", "$controller", "$log", "$alertSuppressWarning", function($scope, $attrs, $controller, $log, $alertSuppressWarning) {
    $alertSuppressWarning || $log.warn("AlertController is now deprecated. Use UibAlertController instead."), 
    angular.extend(this, $controller("UibAlertController", {
        $scope: $scope,
        $attrs: $attrs
    }));
} ]).directive("alert", [ "$log", "$alertSuppressWarning", function($log, $alertSuppressWarning) {
    return {
        controller: "AlertController",
        controllerAs: "alert",
        templateUrl: function(element, attrs) {
            return attrs.templateUrl || "template/alert/alert.html";
        },
        transclude: !0,
        replace: !0,
        scope: {
            type: "@",
            close: "&"
        },
        link: function() {
            $alertSuppressWarning || $log.warn("alert is now deprecated. Use uib-alert instead.");
        }
    };
} ]), angular.module("ui.bootstrap.buttons", []).constant("uibButtonConfig", {
    activeClass: "active",
    toggleEvent: "click"
}).controller("UibButtonsController", [ "uibButtonConfig", function(buttonConfig) {
    this.activeClass = buttonConfig.activeClass || "active", this.toggleEvent = buttonConfig.toggleEvent || "click";
} ]).directive("uibBtnRadio", function() {
    return {
        require: [ "uibBtnRadio", "ngModel" ],
        controller: "UibButtonsController",
        controllerAs: "buttons",
        link: function(scope, element, attrs, ctrls) {
            var buttonsCtrl = ctrls[0], ngModelCtrl = ctrls[1];
            element.find("input").css({
                display: "none"
            }), ngModelCtrl.$render = function() {
                element.toggleClass(buttonsCtrl.activeClass, angular.equals(ngModelCtrl.$modelValue, scope.$eval(attrs.uibBtnRadio)));
            }, element.on(buttonsCtrl.toggleEvent, function() {
                if (!attrs.disabled) {
                    var isActive = element.hasClass(buttonsCtrl.activeClass);
                    (!isActive || angular.isDefined(attrs.uncheckable)) && scope.$apply(function() {
                        ngModelCtrl.$setViewValue(isActive ? null : scope.$eval(attrs.uibBtnRadio)), ngModelCtrl.$render();
                    });
                }
            });
        }
    };
}).directive("uibBtnCheckbox", function() {
    return {
        require: [ "uibBtnCheckbox", "ngModel" ],
        controller: "UibButtonsController",
        controllerAs: "button",
        link: function(scope, element, attrs, ctrls) {
            function getTrueValue() {
                return getCheckboxValue(attrs.btnCheckboxTrue, !0);
            }
            function getFalseValue() {
                return getCheckboxValue(attrs.btnCheckboxFalse, !1);
            }
            function getCheckboxValue(attribute, defaultValue) {
                return angular.isDefined(attribute) ? scope.$eval(attribute) : defaultValue;
            }
            var buttonsCtrl = ctrls[0], ngModelCtrl = ctrls[1];
            element.find("input").css({
                display: "none"
            }), ngModelCtrl.$render = function() {
                element.toggleClass(buttonsCtrl.activeClass, angular.equals(ngModelCtrl.$modelValue, getTrueValue()));
            }, element.on(buttonsCtrl.toggleEvent, function() {
                attrs.disabled || scope.$apply(function() {
                    ngModelCtrl.$setViewValue(element.hasClass(buttonsCtrl.activeClass) ? getFalseValue() : getTrueValue()), 
                    ngModelCtrl.$render();
                });
            });
        }
    };
}), angular.module("ui.bootstrap.buttons").value("$buttonsSuppressWarning", !1).controller("ButtonsController", [ "$controller", "$log", "$buttonsSuppressWarning", function($controller, $log, $buttonsSuppressWarning) {
    $buttonsSuppressWarning || $log.warn("ButtonsController is now deprecated. Use UibButtonsController instead."), 
    angular.extend(this, $controller("UibButtonsController"));
} ]).directive("btnRadio", [ "$log", "$buttonsSuppressWarning", function($log, $buttonsSuppressWarning) {
    return {
        require: [ "btnRadio", "ngModel" ],
        controller: "ButtonsController",
        controllerAs: "buttons",
        link: function(scope, element, attrs, ctrls) {
            $buttonsSuppressWarning || $log.warn("btn-radio is now deprecated. Use uib-btn-radio instead.");
            var buttonsCtrl = ctrls[0], ngModelCtrl = ctrls[1];
            element.find("input").css({
                display: "none"
            }), ngModelCtrl.$render = function() {
                element.toggleClass(buttonsCtrl.activeClass, angular.equals(ngModelCtrl.$modelValue, scope.$eval(attrs.btnRadio)));
            }, element.bind(buttonsCtrl.toggleEvent, function() {
                if (!attrs.disabled) {
                    var isActive = element.hasClass(buttonsCtrl.activeClass);
                    (!isActive || angular.isDefined(attrs.uncheckable)) && scope.$apply(function() {
                        ngModelCtrl.$setViewValue(isActive ? null : scope.$eval(attrs.btnRadio)), ngModelCtrl.$render();
                    });
                }
            });
        }
    };
} ]).directive("btnCheckbox", [ "$document", "$log", "$buttonsSuppressWarning", function($document, $log, $buttonsSuppressWarning) {
    return {
        require: [ "btnCheckbox", "ngModel" ],
        controller: "ButtonsController",
        controllerAs: "button",
        link: function(scope, element, attrs, ctrls) {
            function getTrueValue() {
                return getCheckboxValue(attrs.btnCheckboxTrue, !0);
            }
            function getFalseValue() {
                return getCheckboxValue(attrs.btnCheckboxFalse, !1);
            }
            function getCheckboxValue(attributeValue, defaultValue) {
                var val = scope.$eval(attributeValue);
                return angular.isDefined(val) ? val : defaultValue;
            }
            $buttonsSuppressWarning || $log.warn("btn-checkbox is now deprecated. Use uib-btn-checkbox instead.");
            var buttonsCtrl = ctrls[0], ngModelCtrl = ctrls[1];
            element.find("input").css({
                display: "none"
            }), ngModelCtrl.$render = function() {
                element.toggleClass(buttonsCtrl.activeClass, angular.equals(ngModelCtrl.$modelValue, getTrueValue()));
            }, element.bind(buttonsCtrl.toggleEvent, function() {
                attrs.disabled || scope.$apply(function() {
                    ngModelCtrl.$setViewValue(element.hasClass(buttonsCtrl.activeClass) ? getFalseValue() : getTrueValue()), 
                    ngModelCtrl.$render();
                });
            }), element.on("keypress", function(e) {
                attrs.disabled || 32 !== e.which || $document[0].activeElement !== element[0] || scope.$apply(function() {
                    ngModelCtrl.$setViewValue(element.hasClass(buttonsCtrl.activeClass) ? getFalseValue() : getTrueValue()), 
                    ngModelCtrl.$render();
                });
            });
        }
    };
} ]), angular.module("ui.bootstrap.carousel", []).controller("UibCarouselController", [ "$scope", "$element", "$interval", "$animate", function($scope, $element, $interval, $animate) {
    function goNext(slide, index, direction) {
        destroyed || (angular.extend(slide, {
            direction: direction,
            active: !0
        }), angular.extend(self.currentSlide || {}, {
            direction: direction,
            active: !1
        }), $animate.enabled() && !$scope.noTransition && !$scope.$currentTransition && slide.$element && self.slides.length > 1 && (slide.$element.data(SLIDE_DIRECTION, slide.direction), 
        self.currentSlide && self.currentSlide.$element && self.currentSlide.$element.data(SLIDE_DIRECTION, slide.direction), 
        $scope.$currentTransition = !0, NEW_ANIMATE ? $animate.on("addClass", slide.$element, function(element, phase) {
            "close" === phase && ($scope.$currentTransition = null, $animate.off("addClass", element));
        }) : slide.$element.one("$animate:close", function() {
            $scope.$currentTransition = null;
        })), self.currentSlide = slide, currentIndex = index, restartTimer());
    }
    function getSlideByIndex(index) {
        if (angular.isUndefined(slides[index].index)) return slides[index];
        {
            var i;
            slides.length;
        }
        for (i = 0; i < slides.length; ++i) if (slides[i].index == index) return slides[i];
    }
    function restartTimer() {
        resetTimer();
        var interval = +$scope.interval;
        !isNaN(interval) && interval > 0 && (currentInterval = $interval(timerFn, interval));
    }
    function resetTimer() {
        currentInterval && ($interval.cancel(currentInterval), currentInterval = null);
    }
    function timerFn() {
        var interval = +$scope.interval;
        isPlaying && !isNaN(interval) && interval > 0 && slides.length ? $scope.next() : $scope.pause();
    }
    function resetTransition(slides) {
        slides.length || ($scope.$currentTransition = null);
    }
    var currentInterval, isPlaying, self = this, slides = self.slides = $scope.slides = [], NEW_ANIMATE = angular.version.minor >= 4, NO_TRANSITION = "uib-noTransition", SLIDE_DIRECTION = "uib-slideDirection", currentIndex = -1;
    self.currentSlide = null;
    var destroyed = !1;
    self.select = $scope.select = function(nextSlide, direction) {
        var nextIndex = $scope.indexOfSlide(nextSlide);
        void 0 === direction && (direction = nextIndex > self.getCurrentIndex() ? "next" : "prev"), 
        nextSlide && nextSlide !== self.currentSlide && !$scope.$currentTransition && goNext(nextSlide, nextIndex, direction);
    }, $scope.$on("$destroy", function() {
        destroyed = !0;
    }), self.getCurrentIndex = function() {
        return self.currentSlide && angular.isDefined(self.currentSlide.index) ? +self.currentSlide.index : currentIndex;
    }, $scope.indexOfSlide = function(slide) {
        return angular.isDefined(slide.index) ? +slide.index : slides.indexOf(slide);
    }, $scope.next = function() {
        var newIndex = (self.getCurrentIndex() + 1) % slides.length;
        return 0 === newIndex && $scope.noWrap() ? void $scope.pause() : self.select(getSlideByIndex(newIndex), "next");
    }, $scope.prev = function() {
        var newIndex = self.getCurrentIndex() - 1 < 0 ? slides.length - 1 : self.getCurrentIndex() - 1;
        return $scope.noWrap() && newIndex === slides.length - 1 ? void $scope.pause() : self.select(getSlideByIndex(newIndex), "prev");
    }, $scope.isActive = function(slide) {
        return self.currentSlide === slide;
    }, $scope.$watch("interval", restartTimer), $scope.$watchCollection("slides", resetTransition), 
    $scope.$on("$destroy", resetTimer), $scope.play = function() {
        isPlaying || (isPlaying = !0, restartTimer());
    }, $scope.pause = function() {
        $scope.noPause || (isPlaying = !1, resetTimer());
    }, self.addSlide = function(slide, element) {
        slide.$element = element, slides.push(slide), 1 === slides.length || slide.active ? (self.select(slides[slides.length - 1]), 
        1 === slides.length && $scope.play()) : slide.active = !1;
    }, self.removeSlide = function(slide) {
        angular.isDefined(slide.index) && slides.sort(function(a, b) {
            return +a.index > +b.index;
        });
        var index = slides.indexOf(slide);
        slides.splice(index, 1), slides.length > 0 && slide.active ? self.select(index >= slides.length ? slides[index - 1] : slides[index]) : currentIndex > index && currentIndex--, 
        0 === slides.length && (self.currentSlide = null);
    }, $scope.$watch("noTransition", function(noTransition) {
        $element.data(NO_TRANSITION, noTransition);
    });
} ]).directive("uibCarousel", [ function() {
    return {
        transclude: !0,
        replace: !0,
        controller: "UibCarouselController",
        controllerAs: "carousel",
        require: "carousel",
        templateUrl: function(element, attrs) {
            return attrs.templateUrl || "template/carousel/carousel.html";
        },
        scope: {
            interval: "=",
            noTransition: "=",
            noPause: "=",
            noWrap: "&"
        }
    };
} ]).directive("uibSlide", function() {
    return {
        require: "^uibCarousel",
        restrict: "EA",
        transclude: !0,
        replace: !0,
        templateUrl: function(element, attrs) {
            return attrs.templateUrl || "template/carousel/slide.html";
        },
        scope: {
            active: "=?",
            actual: "=?",
            index: "=?"
        },
        link: function(scope, element, attrs, carouselCtrl) {
            carouselCtrl.addSlide(scope, element), scope.$on("$destroy", function() {
                carouselCtrl.removeSlide(scope);
            }), scope.$watch("active", function(active) {
                active && carouselCtrl.select(scope);
            });
        }
    };
}).animation(".item", [ "$injector", "$animate", function($injector, $animate) {
    function removeClass(element, className, callback) {
        element.removeClass(className), callback && callback();
    }
    var NO_TRANSITION = "uib-noTransition", SLIDE_DIRECTION = "uib-slideDirection", $animateCss = null;
    return $injector.has("$animateCss") && ($animateCss = $injector.get("$animateCss")), 
    {
        beforeAddClass: function(element, className, done) {
            if ("active" == className && element.parent() && element.parent().parent() && !element.parent().parent().data(NO_TRANSITION)) {
                var stopped = !1, direction = element.data(SLIDE_DIRECTION), directionClass = "next" == direction ? "left" : "right", removeClassFn = removeClass.bind(this, element, directionClass + " " + direction, done);
                return element.addClass(direction), $animateCss ? $animateCss(element, {
                    addClass: directionClass
                }).start().done(removeClassFn) : $animate.addClass(element, directionClass).then(function() {
                    stopped || removeClassFn(), done();
                }), function() {
                    stopped = !0;
                };
            }
            done();
        },
        beforeRemoveClass: function(element, className, done) {
            if ("active" === className && element.parent() && element.parent().parent() && !element.parent().parent().data(NO_TRANSITION)) {
                var stopped = !1, direction = element.data(SLIDE_DIRECTION), directionClass = "next" == direction ? "left" : "right", removeClassFn = removeClass.bind(this, element, directionClass, done);
                return $animateCss ? $animateCss(element, {
                    addClass: directionClass
                }).start().done(removeClassFn) : $animate.addClass(element, directionClass).then(function() {
                    stopped || removeClassFn(), done();
                }), function() {
                    stopped = !0;
                };
            }
            done();
        }
    };
} ]), angular.module("ui.bootstrap.carousel").value("$carouselSuppressWarning", !1).controller("CarouselController", [ "$scope", "$element", "$controller", "$log", "$carouselSuppressWarning", function($scope, $element, $controller, $log, $carouselSuppressWarning) {
    $carouselSuppressWarning || $log.warn("CarouselController is now deprecated. Use UibCarouselController instead."), 
    angular.extend(this, $controller("UibCarouselController", {
        $scope: $scope,
        $element: $element
    }));
} ]).directive("carousel", [ "$log", "$carouselSuppressWarning", function($log, $carouselSuppressWarning) {
    return {
        transclude: !0,
        replace: !0,
        controller: "CarouselController",
        controllerAs: "carousel",
        require: "carousel",
        templateUrl: function(element, attrs) {
            return attrs.templateUrl || "template/carousel/carousel.html";
        },
        scope: {
            interval: "=",
            noTransition: "=",
            noPause: "=",
            noWrap: "&"
        },
        link: function() {
            $carouselSuppressWarning || $log.warn("carousel is now deprecated. Use uib-carousel instead.");
        }
    };
} ]).directive("slide", [ "$log", "$carouselSuppressWarning", function($log, $carouselSuppressWarning) {
    return {
        require: "^carousel",
        transclude: !0,
        replace: !0,
        templateUrl: function(element, attrs) {
            return attrs.templateUrl || "template/carousel/slide.html";
        },
        scope: {
            active: "=?",
            actual: "=?",
            index: "=?"
        },
        link: function(scope, element, attrs, carouselCtrl) {
            $carouselSuppressWarning || $log.warn("slide is now deprecated. Use uib-slide instead."), 
            carouselCtrl.addSlide(scope, element), scope.$on("$destroy", function() {
                carouselCtrl.removeSlide(scope);
            }), scope.$watch("active", function(active) {
                active && carouselCtrl.select(scope);
            });
        }
    };
} ]), angular.module("ui.bootstrap.dateparser", []).service("uibDateParser", [ "$log", "$locale", "orderByFilter", function($log, $locale, orderByFilter) {
    function createParser(format) {
        var map = [], regex = format.split("");
        return angular.forEach(formatCodeToRegex, function(data, code) {
            var index = format.indexOf(code);
            if (index > -1) {
                format = format.split(""), regex[index] = "(" + data.regex + ")", format[index] = "$";
                for (var i = index + 1, n = index + code.length; n > i; i++) regex[i] = "", format[i] = "$";
                format = format.join(""), map.push({
                    index: index,
                    apply: data.apply
                });
            }
        }), {
            regex: new RegExp("^" + regex.join("") + "$"),
            map: orderByFilter(map, "index")
        };
    }
    function isValid(year, month, date) {
        return 1 > date ? !1 : 1 === month && date > 28 ? 29 === date && (year % 4 === 0 && year % 100 !== 0 || year % 400 === 0) : 3 === month || 5 === month || 8 === month || 10 === month ? 31 > date : !0;
    }
    var localeId, formatCodeToRegex, SPECIAL_CHARACTERS_REGEXP = /[\\\^\$\*\+\?\|\[\]\(\)\.\{\}]/g;
    this.init = function() {
        localeId = $locale.id, this.parsers = {}, formatCodeToRegex = {
            yyyy: {
                regex: "\\d{4}",
                apply: function(value) {
                    this.year = +value;
                }
            },
            yy: {
                regex: "\\d{2}",
                apply: function(value) {
                    this.year = +value + 2e3;
                }
            },
            y: {
                regex: "\\d{1,4}",
                apply: function(value) {
                    this.year = +value;
                }
            },
            MMMM: {
                regex: $locale.DATETIME_FORMATS.MONTH.join("|"),
                apply: function(value) {
                    this.month = $locale.DATETIME_FORMATS.MONTH.indexOf(value);
                }
            },
            MMM: {
                regex: $locale.DATETIME_FORMATS.SHORTMONTH.join("|"),
                apply: function(value) {
                    this.month = $locale.DATETIME_FORMATS.SHORTMONTH.indexOf(value);
                }
            },
            MM: {
                regex: "0[1-9]|1[0-2]",
                apply: function(value) {
                    this.month = value - 1;
                }
            },
            M: {
                regex: "[1-9]|1[0-2]",
                apply: function(value) {
                    this.month = value - 1;
                }
            },
            dd: {
                regex: "[0-2][0-9]{1}|3[0-1]{1}",
                apply: function(value) {
                    this.date = +value;
                }
            },
            d: {
                regex: "[1-2]?[0-9]{1}|3[0-1]{1}",
                apply: function(value) {
                    this.date = +value;
                }
            },
            EEEE: {
                regex: $locale.DATETIME_FORMATS.DAY.join("|")
            },
            EEE: {
                regex: $locale.DATETIME_FORMATS.SHORTDAY.join("|")
            },
            HH: {
                regex: "(?:0|1)[0-9]|2[0-3]",
                apply: function(value) {
                    this.hours = +value;
                }
            },
            hh: {
                regex: "0[0-9]|1[0-2]",
                apply: function(value) {
                    this.hours = +value;
                }
            },
            H: {
                regex: "1?[0-9]|2[0-3]",
                apply: function(value) {
                    this.hours = +value;
                }
            },
            h: {
                regex: "[0-9]|1[0-2]",
                apply: function(value) {
                    this.hours = +value;
                }
            },
            mm: {
                regex: "[0-5][0-9]",
                apply: function(value) {
                    this.minutes = +value;
                }
            },
            m: {
                regex: "[0-9]|[1-5][0-9]",
                apply: function(value) {
                    this.minutes = +value;
                }
            },
            sss: {
                regex: "[0-9][0-9][0-9]",
                apply: function(value) {
                    this.milliseconds = +value;
                }
            },
            ss: {
                regex: "[0-5][0-9]",
                apply: function(value) {
                    this.seconds = +value;
                }
            },
            s: {
                regex: "[0-9]|[1-5][0-9]",
                apply: function(value) {
                    this.seconds = +value;
                }
            },
            a: {
                regex: $locale.DATETIME_FORMATS.AMPMS.join("|"),
                apply: function(value) {
                    12 === this.hours && (this.hours = 0), "PM" === value && (this.hours += 12);
                }
            }
        };
    }, this.init(), this.parse = function(input, format, baseDate) {
        if (!angular.isString(input) || !format) return input;
        format = $locale.DATETIME_FORMATS[format] || format, format = format.replace(SPECIAL_CHARACTERS_REGEXP, "\\$&"), 
        $locale.id !== localeId && this.init(), this.parsers[format] || (this.parsers[format] = createParser(format));
        var parser = this.parsers[format], regex = parser.regex, map = parser.map, results = input.match(regex);
        if (results && results.length) {
            var fields, dt;
            angular.isDate(baseDate) && !isNaN(baseDate.getTime()) ? fields = {
                year: baseDate.getFullYear(),
                month: baseDate.getMonth(),
                date: baseDate.getDate(),
                hours: baseDate.getHours(),
                minutes: baseDate.getMinutes(),
                seconds: baseDate.getSeconds(),
                milliseconds: baseDate.getMilliseconds()
            } : (baseDate && $log.warn("dateparser:", "baseDate is not a valid date"), fields = {
                year: 1900,
                month: 0,
                date: 1,
                hours: 0,
                minutes: 0,
                seconds: 0,
                milliseconds: 0
            });
            for (var i = 1, n = results.length; n > i; i++) {
                var mapper = map[i - 1];
                mapper.apply && mapper.apply.call(fields, results[i]);
            }
            return isValid(fields.year, fields.month, fields.date) && (angular.isDate(baseDate) && !isNaN(baseDate.getTime()) ? (dt = new Date(baseDate), 
            dt.setFullYear(fields.year, fields.month, fields.date, fields.hours, fields.minutes, fields.seconds, fields.milliseconds || 0)) : dt = new Date(fields.year, fields.month, fields.date, fields.hours, fields.minutes, fields.seconds, fields.milliseconds || 0)), 
            dt;
        }
    };
} ]), angular.module("ui.bootstrap.dateparser").value("$dateParserSuppressWarning", !1).service("dateParser", [ "$log", "$dateParserSuppressWarning", "uibDateParser", function($log, $dateParserSuppressWarning, uibDateParser) {
    $dateParserSuppressWarning || $log.warn("dateParser is now deprecated. Use uibDateParser instead."), 
    angular.extend(this, uibDateParser);
} ]), angular.module("ui.bootstrap.position", []).factory("$uibPosition", [ "$document", "$window", function($document, $window) {
    function getStyle(el, cssprop) {
        return el.currentStyle ? el.currentStyle[cssprop] : $window.getComputedStyle ? $window.getComputedStyle(el)[cssprop] : el.style[cssprop];
    }
    function isStaticPositioned(element) {
        return "static" === (getStyle(element, "position") || "static");
    }
    var parentOffsetEl = function(element) {
        for (var docDomEl = $document[0], offsetParent = element.offsetParent || docDomEl; offsetParent && offsetParent !== docDomEl && isStaticPositioned(offsetParent); ) offsetParent = offsetParent.offsetParent;
        return offsetParent || docDomEl;
    };
    return {
        position: function(element) {
            var elBCR = this.offset(element), offsetParentBCR = {
                top: 0,
                left: 0
            }, offsetParentEl = parentOffsetEl(element[0]);
            offsetParentEl != $document[0] && (offsetParentBCR = this.offset(angular.element(offsetParentEl)), 
            offsetParentBCR.top += offsetParentEl.clientTop - offsetParentEl.scrollTop, offsetParentBCR.left += offsetParentEl.clientLeft - offsetParentEl.scrollLeft);
            var boundingClientRect = element[0].getBoundingClientRect();
            return {
                width: boundingClientRect.width || element.prop("offsetWidth"),
                height: boundingClientRect.height || element.prop("offsetHeight"),
                top: elBCR.top - offsetParentBCR.top,
                left: elBCR.left - offsetParentBCR.left
            };
        },
        offset: function(element) {
            var boundingClientRect = element[0].getBoundingClientRect();
            return {
                width: boundingClientRect.width || element.prop("offsetWidth"),
                height: boundingClientRect.height || element.prop("offsetHeight"),
                top: boundingClientRect.top + ($window.pageYOffset || $document[0].documentElement.scrollTop),
                left: boundingClientRect.left + ($window.pageXOffset || $document[0].documentElement.scrollLeft)
            };
        },
        positionElements: function(hostEl, targetEl, positionStr, appendToBody) {
            var hostElPos, targetElWidth, targetElHeight, targetElPos, positionStrParts = positionStr.split("-"), pos0 = positionStrParts[0], pos1 = positionStrParts[1] || "center";
            hostElPos = appendToBody ? this.offset(hostEl) : this.position(hostEl), targetElWidth = targetEl.prop("offsetWidth"), 
            targetElHeight = targetEl.prop("offsetHeight");
            var shiftWidth = {
                center: function() {
                    return hostElPos.left + hostElPos.width / 2 - targetElWidth / 2;
                },
                left: function() {
                    return hostElPos.left;
                },
                right: function() {
                    return hostElPos.left + hostElPos.width;
                }
            }, shiftHeight = {
                center: function() {
                    return hostElPos.top + hostElPos.height / 2 - targetElHeight / 2;
                },
                top: function() {
                    return hostElPos.top;
                },
                bottom: function() {
                    return hostElPos.top + hostElPos.height;
                }
            };
            switch (pos0) {
              case "right":
                targetElPos = {
                    top: shiftHeight[pos1](),
                    left: shiftWidth[pos0]()
                };
                break;

              case "left":
                targetElPos = {
                    top: shiftHeight[pos1](),
                    left: hostElPos.left - targetElWidth
                };
                break;

              case "bottom":
                targetElPos = {
                    top: shiftHeight[pos0](),
                    left: shiftWidth[pos1]()
                };
                break;

              default:
                targetElPos = {
                    top: hostElPos.top - targetElHeight,
                    left: shiftWidth[pos1]()
                };
            }
            return targetElPos;
        }
    };
} ]), angular.module("ui.bootstrap.position").value("$positionSuppressWarning", !1).service("$position", [ "$log", "$positionSuppressWarning", "$uibPosition", function($log, $positionSuppressWarning, $uibPosition) {
    $positionSuppressWarning || $log.warn("$position is now deprecated. Use $uibPosition instead."), 
    angular.extend(this, $uibPosition);
} ]), angular.module("ui.bootstrap.datepicker", [ "ui.bootstrap.dateparser", "ui.bootstrap.position" ]).value("$datepickerSuppressError", !1).constant("uibDatepickerConfig", {
    formatDay: "dd",
    formatMonth: "MMMM",
    formatYear: "yyyy",
    formatDayHeader: "EEE",
    formatDayTitle: "MMMM yyyy",
    formatMonthTitle: "yyyy",
    datepickerMode: "day",
    minMode: "day",
    maxMode: "year",
    showWeeks: !0,
    startingDay: 0,
    yearRange: 20,
    minDate: null,
    maxDate: null,
    shortcutPropagation: !1
}).controller("UibDatepickerController", [ "$scope", "$attrs", "$parse", "$interpolate", "$log", "dateFilter", "uibDatepickerConfig", "$datepickerSuppressError", function($scope, $attrs, $parse, $interpolate, $log, dateFilter, datepickerConfig, $datepickerSuppressError) {
    var self = this, ngModelCtrl = {
        $setViewValue: angular.noop
    };
    this.modes = [ "day", "month", "year" ], angular.forEach([ "formatDay", "formatMonth", "formatYear", "formatDayHeader", "formatDayTitle", "formatMonthTitle", "showWeeks", "startingDay", "yearRange", "shortcutPropagation" ], function(key, index) {
        self[key] = angular.isDefined($attrs[key]) ? 6 > index ? $interpolate($attrs[key])($scope.$parent) : $scope.$parent.$eval($attrs[key]) : datepickerConfig[key];
    }), angular.forEach([ "minDate", "maxDate" ], function(key) {
        $attrs[key] ? $scope.$parent.$watch($parse($attrs[key]), function(value) {
            self[key] = value ? new Date(value) : null, self.refreshView();
        }) : self[key] = datepickerConfig[key] ? new Date(datepickerConfig[key]) : null;
    }), angular.forEach([ "minMode", "maxMode" ], function(key) {
        $attrs[key] ? $scope.$parent.$watch($parse($attrs[key]), function(value) {
            self[key] = angular.isDefined(value) ? value : $attrs[key], $scope[key] = self[key], 
            ("minMode" == key && self.modes.indexOf($scope.datepickerMode) < self.modes.indexOf(self[key]) || "maxMode" == key && self.modes.indexOf($scope.datepickerMode) > self.modes.indexOf(self[key])) && ($scope.datepickerMode = self[key]);
        }) : (self[key] = datepickerConfig[key] || null, $scope[key] = self[key]);
    }), $scope.datepickerMode = $scope.datepickerMode || datepickerConfig.datepickerMode, 
    $scope.uniqueId = "datepicker-" + $scope.$id + "-" + Math.floor(1e4 * Math.random()), 
    angular.isDefined($attrs.initDate) ? (this.activeDate = $scope.$parent.$eval($attrs.initDate) || new Date(), 
    $scope.$parent.$watch($attrs.initDate, function(initDate) {
        initDate && (ngModelCtrl.$isEmpty(ngModelCtrl.$modelValue) || ngModelCtrl.$invalid) && (self.activeDate = initDate, 
        self.refreshView());
    })) : this.activeDate = new Date(), $scope.isActive = function(dateObject) {
        return 0 === self.compare(dateObject.date, self.activeDate) ? ($scope.activeDateId = dateObject.uid, 
        !0) : !1;
    }, this.init = function(ngModelCtrl_) {
        ngModelCtrl = ngModelCtrl_, ngModelCtrl.$render = function() {
            self.render();
        };
    }, this.render = function() {
        if (ngModelCtrl.$viewValue) {
            var date = new Date(ngModelCtrl.$viewValue), isValid = !isNaN(date);
            isValid ? this.activeDate = date : $datepickerSuppressError || $log.error('Datepicker directive: "ng-model" value must be a Date object, a number of milliseconds since 01.01.1970 or a string representing an RFC2822 or ISO 8601 date.');
        }
        this.refreshView();
    }, this.refreshView = function() {
        if (this.element) {
            this._refreshView();
            var date = ngModelCtrl.$viewValue ? new Date(ngModelCtrl.$viewValue) : null;
            ngModelCtrl.$setValidity("dateDisabled", !date || this.element && !this.isDisabled(date));
        }
    }, this.createDateObject = function(date, format) {
        var model = ngModelCtrl.$viewValue ? new Date(ngModelCtrl.$viewValue) : null;
        return {
            date: date,
            label: dateFilter(date, format),
            selected: model && 0 === this.compare(date, model),
            disabled: this.isDisabled(date),
            current: 0 === this.compare(date, new Date()),
            customClass: this.customClass(date)
        };
    }, this.isDisabled = function(date) {
        return this.minDate && this.compare(date, this.minDate) < 0 || this.maxDate && this.compare(date, this.maxDate) > 0 || $attrs.dateDisabled && $scope.dateDisabled({
            date: date,
            mode: $scope.datepickerMode
        });
    }, this.customClass = function(date) {
        return $scope.customClass({
            date: date,
            mode: $scope.datepickerMode
        });
    }, this.split = function(arr, size) {
        for (var arrays = []; arr.length > 0; ) arrays.push(arr.splice(0, size));
        return arrays;
    }, $scope.select = function(date) {
        if ($scope.datepickerMode === self.minMode) {
            var dt = ngModelCtrl.$viewValue ? new Date(ngModelCtrl.$viewValue) : new Date(0, 0, 0, 0, 0, 0, 0);
            dt.setFullYear(date.getFullYear(), date.getMonth(), date.getDate()), ngModelCtrl.$setViewValue(dt), 
            ngModelCtrl.$render();
        } else self.activeDate = date, $scope.datepickerMode = self.modes[self.modes.indexOf($scope.datepickerMode) - 1];
    }, $scope.move = function(direction) {
        var year = self.activeDate.getFullYear() + direction * (self.step.years || 0), month = self.activeDate.getMonth() + direction * (self.step.months || 0);
        self.activeDate.setFullYear(year, month, 1), self.refreshView();
    }, $scope.toggleMode = function(direction) {
        direction = direction || 1, $scope.datepickerMode === self.maxMode && 1 === direction || $scope.datepickerMode === self.minMode && -1 === direction || ($scope.datepickerMode = self.modes[self.modes.indexOf($scope.datepickerMode) + direction]);
    }, $scope.keys = {
        13: "enter",
        32: "space",
        33: "pageup",
        34: "pagedown",
        35: "end",
        36: "home",
        37: "left",
        38: "up",
        39: "right",
        40: "down"
    };
    var focusElement = function() {
        self.element[0].focus();
    };
    $scope.$on("uib:datepicker.focus", focusElement), $scope.keydown = function(evt) {
        var key = $scope.keys[evt.which];
        if (key && !evt.shiftKey && !evt.altKey) if (evt.preventDefault(), self.shortcutPropagation || evt.stopPropagation(), 
        "enter" === key || "space" === key) {
            if (self.isDisabled(self.activeDate)) return;
            $scope.select(self.activeDate);
        } else !evt.ctrlKey || "up" !== key && "down" !== key ? (self.handleKeyDown(key, evt), 
        self.refreshView()) : $scope.toggleMode("up" === key ? 1 : -1);
    };
} ]).controller("UibDaypickerController", [ "$scope", "$element", "dateFilter", function(scope, $element, dateFilter) {
    function getDaysInMonth(year, month) {
        return 1 !== month || year % 4 !== 0 || year % 100 === 0 && year % 400 !== 0 ? DAYS_IN_MONTH[month] : 29;
    }
    function getISO8601WeekNumber(date) {
        var checkDate = new Date(date);
        checkDate.setDate(checkDate.getDate() + 4 - (checkDate.getDay() || 7));
        var time = checkDate.getTime();
        return checkDate.setMonth(0), checkDate.setDate(1), Math.floor(Math.round((time - checkDate) / 864e5) / 7) + 1;
    }
    var DAYS_IN_MONTH = [ 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 ];
    this.step = {
        months: 1
    }, this.element = $element, this.init = function(ctrl) {
        angular.extend(ctrl, this), scope.showWeeks = ctrl.showWeeks, ctrl.refreshView();
    }, this.getDates = function(startDate, n) {
        for (var date, dates = new Array(n), current = new Date(startDate), i = 0; n > i; ) date = new Date(current), 
        dates[i++] = date, current.setDate(current.getDate() + 1);
        return dates;
    }, this._refreshView = function() {
        var year = this.activeDate.getFullYear(), month = this.activeDate.getMonth(), firstDayOfMonth = new Date(this.activeDate);
        firstDayOfMonth.setFullYear(year, month, 1);
        var difference = this.startingDay - firstDayOfMonth.getDay(), numDisplayedFromPreviousMonth = difference > 0 ? 7 - difference : -difference, firstDate = new Date(firstDayOfMonth);
        numDisplayedFromPreviousMonth > 0 && firstDate.setDate(-numDisplayedFromPreviousMonth + 1);
        for (var days = this.getDates(firstDate, 42), i = 0; 42 > i; i++) days[i] = angular.extend(this.createDateObject(days[i], this.formatDay), {
            secondary: days[i].getMonth() !== month,
            uid: scope.uniqueId + "-" + i
        });
        scope.labels = new Array(7);
        for (var j = 0; 7 > j; j++) scope.labels[j] = {
            abbr: dateFilter(days[j].date, this.formatDayHeader),
            full: dateFilter(days[j].date, "EEEE")
        };
        if (scope.title = dateFilter(this.activeDate, this.formatDayTitle), scope.rows = this.split(days, 7), 
        scope.showWeeks) {
            scope.weekNumbers = [];
            for (var thursdayIndex = (11 - this.startingDay) % 7, numWeeks = scope.rows.length, curWeek = 0; numWeeks > curWeek; curWeek++) scope.weekNumbers.push(getISO8601WeekNumber(scope.rows[curWeek][thursdayIndex].date));
        }
    }, this.compare = function(date1, date2) {
        return new Date(date1.getFullYear(), date1.getMonth(), date1.getDate()) - new Date(date2.getFullYear(), date2.getMonth(), date2.getDate());
    }, this.handleKeyDown = function(key) {
        var date = this.activeDate.getDate();
        if ("left" === key) date -= 1; else if ("up" === key) date -= 7; else if ("right" === key) date += 1; else if ("down" === key) date += 7; else if ("pageup" === key || "pagedown" === key) {
            var month = this.activeDate.getMonth() + ("pageup" === key ? -1 : 1);
            this.activeDate.setMonth(month, 1), date = Math.min(getDaysInMonth(this.activeDate.getFullYear(), this.activeDate.getMonth()), date);
        } else "home" === key ? date = 1 : "end" === key && (date = getDaysInMonth(this.activeDate.getFullYear(), this.activeDate.getMonth()));
        this.activeDate.setDate(date);
    };
} ]).controller("UibMonthpickerController", [ "$scope", "$element", "dateFilter", function(scope, $element, dateFilter) {
    this.step = {
        years: 1
    }, this.element = $element, this.init = function(ctrl) {
        angular.extend(ctrl, this), ctrl.refreshView();
    }, this._refreshView = function() {
        for (var date, months = new Array(12), year = this.activeDate.getFullYear(), i = 0; 12 > i; i++) date = new Date(this.activeDate), 
        date.setFullYear(year, i, 1), months[i] = angular.extend(this.createDateObject(date, this.formatMonth), {
            uid: scope.uniqueId + "-" + i
        });
        scope.title = dateFilter(this.activeDate, this.formatMonthTitle), scope.rows = this.split(months, 3);
    }, this.compare = function(date1, date2) {
        return new Date(date1.getFullYear(), date1.getMonth()) - new Date(date2.getFullYear(), date2.getMonth());
    }, this.handleKeyDown = function(key) {
        var date = this.activeDate.getMonth();
        if ("left" === key) date -= 1; else if ("up" === key) date -= 3; else if ("right" === key) date += 1; else if ("down" === key) date += 3; else if ("pageup" === key || "pagedown" === key) {
            var year = this.activeDate.getFullYear() + ("pageup" === key ? -1 : 1);
            this.activeDate.setFullYear(year);
        } else "home" === key ? date = 0 : "end" === key && (date = 11);
        this.activeDate.setMonth(date);
    };
} ]).controller("UibYearpickerController", [ "$scope", "$element", "dateFilter", function(scope, $element) {
    function getStartingYear(year) {
        return parseInt((year - 1) / range, 10) * range + 1;
    }
    var range;
    this.element = $element, this.yearpickerInit = function() {
        range = this.yearRange, this.step = {
            years: range
        };
    }, this._refreshView = function() {
        for (var date, years = new Array(range), i = 0, start = getStartingYear(this.activeDate.getFullYear()); range > i; i++) date = new Date(this.activeDate), 
        date.setFullYear(start + i, 0, 1), years[i] = angular.extend(this.createDateObject(date, this.formatYear), {
            uid: scope.uniqueId + "-" + i
        });
        scope.title = [ years[0].label, years[range - 1].label ].join(" - "), scope.rows = this.split(years, 5);
    }, this.compare = function(date1, date2) {
        return date1.getFullYear() - date2.getFullYear();
    }, this.handleKeyDown = function(key) {
        var date = this.activeDate.getFullYear();
        "left" === key ? date -= 1 : "up" === key ? date -= 5 : "right" === key ? date += 1 : "down" === key ? date += 5 : "pageup" === key || "pagedown" === key ? date += ("pageup" === key ? -1 : 1) * this.step.years : "home" === key ? date = getStartingYear(this.activeDate.getFullYear()) : "end" === key && (date = getStartingYear(this.activeDate.getFullYear()) + range - 1), 
        this.activeDate.setFullYear(date);
    };
} ]).directive("uibDatepicker", function() {
    return {
        replace: !0,
        templateUrl: function(element, attrs) {
            return attrs.templateUrl || "template/datepicker/datepicker.html";
        },
        scope: {
            datepickerMode: "=?",
            dateDisabled: "&",
            customClass: "&",
            shortcutPropagation: "&?"
        },
        require: [ "uibDatepicker", "^ngModel" ],
        controller: "UibDatepickerController",
        controllerAs: "datepicker",
        link: function(scope, element, attrs, ctrls) {
            var datepickerCtrl = ctrls[0], ngModelCtrl = ctrls[1];
            datepickerCtrl.init(ngModelCtrl);
        }
    };
}).directive("uibDaypicker", function() {
    return {
        replace: !0,
        templateUrl: function(element, attrs) {
            return attrs.templateUrl || "template/datepicker/day.html";
        },
        require: [ "^?uibDatepicker", "uibDaypicker", "^?datepicker" ],
        controller: "UibDaypickerController",
        link: function(scope, element, attrs, ctrls) {
            var datepickerCtrl = ctrls[0] || ctrls[2], daypickerCtrl = ctrls[1];
            daypickerCtrl.init(datepickerCtrl);
        }
    };
}).directive("uibMonthpicker", function() {
    return {
        replace: !0,
        templateUrl: function(element, attrs) {
            return attrs.templateUrl || "template/datepicker/month.html";
        },
        require: [ "^?uibDatepicker", "uibMonthpicker", "^?datepicker" ],
        controller: "UibMonthpickerController",
        link: function(scope, element, attrs, ctrls) {
            var datepickerCtrl = ctrls[0] || ctrls[2], monthpickerCtrl = ctrls[1];
            monthpickerCtrl.init(datepickerCtrl);
        }
    };
}).directive("uibYearpicker", function() {
    return {
        replace: !0,
        templateUrl: function(element, attrs) {
            return attrs.templateUrl || "template/datepicker/year.html";
        },
        require: [ "^?uibDatepicker", "uibYearpicker", "^?datepicker" ],
        controller: "UibYearpickerController",
        link: function(scope, element, attrs, ctrls) {
            var ctrl = ctrls[0] || ctrls[2];
            angular.extend(ctrl, ctrls[1]), ctrl.yearpickerInit(), ctrl.refreshView();
        }
    };
}).constant("uibDatepickerPopupConfig", {
    datepickerPopup: "yyyy-MM-dd",
    datepickerPopupTemplateUrl: "template/datepicker/popup.html",
    datepickerTemplateUrl: "template/datepicker/datepicker.html",
    html5Types: {
        date: "yyyy-MM-dd",
        "datetime-local": "yyyy-MM-ddTHH:mm:ss.sss",
        month: "yyyy-MM"
    },
    currentText: "Today",
    clearText: "Clear",
    closeText: "Done",
    closeOnDateSelection: !0,
    appendToBody: !1,
    showButtonBar: !0,
    onOpenFocus: !0
}).controller("UibDatepickerPopupController", [ "$scope", "$element", "$attrs", "$compile", "$parse", "$document", "$rootScope", "$uibPosition", "dateFilter", "uibDateParser", "uibDatepickerPopupConfig", "$timeout", function(scope, element, attrs, $compile, $parse, $document, $rootScope, $position, dateFilter, dateParser, datepickerPopupConfig, $timeout) {
    function cameltoDash(string) {
        return string.replace(/([A-Z])/g, function($1) {
            return "-" + $1.toLowerCase();
        });
    }
    function parseDate(viewValue) {
        if (angular.isNumber(viewValue) && (viewValue = new Date(viewValue)), viewValue) {
            if (angular.isDate(viewValue) && !isNaN(viewValue)) return viewValue;
            if (angular.isString(viewValue)) {
                var date = dateParser.parse(viewValue, dateFormat, scope.date);
                return isNaN(date) ? void 0 : date;
            }
            return void 0;
        }
        return null;
    }
    function validator(modelValue, viewValue) {
        var value = modelValue || viewValue;
        if (!attrs.ngRequired && !value) return !0;
        if (angular.isNumber(value) && (value = new Date(value)), value) {
            if (angular.isDate(value) && !isNaN(value)) return !0;
            if (angular.isString(value)) {
                var date = dateParser.parse(value, dateFormat);
                return !isNaN(date);
            }
            return !1;
        }
        return !0;
    }
    function documentClickBind(event) {
        var popup = $popup[0], dpContainsTarget = element[0].contains(event.target), popupContainsTarget = void 0 !== popup.contains && popup.contains(event.target);
        !scope.isOpen || dpContainsTarget || popupContainsTarget || scope.$apply(function() {
            scope.isOpen = !1;
        });
    }
    function inputKeydownBind(evt) {
        27 === evt.which && scope.isOpen ? (evt.preventDefault(), evt.stopPropagation(), 
        scope.$apply(function() {
            scope.isOpen = !1;
        }), element[0].focus()) : 40 !== evt.which || scope.isOpen || (evt.preventDefault(), 
        evt.stopPropagation(), scope.$apply(function() {
            scope.isOpen = !0;
        }));
    }
    var dateFormat, closeOnDateSelection, appendToBody, onOpenFocus, datepickerPopupTemplateUrl, datepickerTemplateUrl, popupEl, datepickerEl, ngModel, $popup, cache = {}, isHtml5DateInput = !1;
    scope.watchData = {}, this.init = function(_ngModel_) {
        if (ngModel = _ngModel_, closeOnDateSelection = angular.isDefined(attrs.closeOnDateSelection) ? scope.$parent.$eval(attrs.closeOnDateSelection) : datepickerPopupConfig.closeOnDateSelection, 
        appendToBody = angular.isDefined(attrs.datepickerAppendToBody) ? scope.$parent.$eval(attrs.datepickerAppendToBody) : datepickerPopupConfig.appendToBody, 
        onOpenFocus = angular.isDefined(attrs.onOpenFocus) ? scope.$parent.$eval(attrs.onOpenFocus) : datepickerPopupConfig.onOpenFocus, 
        datepickerPopupTemplateUrl = angular.isDefined(attrs.datepickerPopupTemplateUrl) ? attrs.datepickerPopupTemplateUrl : datepickerPopupConfig.datepickerPopupTemplateUrl, 
        datepickerTemplateUrl = angular.isDefined(attrs.datepickerTemplateUrl) ? attrs.datepickerTemplateUrl : datepickerPopupConfig.datepickerTemplateUrl, 
        scope.showButtonBar = angular.isDefined(attrs.showButtonBar) ? scope.$parent.$eval(attrs.showButtonBar) : datepickerPopupConfig.showButtonBar, 
        datepickerPopupConfig.html5Types[attrs.type] ? (dateFormat = datepickerPopupConfig.html5Types[attrs.type], 
        isHtml5DateInput = !0) : (dateFormat = attrs.datepickerPopup || attrs.uibDatepickerPopup || datepickerPopupConfig.datepickerPopup, 
        attrs.$observe("uibDatepickerPopup", function(value) {
            var newDateFormat = value || datepickerPopupConfig.datepickerPopup;
            if (newDateFormat !== dateFormat && (dateFormat = newDateFormat, ngModel.$modelValue = null, 
            !dateFormat)) throw new Error("uibDatepickerPopup must have a date format specified.");
        })), !dateFormat) throw new Error("uibDatepickerPopup must have a date format specified.");
        if (isHtml5DateInput && attrs.datepickerPopup) throw new Error("HTML5 date input types do not support custom formats.");
        if (popupEl = angular.element("<div uib-datepicker-popup-wrap><div uib-datepicker></div></div>"), 
        popupEl.attr({
            "ng-model": "date",
            "ng-change": "dateSelection(date)",
            "template-url": datepickerPopupTemplateUrl
        }), datepickerEl = angular.element(popupEl.children()[0]), datepickerEl.attr("template-url", datepickerTemplateUrl), 
        isHtml5DateInput && "month" === attrs.type && (datepickerEl.attr("datepicker-mode", '"month"'), 
        datepickerEl.attr("min-mode", "month")), attrs.datepickerOptions) {
            var options = scope.$parent.$eval(attrs.datepickerOptions);
            options && options.initDate && (scope.initDate = options.initDate, datepickerEl.attr("init-date", "initDate"), 
            delete options.initDate), angular.forEach(options, function(value, option) {
                datepickerEl.attr(cameltoDash(option), value);
            });
        }
        angular.forEach([ "minMode", "maxMode", "minDate", "maxDate", "datepickerMode", "initDate", "shortcutPropagation" ], function(key) {
            if (attrs[key]) {
                var getAttribute = $parse(attrs[key]);
                if (scope.$parent.$watch(getAttribute, function(value) {
                    scope.watchData[key] = value, ("minDate" === key || "maxDate" === key) && (cache[key] = new Date(value));
                }), datepickerEl.attr(cameltoDash(key), "watchData." + key), "datepickerMode" === key) {
                    var setAttribute = getAttribute.assign;
                    scope.$watch("watchData." + key, function(value, oldvalue) {
                        angular.isFunction(setAttribute) && value !== oldvalue && setAttribute(scope.$parent, value);
                    });
                }
            }
        }), attrs.dateDisabled && datepickerEl.attr("date-disabled", "dateDisabled({ date: date, mode: mode })"), 
        attrs.showWeeks && datepickerEl.attr("show-weeks", attrs.showWeeks), attrs.customClass && datepickerEl.attr("custom-class", "customClass({ date: date, mode: mode })"), 
        isHtml5DateInput ? ngModel.$formatters.push(function(value) {
            return scope.date = value, value;
        }) : (ngModel.$$parserName = "date", ngModel.$validators.date = validator, ngModel.$parsers.unshift(parseDate), 
        ngModel.$formatters.push(function(value) {
            return scope.date = value, ngModel.$isEmpty(value) ? value : dateFilter(value, dateFormat);
        })), ngModel.$viewChangeListeners.push(function() {
            scope.date = dateParser.parse(ngModel.$viewValue, dateFormat, scope.date);
        }), element.bind("keydown", inputKeydownBind), $popup = $compile(popupEl)(scope), 
        popupEl.remove(), appendToBody ? $document.find("body").append($popup) : element.after($popup), 
        scope.$on("$destroy", function() {
            scope.isOpen === !0 && ($rootScope.$$phase || scope.$apply(function() {
                scope.isOpen = !1;
            })), $popup.remove(), element.unbind("keydown", inputKeydownBind), $document.unbind("click", documentClickBind);
        });
    }, scope.getText = function(key) {
        return scope[key + "Text"] || datepickerPopupConfig[key + "Text"];
    }, scope.isDisabled = function(date) {
        return "today" === date && (date = new Date()), scope.watchData.minDate && scope.compare(date, cache.minDate) < 0 || scope.watchData.maxDate && scope.compare(date, cache.maxDate) > 0;
    }, scope.compare = function(date1, date2) {
        return new Date(date1.getFullYear(), date1.getMonth(), date1.getDate()) - new Date(date2.getFullYear(), date2.getMonth(), date2.getDate());
    }, scope.dateSelection = function(dt) {
        angular.isDefined(dt) && (scope.date = dt);
        var date = scope.date ? dateFilter(scope.date, dateFormat) : null;
        element.val(date), ngModel.$setViewValue(date), closeOnDateSelection && (scope.isOpen = !1, 
        element[0].focus());
    }, scope.keydown = function(evt) {
        27 === evt.which && (scope.isOpen = !1, element[0].focus());
    }, scope.select = function(date) {
        if ("today" === date) {
            var today = new Date();
            angular.isDate(scope.date) ? (date = new Date(scope.date), date.setFullYear(today.getFullYear(), today.getMonth(), today.getDate())) : date = new Date(today.setHours(0, 0, 0, 0));
        }
        scope.dateSelection(date);
    }, scope.close = function() {
        scope.isOpen = !1, element[0].focus();
    }, scope.$watch("isOpen", function(value) {
        value ? (scope.position = appendToBody ? $position.offset(element) : $position.position(element), 
        scope.position.top = scope.position.top + element.prop("offsetHeight"), $timeout(function() {
            onOpenFocus && scope.$broadcast("uib:datepicker.focus"), $document.bind("click", documentClickBind);
        }, 0, !1)) : $document.unbind("click", documentClickBind);
    });
} ]).directive("uibDatepickerPopup", function() {
    return {
        require: [ "ngModel", "uibDatepickerPopup" ],
        controller: "UibDatepickerPopupController",
        scope: {
            isOpen: "=?",
            currentText: "@",
            clearText: "@",
            closeText: "@",
            dateDisabled: "&",
            customClass: "&"
        },
        link: function(scope, element, attrs, ctrls) {
            var ngModel = ctrls[0], ctrl = ctrls[1];
            ctrl.init(ngModel);
        }
    };
}).directive("uibDatepickerPopupWrap", function() {
    return {
        replace: !0,
        transclude: !0,
        templateUrl: function(element, attrs) {
            return attrs.templateUrl || "template/datepicker/popup.html";
        }
    };
}), angular.module("ui.bootstrap.datepicker").value("$datepickerSuppressWarning", !1).controller("DatepickerController", [ "$scope", "$attrs", "$parse", "$interpolate", "$log", "dateFilter", "uibDatepickerConfig", "$datepickerSuppressError", "$datepickerSuppressWarning", function($scope, $attrs, $parse, $interpolate, $log, dateFilter, datepickerConfig, $datepickerSuppressError, $datepickerSuppressWarning) {
    $datepickerSuppressWarning || $log.warn("DatepickerController is now deprecated. Use UibDatepickerController instead.");
    var self = this, ngModelCtrl = {
        $setViewValue: angular.noop
    };
    this.modes = [ "day", "month", "year" ], angular.forEach([ "formatDay", "formatMonth", "formatYear", "formatDayHeader", "formatDayTitle", "formatMonthTitle", "showWeeks", "startingDay", "yearRange", "shortcutPropagation" ], function(key, index) {
        self[key] = angular.isDefined($attrs[key]) ? 6 > index ? $interpolate($attrs[key])($scope.$parent) : $scope.$parent.$eval($attrs[key]) : datepickerConfig[key];
    }), angular.forEach([ "minDate", "maxDate" ], function(key) {
        $attrs[key] ? $scope.$parent.$watch($parse($attrs[key]), function(value) {
            self[key] = value ? new Date(value) : null, self.refreshView();
        }) : self[key] = datepickerConfig[key] ? new Date(datepickerConfig[key]) : null;
    }), angular.forEach([ "minMode", "maxMode" ], function(key) {
        $attrs[key] ? $scope.$parent.$watch($parse($attrs[key]), function(value) {
            self[key] = angular.isDefined(value) ? value : $attrs[key], $scope[key] = self[key], 
            ("minMode" == key && self.modes.indexOf($scope.datepickerMode) < self.modes.indexOf(self[key]) || "maxMode" == key && self.modes.indexOf($scope.datepickerMode) > self.modes.indexOf(self[key])) && ($scope.datepickerMode = self[key]);
        }) : (self[key] = datepickerConfig[key] || null, $scope[key] = self[key]);
    }), $scope.datepickerMode = $scope.datepickerMode || datepickerConfig.datepickerMode, 
    $scope.uniqueId = "datepicker-" + $scope.$id + "-" + Math.floor(1e4 * Math.random()), 
    angular.isDefined($attrs.initDate) ? (this.activeDate = $scope.$parent.$eval($attrs.initDate) || new Date(), 
    $scope.$parent.$watch($attrs.initDate, function(initDate) {
        initDate && (ngModelCtrl.$isEmpty(ngModelCtrl.$modelValue) || ngModelCtrl.$invalid) && (self.activeDate = initDate, 
        self.refreshView());
    })) : this.activeDate = new Date(), $scope.isActive = function(dateObject) {
        return 0 === self.compare(dateObject.date, self.activeDate) ? ($scope.activeDateId = dateObject.uid, 
        !0) : !1;
    }, this.init = function(ngModelCtrl_) {
        ngModelCtrl = ngModelCtrl_, ngModelCtrl.$render = function() {
            self.render();
        };
    }, this.render = function() {
        if (ngModelCtrl.$viewValue) {
            var date = new Date(ngModelCtrl.$viewValue), isValid = !isNaN(date);
            isValid ? this.activeDate = date : $datepickerSuppressError || $log.error('Datepicker directive: "ng-model" value must be a Date object, a number of milliseconds since 01.01.1970 or a string representing an RFC2822 or ISO 8601 date.');
        }
        this.refreshView();
    }, this.refreshView = function() {
        if (this.element) {
            this._refreshView();
            var date = ngModelCtrl.$viewValue ? new Date(ngModelCtrl.$viewValue) : null;
            ngModelCtrl.$setValidity("dateDisabled", !date || this.element && !this.isDisabled(date));
        }
    }, this.createDateObject = function(date, format) {
        var model = ngModelCtrl.$viewValue ? new Date(ngModelCtrl.$viewValue) : null;
        return {
            date: date,
            label: dateFilter(date, format),
            selected: model && 0 === this.compare(date, model),
            disabled: this.isDisabled(date),
            current: 0 === this.compare(date, new Date()),
            customClass: this.customClass(date)
        };
    }, this.isDisabled = function(date) {
        return this.minDate && this.compare(date, this.minDate) < 0 || this.maxDate && this.compare(date, this.maxDate) > 0 || $attrs.dateDisabled && $scope.dateDisabled({
            date: date,
            mode: $scope.datepickerMode
        });
    }, this.customClass = function(date) {
        return $scope.customClass({
            date: date,
            mode: $scope.datepickerMode
        });
    }, this.split = function(arr, size) {
        for (var arrays = []; arr.length > 0; ) arrays.push(arr.splice(0, size));
        return arrays;
    }, this.fixTimeZone = function(date) {
        var hours = date.getHours();
        date.setHours(23 === hours ? hours + 2 : 0);
    }, $scope.select = function(date) {
        if ($scope.datepickerMode === self.minMode) {
            var dt = ngModelCtrl.$viewValue ? new Date(ngModelCtrl.$viewValue) : new Date(0, 0, 0, 0, 0, 0, 0);
            dt.setFullYear(date.getFullYear(), date.getMonth(), date.getDate()), ngModelCtrl.$setViewValue(dt), 
            ngModelCtrl.$render();
        } else self.activeDate = date, $scope.datepickerMode = self.modes[self.modes.indexOf($scope.datepickerMode) - 1];
    }, $scope.move = function(direction) {
        var year = self.activeDate.getFullYear() + direction * (self.step.years || 0), month = self.activeDate.getMonth() + direction * (self.step.months || 0);
        self.activeDate.setFullYear(year, month, 1), self.refreshView();
    }, $scope.toggleMode = function(direction) {
        direction = direction || 1, $scope.datepickerMode === self.maxMode && 1 === direction || $scope.datepickerMode === self.minMode && -1 === direction || ($scope.datepickerMode = self.modes[self.modes.indexOf($scope.datepickerMode) + direction]);
    }, $scope.keys = {
        13: "enter",
        32: "space",
        33: "pageup",
        34: "pagedown",
        35: "end",
        36: "home",
        37: "left",
        38: "up",
        39: "right",
        40: "down"
    };
    var focusElement = function() {
        self.element[0].focus();
    };
    $scope.$on("uib:datepicker.focus", focusElement), $scope.keydown = function(evt) {
        var key = $scope.keys[evt.which];
        if (key && !evt.shiftKey && !evt.altKey) if (evt.preventDefault(), self.shortcutPropagation || evt.stopPropagation(), 
        "enter" === key || "space" === key) {
            if (self.isDisabled(self.activeDate)) return;
            $scope.select(self.activeDate);
        } else !evt.ctrlKey || "up" !== key && "down" !== key ? (self.handleKeyDown(key, evt), 
        self.refreshView()) : $scope.toggleMode("up" === key ? 1 : -1);
    };
} ]).directive("datepicker", [ "$log", "$datepickerSuppressWarning", function($log, $datepickerSuppressWarning) {
    return {
        replace: !0,
        templateUrl: function(element, attrs) {
            return attrs.templateUrl || "template/datepicker/datepicker.html";
        },
        scope: {
            datepickerMode: "=?",
            dateDisabled: "&",
            customClass: "&",
            shortcutPropagation: "&?"
        },
        require: [ "datepicker", "^ngModel" ],
        controller: "DatepickerController",
        controllerAs: "datepicker",
        link: function(scope, element, attrs, ctrls) {
            $datepickerSuppressWarning || $log.warn("datepicker is now deprecated. Use uib-datepicker instead.");
            var datepickerCtrl = ctrls[0], ngModelCtrl = ctrls[1];
            datepickerCtrl.init(ngModelCtrl);
        }
    };
} ]).directive("daypicker", [ "$log", "$datepickerSuppressWarning", function($log, $datepickerSuppressWarning) {
    return {
        replace: !0,
        templateUrl: "template/datepicker/day.html",
        require: [ "^datepicker", "daypicker" ],
        controller: "UibDaypickerController",
        link: function(scope, element, attrs, ctrls) {
            $datepickerSuppressWarning || $log.warn("daypicker is now deprecated. Use uib-daypicker instead.");
            var datepickerCtrl = ctrls[0], daypickerCtrl = ctrls[1];
            daypickerCtrl.init(datepickerCtrl);
        }
    };
} ]).directive("monthpicker", [ "$log", "$datepickerSuppressWarning", function($log, $datepickerSuppressWarning) {
    return {
        replace: !0,
        templateUrl: "template/datepicker/month.html",
        require: [ "^datepicker", "monthpicker" ],
        controller: "UibMonthpickerController",
        link: function(scope, element, attrs, ctrls) {
            $datepickerSuppressWarning || $log.warn("monthpicker is now deprecated. Use uib-monthpicker instead.");
            var datepickerCtrl = ctrls[0], monthpickerCtrl = ctrls[1];
            monthpickerCtrl.init(datepickerCtrl);
        }
    };
} ]).directive("yearpicker", [ "$log", "$datepickerSuppressWarning", function($log, $datepickerSuppressWarning) {
    return {
        replace: !0,
        templateUrl: "template/datepicker/year.html",
        require: [ "^datepicker", "yearpicker" ],
        controller: "UibYearpickerController",
        link: function(scope, element, attrs, ctrls) {
            $datepickerSuppressWarning || $log.warn("yearpicker is now deprecated. Use uib-yearpicker instead.");
            var ctrl = ctrls[0];
            angular.extend(ctrl, ctrls[1]), ctrl.yearpickerInit(), ctrl.refreshView();
        }
    };
} ]).directive("datepickerPopup", [ "$log", "$datepickerSuppressWarning", function($log, $datepickerSuppressWarning) {
    return {
        require: [ "ngModel", "datepickerPopup" ],
        controller: "UibDatepickerPopupController",
        scope: {
            isOpen: "=?",
            currentText: "@",
            clearText: "@",
            closeText: "@",
            dateDisabled: "&",
            customClass: "&"
        },
        link: function(scope, element, attrs, ctrls) {
            $datepickerSuppressWarning || $log.warn("datepicker-popup is now deprecated. Use uib-datepicker-popup instead.");
            var ngModel = ctrls[0], ctrl = ctrls[1];
            ctrl.init(ngModel);
        }
    };
} ]).directive("datepickerPopupWrap", [ "$log", "$datepickerSuppressWarning", function($log, $datepickerSuppressWarning) {
    return {
        replace: !0,
        transclude: !0,
        templateUrl: function(element, attrs) {
            return attrs.templateUrl || "template/datepicker/popup.html";
        },
        link: function() {
            $datepickerSuppressWarning || $log.warn("datepicker-popup-wrap is now deprecated. Use uib-datepicker-popup-wrap instead.");
        }
    };
} ]), angular.module("ui.bootstrap.dropdown", [ "ui.bootstrap.position" ]).constant("uibDropdownConfig", {
    openClass: "open"
}).service("uibDropdownService", [ "$document", "$rootScope", function($document, $rootScope) {
    var openScope = null;
    this.open = function(dropdownScope) {
        openScope || ($document.bind("click", closeDropdown), $document.bind("keydown", keybindFilter)), 
        openScope && openScope !== dropdownScope && (openScope.isOpen = !1), openScope = dropdownScope;
    }, this.close = function(dropdownScope) {
        openScope === dropdownScope && (openScope = null, $document.unbind("click", closeDropdown), 
        $document.unbind("keydown", keybindFilter));
    };
    var closeDropdown = function(evt) {
        if (openScope && (!evt || "disabled" !== openScope.getAutoClose())) {
            var toggleElement = openScope.getToggleElement();
            if (!(evt && toggleElement && toggleElement[0].contains(evt.target))) {
                var dropdownElement = openScope.getDropdownElement();
                evt && "outsideClick" === openScope.getAutoClose() && dropdownElement && dropdownElement[0].contains(evt.target) || (openScope.isOpen = !1, 
                $rootScope.$$phase || openScope.$apply());
            }
        }
    }, keybindFilter = function(evt) {
        27 === evt.which ? (openScope.focusToggleElement(), closeDropdown()) : openScope.isKeynavEnabled() && /(38|40)/.test(evt.which) && openScope.isOpen && (evt.preventDefault(), 
        evt.stopPropagation(), openScope.focusDropdownEntry(evt.which));
    };
} ]).controller("UibDropdownController", [ "$scope", "$element", "$attrs", "$parse", "uibDropdownConfig", "uibDropdownService", "$animate", "$uibPosition", "$document", "$compile", "$templateRequest", function($scope, $element, $attrs, $parse, dropdownConfig, uibDropdownService, $animate, $position, $document, $compile, $templateRequest) {
    var templateScope, getIsOpen, self = this, scope = $scope.$new(), openClass = dropdownConfig.openClass, setIsOpen = angular.noop, toggleInvoker = $attrs.onToggle ? $parse($attrs.onToggle) : angular.noop, appendToBody = !1, keynavEnabled = !1;
    $element.addClass("dropdown"), this.init = function() {
        $attrs.isOpen && (getIsOpen = $parse($attrs.isOpen), setIsOpen = getIsOpen.assign, 
        $scope.$watch(getIsOpen, function(value) {
            scope.isOpen = !!value;
        })), appendToBody = angular.isDefined($attrs.dropdownAppendToBody), keynavEnabled = angular.isDefined($attrs.uibKeyboardNav), 
        appendToBody && self.dropdownMenu && ($document.find("body").append(self.dropdownMenu), 
        $element.on("$destroy", function() {
            self.dropdownMenu.remove();
        }));
    }, this.toggle = function(open) {
        return scope.isOpen = arguments.length ? !!open : !scope.isOpen;
    }, this.isOpen = function() {
        return scope.isOpen;
    }, scope.getToggleElement = function() {
        return self.toggleElement;
    }, scope.getAutoClose = function() {
        return $attrs.autoClose || "always";
    }, scope.getElement = function() {
        return $element;
    }, scope.isKeynavEnabled = function() {
        return keynavEnabled;
    }, scope.focusDropdownEntry = function(keyCode) {
        var elems = self.dropdownMenu ? angular.element(self.dropdownMenu).find("a") : angular.element($element).find("ul").eq(0).find("a");
        switch (keyCode) {
          case 40:
            self.selectedOption = angular.isNumber(self.selectedOption) ? self.selectedOption === elems.length - 1 ? self.selectedOption : self.selectedOption + 1 : 0;
            break;

          case 38:
            self.selectedOption = angular.isNumber(self.selectedOption) ? 0 === self.selectedOption ? 0 : self.selectedOption - 1 : elems.length - 1;
        }
        elems[self.selectedOption].focus();
    }, scope.getDropdownElement = function() {
        return self.dropdownMenu;
    }, scope.focusToggleElement = function() {
        self.toggleElement && self.toggleElement[0].focus();
    }, scope.$watch("isOpen", function(isOpen, wasOpen) {
        if (appendToBody && self.dropdownMenu) {
            var pos = $position.positionElements($element, self.dropdownMenu, "bottom-left", !0), css = {
                top: pos.top + "px",
                display: isOpen ? "block" : "none"
            }, rightalign = self.dropdownMenu.hasClass("dropdown-menu-right");
            rightalign ? (css.left = "auto", css.right = window.innerWidth - (pos.left + $element.prop("offsetWidth")) + "px") : (css.left = pos.left + "px", 
            css.right = "auto"), self.dropdownMenu.css(css);
        }
        if ($animate[isOpen ? "addClass" : "removeClass"]($element, openClass).then(function() {
            angular.isDefined(isOpen) && isOpen !== wasOpen && toggleInvoker($scope, {
                open: !!isOpen
            });
        }), isOpen) self.dropdownMenuTemplateUrl && $templateRequest(self.dropdownMenuTemplateUrl).then(function(tplContent) {
            templateScope = scope.$new(), $compile(tplContent.trim())(templateScope, function(dropdownElement) {
                var newEl = dropdownElement;
                self.dropdownMenu.replaceWith(newEl), self.dropdownMenu = newEl;
            });
        }), scope.focusToggleElement(), uibDropdownService.open(scope); else {
            if (self.dropdownMenuTemplateUrl) {
                templateScope && templateScope.$destroy();
                var newEl = angular.element('<ul class="dropdown-menu"></ul>');
                self.dropdownMenu.replaceWith(newEl), self.dropdownMenu = newEl;
            }
            uibDropdownService.close(scope), self.selectedOption = null;
        }
        angular.isFunction(setIsOpen) && setIsOpen($scope, isOpen);
    }), $scope.$on("$locationChangeSuccess", function() {
        "disabled" !== scope.getAutoClose() && (scope.isOpen = !1);
    });
    var offDestroy = $scope.$on("$destroy", function() {
        scope.$destroy();
    });
    scope.$on("$destroy", offDestroy);
} ]).directive("uibDropdown", function() {
    return {
        controller: "UibDropdownController",
        link: function(scope, element, attrs, dropdownCtrl) {
            dropdownCtrl.init();
        }
    };
}).directive("uibDropdownMenu", function() {
    return {
        restrict: "AC",
        require: "?^uibDropdown",
        link: function(scope, element, attrs, dropdownCtrl) {
            if (dropdownCtrl && !angular.isDefined(attrs.dropdownNested)) {
                element.addClass("dropdown-menu");
                var tplUrl = attrs.templateUrl;
                tplUrl && (dropdownCtrl.dropdownMenuTemplateUrl = tplUrl), dropdownCtrl.dropdownMenu || (dropdownCtrl.dropdownMenu = element);
            }
        }
    };
}).directive("uibKeyboardNav", function() {
    return {
        restrict: "A",
        require: "?^uibDropdown",
        link: function(scope, element, attrs, dropdownCtrl) {
            element.bind("keydown", function(e) {
                if (-1 !== [ 38, 40 ].indexOf(e.which)) {
                    e.preventDefault(), e.stopPropagation();
                    var elems = dropdownCtrl.dropdownMenu.find("a");
                    switch (e.which) {
                      case 40:
                        dropdownCtrl.selectedOption = angular.isNumber(dropdownCtrl.selectedOption) ? dropdownCtrl.selectedOption === elems.length - 1 ? dropdownCtrl.selectedOption : dropdownCtrl.selectedOption + 1 : 0;
                        break;

                      case 38:
                        dropdownCtrl.selectedOption = angular.isNumber(dropdownCtrl.selectedOption) ? 0 === dropdownCtrl.selectedOption ? 0 : dropdownCtrl.selectedOption - 1 : elems.length - 1;
                    }
                    elems[dropdownCtrl.selectedOption].focus();
                }
            });
        }
    };
}).directive("uibDropdownToggle", function() {
    return {
        require: "?^uibDropdown",
        link: function(scope, element, attrs, dropdownCtrl) {
            if (dropdownCtrl) {
                element.addClass("dropdown-toggle"), dropdownCtrl.toggleElement = element;
                var toggleDropdown = function(event) {
                    event.preventDefault(), element.hasClass("disabled") || attrs.disabled || scope.$apply(function() {
                        dropdownCtrl.toggle();
                    });
                };
                element.bind("click", toggleDropdown), element.attr({
                    "aria-haspopup": !0,
                    "aria-expanded": !1
                }), scope.$watch(dropdownCtrl.isOpen, function(isOpen) {
                    element.attr("aria-expanded", !!isOpen);
                }), scope.$on("$destroy", function() {
                    element.unbind("click", toggleDropdown);
                });
            }
        }
    };
}), angular.module("ui.bootstrap.dropdown").value("$dropdownSuppressWarning", !1).service("dropdownService", [ "$log", "$dropdownSuppressWarning", "uibDropdownService", function($log, $dropdownSuppressWarning, uibDropdownService) {
    $dropdownSuppressWarning || $log.warn("dropdownService is now deprecated. Use uibDropdownService instead."), 
    angular.extend(this, uibDropdownService);
} ]).controller("DropdownController", [ "$scope", "$element", "$attrs", "$parse", "uibDropdownConfig", "uibDropdownService", "$animate", "$uibPosition", "$document", "$compile", "$templateRequest", "$log", "$dropdownSuppressWarning", function($scope, $element, $attrs, $parse, dropdownConfig, uibDropdownService, $animate, $position, $document, $compile, $templateRequest, $log, $dropdownSuppressWarning) {
    $dropdownSuppressWarning || $log.warn("DropdownController is now deprecated. Use UibDropdownController instead.");
    var templateScope, getIsOpen, self = this, scope = $scope.$new(), openClass = dropdownConfig.openClass, setIsOpen = angular.noop, toggleInvoker = $attrs.onToggle ? $parse($attrs.onToggle) : angular.noop, appendToBody = !1, keynavEnabled = !1;
    $element.addClass("dropdown"), this.init = function() {
        $attrs.isOpen && (getIsOpen = $parse($attrs.isOpen), setIsOpen = getIsOpen.assign, 
        $scope.$watch(getIsOpen, function(value) {
            scope.isOpen = !!value;
        })), appendToBody = angular.isDefined($attrs.dropdownAppendToBody), keynavEnabled = angular.isDefined($attrs.uibKeyboardNav), 
        appendToBody && self.dropdownMenu && ($document.find("body").append(self.dropdownMenu), 
        $element.on("$destroy", function() {
            self.dropdownMenu.remove();
        }));
    }, this.toggle = function(open) {
        return scope.isOpen = arguments.length ? !!open : !scope.isOpen;
    }, this.isOpen = function() {
        return scope.isOpen;
    }, scope.getToggleElement = function() {
        return self.toggleElement;
    }, scope.getAutoClose = function() {
        return $attrs.autoClose || "always";
    }, scope.getElement = function() {
        return $element;
    }, scope.isKeynavEnabled = function() {
        return keynavEnabled;
    }, scope.focusDropdownEntry = function(keyCode) {
        var elems = self.dropdownMenu ? angular.element(self.dropdownMenu).find("a") : angular.element($element).find("ul").eq(0).find("a");
        switch (keyCode) {
          case 40:
            self.selectedOption = angular.isNumber(self.selectedOption) ? self.selectedOption === elems.length - 1 ? self.selectedOption : self.selectedOption + 1 : 0;
            break;

          case 38:
            self.selectedOption = angular.isNumber(self.selectedOption) ? 0 === self.selectedOption ? 0 : self.selectedOption - 1 : elems.length - 1;
        }
        elems[self.selectedOption].focus();
    }, scope.getDropdownElement = function() {
        return self.dropdownMenu;
    }, scope.focusToggleElement = function() {
        self.toggleElement && self.toggleElement[0].focus();
    }, scope.$watch("isOpen", function(isOpen, wasOpen) {
        if (appendToBody && self.dropdownMenu) {
            var pos = $position.positionElements($element, self.dropdownMenu, "bottom-left", !0), css = {
                top: pos.top + "px",
                display: isOpen ? "block" : "none"
            }, rightalign = self.dropdownMenu.hasClass("dropdown-menu-right");
            rightalign ? (css.left = "auto", css.right = window.innerWidth - (pos.left + $element.prop("offsetWidth")) + "px") : (css.left = pos.left + "px", 
            css.right = "auto"), self.dropdownMenu.css(css);
        }
        if ($animate[isOpen ? "addClass" : "removeClass"]($element, openClass).then(function() {
            angular.isDefined(isOpen) && isOpen !== wasOpen && toggleInvoker($scope, {
                open: !!isOpen
            });
        }), isOpen) self.dropdownMenuTemplateUrl && $templateRequest(self.dropdownMenuTemplateUrl).then(function(tplContent) {
            templateScope = scope.$new(), $compile(tplContent.trim())(templateScope, function(dropdownElement) {
                var newEl = dropdownElement;
                self.dropdownMenu.replaceWith(newEl), self.dropdownMenu = newEl;
            });
        }), scope.focusToggleElement(), uibDropdownService.open(scope); else {
            if (self.dropdownMenuTemplateUrl) {
                templateScope && templateScope.$destroy();
                var newEl = angular.element('<ul class="dropdown-menu"></ul>');
                self.dropdownMenu.replaceWith(newEl), self.dropdownMenu = newEl;
            }
            uibDropdownService.close(scope), self.selectedOption = null;
        }
        angular.isFunction(setIsOpen) && setIsOpen($scope, isOpen);
    }), $scope.$on("$locationChangeSuccess", function() {
        "disabled" !== scope.getAutoClose() && (scope.isOpen = !1);
    });
    var offDestroy = $scope.$on("$destroy", function() {
        scope.$destroy();
    });
    scope.$on("$destroy", offDestroy);
} ]).directive("dropdown", [ "$log", "$dropdownSuppressWarning", function($log, $dropdownSuppressWarning) {
    return {
        controller: "DropdownController",
        link: function(scope, element, attrs, dropdownCtrl) {
            $dropdownSuppressWarning || $log.warn("dropdown is now deprecated. Use uib-dropdown instead."), 
            dropdownCtrl.init();
        }
    };
} ]).directive("dropdownMenu", [ "$log", "$dropdownSuppressWarning", function($log, $dropdownSuppressWarning) {
    return {
        restrict: "AC",
        require: "?^dropdown",
        link: function(scope, element, attrs, dropdownCtrl) {
            if (dropdownCtrl && !angular.isDefined(attrs.dropdownNested)) {
                $dropdownSuppressWarning || $log.warn("dropdown-menu is now deprecated. Use uib-dropdown-menu instead."), 
                element.addClass("dropdown-menu");
                var tplUrl = attrs.templateUrl;
                tplUrl && (dropdownCtrl.dropdownMenuTemplateUrl = tplUrl), dropdownCtrl.dropdownMenu || (dropdownCtrl.dropdownMenu = element);
            }
        }
    };
} ]).directive("keyboardNav", [ "$log", "$dropdownSuppressWarning", function($log, $dropdownSuppressWarning) {
    return {
        restrict: "A",
        require: "?^dropdown",
        link: function(scope, element, attrs, dropdownCtrl) {
            $dropdownSuppressWarning || $log.warn("keyboard-nav is now deprecated. Use uib-keyboard-nav instead."), 
            element.bind("keydown", function(e) {
                if (-1 !== [ 38, 40 ].indexOf(e.which)) {
                    e.preventDefault(), e.stopPropagation();
                    var elems = dropdownCtrl.dropdownMenu.find("a");
                    switch (e.which) {
                      case 40:
                        dropdownCtrl.selectedOption = angular.isNumber(dropdownCtrl.selectedOption) ? dropdownCtrl.selectedOption === elems.length - 1 ? dropdownCtrl.selectedOption : dropdownCtrl.selectedOption + 1 : 0;
                        break;

                      case 38:
                        dropdownCtrl.selectedOption = angular.isNumber(dropdownCtrl.selectedOption) ? 0 === dropdownCtrl.selectedOption ? 0 : dropdownCtrl.selectedOption - 1 : elems.length - 1;
                    }
                    elems[dropdownCtrl.selectedOption].focus();
                }
            });
        }
    };
} ]).directive("dropdownToggle", [ "$log", "$dropdownSuppressWarning", function($log, $dropdownSuppressWarning) {
    return {
        require: "?^dropdown",
        link: function(scope, element, attrs, dropdownCtrl) {
            if ($dropdownSuppressWarning || $log.warn("dropdown-toggle is now deprecated. Use uib-dropdown-toggle instead."), 
            dropdownCtrl) {
                element.addClass("dropdown-toggle"), dropdownCtrl.toggleElement = element;
                var toggleDropdown = function(event) {
                    event.preventDefault(), element.hasClass("disabled") || attrs.disabled || scope.$apply(function() {
                        dropdownCtrl.toggle();
                    });
                };
                element.bind("click", toggleDropdown), element.attr({
                    "aria-haspopup": !0,
                    "aria-expanded": !1
                }), scope.$watch(dropdownCtrl.isOpen, function(isOpen) {
                    element.attr("aria-expanded", !!isOpen);
                }), scope.$on("$destroy", function() {
                    element.unbind("click", toggleDropdown);
                });
            }
        }
    };
} ]), angular.module("ui.bootstrap.stackedMap", []).factory("$$stackedMap", function() {
    return {
        createNew: function() {
            var stack = [];
            return {
                add: function(key, value) {
                    stack.push({
                        key: key,
                        value: value
                    });
                },
                get: function(key) {
                    for (var i = 0; i < stack.length; i++) if (key == stack[i].key) return stack[i];
                },
                keys: function() {
                    for (var keys = [], i = 0; i < stack.length; i++) keys.push(stack[i].key);
                    return keys;
                },
                top: function() {
                    return stack[stack.length - 1];
                },
                remove: function(key) {
                    for (var idx = -1, i = 0; i < stack.length; i++) if (key == stack[i].key) {
                        idx = i;
                        break;
                    }
                    return stack.splice(idx, 1)[0];
                },
                removeTop: function() {
                    return stack.splice(stack.length - 1, 1)[0];
                },
                length: function() {
                    return stack.length;
                }
            };
        }
    };
}), angular.module("ui.bootstrap.modal", [ "ui.bootstrap.stackedMap" ]).factory("$$multiMap", function() {
    return {
        createNew: function() {
            var map = {};
            return {
                entries: function() {
                    return Object.keys(map).map(function(key) {
                        return {
                            key: key,
                            value: map[key]
                        };
                    });
                },
                get: function(key) {
                    return map[key];
                },
                hasKey: function(key) {
                    return !!map[key];
                },
                keys: function() {
                    return Object.keys(map);
                },
                put: function(key, value) {
                    map[key] || (map[key] = []), map[key].push(value);
                },
                remove: function(key, value) {
                    var values = map[key];
                    if (values) {
                        var idx = values.indexOf(value);
                        -1 !== idx && values.splice(idx, 1), values.length || delete map[key];
                    }
                }
            };
        }
    };
}).directive("uibModalBackdrop", [ "$animate", "$injector", "$uibModalStack", function($animate, $injector, $modalStack) {
    function linkFn(scope, element, attrs) {
        element.addClass("modal-backdrop"), attrs.modalInClass && ($animateCss ? $animateCss(element, {
            addClass: attrs.modalInClass
        }).start() : $animate.addClass(element, attrs.modalInClass), scope.$on($modalStack.NOW_CLOSING_EVENT, function(e, setIsAsync) {
            var done = setIsAsync();
            $animateCss ? $animateCss(element, {
                removeClass: attrs.modalInClass
            }).start().then(done) : $animate.removeClass(element, attrs.modalInClass).then(done);
        }));
    }
    var $animateCss = null;
    return $injector.has("$animateCss") && ($animateCss = $injector.get("$animateCss")), 
    {
        replace: !0,
        templateUrl: "template/modal/backdrop.html",
        compile: function(tElement, tAttrs) {
            return tElement.addClass(tAttrs.backdropClass), linkFn;
        }
    };
} ]).directive("uibModalWindow", [ "$uibModalStack", "$q", "$animate", "$injector", function($modalStack, $q, $animate, $injector) {
    var $animateCss = null;
    return $injector.has("$animateCss") && ($animateCss = $injector.get("$animateCss")), 
    {
        scope: {
            index: "@"
        },
        replace: !0,
        transclude: !0,
        templateUrl: function(tElement, tAttrs) {
            return tAttrs.templateUrl || "template/modal/window.html";
        },
        link: function(scope, element, attrs) {
            element.addClass(attrs.windowClass || ""), element.addClass(attrs.windowTopClass || ""), 
            scope.size = attrs.size, scope.close = function(evt) {
                var modal = $modalStack.getTop();
                modal && modal.value.backdrop && "static" !== modal.value.backdrop && evt.target === evt.currentTarget && (evt.preventDefault(), 
                evt.stopPropagation(), $modalStack.dismiss(modal.key, "backdrop click"));
            }, element.on("click", scope.close), scope.$isRendered = !0;
            var modalRenderDeferObj = $q.defer();
            attrs.$observe("modalRender", function(value) {
                "true" == value && modalRenderDeferObj.resolve();
            }), modalRenderDeferObj.promise.then(function() {
                var animationPromise = null;
                attrs.modalInClass && (animationPromise = $animateCss ? $animateCss(element, {
                    addClass: attrs.modalInClass
                }).start() : $animate.addClass(element, attrs.modalInClass), scope.$on($modalStack.NOW_CLOSING_EVENT, function(e, setIsAsync) {
                    var done = setIsAsync();
                    $animateCss ? $animateCss(element, {
                        removeClass: attrs.modalInClass
                    }).start().then(done) : $animate.removeClass(element, attrs.modalInClass).then(done);
                })), $q.when(animationPromise).then(function() {
                    var inputWithAutofocus = element[0].querySelector("[autofocus]");
                    inputWithAutofocus ? inputWithAutofocus.focus() : element[0].focus();
                });
                var modal = $modalStack.getTop();
                modal && $modalStack.modalRendered(modal.key);
            });
        }
    };
} ]).directive("uibModalAnimationClass", function() {
    return {
        compile: function(tElement, tAttrs) {
            tAttrs.modalAnimation && tElement.addClass(tAttrs.uibModalAnimationClass);
        }
    };
}).directive("uibModalTransclude", function() {
    return {
        link: function($scope, $element, $attrs, controller, $transclude) {
            $transclude($scope.$parent, function(clone) {
                $element.empty(), $element.append(clone);
            });
        }
    };
}).factory("$uibModalStack", [ "$animate", "$timeout", "$document", "$compile", "$rootScope", "$q", "$injector", "$$multiMap", "$$stackedMap", function($animate, $timeout, $document, $compile, $rootScope, $q, $injector, $$multiMap, $$stackedMap) {
    function backdropIndex() {
        for (var topBackdropIndex = -1, opened = openedWindows.keys(), i = 0; i < opened.length; i++) openedWindows.get(opened[i]).value.backdrop && (topBackdropIndex = i);
        return topBackdropIndex;
    }
    function removeModalWindow(modalInstance, elementToReceiveFocus) {
        var body = $document.find("body").eq(0), modalWindow = openedWindows.get(modalInstance).value;
        openedWindows.remove(modalInstance), removeAfterAnimate(modalWindow.modalDomEl, modalWindow.modalScope, function() {
            var modalBodyClass = modalWindow.openedClass || OPENED_MODAL_CLASS;
            openedClasses.remove(modalBodyClass, modalInstance), body.toggleClass(modalBodyClass, openedClasses.hasKey(modalBodyClass)), 
            toggleTopWindowClass(!0);
        }), checkRemoveBackdrop(), elementToReceiveFocus && elementToReceiveFocus.focus ? elementToReceiveFocus.focus() : body.focus();
    }
    function toggleTopWindowClass(toggleSwitch) {
        var modalWindow;
        openedWindows.length() > 0 && (modalWindow = openedWindows.top().value, modalWindow.modalDomEl.toggleClass(modalWindow.windowTopClass || "", toggleSwitch));
    }
    function checkRemoveBackdrop() {
        if (backdropDomEl && -1 == backdropIndex()) {
            var backdropScopeRef = backdropScope;
            removeAfterAnimate(backdropDomEl, backdropScope, function() {
                backdropScopeRef = null;
            }), backdropDomEl = void 0, backdropScope = void 0;
        }
    }
    function removeAfterAnimate(domEl, scope, done) {
        function afterAnimating() {
            afterAnimating.done || (afterAnimating.done = !0, $animateCss ? $animateCss(domEl, {
                event: "leave"
            }).start().then(function() {
                domEl.remove();
            }) : $animate.leave(domEl), scope.$destroy(), done && done());
        }
        var asyncDeferred, asyncPromise = null, setIsAsync = function() {
            return asyncDeferred || (asyncDeferred = $q.defer(), asyncPromise = asyncDeferred.promise), 
            function() {
                asyncDeferred.resolve();
            };
        };
        return scope.$broadcast($modalStack.NOW_CLOSING_EVENT, setIsAsync), $q.when(asyncPromise).then(afterAnimating);
    }
    function broadcastClosing(modalWindow, resultOrReason, closing) {
        return !modalWindow.value.modalScope.$broadcast("modal.closing", resultOrReason, closing).defaultPrevented;
    }
    var $animateCss = null;
    $injector.has("$animateCss") && ($animateCss = $injector.get("$animateCss"));
    var backdropDomEl, backdropScope, focusableElementList, OPENED_MODAL_CLASS = "modal-open", openedWindows = $$stackedMap.createNew(), openedClasses = $$multiMap.createNew(), $modalStack = {
        NOW_CLOSING_EVENT: "modal.stack.now-closing"
    }, focusIndex = 0, tababbleSelector = "a[href], area[href], input:not([disabled]), button:not([disabled]),select:not([disabled]), textarea:not([disabled]), iframe, object, embed, *[tabindex], *[contenteditable=true]";
    return $rootScope.$watch(backdropIndex, function(newBackdropIndex) {
        backdropScope && (backdropScope.index = newBackdropIndex);
    }), $document.bind("keydown", function(evt) {
        if (evt.isDefaultPrevented()) return evt;
        var modal = openedWindows.top();
        if (modal && modal.value.keyboard) switch (evt.which) {
          case 27:
            evt.preventDefault(), $rootScope.$apply(function() {
                $modalStack.dismiss(modal.key, "escape key press");
            });
            break;

          case 9:
            $modalStack.loadFocusElementList(modal);
            var focusChanged = !1;
            evt.shiftKey ? $modalStack.isFocusInFirstItem(evt) && (focusChanged = $modalStack.focusLastFocusableElement()) : $modalStack.isFocusInLastItem(evt) && (focusChanged = $modalStack.focusFirstFocusableElement()), 
            focusChanged && (evt.preventDefault(), evt.stopPropagation());
        }
    }), $modalStack.open = function(modalInstance, modal) {
        var modalOpener = $document[0].activeElement, modalBodyClass = modal.openedClass || OPENED_MODAL_CLASS;
        toggleTopWindowClass(!1), openedWindows.add(modalInstance, {
            deferred: modal.deferred,
            renderDeferred: modal.renderDeferred,
            modalScope: modal.scope,
            backdrop: modal.backdrop,
            keyboard: modal.keyboard,
            openedClass: modal.openedClass,
            windowTopClass: modal.windowTopClass
        }), openedClasses.put(modalBodyClass, modalInstance);
        var body = $document.find("body").eq(0), currBackdropIndex = backdropIndex();
        if (currBackdropIndex >= 0 && !backdropDomEl) {
            backdropScope = $rootScope.$new(!0), backdropScope.index = currBackdropIndex;
            var angularBackgroundDomEl = angular.element('<div uib-modal-backdrop="modal-backdrop"></div>');
            angularBackgroundDomEl.attr("backdrop-class", modal.backdropClass), modal.animation && angularBackgroundDomEl.attr("modal-animation", "true"), 
            backdropDomEl = $compile(angularBackgroundDomEl)(backdropScope), body.append(backdropDomEl);
        }
        var angularDomEl = angular.element('<div uib-modal-window="modal-window"></div>');
        angularDomEl.attr({
            "template-url": modal.windowTemplateUrl,
            "window-class": modal.windowClass,
            "window-top-class": modal.windowTopClass,
            size: modal.size,
            index: openedWindows.length() - 1,
            animate: "animate"
        }).html(modal.content), modal.animation && angularDomEl.attr("modal-animation", "true");
        var modalDomEl = $compile(angularDomEl)(modal.scope);
        openedWindows.top().value.modalDomEl = modalDomEl, openedWindows.top().value.modalOpener = modalOpener, 
        body.append(modalDomEl), body.addClass(modalBodyClass), $modalStack.clearFocusListCache();
    }, $modalStack.close = function(modalInstance, result) {
        var modalWindow = openedWindows.get(modalInstance);
        return modalWindow && broadcastClosing(modalWindow, result, !0) ? (modalWindow.value.modalScope.$$uibDestructionScheduled = !0, 
        modalWindow.value.deferred.resolve(result), removeModalWindow(modalInstance, modalWindow.value.modalOpener), 
        !0) : !modalWindow;
    }, $modalStack.dismiss = function(modalInstance, reason) {
        var modalWindow = openedWindows.get(modalInstance);
        return modalWindow && broadcastClosing(modalWindow, reason, !1) ? (modalWindow.value.modalScope.$$uibDestructionScheduled = !0, 
        modalWindow.value.deferred.reject(reason), removeModalWindow(modalInstance, modalWindow.value.modalOpener), 
        !0) : !modalWindow;
    }, $modalStack.dismissAll = function(reason) {
        for (var topModal = this.getTop(); topModal && this.dismiss(topModal.key, reason); ) topModal = this.getTop();
    }, $modalStack.getTop = function() {
        return openedWindows.top();
    }, $modalStack.modalRendered = function(modalInstance) {
        var modalWindow = openedWindows.get(modalInstance);
        modalWindow && modalWindow.value.renderDeferred.resolve();
    }, $modalStack.focusFirstFocusableElement = function() {
        return focusableElementList.length > 0 ? (focusableElementList[0].focus(), !0) : !1;
    }, $modalStack.focusLastFocusableElement = function() {
        return focusableElementList.length > 0 ? (focusableElementList[focusableElementList.length - 1].focus(), 
        !0) : !1;
    }, $modalStack.isFocusInFirstItem = function(evt) {
        return focusableElementList.length > 0 ? (evt.target || evt.srcElement) == focusableElementList[0] : !1;
    }, $modalStack.isFocusInLastItem = function(evt) {
        return focusableElementList.length > 0 ? (evt.target || evt.srcElement) == focusableElementList[focusableElementList.length - 1] : !1;
    }, $modalStack.clearFocusListCache = function() {
        focusableElementList = [], focusIndex = 0;
    }, $modalStack.loadFocusElementList = function(modalWindow) {
        if ((void 0 === focusableElementList || !focusableElementList.length) && modalWindow) {
            var modalDomE1 = modalWindow.value.modalDomEl;
            modalDomE1 && modalDomE1.length && (focusableElementList = modalDomE1[0].querySelectorAll(tababbleSelector));
        }
    }, $modalStack;
} ]).provider("$uibModal", function() {
    var $modalProvider = {
        options: {
            animation: !0,
            backdrop: !0,
            keyboard: !0
        },
        $get: [ "$injector", "$rootScope", "$q", "$templateRequest", "$controller", "$uibModalStack", "$modalSuppressWarning", "$log", function($injector, $rootScope, $q, $templateRequest, $controller, $modalStack, $modalSuppressWarning, $log) {
            function getTemplatePromise(options) {
                return options.template ? $q.when(options.template) : $templateRequest(angular.isFunction(options.templateUrl) ? options.templateUrl() : options.templateUrl);
            }
            function getResolvePromises(resolves) {
                var promisesArr = [];
                return angular.forEach(resolves, function(value) {
                    promisesArr.push(angular.isFunction(value) || angular.isArray(value) ? $q.when($injector.invoke(value)) : angular.isString(value) ? $q.when($injector.get(value)) : $q.when(value));
                }), promisesArr;
            }
            var $modal = {}, promiseChain = null;
            return $modal.getPromiseChain = function() {
                return promiseChain;
            }, $modal.open = function(modalOptions) {
                function resolveWithTemplate() {
                    return templateAndResolvePromise;
                }
                var modalResultDeferred = $q.defer(), modalOpenedDeferred = $q.defer(), modalRenderDeferred = $q.defer(), modalInstance = {
                    result: modalResultDeferred.promise,
                    opened: modalOpenedDeferred.promise,
                    rendered: modalRenderDeferred.promise,
                    close: function(result) {
                        return $modalStack.close(modalInstance, result);
                    },
                    dismiss: function(reason) {
                        return $modalStack.dismiss(modalInstance, reason);
                    }
                };
                if (modalOptions = angular.extend({}, $modalProvider.options, modalOptions), modalOptions.resolve = modalOptions.resolve || {}, 
                !modalOptions.template && !modalOptions.templateUrl) throw new Error("One of template or templateUrl options is required.");
                var samePromise, templateAndResolvePromise = $q.all([ getTemplatePromise(modalOptions) ].concat(getResolvePromises(modalOptions.resolve)));
                return samePromise = promiseChain = $q.all([ promiseChain ]).then(resolveWithTemplate, resolveWithTemplate).then(function(tplAndVars) {
                    var modalScope = (modalOptions.scope || $rootScope).$new();
                    modalScope.$close = modalInstance.close, modalScope.$dismiss = modalInstance.dismiss, 
                    modalScope.$on("$destroy", function() {
                        modalScope.$$uibDestructionScheduled || modalScope.$dismiss("$uibUnscheduledDestruction");
                    });
                    var ctrlInstance, ctrlLocals = {}, resolveIter = 1;
                    modalOptions.controller && (ctrlLocals.$scope = modalScope, ctrlLocals.$uibModalInstance = modalInstance, 
                    Object.defineProperty(ctrlLocals, "$modalInstance", {
                        get: function() {
                            return $modalSuppressWarning || $log.warn("$modalInstance is now deprecated. Use $uibModalInstance instead."), 
                            modalInstance;
                        }
                    }), angular.forEach(modalOptions.resolve, function(value, key) {
                        ctrlLocals[key] = tplAndVars[resolveIter++];
                    }), ctrlInstance = $controller(modalOptions.controller, ctrlLocals), modalOptions.controllerAs && (modalOptions.bindToController && angular.extend(ctrlInstance, modalScope), 
                    modalScope[modalOptions.controllerAs] = ctrlInstance)), $modalStack.open(modalInstance, {
                        scope: modalScope,
                        deferred: modalResultDeferred,
                        renderDeferred: modalRenderDeferred,
                        content: tplAndVars[0],
                        animation: modalOptions.animation,
                        backdrop: modalOptions.backdrop,
                        keyboard: modalOptions.keyboard,
                        backdropClass: modalOptions.backdropClass,
                        windowTopClass: modalOptions.windowTopClass,
                        windowClass: modalOptions.windowClass,
                        windowTemplateUrl: modalOptions.windowTemplateUrl,
                        size: modalOptions.size,
                        openedClass: modalOptions.openedClass
                    }), modalOpenedDeferred.resolve(!0);
                }, function(reason) {
                    modalOpenedDeferred.reject(reason), modalResultDeferred.reject(reason);
                }).finally(function() {
                    promiseChain === samePromise && (promiseChain = null);
                }), modalInstance;
            }, $modal;
        } ]
    };
    return $modalProvider;
}), angular.module("ui.bootstrap.modal").value("$modalSuppressWarning", !1).directive("modalBackdrop", [ "$animate", "$injector", "$modalStack", "$log", "$modalSuppressWarning", function($animate, $injector, $modalStack, $log, $modalSuppressWarning) {
    function linkFn(scope, element, attrs) {
        $modalSuppressWarning || $log.warn("modal-backdrop is now deprecated. Use uib-modal-backdrop instead."), 
        element.addClass("modal-backdrop"), attrs.modalInClass && ($animateCss ? $animateCss(element, {
            addClass: attrs.modalInClass
        }).start() : $animate.addClass(element, attrs.modalInClass), scope.$on($modalStack.NOW_CLOSING_EVENT, function(e, setIsAsync) {
            var done = setIsAsync();
            $animateCss ? $animateCss(element, {
                removeClass: attrs.modalInClass
            }).start().then(done) : $animate.removeClass(element, attrs.modalInClass).then(done);
        }));
    }
    var $animateCss = null;
    return $injector.has("$animateCss") && ($animateCss = $injector.get("$animateCss")), 
    {
        replace: !0,
        templateUrl: "template/modal/backdrop.html",
        compile: function(tElement, tAttrs) {
            return tElement.addClass(tAttrs.backdropClass), linkFn;
        }
    };
} ]).directive("modalWindow", [ "$modalStack", "$q", "$animate", "$injector", "$log", "$modalSuppressWarning", function($modalStack, $q, $animate, $injector, $log, $modalSuppressWarning) {
    var $animateCss = null;
    return $injector.has("$animateCss") && ($animateCss = $injector.get("$animateCss")), 
    {
        scope: {
            index: "@"
        },
        replace: !0,
        transclude: !0,
        templateUrl: function(tElement, tAttrs) {
            return tAttrs.templateUrl || "template/modal/window.html";
        },
        link: function(scope, element, attrs) {
            $modalSuppressWarning || $log.warn("modal-window is now deprecated. Use uib-modal-window instead."), 
            element.addClass(attrs.windowClass || ""), element.addClass(attrs.windowTopClass || ""), 
            scope.size = attrs.size, scope.close = function(evt) {
                var modal = $modalStack.getTop();
                modal && modal.value.backdrop && "static" !== modal.value.backdrop && evt.target === evt.currentTarget && (evt.preventDefault(), 
                evt.stopPropagation(), $modalStack.dismiss(modal.key, "backdrop click"));
            }, element.on("click", scope.close), scope.$isRendered = !0;
            var modalRenderDeferObj = $q.defer();
            attrs.$observe("modalRender", function(value) {
                "true" == value && modalRenderDeferObj.resolve();
            }), modalRenderDeferObj.promise.then(function() {
                var animationPromise = null;
                attrs.modalInClass && (animationPromise = $animateCss ? $animateCss(element, {
                    addClass: attrs.modalInClass
                }).start() : $animate.addClass(element, attrs.modalInClass), scope.$on($modalStack.NOW_CLOSING_EVENT, function(e, setIsAsync) {
                    var done = setIsAsync();
                    $animateCss ? $animateCss(element, {
                        removeClass: attrs.modalInClass
                    }).start().then(done) : $animate.removeClass(element, attrs.modalInClass).then(done);
                })), $q.when(animationPromise).then(function() {
                    var inputWithAutofocus = element[0].querySelector("[autofocus]");
                    inputWithAutofocus ? inputWithAutofocus.focus() : element[0].focus();
                });
                var modal = $modalStack.getTop();
                modal && $modalStack.modalRendered(modal.key);
            });
        }
    };
} ]).directive("modalAnimationClass", [ "$log", "$modalSuppressWarning", function($log, $modalSuppressWarning) {
    return {
        compile: function(tElement, tAttrs) {
            $modalSuppressWarning || $log.warn("modal-animation-class is now deprecated. Use uib-modal-animation-class instead."), 
            tAttrs.modalAnimation && tElement.addClass(tAttrs.modalAnimationClass);
        }
    };
} ]).directive("modalTransclude", [ "$log", "$modalSuppressWarning", function($log, $modalSuppressWarning) {
    return {
        link: function($scope, $element, $attrs, controller, $transclude) {
            $modalSuppressWarning || $log.warn("modal-transclude is now deprecated. Use uib-modal-transclude instead."), 
            $transclude($scope.$parent, function(clone) {
                $element.empty(), $element.append(clone);
            });
        }
    };
} ]).service("$modalStack", [ "$animate", "$timeout", "$document", "$compile", "$rootScope", "$q", "$injector", "$$multiMap", "$$stackedMap", "$uibModalStack", "$log", "$modalSuppressWarning", function($animate, $timeout, $document, $compile, $rootScope, $q, $injector, $$multiMap, $$stackedMap, $uibModalStack, $log, $modalSuppressWarning) {
    $modalSuppressWarning || $log.warn("$modalStack is now deprecated. Use $uibModalStack instead."), 
    angular.extend(this, $uibModalStack);
} ]).provider("$modal", [ "$uibModalProvider", function($uibModalProvider) {
    angular.extend(this, $uibModalProvider), this.$get = [ "$injector", "$log", "$modalSuppressWarning", function($injector, $log, $modalSuppressWarning) {
        return $modalSuppressWarning || $log.warn("$modal is now deprecated. Use $uibModal instead."), 
        $injector.invoke($uibModalProvider.$get);
    } ];
} ]), angular.module("ui.bootstrap.pagination", []).controller("UibPaginationController", [ "$scope", "$attrs", "$parse", function($scope, $attrs, $parse) {
    var self = this, ngModelCtrl = {
        $setViewValue: angular.noop
    }, setNumPages = $attrs.numPages ? $parse($attrs.numPages).assign : angular.noop;
    this.init = function(ngModelCtrl_, config) {
        ngModelCtrl = ngModelCtrl_, this.config = config, ngModelCtrl.$render = function() {
            self.render();
        }, $attrs.itemsPerPage ? $scope.$parent.$watch($parse($attrs.itemsPerPage), function(value) {
            self.itemsPerPage = parseInt(value, 10), $scope.totalPages = self.calculateTotalPages();
        }) : this.itemsPerPage = config.itemsPerPage, $scope.$watch("totalItems", function() {
            $scope.totalPages = self.calculateTotalPages();
        }), $scope.$watch("totalPages", function(value) {
            setNumPages($scope.$parent, value), $scope.page > value ? $scope.selectPage(value) : ngModelCtrl.$render();
        });
    }, this.calculateTotalPages = function() {
        var totalPages = this.itemsPerPage < 1 ? 1 : Math.ceil($scope.totalItems / this.itemsPerPage);
        return Math.max(totalPages || 0, 1);
    }, this.render = function() {
        $scope.page = parseInt(ngModelCtrl.$viewValue, 10) || 1;
    }, $scope.selectPage = function(page, evt) {
        evt && evt.preventDefault();
        var clickAllowed = !$scope.ngDisabled || !evt;
        clickAllowed && $scope.page !== page && page > 0 && page <= $scope.totalPages && (evt && evt.target && evt.target.blur(), 
        ngModelCtrl.$setViewValue(page), ngModelCtrl.$render());
    }, $scope.getText = function(key) {
        return $scope[key + "Text"] || self.config[key + "Text"];
    }, $scope.noPrevious = function() {
        return 1 === $scope.page;
    }, $scope.noNext = function() {
        return $scope.page === $scope.totalPages;
    };
} ]).constant("uibPaginationConfig", {
    itemsPerPage: 10,
    boundaryLinks: !1,
    directionLinks: !0,
    firstText: "First",
    previousText: "Previous",
    nextText: "Next",
    lastText: "Last",
    rotate: !0
}).directive("uibPagination", [ "$parse", "uibPaginationConfig", function($parse, paginationConfig) {
    return {
        restrict: "EA",
        scope: {
            totalItems: "=",
            firstText: "@",
            previousText: "@",
            nextText: "@",
            lastText: "@",
            ngDisabled: "="
        },
        require: [ "uibPagination", "?ngModel" ],
        controller: "UibPaginationController",
        controllerAs: "pagination",
        templateUrl: function(element, attrs) {
            return attrs.templateUrl || "template/pagination/pagination.html";
        },
        replace: !0,
        link: function(scope, element, attrs, ctrls) {
            function makePage(number, text, isActive) {
                return {
                    number: number,
                    text: text,
                    active: isActive
                };
            }
            function getPages(currentPage, totalPages) {
                var pages = [], startPage = 1, endPage = totalPages, isMaxSized = angular.isDefined(maxSize) && totalPages > maxSize;
                isMaxSized && (rotate ? (startPage = Math.max(currentPage - Math.floor(maxSize / 2), 1), 
                endPage = startPage + maxSize - 1, endPage > totalPages && (endPage = totalPages, 
                startPage = endPage - maxSize + 1)) : (startPage = (Math.ceil(currentPage / maxSize) - 1) * maxSize + 1, 
                endPage = Math.min(startPage + maxSize - 1, totalPages)));
                for (var number = startPage; endPage >= number; number++) {
                    var page = makePage(number, number, number === currentPage);
                    pages.push(page);
                }
                if (isMaxSized && !rotate) {
                    if (startPage > 1) {
                        var previousPageSet = makePage(startPage - 1, "...", !1);
                        pages.unshift(previousPageSet);
                    }
                    if (totalPages > endPage) {
                        var nextPageSet = makePage(endPage + 1, "...", !1);
                        pages.push(nextPageSet);
                    }
                }
                return pages;
            }
            var paginationCtrl = ctrls[0], ngModelCtrl = ctrls[1];
            if (ngModelCtrl) {
                var maxSize = angular.isDefined(attrs.maxSize) ? scope.$parent.$eval(attrs.maxSize) : paginationConfig.maxSize, rotate = angular.isDefined(attrs.rotate) ? scope.$parent.$eval(attrs.rotate) : paginationConfig.rotate;
                scope.boundaryLinks = angular.isDefined(attrs.boundaryLinks) ? scope.$parent.$eval(attrs.boundaryLinks) : paginationConfig.boundaryLinks, 
                scope.directionLinks = angular.isDefined(attrs.directionLinks) ? scope.$parent.$eval(attrs.directionLinks) : paginationConfig.directionLinks, 
                paginationCtrl.init(ngModelCtrl, paginationConfig), attrs.maxSize && scope.$parent.$watch($parse(attrs.maxSize), function(value) {
                    maxSize = parseInt(value, 10), paginationCtrl.render();
                });
                var originalRender = paginationCtrl.render;
                paginationCtrl.render = function() {
                    originalRender(), scope.page > 0 && scope.page <= scope.totalPages && (scope.pages = getPages(scope.page, scope.totalPages));
                };
            }
        }
    };
} ]).constant("uibPagerConfig", {
    itemsPerPage: 10,
    previousText: " Previous",
    nextText: "Next ",
    align: !0
}).directive("uibPager", [ "uibPagerConfig", function(pagerConfig) {
    return {
        restrict: "EA",
        scope: {
            totalItems: "=",
            previousText: "@",
            nextText: "@",
            ngDisabled: "="
        },
        require: [ "uibPager", "?ngModel" ],
        controller: "UibPaginationController",
        controllerAs: "pagination",
        templateUrl: function(element, attrs) {
            return attrs.templateUrl || "template/pagination/pager.html";
        },
        replace: !0,
        link: function(scope, element, attrs, ctrls) {
            var paginationCtrl = ctrls[0], ngModelCtrl = ctrls[1];
            ngModelCtrl && (scope.align = angular.isDefined(attrs.align) ? scope.$parent.$eval(attrs.align) : pagerConfig.align, 
            paginationCtrl.init(ngModelCtrl, pagerConfig));
        }
    };
} ]), angular.module("ui.bootstrap.pagination").value("$paginationSuppressWarning", !1).controller("PaginationController", [ "$scope", "$attrs", "$parse", "$log", "$paginationSuppressWarning", function($scope, $attrs, $parse, $log, $paginationSuppressWarning) {
    $paginationSuppressWarning || $log.warn("PaginationController is now deprecated. Use UibPaginationController instead.");
    var self = this, ngModelCtrl = {
        $setViewValue: angular.noop
    }, setNumPages = $attrs.numPages ? $parse($attrs.numPages).assign : angular.noop;
    this.init = function(ngModelCtrl_, config) {
        ngModelCtrl = ngModelCtrl_, this.config = config, ngModelCtrl.$render = function() {
            self.render();
        }, $attrs.itemsPerPage ? $scope.$parent.$watch($parse($attrs.itemsPerPage), function(value) {
            self.itemsPerPage = parseInt(value, 10), $scope.totalPages = self.calculateTotalPages();
        }) : this.itemsPerPage = config.itemsPerPage, $scope.$watch("totalItems", function() {
            $scope.totalPages = self.calculateTotalPages();
        }), $scope.$watch("totalPages", function(value) {
            setNumPages($scope.$parent, value), $scope.page > value ? $scope.selectPage(value) : ngModelCtrl.$render();
        });
    }, this.calculateTotalPages = function() {
        var totalPages = this.itemsPerPage < 1 ? 1 : Math.ceil($scope.totalItems / this.itemsPerPage);
        return Math.max(totalPages || 0, 1);
    }, this.render = function() {
        $scope.page = parseInt(ngModelCtrl.$viewValue, 10) || 1;
    }, $scope.selectPage = function(page, evt) {
        evt && evt.preventDefault();
        var clickAllowed = !$scope.ngDisabled || !evt;
        clickAllowed && $scope.page !== page && page > 0 && page <= $scope.totalPages && (evt && evt.target && evt.target.blur(), 
        ngModelCtrl.$setViewValue(page), ngModelCtrl.$render());
    }, $scope.getText = function(key) {
        return $scope[key + "Text"] || self.config[key + "Text"];
    }, $scope.noPrevious = function() {
        return 1 === $scope.page;
    }, $scope.noNext = function() {
        return $scope.page === $scope.totalPages;
    };
} ]).directive("pagination", [ "$parse", "uibPaginationConfig", "$log", "$paginationSuppressWarning", function($parse, paginationConfig, $log, $paginationSuppressWarning) {
    return {
        restrict: "EA",
        scope: {
            totalItems: "=",
            firstText: "@",
            previousText: "@",
            nextText: "@",
            lastText: "@",
            ngDisabled: "="
        },
        require: [ "pagination", "?ngModel" ],
        controller: "PaginationController",
        controllerAs: "pagination",
        templateUrl: function(element, attrs) {
            return attrs.templateUrl || "template/pagination/pagination.html";
        },
        replace: !0,
        link: function(scope, element, attrs, ctrls) {
            function makePage(number, text, isActive) {
                return {
                    number: number,
                    text: text,
                    active: isActive
                };
            }
            function getPages(currentPage, totalPages) {
                var pages = [], startPage = 1, endPage = totalPages, isMaxSized = angular.isDefined(maxSize) && totalPages > maxSize;
                isMaxSized && (rotate ? (startPage = Math.max(currentPage - Math.floor(maxSize / 2), 1), 
                endPage = startPage + maxSize - 1, endPage > totalPages && (endPage = totalPages, 
                startPage = endPage - maxSize + 1)) : (startPage = (Math.ceil(currentPage / maxSize) - 1) * maxSize + 1, 
                endPage = Math.min(startPage + maxSize - 1, totalPages)));
                for (var number = startPage; endPage >= number; number++) {
                    var page = makePage(number, number, number === currentPage);
                    pages.push(page);
                }
                if (isMaxSized && !rotate) {
                    if (startPage > 1) {
                        var previousPageSet = makePage(startPage - 1, "...", !1);
                        pages.unshift(previousPageSet);
                    }
                    if (totalPages > endPage) {
                        var nextPageSet = makePage(endPage + 1, "...", !1);
                        pages.push(nextPageSet);
                    }
                }
                return pages;
            }
            $paginationSuppressWarning || $log.warn("pagination is now deprecated. Use uib-pagination instead.");
            var paginationCtrl = ctrls[0], ngModelCtrl = ctrls[1];
            if (ngModelCtrl) {
                var maxSize = angular.isDefined(attrs.maxSize) ? scope.$parent.$eval(attrs.maxSize) : paginationConfig.maxSize, rotate = angular.isDefined(attrs.rotate) ? scope.$parent.$eval(attrs.rotate) : paginationConfig.rotate;
                scope.boundaryLinks = angular.isDefined(attrs.boundaryLinks) ? scope.$parent.$eval(attrs.boundaryLinks) : paginationConfig.boundaryLinks, 
                scope.directionLinks = angular.isDefined(attrs.directionLinks) ? scope.$parent.$eval(attrs.directionLinks) : paginationConfig.directionLinks, 
                paginationCtrl.init(ngModelCtrl, paginationConfig), attrs.maxSize && scope.$parent.$watch($parse(attrs.maxSize), function(value) {
                    maxSize = parseInt(value, 10), paginationCtrl.render();
                });
                var originalRender = paginationCtrl.render;
                paginationCtrl.render = function() {
                    originalRender(), scope.page > 0 && scope.page <= scope.totalPages && (scope.pages = getPages(scope.page, scope.totalPages));
                };
            }
        }
    };
} ]).directive("pager", [ "uibPagerConfig", "$log", "$paginationSuppressWarning", function(pagerConfig, $log, $paginationSuppressWarning) {
    return {
        restrict: "EA",
        scope: {
            totalItems: "=",
            previousText: "@",
            nextText: "@",
            ngDisabled: "="
        },
        require: [ "pager", "?ngModel" ],
        controller: "PaginationController",
        controllerAs: "pagination",
        templateUrl: function(element, attrs) {
            return attrs.templateUrl || "template/pagination/pager.html";
        },
        replace: !0,
        link: function(scope, element, attrs, ctrls) {
            $paginationSuppressWarning || $log.warn("pager is now deprecated. Use uib-pager instead.");
            var paginationCtrl = ctrls[0], ngModelCtrl = ctrls[1];
            ngModelCtrl && (scope.align = angular.isDefined(attrs.align) ? scope.$parent.$eval(attrs.align) : pagerConfig.align, 
            paginationCtrl.init(ngModelCtrl, pagerConfig));
        }
    };
} ]), angular.module("ui.bootstrap.tooltip", [ "ui.bootstrap.position", "ui.bootstrap.stackedMap" ]).provider("$uibTooltip", function() {
    function snake_case(name) {
        var regexp = /[A-Z]/g, separator = "-";
        return name.replace(regexp, function(letter, pos) {
            return (pos ? separator : "") + letter.toLowerCase();
        });
    }
    var defaultOptions = {
        placement: "top",
        animation: !0,
        popupDelay: 0,
        popupCloseDelay: 0,
        useContentExp: !1
    }, triggerMap = {
        mouseenter: "mouseleave",
        click: "click",
        focus: "blur",
        none: ""
    }, globalOptions = {};
    this.options = function(value) {
        angular.extend(globalOptions, value);
    }, this.setTriggers = function(triggers) {
        angular.extend(triggerMap, triggers);
    }, this.$get = [ "$window", "$compile", "$timeout", "$document", "$uibPosition", "$interpolate", "$rootScope", "$parse", "$$stackedMap", function($window, $compile, $timeout, $document, $position, $interpolate, $rootScope, $parse, $$stackedMap) {
        var openedTooltips = $$stackedMap.createNew();
        return $document.on("keypress", function(e) {
            if (27 === e.which) {
                var last = openedTooltips.top();
                last && (last.value.close(), openedTooltips.removeTop(), last = null);
            }
        }), function(ttType, prefix, defaultTriggerShow, options) {
            function getTriggers(trigger) {
                var show = (trigger || options.trigger || defaultTriggerShow).split(" "), hide = show.map(function(trigger) {
                    return triggerMap[trigger] || trigger;
                });
                return {
                    show: show,
                    hide: hide
                };
            }
            options = angular.extend({}, defaultOptions, globalOptions, options);
            var directiveName = snake_case(ttType), startSym = $interpolate.startSymbol(), endSym = $interpolate.endSymbol(), template = "<div " + directiveName + '-popup title="' + startSym + "title" + endSym + '" ' + (options.useContentExp ? 'content-exp="contentExp()" ' : 'content="' + startSym + "content" + endSym + '" ') + 'placement="' + startSym + "placement" + endSym + '" popup-class="' + startSym + "popupClass" + endSym + '" animation="animation" is-open="isOpen"origin-scope="origScope" style="visibility: hidden; display: block; top: -9999px; left: -9999px;"></div>';
            return {
                compile: function() {
                    var tooltipLinker = $compile(template);
                    return function(scope, element, attrs) {
                        function toggleTooltipBind() {
                            ttScope.isOpen ? hideTooltipBind() : showTooltipBind();
                        }
                        function showTooltipBind() {
                            (!hasEnableExp || scope.$eval(attrs[prefix + "Enable"])) && (cancelHide(), prepareTooltip(), 
                            ttScope.popupDelay ? showTimeout || (showTimeout = $timeout(show, ttScope.popupDelay, !1)) : show());
                        }
                        function hideTooltipBind() {
                            cancelShow(), ttScope.popupCloseDelay ? hideTimeout || (hideTimeout = $timeout(hide, ttScope.popupCloseDelay, !1)) : hide();
                        }
                        function show() {
                            return cancelShow(), cancelHide(), ttScope.content ? (createTooltip(), void ttScope.$evalAsync(function() {
                                ttScope.isOpen = !0, assignIsOpen(!0), positionTooltip();
                            })) : angular.noop;
                        }
                        function cancelShow() {
                            showTimeout && ($timeout.cancel(showTimeout), showTimeout = null), positionTimeout && ($timeout.cancel(positionTimeout), 
                            positionTimeout = null);
                        }
                        function hide() {
                            cancelShow(), cancelHide(), ttScope && ttScope.$evalAsync(function() {
                                ttScope.isOpen = !1, assignIsOpen(!1), ttScope.animation ? transitionTimeout || (transitionTimeout = $timeout(removeTooltip, 150, !1)) : removeTooltip();
                            });
                        }
                        function cancelHide() {
                            hideTimeout && ($timeout.cancel(hideTimeout), hideTimeout = null), transitionTimeout && ($timeout.cancel(transitionTimeout), 
                            transitionTimeout = null);
                        }
                        function createTooltip() {
                            tooltip || (tooltipLinkedScope = ttScope.$new(), tooltip = tooltipLinker(tooltipLinkedScope, function(tooltip) {
                                appendToBody ? $document.find("body").append(tooltip) : element.after(tooltip);
                            }), prepObservers());
                        }
                        function removeTooltip() {
                            unregisterObservers(), transitionTimeout = null, tooltip && (tooltip.remove(), tooltip = null), 
                            tooltipLinkedScope && (tooltipLinkedScope.$destroy(), tooltipLinkedScope = null);
                        }
                        function prepareTooltip() {
                            ttScope.title = attrs[prefix + "Title"], ttScope.content = contentParse ? contentParse(scope) : attrs[ttType], 
                            ttScope.popupClass = attrs[prefix + "Class"], ttScope.placement = angular.isDefined(attrs[prefix + "Placement"]) ? attrs[prefix + "Placement"] : options.placement;
                            var delay = parseInt(attrs[prefix + "PopupDelay"], 10), closeDelay = parseInt(attrs[prefix + "PopupCloseDelay"], 10);
                            ttScope.popupDelay = isNaN(delay) ? options.popupDelay : delay, ttScope.popupCloseDelay = isNaN(closeDelay) ? options.popupCloseDelay : closeDelay;
                        }
                        function assignIsOpen(isOpen) {
                            isOpenParse && angular.isFunction(isOpenParse.assign) && isOpenParse.assign(scope, isOpen);
                        }
                        function prepObservers() {
                            observers.length = 0, contentParse ? (observers.push(scope.$watch(contentParse, function(val) {
                                ttScope.content = val, !val && ttScope.isOpen && hide();
                            })), observers.push(tooltipLinkedScope.$watch(function() {
                                repositionScheduled || (repositionScheduled = !0, tooltipLinkedScope.$$postDigest(function() {
                                    repositionScheduled = !1, ttScope && ttScope.isOpen && positionTooltip();
                                }));
                            }))) : observers.push(attrs.$observe(ttType, function(val) {
                                ttScope.content = val, !val && ttScope.isOpen ? hide() : positionTooltip();
                            })), observers.push(attrs.$observe(prefix + "Title", function(val) {
                                ttScope.title = val, ttScope.isOpen && positionTooltip();
                            })), observers.push(attrs.$observe(prefix + "Placement", function(val) {
                                ttScope.placement = val ? val : options.placement, ttScope.isOpen && positionTooltip();
                            }));
                        }
                        function unregisterObservers() {
                            observers.length && (angular.forEach(observers, function(observer) {
                                observer();
                            }), observers.length = 0);
                        }
                        function prepTriggers() {
                            var val = attrs[prefix + "Trigger"];
                            unregisterTriggers(), triggers = getTriggers(val), "none" !== triggers.show && triggers.show.forEach(function(trigger, idx) {
                                trigger === triggers.hide[idx] ? element[0].addEventListener(trigger, toggleTooltipBind) : trigger && (element[0].addEventListener(trigger, showTooltipBind), 
                                triggers.hide[idx].split(" ").forEach(function(trigger) {
                                    element[0].addEventListener(trigger, hideTooltipBind);
                                })), element.on("keypress", function(e) {
                                    27 === e.which && hideTooltipBind();
                                });
                            });
                        }
                        var tooltip, tooltipLinkedScope, transitionTimeout, showTimeout, hideTimeout, positionTimeout, appendToBody = angular.isDefined(options.appendToBody) ? options.appendToBody : !1, triggers = getTriggers(void 0), hasEnableExp = angular.isDefined(attrs[prefix + "Enable"]), ttScope = scope.$new(!0), repositionScheduled = !1, isOpenParse = angular.isDefined(attrs[prefix + "IsOpen"]) ? $parse(attrs[prefix + "IsOpen"]) : !1, contentParse = options.useContentExp ? $parse(attrs[ttType]) : !1, observers = [], positionTooltip = function() {
                            tooltip && tooltip.html() && (positionTimeout || (positionTimeout = $timeout(function() {
                                tooltip.css({
                                    top: 0,
                                    left: 0
                                });
                                var ttCss = $position.positionElements(element, tooltip, ttScope.placement, appendToBody);
                                ttCss.top += "px", ttCss.left += "px", ttCss.visibility = "visible", tooltip.css(ttCss), 
                                positionTimeout = null;
                            }, 0, !1)));
                        };
                        ttScope.origScope = scope, ttScope.isOpen = !1, openedTooltips.add(ttScope, {
                            close: hide
                        }), ttScope.contentExp = function() {
                            return ttScope.content;
                        }, attrs.$observe("disabled", function(val) {
                            val && cancelShow(), val && ttScope.isOpen && hide();
                        }), isOpenParse && scope.$watch(isOpenParse, function(val) {
                            ttScope && !val === ttScope.isOpen && toggleTooltipBind();
                        });
                        var unregisterTriggers = function() {
                            triggers.show.forEach(function(trigger) {
                                element.unbind(trigger, showTooltipBind);
                            }), triggers.hide.forEach(function(trigger) {
                                trigger.split(" ").forEach(function(hideTrigger) {
                                    element[0].removeEventListener(hideTrigger, hideTooltipBind);
                                });
                            });
                        };
                        prepTriggers();
                        var animation = scope.$eval(attrs[prefix + "Animation"]);
                        ttScope.animation = angular.isDefined(animation) ? !!animation : options.animation;
                        var appendToBodyVal = scope.$eval(attrs[prefix + "AppendToBody"]);
                        appendToBody = angular.isDefined(appendToBodyVal) ? appendToBodyVal : appendToBody, 
                        appendToBody && scope.$on("$locationChangeSuccess", function() {
                            ttScope.isOpen && hide();
                        }), scope.$on("$destroy", function() {
                            cancelShow(), cancelHide(), unregisterTriggers(), removeTooltip(), openedTooltips.remove(ttScope), 
                            ttScope = null;
                        });
                    };
                }
            };
        };
    } ];
}).directive("uibTooltipTemplateTransclude", [ "$animate", "$sce", "$compile", "$templateRequest", function($animate, $sce, $compile, $templateRequest) {
    return {
        link: function(scope, elem, attrs) {
            var currentScope, previousElement, currentElement, origScope = scope.$eval(attrs.tooltipTemplateTranscludeScope), changeCounter = 0, cleanupLastIncludeContent = function() {
                previousElement && (previousElement.remove(), previousElement = null), currentScope && (currentScope.$destroy(), 
                currentScope = null), currentElement && ($animate.leave(currentElement).then(function() {
                    previousElement = null;
                }), previousElement = currentElement, currentElement = null);
            };
            scope.$watch($sce.parseAsResourceUrl(attrs.uibTooltipTemplateTransclude), function(src) {
                var thisChangeId = ++changeCounter;
                src ? ($templateRequest(src, !0).then(function(response) {
                    if (thisChangeId === changeCounter) {
                        var newScope = origScope.$new(), template = response, clone = $compile(template)(newScope, function(clone) {
                            cleanupLastIncludeContent(), $animate.enter(clone, elem);
                        });
                        currentScope = newScope, currentElement = clone, currentScope.$emit("$includeContentLoaded", src);
                    }
                }, function() {
                    thisChangeId === changeCounter && (cleanupLastIncludeContent(), scope.$emit("$includeContentError", src));
                }), scope.$emit("$includeContentRequested", src)) : cleanupLastIncludeContent();
            }), scope.$on("$destroy", cleanupLastIncludeContent);
        }
    };
} ]).directive("uibTooltipClasses", function() {
    return {
        restrict: "A",
        link: function(scope, element, attrs) {
            scope.placement && element.addClass(scope.placement), scope.popupClass && element.addClass(scope.popupClass), 
            scope.animation() && element.addClass(attrs.tooltipAnimationClass);
        }
    };
}).directive("uibTooltipPopup", function() {
    return {
        replace: !0,
        scope: {
            content: "@",
            placement: "@",
            popupClass: "@",
            animation: "&",
            isOpen: "&"
        },
        templateUrl: "template/tooltip/tooltip-popup.html",
        link: function(scope, element) {
            element.addClass("tooltip");
        }
    };
}).directive("uibTooltip", [ "$uibTooltip", function($uibTooltip) {
    return $uibTooltip("uibTooltip", "tooltip", "mouseenter");
} ]).directive("uibTooltipTemplatePopup", function() {
    return {
        replace: !0,
        scope: {
            contentExp: "&",
            placement: "@",
            popupClass: "@",
            animation: "&",
            isOpen: "&",
            originScope: "&"
        },
        templateUrl: "template/tooltip/tooltip-template-popup.html",
        link: function(scope, element) {
            element.addClass("tooltip");
        }
    };
}).directive("uibTooltipTemplate", [ "$uibTooltip", function($uibTooltip) {
    return $uibTooltip("uibTooltipTemplate", "tooltip", "mouseenter", {
        useContentExp: !0
    });
} ]).directive("uibTooltipHtmlPopup", function() {
    return {
        replace: !0,
        scope: {
            contentExp: "&",
            placement: "@",
            popupClass: "@",
            animation: "&",
            isOpen: "&"
        },
        templateUrl: "template/tooltip/tooltip-html-popup.html",
        link: function(scope, element) {
            element.addClass("tooltip");
        }
    };
}).directive("uibTooltipHtml", [ "$uibTooltip", function($uibTooltip) {
    return $uibTooltip("uibTooltipHtml", "tooltip", "mouseenter", {
        useContentExp: !0
    });
} ]), angular.module("ui.bootstrap.tooltip").value("$tooltipSuppressWarning", !1).provider("$tooltip", [ "$uibTooltipProvider", function($uibTooltipProvider) {
    angular.extend(this, $uibTooltipProvider), this.$get = [ "$log", "$tooltipSuppressWarning", "$injector", function($log, $tooltipSuppressWarning, $injector) {
        return $tooltipSuppressWarning || $log.warn("$tooltip is now deprecated. Use $uibTooltip instead."), 
        $injector.invoke($uibTooltipProvider.$get);
    } ];
} ]).directive("tooltipTemplateTransclude", [ "$animate", "$sce", "$compile", "$templateRequest", "$log", "$tooltipSuppressWarning", function($animate, $sce, $compile, $templateRequest, $log, $tooltipSuppressWarning) {
    return {
        link: function(scope, elem, attrs) {
            $tooltipSuppressWarning || $log.warn("tooltip-template-transclude is now deprecated. Use uib-tooltip-template-transclude instead.");
            var currentScope, previousElement, currentElement, origScope = scope.$eval(attrs.tooltipTemplateTranscludeScope), changeCounter = 0, cleanupLastIncludeContent = function() {
                previousElement && (previousElement.remove(), previousElement = null), currentScope && (currentScope.$destroy(), 
                currentScope = null), currentElement && ($animate.leave(currentElement).then(function() {
                    previousElement = null;
                }), previousElement = currentElement, currentElement = null);
            };
            scope.$watch($sce.parseAsResourceUrl(attrs.tooltipTemplateTransclude), function(src) {
                var thisChangeId = ++changeCounter;
                src ? ($templateRequest(src, !0).then(function(response) {
                    if (thisChangeId === changeCounter) {
                        var newScope = origScope.$new(), template = response, clone = $compile(template)(newScope, function(clone) {
                            cleanupLastIncludeContent(), $animate.enter(clone, elem);
                        });
                        currentScope = newScope, currentElement = clone, currentScope.$emit("$includeContentLoaded", src);
                    }
                }, function() {
                    thisChangeId === changeCounter && (cleanupLastIncludeContent(), scope.$emit("$includeContentError", src));
                }), scope.$emit("$includeContentRequested", src)) : cleanupLastIncludeContent();
            }), scope.$on("$destroy", cleanupLastIncludeContent);
        }
    };
} ]).directive("tooltipClasses", [ "$log", "$tooltipSuppressWarning", function($log, $tooltipSuppressWarning) {
    return {
        restrict: "A",
        link: function(scope, element, attrs) {
            $tooltipSuppressWarning || $log.warn("tooltip-classes is now deprecated. Use uib-tooltip-classes instead."), 
            scope.placement && element.addClass(scope.placement), scope.popupClass && element.addClass(scope.popupClass), 
            scope.animation() && element.addClass(attrs.tooltipAnimationClass);
        }
    };
} ]).directive("tooltipPopup", [ "$log", "$tooltipSuppressWarning", function($log, $tooltipSuppressWarning) {
    return {
        replace: !0,
        scope: {
            content: "@",
            placement: "@",
            popupClass: "@",
            animation: "&",
            isOpen: "&"
        },
        templateUrl: "template/tooltip/tooltip-popup.html",
        link: function(scope, element) {
            $tooltipSuppressWarning || $log.warn("tooltip-popup is now deprecated. Use uib-tooltip-popup instead."), 
            element.addClass("tooltip");
        }
    };
} ]).directive("tooltip", [ "$tooltip", function($tooltip) {
    return $tooltip("tooltip", "tooltip", "mouseenter");
} ]).directive("tooltipTemplatePopup", [ "$log", "$tooltipSuppressWarning", function($log, $tooltipSuppressWarning) {
    return {
        replace: !0,
        scope: {
            contentExp: "&",
            placement: "@",
            popupClass: "@",
            animation: "&",
            isOpen: "&",
            originScope: "&"
        },
        templateUrl: "template/tooltip/tooltip-template-popup.html",
        link: function(scope, element) {
            $tooltipSuppressWarning || $log.warn("tooltip-template-popup is now deprecated. Use uib-tooltip-template-popup instead."), 
            element.addClass("tooltip");
        }
    };
} ]).directive("tooltipTemplate", [ "$tooltip", function($tooltip) {
    return $tooltip("tooltipTemplate", "tooltip", "mouseenter", {
        useContentExp: !0
    });
} ]).directive("tooltipHtmlPopup", [ "$log", "$tooltipSuppressWarning", function($log, $tooltipSuppressWarning) {
    return {
        replace: !0,
        scope: {
            contentExp: "&",
            placement: "@",
            popupClass: "@",
            animation: "&",
            isOpen: "&"
        },
        templateUrl: "template/tooltip/tooltip-html-popup.html",
        link: function(scope, element) {
            $tooltipSuppressWarning || $log.warn("tooltip-html-popup is now deprecated. Use uib-tooltip-html-popup instead."), 
            element.addClass("tooltip");
        }
    };
} ]).directive("tooltipHtml", [ "$tooltip", function($tooltip) {
    return $tooltip("tooltipHtml", "tooltip", "mouseenter", {
        useContentExp: !0
    });
} ]), angular.module("ui.bootstrap.popover", [ "ui.bootstrap.tooltip" ]).directive("uibPopoverTemplatePopup", function() {
    return {
        replace: !0,
        scope: {
            title: "@",
            contentExp: "&",
            placement: "@",
            popupClass: "@",
            animation: "&",
            isOpen: "&",
            originScope: "&"
        },
        templateUrl: "template/popover/popover-template.html",
        link: function(scope, element) {
            element.addClass("popover");
        }
    };
}).directive("uibPopoverTemplate", [ "$uibTooltip", function($uibTooltip) {
    return $uibTooltip("uibPopoverTemplate", "popover", "click", {
        useContentExp: !0
    });
} ]).directive("uibPopoverHtmlPopup", function() {
    return {
        replace: !0,
        scope: {
            contentExp: "&",
            title: "@",
            placement: "@",
            popupClass: "@",
            animation: "&",
            isOpen: "&"
        },
        templateUrl: "template/popover/popover-html.html",
        link: function(scope, element) {
            element.addClass("popover");
        }
    };
}).directive("uibPopoverHtml", [ "$uibTooltip", function($uibTooltip) {
    return $uibTooltip("uibPopoverHtml", "popover", "click", {
        useContentExp: !0
    });
} ]).directive("uibPopoverPopup", function() {
    return {
        replace: !0,
        scope: {
            title: "@",
            content: "@",
            placement: "@",
            popupClass: "@",
            animation: "&",
            isOpen: "&"
        },
        templateUrl: "template/popover/popover.html",
        link: function(scope, element) {
            element.addClass("popover");
        }
    };
}).directive("uibPopover", [ "$uibTooltip", function($uibTooltip) {
    return $uibTooltip("uibPopover", "popover", "click");
} ]), angular.module("ui.bootstrap.popover").value("$popoverSuppressWarning", !1).directive("popoverTemplatePopup", [ "$log", "$popoverSuppressWarning", function($log, $popoverSuppressWarning) {
    return {
        replace: !0,
        scope: {
            title: "@",
            contentExp: "&",
            placement: "@",
            popupClass: "@",
            animation: "&",
            isOpen: "&",
            originScope: "&"
        },
        templateUrl: "template/popover/popover-template.html",
        link: function(scope, element) {
            $popoverSuppressWarning || $log.warn("popover-template-popup is now deprecated. Use uib-popover-template-popup instead."), 
            element.addClass("popover");
        }
    };
} ]).directive("popoverTemplate", [ "$tooltip", function($tooltip) {
    return $tooltip("popoverTemplate", "popover", "click", {
        useContentExp: !0
    });
} ]).directive("popoverHtmlPopup", [ "$log", "$popoverSuppressWarning", function($log, $popoverSuppressWarning) {
    return {
        replace: !0,
        scope: {
            contentExp: "&",
            title: "@",
            placement: "@",
            popupClass: "@",
            animation: "&",
            isOpen: "&"
        },
        templateUrl: "template/popover/popover-html.html",
        link: function(scope, element) {
            $popoverSuppressWarning || $log.warn("popover-html-popup is now deprecated. Use uib-popover-html-popup instead."), 
            element.addClass("popover");
        }
    };
} ]).directive("popoverHtml", [ "$tooltip", function($tooltip) {
    return $tooltip("popoverHtml", "popover", "click", {
        useContentExp: !0
    });
} ]).directive("popoverPopup", [ "$log", "$popoverSuppressWarning", function($log, $popoverSuppressWarning) {
    return {
        replace: !0,
        scope: {
            title: "@",
            content: "@",
            placement: "@",
            popupClass: "@",
            animation: "&",
            isOpen: "&"
        },
        templateUrl: "template/popover/popover.html",
        link: function(scope, element) {
            $popoverSuppressWarning || $log.warn("popover-popup is now deprecated. Use uib-popover-popup instead."), 
            element.addClass("popover");
        }
    };
} ]).directive("popover", [ "$tooltip", function($tooltip) {
    return $tooltip("popover", "popover", "click");
} ]), angular.module("ui.bootstrap.progressbar", []).constant("uibProgressConfig", {
    animate: !0,
    max: 100
}).controller("UibProgressController", [ "$scope", "$attrs", "uibProgressConfig", function($scope, $attrs, progressConfig) {
    var self = this, animate = angular.isDefined($attrs.animate) ? $scope.$parent.$eval($attrs.animate) : progressConfig.animate;
    this.bars = [], $scope.max = angular.isDefined($scope.max) ? $scope.max : progressConfig.max, 
    this.addBar = function(bar, element, attrs) {
        animate || element.css({
            transition: "none"
        }), this.bars.push(bar), bar.max = $scope.max, bar.title = attrs && angular.isDefined(attrs.title) ? attrs.title : "progressbar", 
        bar.$watch("value", function() {
            bar.recalculatePercentage();
        }), bar.recalculatePercentage = function() {
            var totalPercentage = self.bars.reduce(function(total, bar) {
                return bar.percent = +(100 * bar.value / bar.max).toFixed(2), total + bar.percent;
            }, 0);
            totalPercentage > 100 && (bar.percent -= totalPercentage - 100);
        }, bar.$on("$destroy", function() {
            element = null, self.removeBar(bar);
        });
    }, this.removeBar = function(bar) {
        this.bars.splice(this.bars.indexOf(bar), 1), this.bars.forEach(function(bar) {
            bar.recalculatePercentage();
        });
    }, $scope.$watch("max", function() {
        self.bars.forEach(function(bar) {
            bar.max = $scope.max, bar.recalculatePercentage();
        });
    });
} ]).directive("uibProgress", function() {
    return {
        replace: !0,
        transclude: !0,
        controller: "UibProgressController",
        require: "uibProgress",
        scope: {
            max: "=?"
        },
        templateUrl: "template/progressbar/progress.html"
    };
}).directive("uibBar", function() {
    return {
        replace: !0,
        transclude: !0,
        require: "^uibProgress",
        scope: {
            value: "=",
            type: "@"
        },
        templateUrl: "template/progressbar/bar.html",
        link: function(scope, element, attrs, progressCtrl) {
            progressCtrl.addBar(scope, element, attrs);
        }
    };
}).directive("uibProgressbar", function() {
    return {
        replace: !0,
        transclude: !0,
        controller: "UibProgressController",
        scope: {
            value: "=",
            max: "=?",
            type: "@"
        },
        templateUrl: "template/progressbar/progressbar.html",
        link: function(scope, element, attrs, progressCtrl) {
            progressCtrl.addBar(scope, angular.element(element.children()[0]), {
                title: attrs.title
            });
        }
    };
}), angular.module("ui.bootstrap.progressbar").value("$progressSuppressWarning", !1).controller("ProgressController", [ "$scope", "$attrs", "uibProgressConfig", "$log", "$progressSuppressWarning", function($scope, $attrs, progressConfig, $log, $progressSuppressWarning) {
    $progressSuppressWarning || $log.warn("ProgressController is now deprecated. Use UibProgressController instead.");
    var self = this, animate = angular.isDefined($attrs.animate) ? $scope.$parent.$eval($attrs.animate) : progressConfig.animate;
    this.bars = [], $scope.max = angular.isDefined($scope.max) ? $scope.max : progressConfig.max, 
    this.addBar = function(bar, element, attrs) {
        animate || element.css({
            transition: "none"
        }), this.bars.push(bar), bar.max = $scope.max, bar.title = attrs && angular.isDefined(attrs.title) ? attrs.title : "progressbar", 
        bar.$watch("value", function() {
            bar.recalculatePercentage();
        }), bar.recalculatePercentage = function() {
            bar.percent = +(100 * bar.value / bar.max).toFixed(2);
            var totalPercentage = self.bars.reduce(function(total, bar) {
                return total + bar.percent;
            }, 0);
            totalPercentage > 100 && (bar.percent -= totalPercentage - 100);
        }, bar.$on("$destroy", function() {
            element = null, self.removeBar(bar);
        });
    }, this.removeBar = function(bar) {
        this.bars.splice(this.bars.indexOf(bar), 1);
    }, $scope.$watch("max", function() {
        self.bars.forEach(function(bar) {
            bar.max = $scope.max, bar.recalculatePercentage();
        });
    });
} ]).directive("progress", [ "$log", "$progressSuppressWarning", function($log, $progressSuppressWarning) {
    return {
        replace: !0,
        transclude: !0,
        controller: "ProgressController",
        require: "progress",
        scope: {
            max: "=?",
            title: "@?"
        },
        templateUrl: "template/progressbar/progress.html",
        link: function() {
            $progressSuppressWarning || $log.warn("progress is now deprecated. Use uib-progress instead.");
        }
    };
} ]).directive("bar", [ "$log", "$progressSuppressWarning", function($log, $progressSuppressWarning) {
    return {
        replace: !0,
        transclude: !0,
        require: "^progress",
        scope: {
            value: "=",
            type: "@"
        },
        templateUrl: "template/progressbar/bar.html",
        link: function(scope, element, attrs, progressCtrl) {
            $progressSuppressWarning || $log.warn("bar is now deprecated. Use uib-bar instead."), 
            progressCtrl.addBar(scope, element);
        }
    };
} ]).directive("progressbar", [ "$log", "$progressSuppressWarning", function($log, $progressSuppressWarning) {
    return {
        replace: !0,
        transclude: !0,
        controller: "ProgressController",
        scope: {
            value: "=",
            max: "=?",
            type: "@"
        },
        templateUrl: "template/progressbar/progressbar.html",
        link: function(scope, element, attrs, progressCtrl) {
            $progressSuppressWarning || $log.warn("progressbar is now deprecated. Use uib-progressbar instead."), 
            progressCtrl.addBar(scope, angular.element(element.children()[0]), {
                title: attrs.title
            });
        }
    };
} ]), angular.module("ui.bootstrap.rating", []).constant("uibRatingConfig", {
    max: 5,
    stateOn: null,
    stateOff: null,
    titles: [ "one", "two", "three", "four", "five" ]
}).controller("UibRatingController", [ "$scope", "$attrs", "uibRatingConfig", function($scope, $attrs, ratingConfig) {
    var ngModelCtrl = {
        $setViewValue: angular.noop
    };
    this.init = function(ngModelCtrl_) {
        ngModelCtrl = ngModelCtrl_, ngModelCtrl.$render = this.render, ngModelCtrl.$formatters.push(function(value) {
            return angular.isNumber(value) && value << 0 !== value && (value = Math.round(value)), 
            value;
        }), this.stateOn = angular.isDefined($attrs.stateOn) ? $scope.$parent.$eval($attrs.stateOn) : ratingConfig.stateOn, 
        this.stateOff = angular.isDefined($attrs.stateOff) ? $scope.$parent.$eval($attrs.stateOff) : ratingConfig.stateOff;
        var tmpTitles = angular.isDefined($attrs.titles) ? $scope.$parent.$eval($attrs.titles) : ratingConfig.titles;
        this.titles = angular.isArray(tmpTitles) && tmpTitles.length > 0 ? tmpTitles : ratingConfig.titles;
        var ratingStates = angular.isDefined($attrs.ratingStates) ? $scope.$parent.$eval($attrs.ratingStates) : new Array(angular.isDefined($attrs.max) ? $scope.$parent.$eval($attrs.max) : ratingConfig.max);
        $scope.range = this.buildTemplateObjects(ratingStates);
    }, this.buildTemplateObjects = function(states) {
        for (var i = 0, n = states.length; n > i; i++) states[i] = angular.extend({
            index: i
        }, {
            stateOn: this.stateOn,
            stateOff: this.stateOff,
            title: this.getTitle(i)
        }, states[i]);
        return states;
    }, this.getTitle = function(index) {
        return index >= this.titles.length ? index + 1 : this.titles[index];
    }, $scope.rate = function(value) {
        !$scope.readonly && value >= 0 && value <= $scope.range.length && (ngModelCtrl.$setViewValue(ngModelCtrl.$viewValue === value ? 0 : value), 
        ngModelCtrl.$render());
    }, $scope.enter = function(value) {
        $scope.readonly || ($scope.value = value), $scope.onHover({
            value: value
        });
    }, $scope.reset = function() {
        $scope.value = ngModelCtrl.$viewValue, $scope.onLeave();
    }, $scope.onKeydown = function(evt) {
        /(37|38|39|40)/.test(evt.which) && (evt.preventDefault(), evt.stopPropagation(), 
        $scope.rate($scope.value + (38 === evt.which || 39 === evt.which ? 1 : -1)));
    }, this.render = function() {
        $scope.value = ngModelCtrl.$viewValue;
    };
} ]).directive("uibRating", function() {
    return {
        require: [ "uibRating", "ngModel" ],
        scope: {
            readonly: "=?",
            onHover: "&",
            onLeave: "&"
        },
        controller: "UibRatingController",
        templateUrl: "template/rating/rating.html",
        replace: !0,
        link: function(scope, element, attrs, ctrls) {
            var ratingCtrl = ctrls[0], ngModelCtrl = ctrls[1];
            ratingCtrl.init(ngModelCtrl);
        }
    };
}), angular.module("ui.bootstrap.rating").value("$ratingSuppressWarning", !1).controller("RatingController", [ "$scope", "$attrs", "$controller", "$log", "$ratingSuppressWarning", function($scope, $attrs, $controller, $log, $ratingSuppressWarning) {
    $ratingSuppressWarning || $log.warn("RatingController is now deprecated. Use UibRatingController instead."), 
    angular.extend(this, $controller("UibRatingController", {
        $scope: $scope,
        $attrs: $attrs
    }));
} ]).directive("rating", [ "$log", "$ratingSuppressWarning", function($log, $ratingSuppressWarning) {
    return {
        require: [ "rating", "ngModel" ],
        scope: {
            readonly: "=?",
            onHover: "&",
            onLeave: "&"
        },
        controller: "RatingController",
        templateUrl: "template/rating/rating.html",
        replace: !0,
        link: function(scope, element, attrs, ctrls) {
            $ratingSuppressWarning || $log.warn("rating is now deprecated. Use uib-rating instead.");
            var ratingCtrl = ctrls[0], ngModelCtrl = ctrls[1];
            ratingCtrl.init(ngModelCtrl);
        }
    };
} ]), angular.module("ui.bootstrap.tabs", []).controller("UibTabsetController", [ "$scope", function($scope) {
    var ctrl = this, tabs = ctrl.tabs = $scope.tabs = [];
    ctrl.select = function(selectedTab) {
        angular.forEach(tabs, function(tab) {
            tab.active && tab !== selectedTab && (tab.active = !1, tab.onDeselect(), selectedTab.selectCalled = !1);
        }), selectedTab.active = !0, selectedTab.selectCalled || (selectedTab.onSelect(), 
        selectedTab.selectCalled = !0);
    }, ctrl.addTab = function(tab) {
        tabs.push(tab), 1 === tabs.length && tab.active !== !1 ? tab.active = !0 : tab.active ? ctrl.select(tab) : tab.active = !1;
    }, ctrl.removeTab = function(tab) {
        var index = tabs.indexOf(tab);
        if (tab.active && tabs.length > 1 && !destroyed) {
            var newActiveIndex = index == tabs.length - 1 ? index - 1 : index + 1;
            ctrl.select(tabs[newActiveIndex]);
        }
        tabs.splice(index, 1);
    };
    var destroyed;
    $scope.$on("$destroy", function() {
        destroyed = !0;
    });
} ]).directive("uibTabset", function() {
    return {
        restrict: "EA",
        transclude: !0,
        replace: !0,
        scope: {
            type: "@"
        },
        controller: "UibTabsetController",
        templateUrl: "template/tabs/tabset.html",
        link: function(scope, element, attrs) {
            scope.vertical = angular.isDefined(attrs.vertical) ? scope.$parent.$eval(attrs.vertical) : !1, 
            scope.justified = angular.isDefined(attrs.justified) ? scope.$parent.$eval(attrs.justified) : !1;
        }
    };
}).directive("uibTab", [ "$parse", function($parse) {
    return {
        require: "^uibTabset",
        restrict: "EA",
        replace: !0,
        templateUrl: "template/tabs/tab.html",
        transclude: !0,
        scope: {
            active: "=?",
            heading: "@",
            onSelect: "&select",
            onDeselect: "&deselect"
        },
        controller: function() {},
        link: function(scope, elm, attrs, tabsetCtrl, transclude) {
            scope.$watch("active", function(active) {
                active && tabsetCtrl.select(scope);
            }), scope.disabled = !1, attrs.disable && scope.$parent.$watch($parse(attrs.disable), function(value) {
                scope.disabled = !!value;
            }), scope.select = function() {
                scope.disabled || (scope.active = !0);
            }, tabsetCtrl.addTab(scope), scope.$on("$destroy", function() {
                tabsetCtrl.removeTab(scope);
            }), scope.$transcludeFn = transclude;
        }
    };
} ]).directive("uibTabHeadingTransclude", function() {
    return {
        restrict: "A",
        require: [ "?^uibTab", "?^tab" ],
        link: function(scope, elm) {
            scope.$watch("headingElement", function(heading) {
                heading && (elm.html(""), elm.append(heading));
            });
        }
    };
}).directive("uibTabContentTransclude", function() {
    function isTabHeading(node) {
        return node.tagName && (node.hasAttribute("tab-heading") || node.hasAttribute("data-tab-heading") || node.hasAttribute("x-tab-heading") || node.hasAttribute("uib-tab-heading") || node.hasAttribute("data-uib-tab-heading") || node.hasAttribute("x-uib-tab-heading") || "tab-heading" === node.tagName.toLowerCase() || "data-tab-heading" === node.tagName.toLowerCase() || "x-tab-heading" === node.tagName.toLowerCase() || "uib-tab-heading" === node.tagName.toLowerCase() || "data-uib-tab-heading" === node.tagName.toLowerCase() || "x-uib-tab-heading" === node.tagName.toLowerCase());
    }
    return {
        restrict: "A",
        require: [ "?^uibTabset", "?^tabset" ],
        link: function(scope, elm, attrs) {
            var tab = scope.$eval(attrs.uibTabContentTransclude);
            tab.$transcludeFn(tab.$parent, function(contents) {
                angular.forEach(contents, function(node) {
                    isTabHeading(node) ? tab.headingElement = node : elm.append(node);
                });
            });
        }
    };
}), angular.module("ui.bootstrap.tabs").value("$tabsSuppressWarning", !1).controller("TabsetController", [ "$scope", "$controller", "$log", "$tabsSuppressWarning", function($scope, $controller, $log, $tabsSuppressWarning) {
    $tabsSuppressWarning || $log.warn("TabsetController is now deprecated. Use UibTabsetController instead."), 
    angular.extend(this, $controller("UibTabsetController", {
        $scope: $scope
    }));
} ]).directive("tabset", [ "$log", "$tabsSuppressWarning", function($log, $tabsSuppressWarning) {
    return {
        restrict: "EA",
        transclude: !0,
        replace: !0,
        scope: {
            type: "@"
        },
        controller: "TabsetController",
        templateUrl: "template/tabs/tabset.html",
        link: function(scope, element, attrs) {
            $tabsSuppressWarning || $log.warn("tabset is now deprecated. Use uib-tabset instead."), 
            scope.vertical = angular.isDefined(attrs.vertical) ? scope.$parent.$eval(attrs.vertical) : !1, 
            scope.justified = angular.isDefined(attrs.justified) ? scope.$parent.$eval(attrs.justified) : !1;
        }
    };
} ]).directive("tab", [ "$parse", "$log", "$tabsSuppressWarning", function($parse, $log, $tabsSuppressWarning) {
    return {
        require: "^tabset",
        restrict: "EA",
        replace: !0,
        templateUrl: "template/tabs/tab.html",
        transclude: !0,
        scope: {
            active: "=?",
            heading: "@",
            onSelect: "&select",
            onDeselect: "&deselect"
        },
        controller: function() {},
        link: function(scope, elm, attrs, tabsetCtrl, transclude) {
            $tabsSuppressWarning || $log.warn("tab is now deprecated. Use uib-tab instead."), 
            scope.$watch("active", function(active) {
                active && tabsetCtrl.select(scope);
            }), scope.disabled = !1, attrs.disable && scope.$parent.$watch($parse(attrs.disable), function(value) {
                scope.disabled = !!value;
            }), scope.select = function() {
                scope.disabled || (scope.active = !0);
            }, tabsetCtrl.addTab(scope), scope.$on("$destroy", function() {
                tabsetCtrl.removeTab(scope);
            }), scope.$transcludeFn = transclude;
        }
    };
} ]).directive("tabHeadingTransclude", [ "$log", "$tabsSuppressWarning", function($log, $tabsSuppressWarning) {
    return {
        restrict: "A",
        require: "^tab",
        link: function(scope, elm) {
            $tabsSuppressWarning || $log.warn("tab-heading-transclude is now deprecated. Use uib-tab-heading-transclude instead."), 
            scope.$watch("headingElement", function(heading) {
                heading && (elm.html(""), elm.append(heading));
            });
        }
    };
} ]).directive("tabContentTransclude", [ "$log", "$tabsSuppressWarning", function($log, $tabsSuppressWarning) {
    function isTabHeading(node) {
        return node.tagName && (node.hasAttribute("tab-heading") || node.hasAttribute("data-tab-heading") || node.hasAttribute("x-tab-heading") || "tab-heading" === node.tagName.toLowerCase() || "data-tab-heading" === node.tagName.toLowerCase() || "x-tab-heading" === node.tagName.toLowerCase());
    }
    return {
        restrict: "A",
        require: "^tabset",
        link: function(scope, elm, attrs) {
            $tabsSuppressWarning || $log.warn("tab-content-transclude is now deprecated. Use uib-tab-content-transclude instead.");
            var tab = scope.$eval(attrs.tabContentTransclude);
            tab.$transcludeFn(tab.$parent, function(contents) {
                angular.forEach(contents, function(node) {
                    isTabHeading(node) ? tab.headingElement = node : elm.append(node);
                });
            });
        }
    };
} ]), angular.module("ui.bootstrap.timepicker", []).constant("uibTimepickerConfig", {
    hourStep: 1,
    minuteStep: 1,
    showMeridian: !0,
    meridians: null,
    readonlyInput: !1,
    mousewheel: !0,
    arrowkeys: !0,
    showSpinners: !0
}).controller("UibTimepickerController", [ "$scope", "$element", "$attrs", "$parse", "$log", "$locale", "uibTimepickerConfig", function($scope, $element, $attrs, $parse, $log, $locale, timepickerConfig) {
    function getHoursFromTemplate() {
        var hours = parseInt($scope.hours, 10), valid = $scope.showMeridian ? hours > 0 && 13 > hours : hours >= 0 && 24 > hours;
        return valid ? ($scope.showMeridian && (12 === hours && (hours = 0), $scope.meridian === meridians[1] && (hours += 12)), 
        hours) : void 0;
    }
    function getMinutesFromTemplate() {
        var minutes = parseInt($scope.minutes, 10);
        return minutes >= 0 && 60 > minutes ? minutes : void 0;
    }
    function pad(value) {
        return angular.isDefined(value) && value.toString().length < 2 ? "0" + value : value.toString();
    }
    function refresh(keyboardChange) {
        makeValid(), ngModelCtrl.$setViewValue(new Date(selected)), updateTemplate(keyboardChange);
    }
    function makeValid() {
        ngModelCtrl.$setValidity("time", !0), $scope.invalidHours = !1, $scope.invalidMinutes = !1;
    }
    function updateTemplate(keyboardChange) {
        var hours = selected.getHours(), minutes = selected.getMinutes();
        $scope.showMeridian && (hours = 0 === hours || 12 === hours ? 12 : hours % 12), 
        $scope.hours = "h" === keyboardChange ? hours : pad(hours), "m" !== keyboardChange && ($scope.minutes = pad(minutes)), 
        $scope.meridian = selected.getHours() < 12 ? meridians[0] : meridians[1];
    }
    function addMinutes(date, minutes) {
        var dt = new Date(date.getTime() + 6e4 * minutes), newDate = new Date(date);
        return newDate.setHours(dt.getHours(), dt.getMinutes()), newDate;
    }
    function addMinutesToSelected(minutes) {
        selected = addMinutes(selected, minutes), refresh();
    }
    var selected = new Date(), ngModelCtrl = {
        $setViewValue: angular.noop
    }, meridians = angular.isDefined($attrs.meridians) ? $scope.$parent.$eval($attrs.meridians) : timepickerConfig.meridians || $locale.DATETIME_FORMATS.AMPMS;
    $scope.tabindex = angular.isDefined($attrs.tabindex) ? $attrs.tabindex : 0, $element.removeAttr("tabindex"), 
    this.init = function(ngModelCtrl_, inputs) {
        ngModelCtrl = ngModelCtrl_, ngModelCtrl.$render = this.render, ngModelCtrl.$formatters.unshift(function(modelValue) {
            return modelValue ? new Date(modelValue) : null;
        });
        var hoursInputEl = inputs.eq(0), minutesInputEl = inputs.eq(1), mousewheel = angular.isDefined($attrs.mousewheel) ? $scope.$parent.$eval($attrs.mousewheel) : timepickerConfig.mousewheel;
        mousewheel && this.setupMousewheelEvents(hoursInputEl, minutesInputEl);
        var arrowkeys = angular.isDefined($attrs.arrowkeys) ? $scope.$parent.$eval($attrs.arrowkeys) : timepickerConfig.arrowkeys;
        arrowkeys && this.setupArrowkeyEvents(hoursInputEl, minutesInputEl), $scope.readonlyInput = angular.isDefined($attrs.readonlyInput) ? $scope.$parent.$eval($attrs.readonlyInput) : timepickerConfig.readonlyInput, 
        this.setupInputEvents(hoursInputEl, minutesInputEl);
    };
    var hourStep = timepickerConfig.hourStep;
    $attrs.hourStep && $scope.$parent.$watch($parse($attrs.hourStep), function(value) {
        hourStep = parseInt(value, 10);
    });
    var minuteStep = timepickerConfig.minuteStep;
    $attrs.minuteStep && $scope.$parent.$watch($parse($attrs.minuteStep), function(value) {
        minuteStep = parseInt(value, 10);
    });
    var min;
    $scope.$parent.$watch($parse($attrs.min), function(value) {
        var dt = new Date(value);
        min = isNaN(dt) ? void 0 : dt;
    });
    var max;
    $scope.$parent.$watch($parse($attrs.max), function(value) {
        var dt = new Date(value);
        max = isNaN(dt) ? void 0 : dt;
    }), $scope.noIncrementHours = function() {
        var incrementedSelected = addMinutes(selected, 60 * hourStep);
        return incrementedSelected > max || selected > incrementedSelected && min > incrementedSelected;
    }, $scope.noDecrementHours = function() {
        var decrementedSelected = addMinutes(selected, 60 * -hourStep);
        return min > decrementedSelected || decrementedSelected > selected && decrementedSelected > max;
    }, $scope.noIncrementMinutes = function() {
        var incrementedSelected = addMinutes(selected, minuteStep);
        return incrementedSelected > max || selected > incrementedSelected && min > incrementedSelected;
    }, $scope.noDecrementMinutes = function() {
        var decrementedSelected = addMinutes(selected, -minuteStep);
        return min > decrementedSelected || decrementedSelected > selected && decrementedSelected > max;
    }, $scope.noToggleMeridian = function() {
        return selected.getHours() < 13 ? addMinutes(selected, 720) > max : addMinutes(selected, -720) < min;
    }, $scope.showMeridian = timepickerConfig.showMeridian, $attrs.showMeridian && $scope.$parent.$watch($parse($attrs.showMeridian), function(value) {
        if ($scope.showMeridian = !!value, ngModelCtrl.$error.time) {
            var hours = getHoursFromTemplate(), minutes = getMinutesFromTemplate();
            angular.isDefined(hours) && angular.isDefined(minutes) && (selected.setHours(hours), 
            refresh());
        } else updateTemplate();
    }), this.setupMousewheelEvents = function(hoursInputEl, minutesInputEl) {
        var isScrollingUp = function(e) {
            e.originalEvent && (e = e.originalEvent);
            var delta = e.wheelDelta ? e.wheelDelta : -e.deltaY;
            return e.detail || delta > 0;
        };
        hoursInputEl.bind("mousewheel wheel", function(e) {
            $scope.$apply(isScrollingUp(e) ? $scope.incrementHours() : $scope.decrementHours()), 
            e.preventDefault();
        }), minutesInputEl.bind("mousewheel wheel", function(e) {
            $scope.$apply(isScrollingUp(e) ? $scope.incrementMinutes() : $scope.decrementMinutes()), 
            e.preventDefault();
        });
    }, this.setupArrowkeyEvents = function(hoursInputEl, minutesInputEl) {
        hoursInputEl.bind("keydown", function(e) {
            38 === e.which ? (e.preventDefault(), $scope.incrementHours(), $scope.$apply()) : 40 === e.which && (e.preventDefault(), 
            $scope.decrementHours(), $scope.$apply());
        }), minutesInputEl.bind("keydown", function(e) {
            38 === e.which ? (e.preventDefault(), $scope.incrementMinutes(), $scope.$apply()) : 40 === e.which && (e.preventDefault(), 
            $scope.decrementMinutes(), $scope.$apply());
        });
    }, this.setupInputEvents = function(hoursInputEl, minutesInputEl) {
        if ($scope.readonlyInput) return $scope.updateHours = angular.noop, void ($scope.updateMinutes = angular.noop);
        var invalidate = function(invalidHours, invalidMinutes) {
            ngModelCtrl.$setViewValue(null), ngModelCtrl.$setValidity("time", !1), angular.isDefined(invalidHours) && ($scope.invalidHours = invalidHours), 
            angular.isDefined(invalidMinutes) && ($scope.invalidMinutes = invalidMinutes);
        };
        $scope.updateHours = function() {
            var hours = getHoursFromTemplate(), minutes = getMinutesFromTemplate();
            angular.isDefined(hours) && angular.isDefined(minutes) ? (selected.setHours(hours), 
            min > selected || selected > max ? invalidate(!0) : refresh("h")) : invalidate(!0);
        }, hoursInputEl.bind("blur", function() {
            !$scope.invalidHours && $scope.hours < 10 && $scope.$apply(function() {
                $scope.hours = pad($scope.hours);
            });
        }), $scope.updateMinutes = function() {
            var minutes = getMinutesFromTemplate(), hours = getHoursFromTemplate();
            angular.isDefined(minutes) && angular.isDefined(hours) ? (selected.setMinutes(minutes), 
            min > selected || selected > max ? invalidate(void 0, !0) : refresh("m")) : invalidate(void 0, !0);
        }, minutesInputEl.bind("blur", function() {
            !$scope.invalidMinutes && $scope.minutes < 10 && $scope.$apply(function() {
                $scope.minutes = pad($scope.minutes);
            });
        });
    }, this.render = function() {
        var date = ngModelCtrl.$viewValue;
        isNaN(date) ? (ngModelCtrl.$setValidity("time", !1), $log.error('Timepicker directive: "ng-model" value must be a Date object, a number of milliseconds since 01.01.1970 or a string representing an RFC2822 or ISO 8601 date.')) : (date && (selected = date), 
        min > selected || selected > max ? (ngModelCtrl.$setValidity("time", !1), $scope.invalidHours = !0, 
        $scope.invalidMinutes = !0) : makeValid(), updateTemplate());
    }, $scope.showSpinners = angular.isDefined($attrs.showSpinners) ? $scope.$parent.$eval($attrs.showSpinners) : timepickerConfig.showSpinners, 
    $scope.incrementHours = function() {
        $scope.noIncrementHours() || addMinutesToSelected(60 * hourStep);
    }, $scope.decrementHours = function() {
        $scope.noDecrementHours() || addMinutesToSelected(60 * -hourStep);
    }, $scope.incrementMinutes = function() {
        $scope.noIncrementMinutes() || addMinutesToSelected(minuteStep);
    }, $scope.decrementMinutes = function() {
        $scope.noDecrementMinutes() || addMinutesToSelected(-minuteStep);
    }, $scope.toggleMeridian = function() {
        $scope.noToggleMeridian() || addMinutesToSelected(720 * (selected.getHours() < 12 ? 1 : -1));
    };
} ]).directive("uibTimepicker", function() {
    return {
        restrict: "EA",
        require: [ "uibTimepicker", "?^ngModel" ],
        controller: "UibTimepickerController",
        controllerAs: "timepicker",
        replace: !0,
        scope: {},
        templateUrl: function(element, attrs) {
            return attrs.templateUrl || "template/timepicker/timepicker.html";
        },
        link: function(scope, element, attrs, ctrls) {
            var timepickerCtrl = ctrls[0], ngModelCtrl = ctrls[1];
            ngModelCtrl && timepickerCtrl.init(ngModelCtrl, element.find("input"));
        }
    };
}), angular.module("ui.bootstrap.timepicker").value("$timepickerSuppressWarning", !1).controller("TimepickerController", [ "$scope", "$element", "$attrs", "$controller", "$log", "$timepickerSuppressWarning", function($scope, $element, $attrs, $controller, $log, $timepickerSuppressWarning) {
    $timepickerSuppressWarning || $log.warn("TimepickerController is now deprecated. Use UibTimepickerController instead."), 
    angular.extend(this, $controller("UibTimepickerController", {
        $scope: $scope,
        $element: $element,
        $attrs: $attrs
    }));
} ]).directive("timepicker", [ "$log", "$timepickerSuppressWarning", function($log, $timepickerSuppressWarning) {
    return {
        restrict: "EA",
        require: [ "timepicker", "?^ngModel" ],
        controller: "TimepickerController",
        controllerAs: "timepicker",
        replace: !0,
        scope: {},
        templateUrl: function(element, attrs) {
            return attrs.templateUrl || "template/timepicker/timepicker.html";
        },
        link: function(scope, element, attrs, ctrls) {
            $timepickerSuppressWarning || $log.warn("timepicker is now deprecated. Use uib-timepicker instead.");
            var timepickerCtrl = ctrls[0], ngModelCtrl = ctrls[1];
            ngModelCtrl && timepickerCtrl.init(ngModelCtrl, element.find("input"));
        }
    };
} ]), angular.module("ui.bootstrap.typeahead", [ "ui.bootstrap.position" ]).factory("uibTypeaheadParser", [ "$parse", function($parse) {
    var TYPEAHEAD_REGEXP = /^\s*([\s\S]+?)(?:\s+as\s+([\s\S]+?))?\s+for\s+(?:([\$\w][\$\w\d]*))\s+in\s+([\s\S]+?)$/;
    return {
        parse: function(input) {
            var match = input.match(TYPEAHEAD_REGEXP);
            if (!match) throw new Error('Expected typeahead specification in form of "_modelValue_ (as _label_)? for _item_ in _collection_" but got "' + input + '".');
            return {
                itemName: match[3],
                source: $parse(match[4]),
                viewMapper: $parse(match[2] || match[1]),
                modelMapper: $parse(match[1])
            };
        }
    };
} ]).controller("UibTypeaheadController", [ "$scope", "$element", "$attrs", "$compile", "$parse", "$q", "$timeout", "$document", "$window", "$rootScope", "$uibPosition", "uibTypeaheadParser", function(originalScope, element, attrs, $compile, $parse, $q, $timeout, $document, $window, $rootScope, $position, typeaheadParser) {
    function fireRecalculating() {
        scope.moveInProgress || (scope.moveInProgress = !0, scope.$digest()), timeoutEventPromise && $timeout.cancel(timeoutEventPromise), 
        timeoutEventPromise = $timeout(function() {
            scope.matches.length && recalculatePosition(), scope.moveInProgress = !1;
        }, eventDebounceTime);
    }
    function recalculatePosition() {
        scope.position = appendToBody ? $position.offset(element) : $position.position(element), 
        scope.position.top += element.prop("offsetHeight");
    }
    var modelCtrl, ngModelOptions, HOT_KEYS = [ 9, 13, 27, 38, 40 ], eventDebounceTime = 200, minLength = originalScope.$eval(attrs.typeaheadMinLength);
    minLength || 0 === minLength || (minLength = 1);
    var hasFocus, selected, waitTime = originalScope.$eval(attrs.typeaheadWaitMs) || 0, isEditable = originalScope.$eval(attrs.typeaheadEditable) !== !1, isLoadingSetter = $parse(attrs.typeaheadLoading).assign || angular.noop, onSelectCallback = $parse(attrs.typeaheadOnSelect), isSelectOnBlur = angular.isDefined(attrs.typeaheadSelectOnBlur) ? originalScope.$eval(attrs.typeaheadSelectOnBlur) : !1, isNoResultsSetter = $parse(attrs.typeaheadNoResults).assign || angular.noop, inputFormatter = attrs.typeaheadInputFormatter ? $parse(attrs.typeaheadInputFormatter) : void 0, appendToBody = attrs.typeaheadAppendToBody ? originalScope.$eval(attrs.typeaheadAppendToBody) : !1, appendToElementId = attrs.typeaheadAppendToElementId || !1, focusFirst = originalScope.$eval(attrs.typeaheadFocusFirst) !== !1, selectOnExact = attrs.typeaheadSelectOnExact ? originalScope.$eval(attrs.typeaheadSelectOnExact) : !1, parsedModel = $parse(attrs.ngModel), invokeModelSetter = $parse(attrs.ngModel + "($$$p)"), $setModelValue = function(scope, newValue) {
        return angular.isFunction(parsedModel(originalScope)) && ngModelOptions && ngModelOptions.$options && ngModelOptions.$options.getterSetter ? invokeModelSetter(scope, {
            $$$p: newValue
        }) : parsedModel.assign(scope, newValue);
    }, parserResult = typeaheadParser.parse(attrs.uibTypeahead), scope = originalScope.$new(), offDestroy = originalScope.$on("$destroy", function() {
        scope.$destroy();
    });
    scope.$on("$destroy", offDestroy);
    var popupId = "typeahead-" + scope.$id + "-" + Math.floor(1e4 * Math.random());
    element.attr({
        "aria-autocomplete": "list",
        "aria-expanded": !1,
        "aria-owns": popupId
    });
    var popUpEl = angular.element("<div uib-typeahead-popup></div>");
    popUpEl.attr({
        id: popupId,
        matches: "matches",
        active: "activeIdx",
        select: "select(activeIdx)",
        "move-in-progress": "moveInProgress",
        query: "query",
        position: "position"
    }), angular.isDefined(attrs.typeaheadTemplateUrl) && popUpEl.attr("template-url", attrs.typeaheadTemplateUrl), 
    angular.isDefined(attrs.typeaheadPopupTemplateUrl) && popUpEl.attr("popup-template-url", attrs.typeaheadPopupTemplateUrl);
    var resetMatches = function() {
        scope.matches = [], scope.activeIdx = -1, element.attr("aria-expanded", !1);
    }, getMatchId = function(index) {
        return popupId + "-option-" + index;
    };
    scope.$watch("activeIdx", function(index) {
        0 > index ? element.removeAttr("aria-activedescendant") : element.attr("aria-activedescendant", getMatchId(index));
    });
    var inputIsExactMatch = function(inputValue, index) {
        return scope.matches.length > index && inputValue ? inputValue.toUpperCase() === scope.matches[index].label.toUpperCase() : !1;
    }, getMatchesAsync = function(inputValue) {
        var locals = {
            $viewValue: inputValue
        };
        isLoadingSetter(originalScope, !0), isNoResultsSetter(originalScope, !1), $q.when(parserResult.source(originalScope, locals)).then(function(matches) {
            var onCurrentRequest = inputValue === modelCtrl.$viewValue;
            if (onCurrentRequest && hasFocus) if (matches && matches.length > 0) {
                scope.activeIdx = focusFirst ? 0 : -1, isNoResultsSetter(originalScope, !1), scope.matches.length = 0;
                for (var i = 0; i < matches.length; i++) locals[parserResult.itemName] = matches[i], 
                scope.matches.push({
                    id: getMatchId(i),
                    label: parserResult.viewMapper(scope, locals),
                    model: matches[i]
                });
                scope.query = inputValue, recalculatePosition(), element.attr("aria-expanded", !0), 
                selectOnExact && 1 === scope.matches.length && inputIsExactMatch(inputValue, 0) && scope.select(0);
            } else resetMatches(), isNoResultsSetter(originalScope, !0);
            onCurrentRequest && isLoadingSetter(originalScope, !1);
        }, function() {
            resetMatches(), isLoadingSetter(originalScope, !1), isNoResultsSetter(originalScope, !0);
        });
    };
    appendToBody && (angular.element($window).bind("resize", fireRecalculating), $document.find("body").bind("scroll", fireRecalculating));
    var timeoutEventPromise;
    scope.moveInProgress = !1, scope.query = void 0;
    var timeoutPromise, scheduleSearchWithTimeout = function(inputValue) {
        timeoutPromise = $timeout(function() {
            getMatchesAsync(inputValue);
        }, waitTime);
    }, cancelPreviousTimeout = function() {
        timeoutPromise && $timeout.cancel(timeoutPromise);
    };
    resetMatches(), scope.select = function(activeIdx) {
        var model, item, locals = {};
        selected = !0, locals[parserResult.itemName] = item = scope.matches[activeIdx].model, 
        model = parserResult.modelMapper(originalScope, locals), $setModelValue(originalScope, model), 
        modelCtrl.$setValidity("editable", !0), modelCtrl.$setValidity("parse", !0), onSelectCallback(originalScope, {
            $item: item,
            $model: model,
            $label: parserResult.viewMapper(originalScope, locals)
        }), resetMatches(), scope.$eval(attrs.typeaheadFocusOnSelect) !== !1 && $timeout(function() {
            element[0].focus();
        }, 0, !1);
    }, element.bind("keydown", function(evt) {
        if (0 !== scope.matches.length && -1 !== HOT_KEYS.indexOf(evt.which)) {
            if (-1 === scope.activeIdx && (9 === evt.which || 13 === evt.which)) return resetMatches(), 
            void scope.$digest();
            evt.preventDefault(), 40 === evt.which ? (scope.activeIdx = (scope.activeIdx + 1) % scope.matches.length, 
            scope.$digest()) : 38 === evt.which ? (scope.activeIdx = (scope.activeIdx > 0 ? scope.activeIdx : scope.matches.length) - 1, 
            scope.$digest()) : 13 === evt.which || 9 === evt.which ? scope.$apply(function() {
                scope.select(scope.activeIdx);
            }) : 27 === evt.which && (evt.stopPropagation(), resetMatches(), scope.$digest());
        }
    }), element.bind("blur", function() {
        isSelectOnBlur && scope.matches.length && -1 !== scope.activeIdx && !selected && (selected = !0, 
        scope.$apply(function() {
            scope.select(scope.activeIdx);
        })), hasFocus = !1, selected = !1;
    });
    var dismissClickHandler = function(evt) {
        element[0] !== evt.target && 3 !== evt.which && 0 !== scope.matches.length && (resetMatches(), 
        $rootScope.$$phase || scope.$digest());
    };
    $document.bind("click", dismissClickHandler), originalScope.$on("$destroy", function() {
        $document.unbind("click", dismissClickHandler), (appendToBody || appendToElementId) && $popup.remove(), 
        appendToBody && (angular.element($window).unbind("resize", fireRecalculating), $document.find("body").unbind("scroll", fireRecalculating)), 
        popUpEl.remove();
    });
    var $popup = $compile(popUpEl)(scope);
    appendToBody ? $document.find("body").append($popup) : appendToElementId !== !1 ? angular.element($document[0].getElementById(appendToElementId)).append($popup) : element.after($popup), 
    this.init = function(_modelCtrl, _ngModelOptions) {
        modelCtrl = _modelCtrl, ngModelOptions = _ngModelOptions, modelCtrl.$parsers.unshift(function(inputValue) {
            return hasFocus = !0, 0 === minLength || inputValue && inputValue.length >= minLength ? waitTime > 0 ? (cancelPreviousTimeout(), 
            scheduleSearchWithTimeout(inputValue)) : getMatchesAsync(inputValue) : (isLoadingSetter(originalScope, !1), 
            cancelPreviousTimeout(), resetMatches()), isEditable ? inputValue : inputValue ? void modelCtrl.$setValidity("editable", !1) : (modelCtrl.$setValidity("editable", !0), 
            null);
        }), modelCtrl.$formatters.push(function(modelValue) {
            var candidateViewValue, emptyViewValue, locals = {};
            return isEditable || modelCtrl.$setValidity("editable", !0), inputFormatter ? (locals.$model = modelValue, 
            inputFormatter(originalScope, locals)) : (locals[parserResult.itemName] = modelValue, 
            candidateViewValue = parserResult.viewMapper(originalScope, locals), locals[parserResult.itemName] = void 0, 
            emptyViewValue = parserResult.viewMapper(originalScope, locals), candidateViewValue !== emptyViewValue ? candidateViewValue : modelValue);
        });
    };
} ]).directive("uibTypeahead", function() {
    return {
        controller: "UibTypeaheadController",
        require: [ "ngModel", "^?ngModelOptions", "uibTypeahead" ],
        link: function(originalScope, element, attrs, ctrls) {
            ctrls[2].init(ctrls[0], ctrls[1]);
        }
    };
}).directive("uibTypeaheadPopup", function() {
    return {
        scope: {
            matches: "=",
            query: "=",
            active: "=",
            position: "&",
            moveInProgress: "=",
            select: "&"
        },
        replace: !0,
        templateUrl: function(element, attrs) {
            return attrs.popupTemplateUrl || "template/typeahead/typeahead-popup.html";
        },
        link: function(scope, element, attrs) {
            scope.templateUrl = attrs.templateUrl, scope.isOpen = function() {
                return scope.matches.length > 0;
            }, scope.isActive = function(matchIdx) {
                return scope.active == matchIdx;
            }, scope.selectActive = function(matchIdx) {
                scope.active = matchIdx;
            }, scope.selectMatch = function(activeIdx) {
                scope.select({
                    activeIdx: activeIdx
                });
            };
        }
    };
}).directive("uibTypeaheadMatch", [ "$templateRequest", "$compile", "$parse", function($templateRequest, $compile, $parse) {
    return {
        scope: {
            index: "=",
            match: "=",
            query: "="
        },
        link: function(scope, element, attrs) {
            var tplUrl = $parse(attrs.templateUrl)(scope.$parent) || "template/typeahead/typeahead-match.html";
            $templateRequest(tplUrl).then(function(tplContent) {
                $compile(tplContent.trim())(scope, function(clonedElement) {
                    element.replaceWith(clonedElement);
                });
            });
        }
    };
} ]).filter("uibTypeaheadHighlight", [ "$sce", "$injector", "$log", function($sce, $injector, $log) {
    function escapeRegexp(queryToEscape) {
        return queryToEscape.replace(/([.?*+^$[\]\\(){}|-])/g, "\\$1");
    }
    function containsHtml(matchItem) {
        return /<.*>/g.test(matchItem);
    }
    var isSanitizePresent;
    return isSanitizePresent = $injector.has("$sanitize"), function(matchItem, query) {
        return !isSanitizePresent && containsHtml(matchItem) && $log.warn("Unsafe use of typeahead please use ngSanitize"), 
        matchItem = query ? ("" + matchItem).replace(new RegExp(escapeRegexp(query), "gi"), "<strong>$&</strong>") : matchItem, 
        isSanitizePresent || (matchItem = $sce.trustAsHtml(matchItem)), matchItem;
    };
} ]), angular.module("ui.bootstrap.typeahead").value("$typeaheadSuppressWarning", !1).service("typeaheadParser", [ "$parse", "uibTypeaheadParser", "$log", "$typeaheadSuppressWarning", function($parse, uibTypeaheadParser, $log, $typeaheadSuppressWarning) {
    return $typeaheadSuppressWarning || $log.warn("typeaheadParser is now deprecated. Use uibTypeaheadParser instead."), 
    uibTypeaheadParser;
} ]).directive("typeahead", [ "$compile", "$parse", "$q", "$timeout", "$document", "$window", "$rootScope", "$uibPosition", "typeaheadParser", "$log", "$typeaheadSuppressWarning", function($compile, $parse, $q, $timeout, $document, $window, $rootScope, $position, typeaheadParser, $log, $typeaheadSuppressWarning) {
    var HOT_KEYS = [ 9, 13, 27, 38, 40 ], eventDebounceTime = 200;
    return {
        require: [ "ngModel", "^?ngModelOptions" ],
        link: function(originalScope, element, attrs, ctrls) {
            function fireRecalculating() {
                scope.moveInProgress || (scope.moveInProgress = !0, scope.$digest()), timeoutEventPromise && $timeout.cancel(timeoutEventPromise), 
                timeoutEventPromise = $timeout(function() {
                    scope.matches.length && recalculatePosition(), scope.moveInProgress = !1;
                }, eventDebounceTime);
            }
            function recalculatePosition() {
                scope.position = appendToBody ? $position.offset(element) : $position.position(element), 
                scope.position.top += element.prop("offsetHeight");
            }
            $typeaheadSuppressWarning || $log.warn("typeahead is now deprecated. Use uib-typeahead instead.");
            var modelCtrl = ctrls[0], ngModelOptions = ctrls[1], minLength = originalScope.$eval(attrs.typeaheadMinLength);
            minLength || 0 === minLength || (minLength = 1);
            var hasFocus, selected, waitTime = originalScope.$eval(attrs.typeaheadWaitMs) || 0, isEditable = originalScope.$eval(attrs.typeaheadEditable) !== !1, isLoadingSetter = $parse(attrs.typeaheadLoading).assign || angular.noop, onSelectCallback = $parse(attrs.typeaheadOnSelect), isSelectOnBlur = angular.isDefined(attrs.typeaheadSelectOnBlur) ? originalScope.$eval(attrs.typeaheadSelectOnBlur) : !1, isNoResultsSetter = $parse(attrs.typeaheadNoResults).assign || angular.noop, inputFormatter = attrs.typeaheadInputFormatter ? $parse(attrs.typeaheadInputFormatter) : void 0, appendToBody = attrs.typeaheadAppendToBody ? originalScope.$eval(attrs.typeaheadAppendToBody) : !1, appendToElementId = attrs.typeaheadAppendToElementId || !1, focusFirst = originalScope.$eval(attrs.typeaheadFocusFirst) !== !1, selectOnExact = attrs.typeaheadSelectOnExact ? originalScope.$eval(attrs.typeaheadSelectOnExact) : !1, parsedModel = $parse(attrs.ngModel), invokeModelSetter = $parse(attrs.ngModel + "($$$p)"), $setModelValue = function(scope, newValue) {
                return angular.isFunction(parsedModel(originalScope)) && ngModelOptions && ngModelOptions.$options && ngModelOptions.$options.getterSetter ? invokeModelSetter(scope, {
                    $$$p: newValue
                }) : parsedModel.assign(scope, newValue);
            }, parserResult = typeaheadParser.parse(attrs.typeahead), scope = originalScope.$new(), offDestroy = originalScope.$on("$destroy", function() {
                scope.$destroy();
            });
            scope.$on("$destroy", offDestroy);
            var popupId = "typeahead-" + scope.$id + "-" + Math.floor(1e4 * Math.random());
            element.attr({
                "aria-autocomplete": "list",
                "aria-expanded": !1,
                "aria-owns": popupId
            });
            var popUpEl = angular.element("<div typeahead-popup></div>");
            popUpEl.attr({
                id: popupId,
                matches: "matches",
                active: "activeIdx",
                select: "select(activeIdx)",
                "move-in-progress": "moveInProgress",
                query: "query",
                position: "position"
            }), angular.isDefined(attrs.typeaheadTemplateUrl) && popUpEl.attr("template-url", attrs.typeaheadTemplateUrl), 
            angular.isDefined(attrs.typeaheadPopupTemplateUrl) && popUpEl.attr("popup-template-url", attrs.typeaheadPopupTemplateUrl);
            var resetMatches = function() {
                scope.matches = [], scope.activeIdx = -1, element.attr("aria-expanded", !1);
            }, getMatchId = function(index) {
                return popupId + "-option-" + index;
            };
            scope.$watch("activeIdx", function(index) {
                0 > index ? element.removeAttr("aria-activedescendant") : element.attr("aria-activedescendant", getMatchId(index));
            });
            var inputIsExactMatch = function(inputValue, index) {
                return scope.matches.length > index && inputValue ? inputValue.toUpperCase() === scope.matches[index].label.toUpperCase() : !1;
            }, getMatchesAsync = function(inputValue) {
                var locals = {
                    $viewValue: inputValue
                };
                isLoadingSetter(originalScope, !0), isNoResultsSetter(originalScope, !1), $q.when(parserResult.source(originalScope, locals)).then(function(matches) {
                    var onCurrentRequest = inputValue === modelCtrl.$viewValue;
                    if (onCurrentRequest && hasFocus) if (matches && matches.length > 0) {
                        scope.activeIdx = focusFirst ? 0 : -1, isNoResultsSetter(originalScope, !1), scope.matches.length = 0;
                        for (var i = 0; i < matches.length; i++) locals[parserResult.itemName] = matches[i], 
                        scope.matches.push({
                            id: getMatchId(i),
                            label: parserResult.viewMapper(scope, locals),
                            model: matches[i]
                        });
                        scope.query = inputValue, recalculatePosition(), element.attr("aria-expanded", !0), 
                        selectOnExact && 1 === scope.matches.length && inputIsExactMatch(inputValue, 0) && scope.select(0);
                    } else resetMatches(), isNoResultsSetter(originalScope, !0);
                    onCurrentRequest && isLoadingSetter(originalScope, !1);
                }, function() {
                    resetMatches(), isLoadingSetter(originalScope, !1), isNoResultsSetter(originalScope, !0);
                });
            };
            appendToBody && (angular.element($window).bind("resize", fireRecalculating), $document.find("body").bind("scroll", fireRecalculating));
            var timeoutEventPromise;
            scope.moveInProgress = !1, resetMatches(), scope.query = void 0;
            var timeoutPromise, scheduleSearchWithTimeout = function(inputValue) {
                timeoutPromise = $timeout(function() {
                    getMatchesAsync(inputValue);
                }, waitTime);
            }, cancelPreviousTimeout = function() {
                timeoutPromise && $timeout.cancel(timeoutPromise);
            };
            modelCtrl.$parsers.unshift(function(inputValue) {
                return hasFocus = !0, 0 === minLength || inputValue && inputValue.length >= minLength ? waitTime > 0 ? (cancelPreviousTimeout(), 
                scheduleSearchWithTimeout(inputValue)) : getMatchesAsync(inputValue) : (isLoadingSetter(originalScope, !1), 
                cancelPreviousTimeout(), resetMatches()), isEditable ? inputValue : inputValue ? void modelCtrl.$setValidity("editable", !1) : (modelCtrl.$setValidity("editable", !0), 
                null);
            }), modelCtrl.$formatters.push(function(modelValue) {
                var candidateViewValue, emptyViewValue, locals = {};
                return isEditable || modelCtrl.$setValidity("editable", !0), inputFormatter ? (locals.$model = modelValue, 
                inputFormatter(originalScope, locals)) : (locals[parserResult.itemName] = modelValue, 
                candidateViewValue = parserResult.viewMapper(originalScope, locals), locals[parserResult.itemName] = void 0, 
                emptyViewValue = parserResult.viewMapper(originalScope, locals), candidateViewValue !== emptyViewValue ? candidateViewValue : modelValue);
            }), scope.select = function(activeIdx) {
                var model, item, locals = {};
                selected = !0, locals[parserResult.itemName] = item = scope.matches[activeIdx].model, 
                model = parserResult.modelMapper(originalScope, locals), $setModelValue(originalScope, model), 
                modelCtrl.$setValidity("editable", !0), modelCtrl.$setValidity("parse", !0), onSelectCallback(originalScope, {
                    $item: item,
                    $model: model,
                    $label: parserResult.viewMapper(originalScope, locals)
                }), resetMatches(), scope.$eval(attrs.typeaheadFocusOnSelect) !== !1 && $timeout(function() {
                    element[0].focus();
                }, 0, !1);
            }, element.bind("keydown", function(evt) {
                if (0 !== scope.matches.length && -1 !== HOT_KEYS.indexOf(evt.which)) {
                    if (-1 === scope.activeIdx && (9 === evt.which || 13 === evt.which)) return resetMatches(), 
                    void scope.$digest();
                    evt.preventDefault(), 40 === evt.which ? (scope.activeIdx = (scope.activeIdx + 1) % scope.matches.length, 
                    scope.$digest()) : 38 === evt.which ? (scope.activeIdx = (scope.activeIdx > 0 ? scope.activeIdx : scope.matches.length) - 1, 
                    scope.$digest()) : 13 === evt.which || 9 === evt.which ? scope.$apply(function() {
                        scope.select(scope.activeIdx);
                    }) : 27 === evt.which && (evt.stopPropagation(), resetMatches(), scope.$digest());
                }
            }), element.bind("blur", function() {
                isSelectOnBlur && scope.matches.length && -1 !== scope.activeIdx && !selected && (selected = !0, 
                scope.$apply(function() {
                    scope.select(scope.activeIdx);
                })), hasFocus = !1, selected = !1;
            });
            var dismissClickHandler = function(evt) {
                element[0] !== evt.target && 3 !== evt.which && 0 !== scope.matches.length && (resetMatches(), 
                $rootScope.$$phase || scope.$digest());
            };
            $document.bind("click", dismissClickHandler), originalScope.$on("$destroy", function() {
                $document.unbind("click", dismissClickHandler), (appendToBody || appendToElementId) && $popup.remove(), 
                appendToBody && (angular.element($window).unbind("resize", fireRecalculating), $document.find("body").unbind("scroll", fireRecalculating)), 
                popUpEl.remove();
            });
            var $popup = $compile(popUpEl)(scope);
            appendToBody ? $document.find("body").append($popup) : appendToElementId !== !1 ? angular.element($document[0].getElementById(appendToElementId)).append($popup) : element.after($popup);
        }
    };
} ]).directive("typeaheadPopup", [ "$typeaheadSuppressWarning", "$log", function($typeaheadSuppressWarning, $log) {
    return {
        scope: {
            matches: "=",
            query: "=",
            active: "=",
            position: "&",
            moveInProgress: "=",
            select: "&"
        },
        replace: !0,
        templateUrl: function(element, attrs) {
            return attrs.popupTemplateUrl || "template/typeahead/typeahead-popup.html";
        },
        link: function(scope, element, attrs) {
            $typeaheadSuppressWarning || $log.warn("typeahead-popup is now deprecated. Use uib-typeahead-popup instead."), 
            scope.templateUrl = attrs.templateUrl, scope.isOpen = function() {
                return scope.matches.length > 0;
            }, scope.isActive = function(matchIdx) {
                return scope.active == matchIdx;
            }, scope.selectActive = function(matchIdx) {
                scope.active = matchIdx;
            }, scope.selectMatch = function(activeIdx) {
                scope.select({
                    activeIdx: activeIdx
                });
            };
        }
    };
} ]).directive("typeaheadMatch", [ "$templateRequest", "$compile", "$parse", "$typeaheadSuppressWarning", "$log", function($templateRequest, $compile, $parse, $typeaheadSuppressWarning, $log) {
    return {
        restrict: "EA",
        scope: {
            index: "=",
            match: "=",
            query: "="
        },
        link: function(scope, element, attrs) {
            $typeaheadSuppressWarning || $log.warn("typeahead-match is now deprecated. Use uib-typeahead-match instead.");
            var tplUrl = $parse(attrs.templateUrl)(scope.$parent) || "template/typeahead/typeahead-match.html";
            $templateRequest(tplUrl).then(function(tplContent) {
                $compile(tplContent.trim())(scope, function(clonedElement) {
                    element.replaceWith(clonedElement);
                });
            });
        }
    };
} ]).filter("typeaheadHighlight", [ "$sce", "$injector", "$log", "$typeaheadSuppressWarning", function($sce, $injector, $log, $typeaheadSuppressWarning) {
    function escapeRegexp(queryToEscape) {
        return queryToEscape.replace(/([.?*+^$[\]\\(){}|-])/g, "\\$1");
    }
    function containsHtml(matchItem) {
        return /<.*>/g.test(matchItem);
    }
    var isSanitizePresent;
    return isSanitizePresent = $injector.has("$sanitize"), function(matchItem, query) {
        return $typeaheadSuppressWarning || $log.warn("typeaheadHighlight is now deprecated. Use uibTypeaheadHighlight instead."), 
        !isSanitizePresent && containsHtml(matchItem) && $log.warn("Unsafe use of typeahead please use ngSanitize"), 
        matchItem = query ? ("" + matchItem).replace(new RegExp(escapeRegexp(query), "gi"), "<strong>$&</strong>") : matchItem, 
        isSanitizePresent || (matchItem = $sce.trustAsHtml(matchItem)), matchItem;
    };
} ]), angular.module("template/accordion/accordion-group.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("template/accordion/accordion-group.html", '<div class="panel {{panelClass || \'panel-default\'}}">\n  <div class="panel-heading" ng-keypress="toggleOpen($event)">\n    <h4 class="panel-title">\n      <a href tabindex="0" class="accordion-toggle" ng-click="toggleOpen()" uib-accordion-transclude="heading"><span ng-class="{\'text-muted\': isDisabled}">{{heading}}</span></a>\n    </h4>\n  </div>\n  <div class="panel-collapse collapse" uib-collapse="!isOpen">\n	  <div class="panel-body" ng-transclude></div>\n  </div>\n</div>\n');
} ]), angular.module("template/accordion/accordion.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("template/accordion/accordion.html", '<div class="panel-group" ng-transclude></div>');
} ]), angular.module("template/alert/alert.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("template/alert/alert.html", '<div class="alert" ng-class="[\'alert-\' + (type || \'warning\'), closeable ? \'alert-dismissible\' : null]" role="alert">\n    <button ng-show="closeable" type="button" class="close" ng-click="close({$event: $event})">\n        <span aria-hidden="true">&times;</span>\n        <span class="sr-only">Close</span>\n    </button>\n    <div ng-transclude></div>\n</div>\n');
} ]), angular.module("template/carousel/carousel.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("template/carousel/carousel.html", '<div ng-mouseenter="pause()" ng-mouseleave="play()" class="carousel" ng-swipe-right="prev()" ng-swipe-left="next()">\n  <div class="carousel-inner" ng-transclude></div>\n  <a role="button" href class="left carousel-control" ng-click="prev()" ng-show="slides.length > 1">\n    <span aria-hidden="true" class="glyphicon glyphicon-chevron-left"></span>\n    <span class="sr-only">previous</span>\n  </a>\n  <a role="button" href class="right carousel-control" ng-click="next()" ng-show="slides.length > 1">\n    <span aria-hidden="true" class="glyphicon glyphicon-chevron-right"></span>\n    <span class="sr-only">next</span>\n  </a>\n  <ol class="carousel-indicators" ng-show="slides.length > 1">\n    <li ng-repeat="slide in slides | orderBy:indexOfSlide track by $index" ng-class="{ active: isActive(slide) }" ng-click="select(slide)">\n      <span class="sr-only">slide {{ $index + 1 }} of {{ slides.length }}<span ng-if="isActive(slide)">, currently active</span></span>\n    </li>\n  </ol>\n</div>');
} ]), angular.module("template/carousel/slide.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("template/carousel/slide.html", '<div ng-class="{\n    \'active\': active\n  }" class="item text-center" ng-transclude></div>\n');
} ]), angular.module("template/datepicker/datepicker.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("template/datepicker/datepicker.html", '<div ng-switch="datepickerMode" role="application" ng-keydown="keydown($event)">\n  <uib-daypicker ng-switch-when="day" tabindex="0"></uib-daypicker>\n  <uib-monthpicker ng-switch-when="month" tabindex="0"></uib-monthpicker>\n  <uib-yearpicker ng-switch-when="year" tabindex="0"></uib-yearpicker>\n</div>');
} ]), angular.module("template/datepicker/day.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("template/datepicker/day.html", '<table role="grid" aria-labelledby="{{::uniqueId}}-title" aria-activedescendant="{{activeDateId}}">\n  <thead>\n    <tr>\n      <th><button type="button" class="btn btn-default btn-sm pull-left" ng-click="move(-1)" tabindex="-1"><i class="glyphicon glyphicon-chevron-left"></i></button></th>\n      <th colspan="{{::5 + showWeeks}}"><button id="{{::uniqueId}}-title" role="heading" aria-live="assertive" aria-atomic="true" type="button" class="btn btn-default btn-sm" ng-click="toggleMode()" ng-disabled="datepickerMode === maxMode" tabindex="-1" style="width:100%;"><strong>{{title}}</strong></button></th>\n      <th><button type="button" class="btn btn-default btn-sm pull-right" ng-click="move(1)" tabindex="-1"><i class="glyphicon glyphicon-chevron-right"></i></button></th>\n    </tr>\n    <tr>\n      <th ng-if="showWeeks" class="text-center"></th>\n      <th ng-repeat="label in ::labels track by $index" class="text-center"><small aria-label="{{::label.full}}">{{::label.abbr}}</small></th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr ng-repeat="row in rows track by $index">\n      <td ng-if="showWeeks" class="text-center h6"><em>{{ weekNumbers[$index] }}</em></td>\n      <td ng-repeat="dt in row track by dt.date" class="text-center" role="gridcell" id="{{::dt.uid}}" ng-class="::dt.customClass">\n        <button type="button" style="min-width:100%;" class="btn btn-default btn-sm" ng-class="{\'btn-info\': dt.selected, active: isActive(dt)}" ng-click="select(dt.date)" ng-disabled="dt.disabled" tabindex="-1"><span ng-class="::{\'text-muted\': dt.secondary, \'text-info\': dt.current}">{{::dt.label}}</span></button>\n      </td>\n    </tr>\n  </tbody>\n</table>\n');
} ]), angular.module("template/datepicker/month.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("template/datepicker/month.html", '<table role="grid" aria-labelledby="{{::uniqueId}}-title" aria-activedescendant="{{activeDateId}}">\n  <thead>\n    <tr>\n      <th><button type="button" class="btn btn-default btn-sm pull-left" ng-click="move(-1)" tabindex="-1"><i class="glyphicon glyphicon-chevron-left"></i></button></th>\n      <th><button id="{{::uniqueId}}-title" role="heading" aria-live="assertive" aria-atomic="true" type="button" class="btn btn-default btn-sm" ng-click="toggleMode()" ng-disabled="datepickerMode === maxMode" tabindex="-1" style="width:100%;"><strong>{{title}}</strong></button></th>\n      <th><button type="button" class="btn btn-default btn-sm pull-right" ng-click="move(1)" tabindex="-1"><i class="glyphicon glyphicon-chevron-right"></i></button></th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr ng-repeat="row in rows track by $index">\n      <td ng-repeat="dt in row track by dt.date" class="text-center" role="gridcell" id="{{::dt.uid}}" ng-class="::dt.customClass">\n        <button type="button" style="min-width:100%;" class="btn btn-default" ng-class="{\'btn-info\': dt.selected, active: isActive(dt)}" ng-click="select(dt.date)" ng-disabled="dt.disabled" tabindex="-1"><span ng-class="::{\'text-info\': dt.current}">{{::dt.label}}</span></button>\n      </td>\n    </tr>\n  </tbody>\n</table>\n');
} ]), angular.module("template/datepicker/popup.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("template/datepicker/popup.html", '<ul class="dropdown-menu" dropdown-nested ng-if="isOpen" style="display: block" ng-style="{top: position.top+\'px\', left: position.left+\'px\'}" ng-keydown="keydown($event)" ng-click="$event.stopPropagation()">\n	<li ng-transclude></li>\n	<li ng-if="showButtonBar" style="padding:10px 9px 2px">\n		<span class="btn-group pull-left">\n			<button type="button" class="btn btn-sm btn-info" ng-click="select(\'today\')" ng-disabled="isDisabled(\'today\')">{{ getText(\'current\') }}</button>\n			<button type="button" class="btn btn-sm btn-danger" ng-click="select(null)">{{ getText(\'clear\') }}</button>\n		</span>\n		<button type="button" class="btn btn-sm btn-success pull-right" ng-click="close()">{{ getText(\'close\') }}</button>\n	</li>\n</ul>\n');
} ]), angular.module("template/datepicker/year.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("template/datepicker/year.html", '<table role="grid" aria-labelledby="{{::uniqueId}}-title" aria-activedescendant="{{activeDateId}}">\n  <thead>\n    <tr>\n      <th><button type="button" class="btn btn-default btn-sm pull-left" ng-click="move(-1)" tabindex="-1"><i class="glyphicon glyphicon-chevron-left"></i></button></th>\n      <th colspan="3"><button id="{{::uniqueId}}-title" role="heading" aria-live="assertive" aria-atomic="true" type="button" class="btn btn-default btn-sm" ng-click="toggleMode()" ng-disabled="datepickerMode === maxMode" tabindex="-1" style="width:100%;"><strong>{{title}}</strong></button></th>\n      <th><button type="button" class="btn btn-default btn-sm pull-right" ng-click="move(1)" tabindex="-1"><i class="glyphicon glyphicon-chevron-right"></i></button></th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr ng-repeat="row in rows track by $index">\n      <td ng-repeat="dt in row track by dt.date" class="text-center" role="gridcell" id="{{::dt.uid}}" ng-class="::dt.customClass">\n        <button type="button" style="min-width:100%;" class="btn btn-default" ng-class="{\'btn-info\': dt.selected, active: isActive(dt)}" ng-click="select(dt.date)" ng-disabled="dt.disabled" tabindex="-1"><span ng-class="::{\'text-info\': dt.current}">{{::dt.label}}</span></button>\n      </td>\n    </tr>\n  </tbody>\n</table>\n');
} ]), angular.module("template/modal/backdrop.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("template/modal/backdrop.html", '<div uib-modal-animation-class="fade"\n     modal-in-class="in"\n     ng-style="{\'z-index\': 1040 + (index && 1 || 0) + index*10}"\n></div>\n');
} ]), angular.module("template/modal/window.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("template/modal/window.html", '<div modal-render="{{$isRendered}}" tabindex="-1" role="dialog" class="modal"\n    uib-modal-animation-class="fade"\n    modal-in-class="in"\n    ng-style="{\'z-index\': 1050 + index*10, display: \'block\'}">\n    <div class="modal-dialog" ng-class="size ? \'modal-\' + size : \'\'"><div class="modal-content" uib-modal-transclude></div></div>\n</div>\n');
} ]), angular.module("template/pagination/pager.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("template/pagination/pager.html", '<ul class="pager">\n  <li ng-class="{disabled: noPrevious()||ngDisabled, previous: align}"><a href ng-click="selectPage(page - 1, $event)">{{::getText(\'previous\')}}</a></li>\n  <li ng-class="{disabled: noNext()||ngDisabled, next: align}"><a href ng-click="selectPage(page + 1, $event)">{{::getText(\'next\')}}</a></li>\n</ul>\n');
} ]), angular.module("template/pagination/pagination.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("template/pagination/pagination.html", '<ul class="pagination">\n  <li ng-if="::boundaryLinks" ng-class="{disabled: noPrevious()||ngDisabled}" class="pagination-first"><a href ng-click="selectPage(1, $event)">{{::getText(\'first\')}}</a></li>\n  <li ng-if="::directionLinks" ng-class="{disabled: noPrevious()||ngDisabled}" class="pagination-prev"><a href ng-click="selectPage(page - 1, $event)">{{::getText(\'previous\')}}</a></li>\n  <li ng-repeat="page in pages track by $index" ng-class="{active: page.active,disabled: ngDisabled&&!page.active}" class="pagination-page"><a href ng-click="selectPage(page.number, $event)">{{page.text}}</a></li>\n  <li ng-if="::directionLinks" ng-class="{disabled: noNext()||ngDisabled}" class="pagination-next"><a href ng-click="selectPage(page + 1, $event)">{{::getText(\'next\')}}</a></li>\n  <li ng-if="::boundaryLinks" ng-class="{disabled: noNext()||ngDisabled}" class="pagination-last"><a href ng-click="selectPage(totalPages, $event)">{{::getText(\'last\')}}</a></li>\n</ul>\n');
} ]), angular.module("template/tooltip/tooltip-html-popup.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("template/tooltip/tooltip-html-popup.html", '<div\n  tooltip-animation-class="fade"\n  uib-tooltip-classes\n  ng-class="{ in: isOpen() }">\n  <div class="tooltip-arrow"></div>\n  <div class="tooltip-inner" ng-bind-html="contentExp()"></div>\n</div>\n');
} ]), angular.module("template/tooltip/tooltip-popup.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("template/tooltip/tooltip-popup.html", '<div\n  tooltip-animation-class="fade"\n  uib-tooltip-classes\n  ng-class="{ in: isOpen() }">\n  <div class="tooltip-arrow"></div>\n  <div class="tooltip-inner" ng-bind="content"></div>\n</div>\n');
} ]), angular.module("template/tooltip/tooltip-template-popup.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("template/tooltip/tooltip-template-popup.html", '<div\n  tooltip-animation-class="fade"\n  uib-tooltip-classes\n  ng-class="{ in: isOpen() }">\n  <div class="tooltip-arrow"></div>\n  <div class="tooltip-inner"\n    uib-tooltip-template-transclude="contentExp()"\n    tooltip-template-transclude-scope="originScope()"></div>\n</div>\n');
} ]), angular.module("template/popover/popover-html.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("template/popover/popover-html.html", '<div tooltip-animation-class="fade"\n  uib-tooltip-classes\n  ng-class="{ in: isOpen() }">\n  <div class="arrow"></div>\n\n  <div class="popover-inner">\n      <h3 class="popover-title" ng-bind="title" ng-if="title"></h3>\n      <div class="popover-content" ng-bind-html="contentExp()"></div>\n  </div>\n</div>\n');
} ]), angular.module("template/popover/popover-template.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("template/popover/popover-template.html", '<div tooltip-animation-class="fade"\n  uib-tooltip-classes\n  ng-class="{ in: isOpen() }">\n  <div class="arrow"></div>\n\n  <div class="popover-inner">\n      <h3 class="popover-title" ng-bind="title" ng-if="title"></h3>\n      <div class="popover-content"\n        uib-tooltip-template-transclude="contentExp()"\n        tooltip-template-transclude-scope="originScope()"></div>\n  </div>\n</div>\n');
} ]), angular.module("template/popover/popover.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("template/popover/popover.html", '<div tooltip-animation-class="fade"\n  uib-tooltip-classes\n  ng-class="{ in: isOpen() }">\n  <div class="arrow"></div>\n\n  <div class="popover-inner">\n      <h3 class="popover-title" ng-bind="title" ng-if="title"></h3>\n      <div class="popover-content" ng-bind="content"></div>\n  </div>\n</div>\n');
} ]), angular.module("template/progressbar/bar.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("template/progressbar/bar.html", '<div class="progress-bar" ng-class="type && \'progress-bar-\' + type" role="progressbar" aria-valuenow="{{value}}" aria-valuemin="0" aria-valuemax="{{max}}" ng-style="{width: (percent < 100 ? percent : 100) + \'%\'}" aria-valuetext="{{percent | number:0}}%" aria-labelledby="{{::title}}" style="min-width: 0;" ng-transclude></div>\n');
} ]), angular.module("template/progressbar/progress.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("template/progressbar/progress.html", '<div class="progress" ng-transclude aria-labelledby="{{::title}}"></div>');
} ]), angular.module("template/progressbar/progressbar.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("template/progressbar/progressbar.html", '<div class="progress">\n  <div class="progress-bar" ng-class="type && \'progress-bar-\' + type" role="progressbar" aria-valuenow="{{value}}" aria-valuemin="0" aria-valuemax="{{max}}" ng-style="{width: (percent < 100 ? percent : 100) + \'%\'}" aria-valuetext="{{percent | number:0}}%" aria-labelledby="{{::title}}" style="min-width: 0;" ng-transclude></div>\n</div>\n');
} ]), angular.module("template/rating/rating.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("template/rating/rating.html", '<span ng-mouseleave="reset()" ng-keydown="onKeydown($event)" tabindex="0" role="slider" aria-valuemin="0" aria-valuemax="{{range.length}}" aria-valuenow="{{value}}">\n    <span ng-repeat-start="r in range track by $index" class="sr-only">({{ $index < value ? \'*\' : \' \' }})</span>\n    <i ng-repeat-end ng-mouseenter="enter($index + 1)" ng-click="rate($index + 1)" class="glyphicon" ng-class="$index < value && (r.stateOn || \'glyphicon-star\') || (r.stateOff || \'glyphicon-star-empty\')" ng-attr-title="{{r.title}}" aria-valuetext="{{r.title}}"></i>\n</span>\n');
} ]), angular.module("template/tabs/tab.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("template/tabs/tab.html", '<li ng-class="{active: active, disabled: disabled}">\n  <a href ng-click="select()" uib-tab-heading-transclude>{{heading}}</a>\n</li>\n');
} ]), angular.module("template/tabs/tabset.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("template/tabs/tabset.html", '<div>\n  <ul class="nav nav-{{type || \'tabs\'}}" ng-class="{\'nav-stacked\': vertical, \'nav-justified\': justified}" ng-transclude></ul>\n  <div class="tab-content">\n    <div class="tab-pane" \n         ng-repeat="tab in tabs" \n         ng-class="{active: tab.active}"\n         uib-tab-content-transclude="tab">\n    </div>\n  </div>\n</div>\n');
} ]), angular.module("template/timepicker/timepicker.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("template/timepicker/timepicker.html", '<table>\n  <tbody>\n    <tr class="text-center" ng-show="::showSpinners">\n      <td><a ng-click="incrementHours()" ng-class="{disabled: noIncrementHours()}" class="btn btn-link" ng-disabled="noIncrementHours()" tabindex="{{::tabindex}}"><span class="glyphicon glyphicon-chevron-up"></span></a></td>\n      <td>&nbsp;</td>\n      <td><a ng-click="incrementMinutes()" ng-class="{disabled: noIncrementMinutes()}" class="btn btn-link" ng-disabled="noIncrementMinutes()" tabindex="{{::tabindex}}"><span class="glyphicon glyphicon-chevron-up"></span></a></td>\n      <td ng-show="showMeridian"></td>\n    </tr>\n    <tr>\n      <td class="form-group" ng-class="{\'has-error\': invalidHours}">\n        <input style="width:50px;" type="text" ng-model="hours" ng-change="updateHours()" class="form-control text-center" ng-readonly="::readonlyInput" maxlength="2" tabindex="{{::tabindex}}">\n      </td>\n      <td>:</td>\n      <td class="form-group" ng-class="{\'has-error\': invalidMinutes}">\n        <input style="width:50px;" type="text" ng-model="minutes" ng-change="updateMinutes()" class="form-control text-center" ng-readonly="::readonlyInput" maxlength="2" tabindex="{{::tabindex}}">\n      </td>\n      <td ng-show="showMeridian"><button type="button" ng-class="{disabled: noToggleMeridian()}" class="btn btn-default text-center" ng-click="toggleMeridian()" ng-disabled="noToggleMeridian()" tabindex="{{::tabindex}}">{{meridian}}</button></td>\n    </tr>\n    <tr class="text-center" ng-show="::showSpinners">\n      <td><a ng-click="decrementHours()" ng-class="{disabled: noDecrementHours()}" class="btn btn-link" ng-disabled="noDecrementHours()" tabindex="{{::tabindex}}"><span class="glyphicon glyphicon-chevron-down"></span></a></td>\n      <td>&nbsp;</td>\n      <td><a ng-click="decrementMinutes()" ng-class="{disabled: noDecrementMinutes()}" class="btn btn-link" ng-disabled="noDecrementMinutes()" tabindex="{{::tabindex}}"><span class="glyphicon glyphicon-chevron-down"></span></a></td>\n      <td ng-show="showMeridian"></td>\n    </tr>\n  </tbody>\n</table>\n');
} ]), angular.module("template/typeahead/typeahead-match.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("template/typeahead/typeahead-match.html", '<a href tabindex="-1" ng-bind-html="match.label | uibTypeaheadHighlight:query"></a>\n');
} ]), angular.module("template/typeahead/typeahead-popup.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("template/typeahead/typeahead-popup.html", '<ul class="dropdown-menu" ng-show="isOpen() && !moveInProgress" ng-style="{top: position().top+\'px\', left: position().left+\'px\'}" style="display: block;" role="listbox" aria-hidden="{{!isOpen()}}">\n    <li ng-repeat="match in matches track by $index" ng-class="{active: isActive($index) }" ng-mouseenter="selectActive($index)" ng-click="selectMatch($index)" role="option" id="{{::match.id}}">\n        <div uib-typeahead-match index="$index" match="match" query="query" template-url="templateUrl"></div>\n    </li>\n</ul>\n');
} ]), !angular.$$csp() && angular.element(document).find("head").prepend('<style type="text/css">.ng-animate.item:not(.left):not(.right){-webkit-transition:0s ease-in-out left;transition:0s ease-in-out left}</style>'), 
define("ngdir/angular-ui-bootstrap", [ "angular" ], function() {}), angular.module("ngUpload", []).directive("uploadSubmit", [ "$parse", function() {
    function getParentNodeByTagName(element, tagName) {
        element = angular.element(element);
        var parent = element.parent();
        return tagName = tagName.toLowerCase(), parent && parent[0].tagName.toLowerCase() === tagName ? parent : parent ? getParentNodeByTagName(parent, tagName) : null;
    }
    return {
        restrict: "AC",
        link: function(scope, element) {
            element.bind("click", function($event) {
                if ($event && ($event.preventDefault(), $event.stopPropagation()), !element.attr("disabled")) {
                    var form = getParentNodeByTagName(element, "form");
                    form.triggerHandler("submit"), form[0].submit();
                }
            });
        }
    };
} ]).directive("ngUpload", [ "$log", "$parse", "$document", function($log, $parse, $document) {
    function getMetaTagWithName(name) {
        var match, head = $document.find("head");
        return angular.forEach(head.find("meta"), function(element) {
            element.getAttribute("name") === name && (match = element);
        }), angular.element(match);
    }
    var iframeID = 1;
    return {
        restrict: "AC",
        link: function(scope, element, attrs) {
            function setLoadingState(state) {
                scope.$isUploading = state;
            }
            function uploadEnd() {
                iframe.unbind("load"), scope.$$phase ? setLoadingState(!1) : scope.$apply(function() {
                    setLoadingState(!1);
                });
                var content, bodyContent = (iframe[0].contentDocument || iframe[0].contentWindow.document).body;
                try {
                    content = angular.fromJson(bodyContent.innerText || bodyContent.textContent);
                } catch (e) {
                    content = bodyContent.innerHTML, $log.warn("Response is not valid JSON");
                }
                scope.$$phase ? fn(scope, {
                    content: content
                }) : scope.$apply(function() {
                    fn(scope, {
                        content: content
                    });
                });
            }
            iframeID++;
            var options = {}, fn = attrs.ngUpload ? $parse(attrs.ngUpload) : angular.noop, loading = attrs.ngUploadLoading ? $parse(attrs.ngUploadLoading) : null;
            attrs.hasOwnProperty("uploadOptionsConvertHidden") && (options.convertHidden = "false" != attrs.uploadOptionsConvertHidden), 
            attrs.hasOwnProperty("uploadOptionsEnableRailsCsrf") && (options.enableRailsCsrf = "false" != attrs.uploadOptionsEnableRailsCsrf), 
            attrs.hasOwnProperty("uploadOptionsBeforeSubmit") && (options.beforeSubmit = $parse(attrs.uploadOptionsBeforeSubmit)), 
            element.attr({
                target: "upload-iframe-" + iframeID,
                method: "post",
                enctype: "multipart/form-data",
                encoding: "multipart/form-data"
            });
            var iframe = angular.element('<iframe name="upload-iframe-' + iframeID + '" border="0" width="0" height="0" style="width:0px;height:0px;border:none;display:none">');
            if (options.enableRailsCsrf) {
                var input = angular.element("<input />");
                input.attr("class", "upload-csrf-token"), input.attr("type", "hidden"), input.attr("name", getMetaTagWithName("csrf-param").attr("content")), 
                input.val(getMetaTagWithName("csrf-token").attr("content")), element.append(input);
            }
            element.after(iframe), setLoadingState(!1), element.bind("submit", function() {
                var formController = scope[attrs.name];
                return formController && formController.$invalid ? !1 : options.beforeSubmit && 0 == options.beforeSubmit(scope, {}) ? !1 : (iframe.bind("load", uploadEnd), 
                options.convertHidden && angular.forEach(element.find("input"), function(el) {
                    var _el = angular.element(el);
                    _el.attr("ng-model") && _el.attr("type") && "hidden" == _el.attr("type") && _el.attr("value", scope.$eval(_el.attr("ng-model")));
                }), void (scope.$$phase ? (loading && loading(scope), setLoadingState(!0)) : scope.$apply(function() {
                    loading && loading(scope), setLoadingState(!0);
                })));
            });
        }
    };
} ]), define("ngdir/angular-upload", [ "angular" ], function() {}), angular.module("angular-google-analytics", []).provider("Analytics", function() {
    var accountId, displayFeatures, domainName, removeRegExp, experimentId, crossLinkDomains, created = !1, trackRoutes = !0, trackPrefix = "", analyticsJS = !1, pageEvent = "$routeChangeSuccess", cookieConfig = "auto", ecommerce = !1, enhancedEcommerce = !1, enhancedLinkAttribution = !1, ignoreFirstPageLoad = !1, crossDomainLinker = !1, linkerConfig = {
        allowLinker: !0
    };
    this._logs = [], this.setAccount = function(id) {
        return accountId = id, !0;
    }, this.trackPages = function(doTrack) {
        return trackRoutes = doTrack, !0;
    }, this.trackPrefix = function(prefix) {
        return trackPrefix = prefix, !0;
    }, this.setDomainName = function(domain) {
        return domainName = domain, !0;
    }, this.useDisplayFeatures = function(val) {
        return displayFeatures = !!val, !0;
    }, this.useAnalytics = function(val) {
        return analyticsJS = !!val, !0;
    }, this.useEnhancedLinkAttribution = function(val) {
        return enhancedLinkAttribution = !!val, !0;
    }, this.useCrossDomainLinker = function(val) {
        return crossDomainLinker = !!val, !0;
    }, this.setCrossLinkDomains = function(domains) {
        return crossLinkDomains = domains, !0;
    }, this.setPageEvent = function(name) {
        return pageEvent = name, !0;
    }, this.setCookieConfig = function(config) {
        return cookieConfig = config, !0;
    }, this.useECommerce = function(val, enhanced) {
        return ecommerce = !!val, enhancedEcommerce = !!enhanced, !0;
    }, this.setRemoveRegExp = function(regex) {
        return regex instanceof RegExp ? (removeRegExp = regex, !0) : !1;
    }, this.setExperimentId = function(id) {
        return experimentId = id, !0;
    }, this.ignoreFirstPageLoad = function(val) {
        ignoreFirstPageLoad = !!val;
    }, this.$get = [ "$document", "$rootScope", "$location", "$window", function($document, $rootScope, $location, $window) {
        function _createScriptTag() {
            if (accountId) {
                $window._gaq = [], $window._gaq.push([ "_setAccount", accountId ]), domainName && $window._gaq.push([ "_setDomainName", domainName ]), 
                enhancedLinkAttribution && $window._gaq.push([ "_require", "inpage_linkid", "//www.google-analytics.com/plugins/ga/inpage_linkid.js" ]), 
                trackRoutes && !ignoreFirstPageLoad && $window._gaq.push(removeRegExp ? [ "_trackPageview", getUrl() ] : [ "_trackPageview" ]);
                var gaSrc;
                gaSrc = displayFeatures ? ("https:" === document.location.protocol ? "https://" : "http://") + "stats.g.doubleclick.net/dc.js" : ("https:" === document.location.protocol ? "https://ssl" : "http://www") + ".google-analytics.com/ga.js", 
                function() {
                    var document = $document[0], ga = document.createElement("script");
                    ga.type = "text/javascript", ga.async = !0, ga.src = gaSrc;
                    var s = document.getElementsByTagName("script")[0];
                    s.parentNode.insertBefore(ga, s);
                }(gaSrc), created = !0;
            }
        }
        function _createAnalyticsScriptTag() {
            if (!accountId) return console.warn("No account id set for Analytics.js");
            if (function(i, s, o, g, r, a, m) {
                i.GoogleAnalyticsObject = r, i[r] = i[r] || function() {
                    (i[r].q = i[r].q || []).push(arguments);
                }, i[r].l = 1 * new Date(), a = s.createElement(o), m = s.getElementsByTagName(o)[0], 
                a.async = 1, a.src = g, m.parentNode.insertBefore(a, m);
            }(window, document, "script", "//www.google-analytics.com/analytics.js", "ga"), 
            angular.isArray(accountId) ? accountId.forEach(function(trackerObj) {
                $window.ga("create", trackerObj.tracker, cookieConfig, {
                    name: trackerObj.name
                });
            }) : crossDomainLinker ? ($window.ga("create", accountId, cookieConfig, linkerConfig), 
            $window.ga("require", "linker"), crossLinkDomains && $window.ga("linker:autoLink", crossLinkDomains)) : $window.ga("create", accountId, cookieConfig), 
            displayFeatures && $window.ga("require", "displayfeatures"), trackRoutes && !ignoreFirstPageLoad && $window.ga("send", "pageview", getUrl()), 
            $window.ga && (ecommerce && (enhancedEcommerce ? $window.ga("require", "ec", "ec.js") : $window.ga("require", "ecommerce", "ecommerce.js")), 
            enhancedLinkAttribution && $window.ga("require", "linkid", "linkid.js"), experimentId)) {
                var expScript = document.createElement("script"), s = document.getElementsByTagName("script")[0];
                expScript.src = "//www.google-analytics.com/cx/api.js?experiment=" + experimentId, 
                s.parentNode.insertBefore(expScript, s);
            }
        }
        var getUrl = function() {
            var url = $location.path();
            return removeRegExp ? url.replace(removeRegExp, "") : url;
        };
        this._log = function() {
            this._logs.push(arguments);
        }, this._trackPage = function(url, title) {
            title = title ? title : $document[0].title, trackRoutes && !analyticsJS && $window._gaq ? ($window._gaq.push([ "_set", "title", title ]), 
            $window._gaq.push([ "_trackPageview", trackPrefix + url ]), this._log("_trackPageview", arguments)) : trackRoutes && analyticsJS && $window.ga && (angular.isArray(accountId) ? accountId.forEach(function(trackerObj) {
                $window.ga(trackerObj.name + ".send", "pageview", {
                    page: trackPrefix + url,
                    title: title
                });
            }) : $window.ga("send", "pageview", {
                page: trackPrefix + url,
                title: title
            }), this._log("pageview", arguments));
        }, this._trackEvent = function(category, action, label, value) {
            !analyticsJS && $window._gaq ? ($window._gaq.push([ "_trackEvent", category, action, label, value ]), 
            this._log("trackEvent", arguments)) : $window.ga && ($window.ga("send", "event", category, action, label, value), 
            this._log("event", arguments));
        }, this._addTrans = function(transactionId, affiliation, total, tax, shipping, city, state, country, currency) {
            !analyticsJS && $window._gaq ? ($window._gaq.push([ "_addTrans", transactionId, affiliation, total, tax, shipping, city, state, country ]), 
            this._log("_addTrans", arguments)) : $window.ga && (ecommerce ? enhancedEcommerce ? console.warn("Enhanced ecommerce plugin is enabled. Only one plugin(ecommerce/ec) can be used at a time. Use AnalyticsProvider.setECommerce(true,false);") : ($window.ga("ecommerce:addTransaction", {
                id: transactionId,
                affiliation: affiliation,
                revenue: total,
                tax: tax,
                shipping: shipping,
                currency: currency || "USD"
            }), this._log("ecommerce:addTransaction", arguments)) : console.warn("ecommerce no set. Use AnalyticsProvider.setECommerce(true,false);"));
        }, this._addItem = function(transactionId, sku, name, category, price, quantity) {
            !analyticsJS && $window._gaq ? ($window._gaq.push([ "_addItem", transactionId, sku, name, category, price, quantity ]), 
            this._log("_addItem", arguments)) : $window.ga && (ecommerce ? enhancedEcommerce ? console.warn("Enhanced ecommerce plugin is enabled. Only one plugin(ecommerce/ec) can be used at a time. Use AnalyticsProvider.setECommerce(true,false);") : ($window.ga("ecommerce:addItem", {
                id: transactionId,
                name: name,
                sku: sku,
                category: category,
                price: price,
                quantity: quantity
            }), this._log("ecommerce:addItem", arguments)) : console.warn("ecommerce no set. Use AnalyticsProvider.setECommerce(true,false);"));
        }, this._trackTrans = function() {
            !analyticsJS && $window._gaq ? ($window._gaq.push([ "_trackTrans" ]), this._log("_trackTrans", arguments)) : $window.ga && (ecommerce ? enhancedEcommerce ? console.warn("Enhanced ecommerce plugin is enabled. Only one plugin(ecommerce/ec) can be used at a time. Use AnalyticsProvider.setECommerce(true,false);") : ($window.ga("ecommerce:send"), 
            this._log("ecommerce:send", arguments)) : console.warn("ecommerce no set. Use AnalyticsProvider.setECommerce(true,false);"));
        }, this._clearTrans = function() {
            $window.ga && (ecommerce ? enhancedEcommerce ? console.warn("Enhanced ecommerce plugin is enabled. Only one plugin(ecommerce/ec) can be used at a time. Use AnalyticsProvider.setECommerce(true,false);") : ($window.ga("ecommerce:clear"), 
            this._log("ecommerce:clear", arguments)) : console.warn("ecommerce no set. Use AnalyticsProvider.setECommerce(true,false);"));
        }, this._addProduct = function(productId, name, category, brand, variant, price, quantity, coupon, position) {
            !analyticsJS && $window._gaq ? ($window._gaq.push([ "_addProduct", productId, name, category, brand, variant, price, quantity, coupon, position ]), 
            this._log("_addProduct", arguments)) : $window.ga && (ecommerce ? enhancedEcommerce ? ($window.ga("ec:addProduct", {
                id: productId,
                name: name,
                category: category,
                brand: brand,
                variant: variant,
                price: price,
                quantity: quantity,
                coupon: coupon,
                position: position
            }), this._log("ec:addProduct", arguments)) : console.warn("Enhanced ecommerce plugin is disabled. Use AnalyticsProvider.setECommerce(true,true);") : console.warn("ecommerce not set. Use AnalyticsProvider.setECommerce(true,true);"));
        }, this._addImpression = function(id, name, list, brand, category, variant, position, price) {
            !analyticsJS && $window._gaq ? ($window._gaq.push([ "_addImpression", id, name, list, brand, category, variant, position, price ]), 
            this._log("_addImpression", arguments)) : $window.ga && (ecommerce ? enhancedEcommerce ? $window.ga("ec:addImpression", {
                id: id,
                name: name,
                category: category,
                brand: brand,
                variant: variant,
                list: list,
                position: position,
                price: price
            }) : console.warn("Enhanced ecommerce plugin is disabled. Use AnalyticsProvider.setECommerce(true,true);") : console.warn("ecommerce not set. Use AnalyticsProvider.setECommerce(true,true);"), 
            this._log("ec:addImpression", arguments));
        }, this._addPromo = function(productId, name, creative, position) {
            !analyticsJS && $window._gaq ? ($window._gaq.push([ "_addPromo", productId, name, creative, position ]), 
            this._log("_addPromo", arguments)) : $window.ga && (ecommerce ? enhancedEcommerce ? ($window.ga("ec:addPromo", {
                id: productId,
                name: name,
                creative: creative,
                position: position
            }), this._log("ec:addPromo", arguments)) : console.warn("Enhanced ecommerce plugin is disabled. Use AnalyticsProvider.setECommerce(true,true);") : console.warn("ecommerce not set. Use AnalyticsProvider.setECommerce(true,true);"));
        }, this._getActionFieldObject = function(id, affiliation, revenue, tax, shipping, coupon, list, step, option) {
            var obj = {};
            return id && (obj.id = id), affiliation && (obj.affiliation = affiliation), revenue && (obj.revenue = revenue), 
            tax && (obj.tax = tax), shipping && (obj.shipping = shipping), coupon && (obj.coupon = coupon), 
            list && (obj.list = list), step && (obj.step = step), option && (obj.option = option), 
            obj;
        }, this._setAction = function(action, obj) {
            !analyticsJS && $window._gaq ? ($window._gaq.push([ "_setAction", action, obj ]), 
            this._log("__setAction", arguments)) : $window.ga && (ecommerce ? enhancedEcommerce ? ($window.ga("ec:setAction", action, obj), 
            this._log("ec:setAction", arguments)) : console.warn("Enhanced ecommerce plugin is disabled. Use AnalyticsProvider.setECommerce(true,true);") : console.warn("ecommerce not set. Use AnalyticsProvider.setECommerce(true,true);"));
        }, this._trackTransaction = function(transactionId, affiliation, revenue, tax, shipping, coupon, list, step, option) {
            this._setAction("purchase", this._getActionFieldObject(transactionId, affiliation, revenue, tax, shipping, coupon, list, step, option)), 
            this._pageView();
        }, this._trackRefund = function(transactionId) {
            this._setAction("refund", this._getActionFieldObject(transactionId)), this._pageView();
        }, this._trackCheckOut = function(step, option) {
            this._setAction("checkout", this._getActionFieldObject(null, null, null, null, null, null, null, step, option)), 
            this._pageView();
        }, this._trackCart = function(action) {
            -1 !== [ "add", "remove" ].indexOf(action) && (this._setAction(action), this._send("event", "UX", "click", action + "to cart"));
        }, this._promoClick = function(promotionName) {
            this._setAction("promo_click"), this._send("event", "Internal Promotions", "click", promotionName);
        }, this._productClick = function(listName) {
            this._setAction("click", this._getActionFieldObject(null, null, null, null, null, null, listName, null, null)), 
            this._send("event", "UX", "click", listName);
        }, this._send = function(obj) {
            $window.ga && ($window.ga("send", obj), this._log("send", obj));
        }, this._pageView = function() {
            this._send("pageview");
        }, this._set = function(name, value) {
            $window.ga && ($window.ga("set", name, value), this._log("set", name, value));
        }, analyticsJS ? _createAnalyticsScriptTag() : _createScriptTag();
        var me = this;
        return trackRoutes && $rootScope.$on(pageEvent, function() {
            me._trackPage(getUrl());
        }), {
            _logs: me._logs,
            cookieConfig: cookieConfig,
            displayFeatures: displayFeatures,
            ecommerce: ecommerce,
            enhancedEcommerce: enhancedEcommerce,
            enhancedLinkAttribution: enhancedLinkAttribution,
            getUrl: getUrl,
            experimentId: experimentId,
            ignoreFirstPageLoad: ignoreFirstPageLoad,
            trackPage: function(url, title) {
                me._trackPage(url, title);
            },
            trackEvent: function(category, action, label, value) {
                me._trackEvent(category, action, label, value);
            },
            addTrans: function(transactionId, affiliation, total, tax, shipping, city, state, country, currency) {
                me._addTrans(transactionId, affiliation, total, tax, shipping, city, state, country, currency);
            },
            addItem: function(transactionId, sku, name, category, price, quantity) {
                me._addItem(transactionId, sku, name, category, price, quantity);
            },
            trackTrans: function() {
                me._trackTrans();
            },
            clearTrans: function() {
                me._clearTrans();
            },
            addProduct: function(productId, name, category, brand, variant, price, quantity, coupon, position) {
                me._addProduct(productId, name, category, brand, variant, price, quantity, coupon, position);
            },
            addPromo: function(productId, name, creative, position) {
                me._addPromo(productId, name, creative, position);
            },
            addImpression: function(productId, name, list, brand, category, variant, position, price) {
                me._addImpression(productId, name, list, brand, category, variant, position, price);
            },
            productClick: function(listName) {
                me._productClick(listName);
            },
            promoClick: function(promotionName) {
                me._promoClick(promotionName);
            },
            trackDetail: function() {
                me._setAction("detail"), me._pageView();
            },
            trackCart: function(action) {
                me._trackCart(action);
            },
            trackCheckout: function(step, option) {
                me._trackCheckOut(step, option);
            },
            trackTransaction: function(transactionId, affiliation, revenue, tax, shipping, coupon, list, step, option) {
                me._trackTransaction(transactionId, affiliation, revenue, tax, shipping, coupon, list, step, option);
            },
            setAction: function(action, obj) {
                me._setAction(action, obj);
            },
            send: function(obj) {
                me._send(obj);
            },
            pageView: function() {
                me._pageView();
            },
            set: function(name, value) {
                me._set(name, value);
            }
        };
    } ];
}), define("ngdir/angular-google-analytics", [ "angular" ], function() {}), define("common/js/modules/strings/stringsModule", [ "angular" ], function(ng) {
    return ng.module("commonModules.strings", []);
}), define("common/js/modules/strings/stringsService", [ "./stringsModule" ], function(module) {
    module.factory("StringsService", function() {
        function trim(str) {
            return str.replace(/^\s+|\s+$/g, "");
        }
        function trimToWord(str, len) {
            if (null == str || 0 >= len) return "";
            var chopped = str;
            return len && str.length > len && (chopped = chopped.substr(0, len - 4), chopped = chopped.replace(/\s+[^\s]*$/, ""), 
            chopped += " ..."), chopped;
        }
        function isBlank(str) {
            return null == str ? !0 : (str + "").match(/^[\s|\n]*$/) ? !0 : !1;
        }
        function capitalize(text) {
            return text ? text.substr(0, 1).toUpperCase() + text.substr(1) : "";
        }
        function camelCaseToUpUnderscore(fieldName) {
            return fieldName ? fieldName.replace(/([A-Z])/g, "_$1").toUpperCase() : "";
        }
        function upUnderscoreTocamelCase(fieldName) {
            if (!fieldName) return "";
            for (var words = fieldName.toLowerCase().split("_"), ret = "", i = 0; i < words.length; i++) {
                var word = words[i];
                i > 0 && (word = capitalize(word)), ret += word;
            }
            return ret;
        }
        function underscoreToHuman(fieldName) {
            if (!fieldName) return "";
            for (var words = fieldName.toLowerCase().split("_"), ret = "", i = 0; i < words.length; i++) ret += " " + words[i];
            return capitalize(ret.substr(1));
        }
        function camelCaseToHuman(fieldName) {
            return underscoreToHuman(camelCaseToUpUnderscore(fieldName));
        }
        function stripTags(str) {
            return str.replace(/<(div|br)>/gi, "\n").replace(/<[^>]*>/g, "").replace(/\&nbsp\;/g, " ").replace(/\&quot\;/g, '"').replace(/\&lt\;/g, "<").replace(/\&gt\;/g, ">").replace(/\&amp;\;/g, "&").replace(/\n[\n\s]*/g, "\n");
        }
        function brLines(str) {
            return str.replace(/\n/g, "<br>");
        }
        function pad(str, len, c) {
            for (var paddedStr = str.toString(); paddedStr.length < len; ) paddedStr = c + paddedStr;
            return paddedStr;
        }
        function mask(str) {
            var len = str.length;
            return 2 > len ? "**" : str.substring(0, 1) + pad("", len - 2, "*") + str.substring(len - 2, len - 1);
        }
        function compare(str1, str2) {
            return str1 > str2 ? 1 : str2 > str1 ? -1 : 0;
        }
        function randomString(len) {
            return Math.random().toString(36).substring(2, len + 2);
        }
        function isHebChar(char) {
            return char >= "" && "" >= char;
        }
        function readableNumber(number) {
            if (null == number) return "";
            var numberStr = trim(number + ""), readable = "";
            0 > number && (numberStr = numberStr.substr(1));
            for (var numberLength = numberStr.length, i = 0; numberLength > i; i++) readable = numberStr.charAt(numberLength - i - 1) + readable, 
            i != numberLength - 1 && i % 3 == 2 && (readable = "," + readable);
            return 0 > number && (readable = "-" + readable), readable;
        }
        function escapeHtml(str) {
            var entityMap = {
                "&": "&amp;",
                "<": "&lt;",
                ">": "&gt;",
                '"': "&quot;",
                "'": "&#39;",
                "/": "&#x2F;"
            };
            return String(str).replace(/[&<>"'\/]/g, function(s) {
                return entityMap[s];
            });
        }
        return {
            isBlank: isBlank,
            trim: trim,
            trimToWord: trimToWord,
            stripTags: stripTags,
            escapeHtml: escapeHtml,
            brLines: brLines,
            pad: pad,
            randomString: randomString,
            compare: compare,
            readableNumber: readableNumber,
            capitalize: capitalize,
            camelCaseToHuman: camelCaseToHuman,
            camelCaseToUpUnderscore: camelCaseToUpUnderscore,
            upUnderscoreTocamelCase: upUnderscoreTocamelCase,
            underscoreToHuman: underscoreToHuman,
            mask: mask,
            isHebChar: isHebChar
        };
    });
}), define("common/js/modules/strings/stringsFilters", [ "./stringsModule" ], function(module) {
    return module.filter("capitalize", [ "StringsService", function(StringsService) {
        return function(text) {
            return StringsService.capitalize(text);
        };
    } ]).filter("trim", [ "StringsService", function(StringsService) {
        return function(text, length) {
            return StringsService.trimToWord(text, length);
        };
    } ]).filter("stripTags", [ "StringsService", function(StringsService) {
        return function(text) {
            return StringsService.stripTags(text);
        };
    } ]).filter("brLines", [ "StringsService", function(StringsService) {
        return function(text) {
            return StringsService.brLines(text);
        };
    } ]).filter("strArr", [ "ArraysService", function(ArraysService) {
        return function(arr, separator) {
            return ArraysService.toString(arr, separator || ", ");
        };
    } ]).filter("camelCaseToUpUnderscore", [ "StringsService", function(StringsService) {
        return function(text) {
            return StringsService.camelCaseToUpUnderscore(text);
        };
    } ]).filter("underscoreToHuman", [ "StringsService", function(StringsService) {
        return function(text) {
            return StringsService.underscoreToHuman(text);
        };
    } ]).filter("camelToHuman", [ "StringsService", function(StringsService) {
        return function(text) {
            return StringsService.camelCaseToHuman(text);
        };
    } ]);
}), define("common/js/modules/strings/diffService", [ "./stringsModule" ], function(module) {
    module.factory("DiffService", function() {
        function getChangeInds(str1, str2) {
            if (!str1 || !str2 || str1 == str2) return null;
            var fromStart = findFirstChangeFromStart(str1, str2), fromEnd = findFirstChangeFromEnd(str1, str2, fromStart);
            return {
                fromStart: fromStart,
                fromEnd: fromEnd
            };
        }
        function findFirstChangeFromStart(str1, str2) {
            for (var str1Length = str1.length, str2Length = str2.length, i = 0; str1Length > i && str2Length > i; i++) {
                var c1 = str1.charAt(i), c2 = str2.charAt(i);
                if (c1 != c2) return i;
            }
            return Math.min(str1Length, str2Length);
        }
        function findFirstChangeFromEnd(str1, str2, changeStartInd) {
            for (var str1Length = str1.length, str2Length = str2.length, i = 0; str1Length > i && str2Length > i; i++) {
                var str1Ind = str1Length - 1 - i, str2Ind = str2Length - 1 - i;
                if (changeStartInd >= str1Ind || changeStartInd >= str1Ind) return i - 1;
                var c1 = str1.charAt(str1Ind), c2 = str2.charAt(str2Ind);
                if (c1 != c2) return i;
            }
            return Math.min(str1Length, str2Length);
        }
        return {
            getChangeInds: getChangeInds
        };
    });
}), define("common/js/modules/strings/index", [ "./stringsModule", "./stringsService", "./stringsFilters", "./diffService" ], function() {}), 
define("common/js/modules/utils/utilsModule", [ "angular" ], function(ng) {
    return ng.module("commonModules.utils", []);
}), define("common/js/modules/utils/externalHrefDirective", [ "./utilsModule" ], function(module) {
    module.directive("bsExternalHref", function() {
        return {
            restrict: "A",
            scope: {},
            link: function(scope, elem, attrs) {
                function update(urlAttr) {
                    if (urlAttr) {
                        var url = urlAttr;
                        0 == !url.indexOf("http") && (url = "http://" + url), elem.attr("href", url), elem.removeClass("inactive");
                    } else elem.attr("href", "javascript:{}"), elem.addClass("inactive");
                }
                attrs.$observe("bsExternalHref", function(urlAttr) {
                    update(urlAttr);
                });
            }
        };
    });
}), define("common/js/modules/utils/arraysService", [ "./utilsModule" ], function(module) {
    module.factory("ArraysService", function() {
        function getInd(list, value) {
            if (!list) return null;
            for (var i = 0; i < list.length; i++) if (list[i] == value) return i;
            return null;
        }
        function contains(list, value) {
            var ind = getInd(list, value);
            return null == ind ? !1 : !0;
        }
        function remove(list, value) {
            var ind = getInd(list, value);
            return null != ind && list.splice(ind, 1), ind;
        }
        function containsByKey(list, key, value) {
            var ind = getIndByKey(list, key, value);
            return null == ind ? !1 : !0;
        }
        function filteredByNonEmpty(list, key) {
            return filterByNotInValuesList(list, key, [ null, "" ]);
        }
        function filteredByEmpty(list, key) {
            return filterByValuesList(list, key, [ null, "" ]);
        }
        function filteredBy(list, key, val) {
            return getFilteredList(list, key, !0, val);
        }
        function filteredByNot(list, key, val) {
            return getFilteredList(list, key, !1, val);
        }
        function getFilteredList(list, key, equals, value) {
            return filterWithFunction(list, function(item) {
                var matches = item[key] == value;
                return equals && matches || !equals && !matches;
            });
        }
        function filterByValuesList(list, key, values, matchCondtion) {
            return filterWithFunction(list, function(item) {
                var value = item[key], inList = contains(values, value);
                switch (matchCondtion) {
                  case "matchIfNotInList":
                    return !inList;

                  default:
                    return inList;
                }
            });
        }
        function filterByNotInValuesList(list, key, values) {
            return filterByValuesList(list, key, values, "matchIfNotInList");
        }
        function filterWithFunction(list, fn) {
            if (!list) return [];
            for (var filtered = [], i = 0; i < list.length; i++) {
                var item = list[i];
                fn(item) && filtered.push(item);
            }
            return filtered;
        }
        function getByKey(list, key, value) {
            var ind = getIndByKey(list, key, value);
            return null == ind ? null : list[ind];
        }
        function getIndByKey(list, key, value) {
            if (!list) return null;
            for (var i = 0; i < list.length; i++) {
                var item = list[i];
                if (item) {
                    var itemVal = eval("item." + key);
                    if (itemVal == value) return i;
                }
            }
            return null;
        }
        function getNotNullKey(list, key) {
            if (!list) return null;
            for (var i = 0; i < list.length; i++) if (null != list[i][key]) return list[i];
            return null;
        }
        function getById(list, id) {
            return getByKey(list, "id", id);
        }
        function getIndById(list, id) {
            return getIndByKey(list, "id", id);
        }
        function removeById(list, id) {
            return removeByKey(list, "id", id);
        }
        function addOrReplace(list, obj) {
            var ind = remove(list, obj);
            insert(list, ind, obj);
        }
        function addIfNotExists(list, obj) {
            contains(list, obj) || list.push(obj);
        }
        function insert(list, ind, obj) {
            null != ind ? list.splice(ind, 0, obj) : list.push(obj);
        }
        function addOrReplaceById(list, obj) {
            addOrReplaceByKey(list, "id", obj);
        }
        function addOrReplaceByKey(list, key, obj) {
            var ind = removeByKey(list, key, obj[key]);
            insert(list, ind, obj);
        }
        function removeByKey(list, key, val) {
            if (!list) return null;
            for (var objToRemoveInd = null, removedObj = null, i = 0; i < list.length; i++) if (list[i][key] && list[i][key] == val) {
                objToRemoveInd = i, removedObj = list[i];
                break;
            }
            return removedObj && list.splice(objToRemoveInd, 1), objToRemoveInd;
        }
        function chop(list, size) {
            return list.length > size ? list.slice(0, size) : list;
        }
        function sort(list, key, desc, emptyBehaviour) {
            var keyParts = key.split(","), mainKey = keyParts[0], subKey = keyParts[1];
            return list.sort(function(a, b) {
                var aVal = eval("a." + mainKey), bVal = eval("b." + mainKey);
                if (aVal == bVal) {
                    if (!subKey) return 0;
                    aVal = eval("a." + subKey), bVal = eval("b." + subKey);
                }
                if (null != aVal && null != bVal || !emptyBehaviour) {
                    var greater = bVal > aVal ? -1 : 1;
                    return greater * (desc ? -1 : 1);
                }
                return "emptyFirst" == emptyBehaviour ? null == bVal ? 1 : -1 : "emptyLast" == emptyBehaviour ? null == bVal ? -1 : 1 : void 0;
            });
        }
        function shuffle(list) {
            for (var tempList = []; list.length > 0; ) tempList.push(popRandom(list));
            for (;tempList.length > 0; ) list.push(tempList.pop());
            return list;
        }
        function toString(list, separator) {
            if (!list || 0 == list.length) return "";
            var listStr = "";
            separator || (separator = ",");
            for (var i = 0; i < list.length; i++) listStr += separator + list[i];
            return listStr.substring(separator.length);
        }
        function toFieldsString(list, field, separator) {
            return toString(getAttributesList(list, field, separator));
        }
        function getMaxByKey(list, key) {
            if (!list) return null;
            var maxObj = null;
            for (var i in list) (null == maxObj || list[i][key] && list[i][key] > maxObj[key]) && (maxObj = list[i]);
            return maxObj;
        }
        function getMaxesByKey(list, key) {
            if (!list) return null;
            for (var maxesList = [], maxObj = null, i = 0; i < list.length; i++) null == maxObj || list[i][key] > maxObj[key] ? (maxObj = list[i], 
            maxesList = [ maxObj ]) : list[i][key] == maxObj[key] && maxesList.push(list[i][key]);
            return maxesList;
        }
        function popRandom(list) {
            var obj = getRandom(list);
            return remove(list, obj), obj;
        }
        function getRandom(list) {
            var randomInd = Math.floor(Math.random() * list.length), obj = list[randomInd];
            return obj;
        }
        function inverse(list) {
            for (var listCopy = []; list.length > 0; ) listCopy.push(list.pop());
            for (var i = 0; i < listCopy.length; i++) list.push(listCopy[i]);
        }
        function average(list, key) {
            return list ? sum(list, key) / list.length : null;
        }
        function sum(list, key) {
            if (!list) return null;
            for (var total = 0, i = 0; i < list.length; i++) {
                var elem = list[i];
                total += key ? elem[key] : elem;
            }
            return total;
        }
        function getAttributesList(list, key) {
            var attrList = [];
            if (!list) return [];
            for (var i = 0; i < list.length; i++) attrList.push(list[i][key]);
            return attrList;
        }
        function getIdsList(list) {
            return getAttributesList(list, "id");
        }
        function hasCommonElement(list1, list2) {
            if (!list1 || !list2 || 0 == list1.length || 0 == list2.length) return !1;
            for (var i = 0; i < list1.length; i++) for (var j = 0; j < list2.length; j++) if (list1[i] == list2[j]) return !0;
            return !1;
        }
        function replaceContent(oldList, newList) {
            var newListClone = newList ? newList.slice(0) : [];
            oldList.length = 0, Array.prototype.push.apply(oldList, newListClone);
        }
        function listToMap(list, key) {
            var map = {};
            if (list) for (var i = 0; i < list.length; i++) {
                var item = list[i];
                map[item[key]] = item;
            }
            return map;
        }
        function listToMapById(list) {
            return listToMap(list, "id");
        }
        function setPropertyFromMap(list, property, map, key, detaultVal) {
            if (list) for (var i = 0; i < list.length; i++) {
                var item = list[i];
                item[property] = map[item[key]] || detaultVal;
            }
        }
        function setPropertyFromMapById(list, property, map) {
            setPropertyFromMap(list, property, map, "id");
        }
        function setPropertyFromList(list, property, propertiesList, listKey, propertyKey, detaultVal) {
            if (list && propertiesList) for (var map = listToMap(propertiesList, propertyKey), i = 0; i < list.length; i++) {
                var item = list[i], itemKey = item[listKey];
                item[property] = map[itemKey] || detaultVal;
            }
        }
        function addOrReplaceAllByKey(oldList, newList, key) {
            for (var i = 0; i < newList.length; i++) {
                var newItem = newList[i];
                addOrReplaceByKey(oldList, newItem, key), newItem.existsInNewList = !0;
            }
        }
        return {
            shuffle: shuffle,
            sort: sort,
            inverse: inverse,
            chop: chop,
            insert: insert,
            addOrReplaceByKey: addOrReplaceByKey,
            addOrReplaceById: addOrReplaceById,
            addOrReplace: addOrReplace,
            addIfNotExists: addIfNotExists,
            replaceContent: replaceContent,
            addOrReplaceAllByKey: addOrReplaceAllByKey,
            getIndById: getIndById,
            getById: getById,
            getNotNullKey: getNotNullKey,
            getIndByKey: getIndByKey,
            getByKey: getByKey,
            getInd: getInd,
            removeByKey: removeByKey,
            removeById: removeById,
            remove: remove,
            sum: sum,
            average: average,
            getMaxesByKey: getMaxesByKey,
            getMaxByKey: getMaxByKey,
            filterByValuesList: filterByValuesList,
            filterWithFunction: filterWithFunction,
            getFilteredList: getFilteredList,
            filteredByNonEmpty: filteredByNonEmpty,
            filteredByEmpty: filteredByEmpty,
            filteredByNot: filteredByNot,
            filteredBy: filteredBy,
            containsByKey: containsByKey,
            contains: contains,
            hasCommonElement: hasCommonElement,
            getRandom: getRandom,
            popRandom: popRandom,
            listToMap: listToMap,
            listToMapById: listToMapById,
            setPropertyFromMap: setPropertyFromMap,
            setPropertyFromMapById: setPropertyFromMapById,
            setPropertyFromList: setPropertyFromList,
            getIdsList: getIdsList,
            getAttributesList: getAttributesList,
            toFieldsString: toFieldsString,
            toString: toString
        };
    });
}), Array.prototype.indexOf || (Array.prototype.indexOf = function(obj, start) {
    for (var i = start || 0, j = this.length; j > i; i++) if (this[i] === obj) return i;
    return -1;
}), define("common/js/modules/utils/dateUtilsService", [ "./utilsModule" ], function(module) {
    module.factory("DateUtilsService", function($q, $filter) {
        function utcDate(millis, withTime) {
            var date = new Date(millis);
            return withTime ? new Date(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate(), date.getUTCHours(), date.getUTCMinutes(), date.getUTCSeconds()) : new Date(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate());
        }
        function formatToServerDate(date, withTime) {
            var format = "yyyy-MM-dd";
            return withTime && (format += " HH:mm:ss"), $filter("date")(date, format);
        }
        function parseServerDate(dateStr) {
            var dateComponenets = dateStr.split(" "), dateParts = dateComponenets[0].split("-"), date = new Date(dateParts[0], dateParts[1] - 1, dateParts[2]);
            if (dateComponenets.length > 1) {
                var timeParts = dateComponenets[1].split(":");
                2 == timeParts.length && timeParts.push("00"), date = new Date(dateParts[0], dateParts[1] - 1, dateParts[2], timeParts[0], timeParts[1], timeParts[2]);
            }
            return date;
        }
        function parseMillisLeft(millisLeft) {
            var delta = Math.floor(millisLeft / 1e3), days = Math.floor(delta / 86400);
            delta -= 86400 * days;
            var hours = Math.floor(delta / 3600) % 24;
            delta -= 3600 * hours;
            var minutes = Math.floor(delta / 60) % 60;
            delta -= 60 * minutes;
            var seconds = Math.floor(delta % 60);
            return {
                days: days,
                hours: hours,
                minutes: minutes,
                seconds: seconds
            };
        }
        return {
            utcDate: utcDate,
            formatToServerDate: formatToServerDate,
            parseServerDate: parseServerDate,
            parseMillisLeft: parseMillisLeft
        };
    });
}), define("common/js/modules/utils/index", [ "./utilsModule", "./externalHrefDirective", "./arraysService", "./dateUtilsService" ], function() {}), 
define("common/js/modules/domUtils/domUtilsModule", [ "angular" ], function(ng) {
    return ng.module("commonModules.domUtils", []);
}), define("common/js/modules/domUtils/domUtilsService", [ "./domUtilsModule" ], function(module) {
    module.factory("DomUtilsService", function($q, I18nService, OsInfoService) {
        function getParentElement(element, tagName, attribute, value) {
            for (var elem = element, result = null; null == result && "body" != elem[0].tagName.toLowerCase(); ) elem = elem.parent(), 
            elem[0].tagName.toLowerCase() != tagName.toLowerCase() || attribute && elem.attr(attribute) != value || (result = elem);
            return result;
        }
        function insertBefore(existingElement, elementToAdd) {
            existingElement.parent()[0].insertBefore(elementToAdd[0], existingElement[0]);
        }
        function findAny(parent, selectors) {
            for (var elements = [], i = 0; i < selectors.length; i++) for (var selectedElements = parent.find(selectors[i]), j = 0; j < selectedElements.length; j++) elements.push(angular.element(selectedElements[i]));
            return elements;
        }
        function findInputByName(parent, inputName) {
            for (var inputs = findAny(parent, [ "input", "select", "textarea" ]), i = 0; i < inputs.length; i++) {
                var input = inputs[i];
                if (input.attr("name") == inputName) return input;
            }
            return null;
        }
        function loadImage(src) {
            var deferred = $q.defer(), image = angular.element(new Image());
            return image.bind("load", function() {
                deferred.resolve({
                    size: {
                        width: image[0].naturalWidth,
                        height: image[0].naturalHeight
                    },
                    src: src
                });
            }), image.bind("error", function() {
                deferred.reject();
            }), image.attr("src", src), deferred.promise;
        }
        function isTextInputFocused() {
            var activeElement = document.activeElement;
            return !activeElement || "input" != activeElement.tagName.toLowerCase() && "textarea" != activeElement.tagName.toLowerCase() ? !1 : !0;
        }
        function getWindowScroll() {
            var doc = document.documentElement, left = (window.pageXOffset || doc.scrollLeft) - (doc.clientLeft || 0), top = (window.pageYOffset || doc.scrollTop) - (doc.clientTop || 0);
            return {
                left: left,
                top: top
            };
        }
        function link(href, text, target) {
            var targetStr = target ? "target='" + target + "'" : "";
            return "<a dir='ltr' href='" + href + "' " + targetStr + ">" + text + "</a>";
        }
        function noWrap(text, dir) {
            return "<span " + (dir ? "dir='" + dir : "") + "' style='white-space:nowrap'>" + text + "</span>";
        }
        function getDirection(lang) {
            switch (lang || I18nService.getCurrentLang()) {
              case "he":
                return "rtl";

              default:
                return "ltr";
            }
        }
        function getTag(tagName, attributeName, attributeValue) {
            for (var tags = document.getElementsByTagName(tagName), i = 0; i < tags.length; i++) {
                var tag = tags[i];
                if (tag.getAttribute(attributeName) == attributeValue) return tag;
            }
        }
        function setTagProp(tagName, attributeName, attributeValue, propName, propValue) {
            var tag = getTag(tagName, attributeName, attributeValue);
            tag || (tag = document.createElement(tagName), tag.setAttribute(attributeName, attributeValue), 
            document.getElementsByTagName("head")[0].appendChild(tag)), tag.setAttribute(propName, propValue);
        }
        function removeTag(tagName, attributeName, attributeValue) {
            var tag = getTag(tagName, attributeName, attributeValue);
            tag && tag.remove();
        }
        function setMetaTag(attributeName, attributeValue, content) {
            setTagProp("meta", attributeName, attributeValue, "content", content);
        }
        function removeMetaTag(attributeName, attributeValue) {
            removeTag("meta", attributeName, attributeValue);
        }
        function getBoundingRect(element) {
            var rect = element[0].getBoundingClientRect(), bodyZoom = document.body.style.zoom;
            if (bodyZoom) {
                var scale = 1 * bodyZoom.replace("%", "") / 100;
                return {
                    top: rect.top * scale,
                    left: rect.left * scale,
                    width: rect.width * scale,
                    height: rect.height * scale
                };
            }
            return rect;
        }
        function scrollToElementTop(element, offset) {
            var scrollOffset = getBoundingRect(element).top;
            scrollOffset += window.pageYOffset - document.documentElement.clientTop, OsInfoService.isAndroid() && GlobalConfig.isMobileApp && (scrollOffset += 24), 
            offset && (scrollOffset += offset), window.scrollTo(0, scrollOffset);
        }
        function scrollToElementBottom(element, offset) {
            scrollToElementTop(element, getBoundingRect(element).height + (offset || 0));
        }
        return {
            getParentElement: getParentElement,
            insertBefore: insertBefore,
            setTagProp: setTagProp,
            setMetaTag: setMetaTag,
            removeMetaTag: removeMetaTag,
            findInputByName: findInputByName,
            isTextInputFocused: isTextInputFocused,
            getWindowScroll: getWindowScroll,
            getBoundingRect: getBoundingRect,
            scrollToElementTop: scrollToElementTop,
            scrollToElementBottom: scrollToElementBottom,
            getDirection: getDirection,
            loadImage: loadImage,
            link: link,
            noWrap: noWrap
        };
    });
}), define("common/js/modules/domUtils/enterKeyActionDirective", [ "./domUtilsModule" ], function(module) {
    module.directive("bsEnterKeyAction", function() {
        return {
            restrict: "A",
            scope: {
                action: "&bsEnterKeyAction"
            },
            link: function(scope, element) {
                element.bind("keydown keypress", function(event) {
                    13 === event.which && (scope.action(), setTimeout(function() {
                        scope.$apply();
                    }, 30), event.preventDefault());
                });
            }
        };
    });
}), define("common/js/modules/domUtils/viewPortService", [ "./domUtilsModule" ], function(module) {
    module.factory("ViewPortService", function($rootScope, $timeout, DomUtilsService, OsInfoService) {
        function onResize() {
            if (!DomUtilsService.isTextInputFocused()) {
                $timeout.cancel(mResizeTriggerTimer);
                {
                    document.activeElement;
                }
                mResizeTriggerTimer = $timeout(function() {
                    DomUtilsService.isTextInputFocused() || (adjustViewPortAccordingToOrientation(), 
                    mViewPortInfo.orientation && mViewPortInfo.orientation != getOrientation(), updateViewportInfo());
                }, 300);
            }
        }
        function updateViewportInfo() {
            mViewPortInfo.innerWidth = window.innerWidth, mViewPortInfo.innerHeight = window.innerHeight, 
            window.innerWidth < 1200 && (mViewPortInfo.mobileMedia = !0, mViewPortInfo.pcMedia = !1), 
            window.innerWidth >= 1200 && (mViewPortInfo.pcMedia = !0, mViewPortInfo.mobileMedia = !1), 
            mViewPortInfo.isWideDevice = isWideDevice(), mViewPortInfo.orientation = getOrientation(), 
            mViewPortInfo.clientWidth = getClientWidth(), mViewPortInfo.contentWidth = Math.min(mViewPortInfo.clientWidth, 1024), 
            mViewPortInfo.clientHeight = getClientHeight(), mViewPortInfo.maxWidth = getMaxWidth(), 
            $rootScope.viewPort = mViewPortInfo, mDebugInfo.viewPort = mViewPortInfo;
        }
        function adjustViewPortAccordingToOrientation() {
            var width;
            width = isLandscapeOrientation() ? 900 : mViewPortInfo.minInitialDimenstion < 400 ? 500 : 900;
            var viewportChanged = !1;
            if (OsInfoService.isAndroid() && GlobalConfig.isMobileApp) {
                var initialWidth = isLandscapeOrientation() ? mInitialHeight : mInitialWidth, newZoom = Math.round(1e4 * initialWidth / width) / 100 + "%";
                (newZoom != document.body.style.zoom || width != mViewPortWidth) && (document.body.style.zoom = newZoom, 
                document.body.style.width = width + "px", viewportChanged = !0);
            } else if (OsInfoService.isIos()) {
                var prevWidth = mViewPortWidth || window.innerWidth, scale = Math.round(100 * prevWidth / width) / 100;
                scale = Math.max(.5, scale);
                var viewPortWidthContent = "width=" + width;
                mViewPortWidth && mViewPortInfo.orientation == getOrientation() || (viewPortWidthContent += ", initial-scale=" + scale + ", maximum-scale=" + scale), 
                GlobalConfig.isMobileApp && (viewPortWidthContent += ", user-scalable=no"), mViewPortElement.setAttribute("content", viewPortWidthContent), 
                viewportChanged = !0;
            } else width != mViewPortWidth && (mViewPortElement.setAttribute("content", "width=" + width), 
            viewportChanged = !0);
            mViewPortWidth = width, $rootScope.viewPort.viewPortWidth = mViewPortWidth;
        }
        function bindViewPortSizeToWindowWidth() {
            mViewPortInfo.minInitialDimenstion = Math.min(window.innerWidth, window.innerHeight), 
            mInitialWidth = Math.min(window.innerWidth, window.innerHeight), mInitialHeight = Math.max(window.innerWidth, window.innerHeight), 
            mViewPortElement = document.querySelector('meta[name="viewport"]'), $rootScope.viewPortDebugInfo = mDebugInfo, 
            window.addEventListener("resize", onResize), updateViewportInfo(), onResize(), $timeout(updateViewportInfo, 1e3);
        }
        function getWindowScroll() {
            var doc = document.documentElement, left = (window.pageXOffset || doc.scrollLeft) - (doc.clientLeft || 0), top = (window.pageYOffset || doc.scrollTop) - (doc.clientTop || 0);
            return {
                left: left,
                top: top
            };
        }
        function getClientWidth() {
            return GlobalConfig.isMobileApp && mViewPortWidth ? mViewPortWidth : window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth;
        }
        function getMaxWidth() {
            return Math.max(Math.max(window.innerWidth, mViewPortWidth), document.getElementById("mainView").offsetWidth);
        }
        function getViewPortWidth() {
            return mViewPortWidth || getClientWidth();
        }
        function getClientHeight() {
            return OsInfoService.isAndroid() && GlobalConfig.isMobileApp ? window.innerHeight * mViewPortWidth / window.innerWidth : window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;
        }
        function isWideDevice() {
            return getClientWidth() < 500 ? !1 : OsInfoService.isMobile() ? !1 : !0;
        }
        function isLandscapeOrientation() {
            return window.innerWidth > window.innerHeight ? !0 : !1;
        }
        function getOrientation() {
            return isLandscapeOrientation() ? "landscape" : "portrait";
        }
        var mViewPortWidth, mInitialWidth, mInitialHeight, mViewPortElement = null, mDebugInfo = {
            resizeCount: 0
        }, mViewPortInfo = {}, mResizeTriggerTimer = null;
        return {
            bindViewPortSizeToWindowWidth: bindViewPortSizeToWindowWidth,
            clientHeight: getClientHeight,
            clientWidth: getClientWidth,
            updateViewportInfo: updateViewportInfo,
            getMaxWidth: getMaxWidth,
            getViewPortWidth: getViewPortWidth,
            getWindowScroll: getWindowScroll,
            isWideDevice: isWideDevice
        };
    });
}), define("common/js/modules/domUtils/slideToggleDirective", [ "./domUtilsModule" ], function(module) {
    module.directive("slideable", function() {
        return {
            restrict: "C",
            compile: function(element) {
                var contents = element.html();
                return element.html('<div class="slideable_content" style="margin:0 !important; padding:0 !important" >' + contents + "</div>"), 
                function(scope, element, attrs) {
                    attrs.duration = attrs.duration ? attrs.duration : "1s", attrs.easing = attrs.easing ? attrs.easing : "ease-in-out", 
                    element.css({
                        overflow: "hidden",
                        height: "0px",
                        transitionProperty: "height",
                        transitionDuration: attrs.duration,
                        transitionTimingFunction: attrs.easing
                    }), element[0].addEventListener("webkitTransitionEnd", function() {
                        "0px" != element[0].style.height && setTimeout(function() {
                            element.css({
                                transitionProperty: "none",
                                height: ""
                            });
                        }, 10);
                    }, !1);
                };
            }
        };
    }).directive("slideToggle", function() {
        return {
            restrict: "A",
            link: function(scope, element, attrs) {
                function init() {
                    attrs.expanded = !1, target = document.querySelector(attrs.slideToggle), content = target.querySelector(".slideable_content");
                }
                function slideUp() {
                    target.style.height = content.clientHeight + "px", setTimeout(function() {
                        angular.element(target).css({
                            transitionProperty: "height",
                            height: "0px"
                        }), content.classList.remove("expanded"), element.removeClass("expanded"), attrs.expanded = !1;
                    }, 10);
                }
                function slideDown() {
                    init(), content.style.border = "1px solid rgba(0,0,0,0)";
                    var y = content.clientHeight;
                    content.style.border = 0, target.style.height = y + "px", content.classList.add("expanded"), 
                    element.addClass("expanded"), attrs.expanded = !0;
                }
                var target, content;
                element.bind("click", function() {
                    attrs.expanded ? slideUp() : slideDown();
                }), element.bind("slideUp", slideUp);
            }
        };
    });
}), define("common/js/modules/domUtils/autoFontSizeDirective", [ "./domUtilsModule" ], function(module) {
    module.directive("bsAutoFontSize", function($window) {
        return {
            template: '<div data-role="inner" ng-transclude></div>',
            transclude: !0,
            link: {
                post: function(scope, elem, attrs) {
                    function shrinkOrGrow() {
                        var i = 0;
                        if (adjustLineHeightAndInlineImages(), fontTooBig() && options.shrink) for (;fontTooBig() && 100 > i && fontSizeI() >= options.minSize; ) setFontSize(fontSizeI() - 1), 
                        i += 1; else {
                            if (!fontTooSmall() || !options.grow) return;
                            for (;fontTooSmall() && 100 > i; ) setFontSize(fontSizeI() + 1), i += 1;
                        }
                        scope.$emit("auto-font-size:resized", {
                            fontSize: fontSizeI(),
                            elem: elem
                        });
                    }
                    function css(el, prop) {
                        return $window.getComputedStyle ? $window.getComputedStyle(el[0]).getPropertyValue(prop) : void 0;
                    }
                    function fontSizeI() {
                        var fontSize = css(inner, "font-size");
                        return Number(fontSize.match(/\d+/)[0]);
                    }
                    function setFontSize(size) {
                        inner[0].style.fontSize = size + "px", adjustLineHeightAndInlineImages();
                    }
                    function adjustLineHeightAndInlineImages() {
                        if (fontSizeAdjusted()) {
                            var size = fontSizeI();
                            inner[0].style.lineHeight = size + 2 + "px";
                            var images = inner[0].querySelectorAll("img");
                            angular.forEach(images, function(img) {
                                img.style.height(size + 2 + "px");
                            });
                        }
                    }
                    function fontSizeAdjusted() {
                        return !!inner[0].style.fontSize;
                    }
                    function fontTooBig() {
                        return inner[0].offsetWidth > options.maxWidth || inner[0].offsetWidth > elem[0].offsetWidth || inner[0].offsetHeight > elem[0].offsetHeight;
                    }
                    function fontTooSmall() {
                        return inner[0].offsetWidth < elem[0].offsetWidth || inner[0].offsetHeight < elem[0].offsetHeight;
                    }
                    var providedOptions = scope.$eval(attrs.bsAutoFontSize) || {};
                    if (providedOptions.maxWidth) {
                        var options = angular.extend({
                            shrink: !0,
                            grow: !0,
                            minSize: 1,
                            maxWidth: null
                        }, providedOptions), inner = angular.element(elem[0].querySelector("div[data-role]"));
                        scope.$watch(shrinkOrGrow);
                    }
                }
            }
        };
    });
}), define("common/js/modules/domUtils/textDirectionDirective", [ "./domUtilsModule" ], function(module) {
    module.directive("bsTextDirection", function($rootScope, DomUtilsService) {
        return {
            restrict: "A",
            link: function(scope, element, attrs) {
                function setDirection() {
                    var direction = DomUtilsService.getDirection(lang);
                    element.attr("dir", direction);
                }
                var lang = attrs.lang;
                $rootScope.$on("i18n.languageChanged", setDirection), setDirection();
            }
        };
    });
}), define("common/js/modules/domUtils/scrollOnDirective", [ "./domUtilsModule" ], function(module) {
    module.directive("bsScrollOn", function($timeout, $rootScope, PathsService, OsInfoService, DomUtilsService) {
        return {
            restrict: "A",
            scope: {
                bsScrollOn: "=",
                scrollToParent: "=",
                watchedValue: "=",
                offset: "=",
                delay: "="
            },
            link: function(scope, element) {
                function scrollIfConditionMet() {
                    if (1 == scope.watchedValue || scope.bsScrollOn) {
                        var elementToScroll = scope.scrollToParent ? element.parent : element;
                        DomUtilsService.scrollToElementTop(elementToScroll, scope.offset || -100);
                    }
                }
                $timeout(scrollIfConditionMet, 50 | scope.delay), null != scope.watchedValue && scope.$watch("watchedValue", scrollIfConditionMet);
            }
        };
    });
}), define("common/js/modules/domUtils/backButtonDirective", [ "./domUtilsModule" ], function(module) {
    module.directive("bsBackButton", function($rootScope, $window) {
        return {
            restrict: "A",
            link: function(scope, elem) {
                elem.bind("click", function() {
                    $window.history.back();
                });
            }
        };
    });
}), define("common/js/modules/domUtils/bsWidthLimitDirective", [ "./domUtilsModule" ], function(module) {
    module.directive("bsWidthLimit", function($parse, $timeout, ViewPortService) {
        return {
            restrict: "A",
            scope: {
                params: "=bsWidthLimit"
            },
            link: function(scope, element) {
                if (scope.params.lessThen) {
                    var parts = scope.params.lessThen.split(" "), what = parts[0], maxWitdh = 0;
                    "screenWidth" == what && (maxWitdh = ViewPortService.clientWidth());
                    var operand = parts[1], offset = parts[2];
                    switch (operand) {
                      case "+":
                        maxWitdh += offset;
                        break;

                      case "-":
                        maxWitdh -= offset;
                    }
                    element.css({
                        maxWidth: maxWitdh + "px"
                    });
                }
            }
        };
    });
}), define("common/js/modules/domUtils/focusOnDirective", [ "./domUtilsModule" ], function(module) {
    module.directive("bsFocusOn", function(PathsService, $parse, $timeout) {
        return {
            restrict: "A",
            scope: {
                bsFocusOn: "="
            },
            link: function(scope, element) {
                function focusIfConditionMet() {
                    scope.bsFocusOn && (element[0].focus(), $timeout(function() {
                        element[0].focus();
                    }, 20));
                }
                scope.$watch("bsFocusOn", focusIfConditionMet);
            }
        };
    });
}), define("common/js/modules/domUtils/linkableTextDirective", [ "./domUtilsModule" ], function(module) {
    module.directive("bsLinkableText", function($rootScope, I18nService) {
        return {
            restrict: "E",
            scope: {
                options: "="
            },
            link: function(scope, elem) {
                function display() {
                    elem.html(I18nService.getText(scope.options.textKey, scope.options.textParams));
                    for (var links = elem.find("a"), i = 0; i < links.length; i++) !function(link) {
                        link.bind("click", function() {
                            scope.options.onLinkClick(link.attr("code"));
                        });
                    }(angular.element(links[i]));
                }
                display();
            }
        };
    });
}), define("common/js/modules/domUtils/scrollToTop", [ "./domUtilsModule" ], function(module) {
    module.directive("bsScrollToTop", function() {
        return {
            restrict: "A",
            link: function() {
                window.scrollTo(0, 0);
            }
        };
    });
}), define("common/js/modules/domUtils/paginationDirective", [ "./domUtilsModule" ], function(module) {
    module.directive("bsPagination", function($timeout, $rootScope, $stateParams, PathsService) {
        return {
            restrict: "E",
            replace: !0,
            scope: {
                pagesData: "=",
                hrefPages: "=",
                availableWidth: "=",
                onCurrentPageChange: "&"
            },
            link: function(scope, element) {
                function updateDisplay() {
                    scope.currentLang = $rootScope.currentLang, rebuildNavigationBar(), scope.shouldShow = scope.pagesData.itemsCount > scope.pagesData.itemsPerPage;
                }
                function setBaseHref() {
                    var hashValue = window.location.hash;
                    scope.baseHref = $stateParams.page ? hashValue.substr(0, hashValue.lastIndexOf("/")) + "/" : hashValue;
                }
                function getMaxButtonsNumber() {
                    var parent = element.parent()[0];
                    if (parent) {
                        var buttonWidth = $rootScope.viewPort.mobileMedia ? 60 : 50, availableWidth = scope.availableWidth || Math.min(800, parent.offsetWidth), maxButtons = Math.floor(availableWidth / buttonWidth) - 2;
                        return 3 > maxButtons && (maxButtons = 3), maxButtons;
                    }
                }
                function getPageNavigationInfo(totalItems, itemsPerPage, currentPage, maxDisplayedPages) {
                    var firstPage = 1, totalPages = Math.ceil(totalItems / itemsPerPage);
                    maxDisplayedPages >= totalPages ? lastPage = totalPages : maxDisplayedPages / 2 > currentPage ? lastPage = maxDisplayedPages : currentPage > totalPages - maxDisplayedPages / 2 ? (lastPage = totalPages, 
                    firstPage = lastPage - maxDisplayedPages + 1) : (lastPage = currentPage + Math.floor(maxDisplayedPages / 2), 
                    firstPage = lastPage - maxDisplayedPages + 1);
                    var startInd = (currentPage - 1) * itemsPerPage, endInd = Math.min(startInd + itemsPerPage - 1, totalItems - 1);
                    return {
                        firstPage: firstPage,
                        lastPage: lastPage,
                        totalPages: totalPages,
                        currentPageFirstInd: startInd,
                        currentPageLastInd: endInd,
                        currentPage: currentPage,
                        prevPage: 1 == currentPage ? null : currentPage - 1,
                        nextPage: currentPage == totalPages ? null : currentPage + 1
                    };
                }
                function rebuildNavigationBar() {
                    scope.links = [];
                    var pagesData = scope.pagesData, maxButtons = getMaxButtonsNumber(), navPageInfo = getPageNavigationInfo(pagesData.itemsCount, pagesData.itemsPerPage, 1 * pagesData.currentPage, maxButtons);
                    if (navPageInfo.totalPages > 1) {
                        scope.links.push({
                            page: navPageInfo.prevPage,
                            isPrev: !0,
                            html: "&nbsp;"
                        });
                        for (var i = navPageInfo.firstPage; i <= navPageInfo.lastPage; i++) scope.links.push({
                            page: i,
                            isCurrent: i == pagesData.currentPage,
                            html: i
                        });
                        if (maxButtons > 4) {
                            1 != scope.links[1].page && (scope.links[1].page = 1, scope.links[1].html = 1, scope.links[2].html = "...");
                            var lastLinkInd = scope.links.length - 1;
                            scope.links[lastLinkInd].page != navPageInfo.totalPages && (scope.links[lastLinkInd].page = navPageInfo.totalPages, 
                            scope.links[lastLinkInd].html = navPageInfo.totalPages, scope.links[lastLinkInd - 1].html = "...");
                        }
                        scope.links.push({
                            page: navPageInfo.nextPage,
                            isNext: !0,
                            html: "&nbsp;"
                        });
                    }
                }
                function onDataChange(newValue, oldValue) {
                    oldValue && oldValue.itemsPerPage != newValue.itemsPerPage && (scope.pagesData.currentPage = 1), 
                    scope.baseHref && $stateParams.page && scope.pagesData.currentPage != $stateParams.page && (window.location.href = scope.baseHref + scope.pagesData.currentPage), 
                    updateDisplay();
                }
                $rootScope.$on("viewPort.windowSizeChanged", function() {
                    updateDisplay(), $timeout(updateDisplay, 100);
                }), scope.onLinkClick = function(link) {
                    !scope.hrefPages && link.page && (scope.pagesData.currentPage = link.page), scope.onCurrentPageChange && scope.onCurrentPageChange();
                }, scope.hrefPages && setBaseHref(), scope.$watchCollection("pagesData", onDataChange), 
                updateDisplay();
            },
            templateUrl: PathsService.commonTemplatePath("elements/pagination")
        };
    });
}), define("common/js/modules/domUtils/touchedClassDirective", [ "./domUtilsModule" ], function(module) {
    module.directive("bsTouchedClass", function($timeout) {
        return {
            restrict: "A",
            scope: {
                touchedClassName: "=bsTouchedClass"
            },
            link: function(scope, element) {
                function addTouchedClass() {
                    $timeout.cancel(timer), element.addClass(scope.touchedClassName);
                }
                function removeTouchedClass() {
                    $timeout.cancel(timer), timer = $timeout(function() {
                        element.removeClass(scope.touchedClassName);
                    }, 300);
                }
                var timer;
                element.bind("touchstart", addTouchedClass), element.bind("touchend", removeTouchedClass), 
                element.bind("touchcancel", removeTouchedClass);
            }
        };
    });
}), define("common/js/modules/domUtils/checkBidmoodDirective", [ "./domUtilsModule" ], function(module) {
    module.directive("bsCheckBidmood", function() {
        return {
            restrict: "A",
            link: function(scope, element) {
                GlobalConfig.bidmoodEnv && element.addClass("bidmood");
            }
        };
    });
}), define("common/js/modules/domUtils/index", [ "./domUtilsModule", "./domUtilsService", "./enterKeyActionDirective", "./viewPortService", "./slideToggleDirective", "./autoFontSizeDirective", "./textDirectionDirective", "./scrollOnDirective", "./backButtonDirective", "./bsWidthLimitDirective", "./focusOnDirective", "./linkableTextDirective", "./scrollToTop", "./paginationDirective", "./touchedClassDirective", "./checkBidmoodDirective" ], function() {}), 
define("common/js/modules/api/apiModule", [ "angular", "../utils/index" ], function(ng) {
    return ng.module("commonModules.api", [ "commonModules.utils" ]);
}), define("common/js/modules/api/apiInterceptor", [ "./apiModule", "angular" ], function(module) {
    module.factory("ApiInterceptor", [ "$q", "$location", "$log", "$rootScope", function($q, $location, $log, $rootScope) {
        function isApiRequest(config) {
            return -1 == config.url.indexOf(GlobalConfig.apiBase) ? !1 : -1 != config.url.split("?")[0].indexOf(".properties") ? !1 : !0;
        }
        return {
            response: function(response) {
                if (isApiRequest(response.config)) {
                    if (!angular.isObject(response.data)) return $log.warn("Bad resopnse:" + response.data), 
                    response.data = {
                        errorType: "INVALID_RESPONSE",
                        message: "Invalid response from server"
                    }, $q.reject(response);
                    if (response.data.errorType) {
                        switch ($log.warn("Error while invoking api. " + response.data.message), response.data.errorType) {
                          case "SESSION_ENDED":
                            $rootScope.$broadcast("sessionEnded");
                            break;

                          case "NOT_ALLOWED":
                            $rootScope.$broadcast("notAllowed");
                        }
                        return $q.reject(response);
                    }
                }
                return response;
            }
        };
    } ]);
}), define("common/js/modules/api/apiService", [ "./apiModule" ], function(module) {
    module.factory("ApiService", function($http, $log, SessionInfo) {
        function callApi(param1, param2, param3) {
            return angular.isObject(param1) ? callApiWithOptions(param1) : callApiWithParams(param1, param2, param3);
        }
        function callApiWithParams(api, data, method) {
            return callApiWithOptions({
                api: api,
                method: method,
                data: data
            });
        }
        function callApiWithOptions(options) {
            var method = options.method;
            method || (method = "GET");
            var data = angular.copy(options.data);
            data || (data = {});
            var params = {};
            if ("GET" == method && (params = data, data = null, "object" != typeof params)) return void $log.warn("Bad request: must send object to a get request, but found " + typeof params + " (" + params + ")");
            SessionInfo.sessionId && (params.sessionId = SessionInfo.sessionId);
            var isOldIe = -1 != navigator.appVersion.indexOf("MSIE"), apiBase = options.useCdnCache && !isOldIe ? GlobalConfig.cachedApiBase : GlobalConfig.apiBase, apiPath = options.api;
            "/" == apiPath.charAt(0) && "/" == apiBase.charAt(apiBase.length - 1) && (apiPath = apiPath.substring(1));
            var url = apiBase + apiPath, request = {
                method: method,
                url: url,
                data: data,
                params: params
            };
            "postForm" == options.method && (request.headers = {
                "Content-Type": "application/x-www-form-urlencoded"
            }, request.method = "POST", request.data = serializeData(request.data));
            var promise = $http(request);
            return promise;
        }
        function serializeData(data) {
            if (!angular.isObject(data)) return null == data ? "" : data.toString();
            var buffer = [];
            for (var name in data) if (data.hasOwnProperty(name)) {
                var value = data[name];
                buffer.push(encodeURIComponent(name) + "=" + encodeURIComponent(null == value ? "" : value));
            }
            var source = buffer.join("&").replace(/%20/g, "+");
            return source;
        }
        return {
            callApi: callApi
        };
    });
}), define("common/js/modules/api/cachedApiService", [ "./apiModule" ], function(module) {
    module.factory("CachedApiService", function($q, ApiService, ArraysService) {
        function setEntityApisOptions(entityName, apisMap) {
            mEntityApisOptions[entityName] = apisMap;
        }
        function setEntityApiUrl(entityName, apiName, url) {
            mEntityApisOptions[entityName][apiName] != url && (clearEntitiyCache(entityName), 
            mEntityApisOptions[entityName][apiName] = url);
        }
        function cachedPromiseWrap(cachedData) {
            var promise = {};
            return promise.success = function(fn) {
                return fn(cachedData), promise;
            }, promise.then = function(fn) {
                return fn(cachedData), promise;
            }, promise.error = function(fn) {
                return fn(), promise;
            }, promise;
        }
        function getListName(entityName) {
            return entityName + "List";
        }
        function getCachedEntitiesList(entityName) {
            return mCache[getListName(entityName)];
        }
        function getList(entityName, reload) {
            return reload && clearEntitiyCache(entityName), callCachableApi(getListName(entityName), mEntityApisOptions[entityName].getListUrl);
        }
        function getCachedEntity(entityName, entityId) {
            var list = getCachedEntitiesList(entityName);
            return list ? ArraysService.getById(list, entityId) : null;
        }
        function addHttpPromiseHandlers(deferred) {
            deferred.promise.success = function(fn) {
                deferred._bsData ? fn(deferred._bsData) : deferred._bsSuccessFn = fn;
            }, deferred.promise.then(function(response) {
                deferred._bsSuccessFn ? deferred._bsSuccessFn(response.data) : deferred._bsData = response.data;
            });
        }
        function getEntityFromList(entityName, entityId) {
            var deferred = $q.defer();
            return getList(entityName).then(function() {
                deferred.resolve({
                    data: getCachedEntity(entityName, entityId)
                });
            }), addHttpPromiseHandlers(deferred), deferred.promise;
        }
        function saveEntity(entityName, entity) {
            var promise = ApiService.callApi(mEntityApisOptions[entityName].saveUrl, entity, "post");
            return promise.success(function(updatedEntity) {
                updateCachedEntity(entityName, entity.id, updatedEntity);
            }), promise;
        }
        function updateCachedEntity(entityName, entityId, entity) {
            var list = getCachedEntitiesList(entityName);
            list && (entityId ? angular.copy(entity, getCachedEntity(entityName, entityId)) : list.push(entity));
        }
        function removeEntity(entityName, entityId) {
            var apiOptions = mEntityApisOptions[entityName], removeOptions = {
                api: apiOptions.removeUrl,
                data: {}
            }, idKey = apiOptions.idKey;
            return idKey || (idKey = "id"), removeOptions.data[idKey] = entityId, ApiService.callApi(removeOptions).success(function() {
                removeEntityFromCache(entityName, entityId);
            });
        }
        function removeEntityFromCache(entityName, entityId) {
            var list = getCachedEntitiesList(entityName);
            list && ArraysService.removeById(list, entityId);
        }
        function clearEntitiyCache(entityName) {
            delete mCache[getListName(entityName)];
        }
        function touchEntity(entityName, entityId) {
            var entity = getCachedEntity(entityName, entityId);
            entity && (entity.lastTouch = new Date().getTime());
        }
        function callCachableApi(cacheKey, param1, param2, param3) {
            var data = mCache[cacheKey];
            if (data) return cachedPromiseWrap(data);
            var promise = ApiService.callApi(param1, param2, param3);
            return promise.success(function(response) {
                mCache[cacheKey] = response;
            }), promise;
        }
        var mCache = {}, mEntityApisOptions = {};
        return {
            setEntityApisOptions: setEntityApisOptions,
            setEntityApiUrl: setEntityApiUrl,
            getList: getList,
            clearEntitiyCache: clearEntitiyCache,
            getEntityFromList: getEntityFromList,
            getCachedEntity: getCachedEntity,
            getCachedEntitiesList: getCachedEntitiesList,
            saveEntity: saveEntity,
            removeEntity: removeEntity,
            touchEntity: touchEntity,
            callCachableApi: callCachableApi,
            cachedPromiseWrap: cachedPromiseWrap,
            _cache: mCache
        };
    });
}), define("common/js/modules/api/index", [ "./apiInterceptor", "./apiModule", "./apiService", "./cachedApiService" ], function() {}), 
define("common/js/modules/system/systemModule", [ "angular", "../utils/index" ], function(ng) {
    return ng.module("commonModules.system", []);
}), define("common/js/modules/system/localStorageService", [ "./systemModule" ], function(module) {
    module.factory("LocalStorageService", function($rootScope, LogService) {
        function init() {
            try {
                localStorage.dummy = "dummy", "dummy" == localStorage.dummy ? (delete localStorage.dummy, 
                storageIsWorking = !0) : storageIsWorking = !1;
            } catch (e) {
                LogService.logError("storage is not working", e), storageIsWorking = !1;
            }
        }
        function storageAllowed() {
            return $rootScope.searchAgentRequest ? !1 : !0;
        }
        function checkStorageEnabled() {
            return storageIsWorking && storageAllowed();
        }
        function storeLocal(key, value) {
            try {
                if (storageIsWorking && storageAllowed()) return localStorage[appKey(key)] = value, 
                !0;
            } catch (e) {}
            return !1;
        }
        function deleteLocal(key) {
            try {
                storageIsWorking && storageAllowed() && delete localStorage[appKey(key)];
            } catch (e) {}
        }
        function appKey(key) {
            return GlobalConfig.appName + "_" + key;
        }
        function loadLocal(key) {
            try {
                if (storageIsWorking && storageAllowed()) {
                    var val = localStorage[appKey(key)];
                    return "undefined" == typeof val && (val = ""), val;
                }
            } catch (e) {}
            return null;
        }
        function storeLocalObject(key, obj) {
            return storeLocal(key, JSON.stringify(obj));
        }
        function loadLocalObject(key) {
            var objStr = loadLocal(key);
            return objStr ? JSON.parse(objStr) : null;
        }
        var storageIsWorking;
        return init(), {
            isEnabled: checkStorageEnabled,
            load: loadLocal,
            store: storeLocal,
            storeObject: storeLocalObject,
            loadObject: loadLocalObject,
            remove: deleteLocal
        };
    });
}), define("common/js/modules/system/cssLoaderService", [ "./systemModule" ], function(module) {
    module.factory("CssLoaderService", function($q, LocalStorageService, PortalMobileUtils) {
        function getCssPastLoadInfo() {
            var cssPastLoadInfoStr = LocalStorageService.load("cssPastLoadInfo");
            return cssPastLoadInfoStr ? JSON.parse(cssPastLoadInfoStr) : {
                cacheVersion: GlobalConfig.cssCacheVersion,
                loadVersion: 1,
                status: "init"
            };
        }
        function createCssLinkElement(cssPath) {
            var fileref = document.createElement("link");
            fileref.setAttribute("rel", "stylesheet"), fileref.setAttribute("type", "text/css"), 
            fileref.setAttribute("href", cssPath), document.getElementsByTagName("head")[0].appendChild(fileref);
        }
        function createCssStyleElement(content) {
            var style = document.createElement("style");
            style.appendChild(document.createTextNode(content)), document.getElementsByTagName("head")[0].appendChild(style);
        }
        function loadCss(cssPath) {
            return mPastLoadInfo = getCssPastLoadInfo(), mCssLoadStart = new Date().getTime(), 
            GlobalConfig.isMobileApp ? BidspiritLoader.localContentLoaded ? PortalMobileUtils.loadLocalData("theme", function(content) {
                createCssStyleElement(content);
            }, function() {
                createCssLinkElement(cssPath);
            }) : createCssLinkElement(cssPath) : createCssLinkElement(cssPath + "?v=" + GlobalConfig.cssCacheVersion + "&load=" + getCssLoadVersion()), 
            waitForCssLoad(), mDeferred.promise;
        }
        function isCssLoaded() {
            var pagePreLoader = document.getElementById("pagePreLoader");
            if (!pagePreLoader) return !0;
            var preLoaderStyle;
            return preLoaderStyle = angular.isDefined(window.getComputedStyle) ? window.getComputedStyle(pagePreLoader) : pagePreLoader.currentStyle, 
            "hidden" === preLoaderStyle.visibility ? (pagePreLoader.parentElement.removeChild(pagePreLoader), 
            !0) : !1;
        }
        function checkLoadTimeout() {
            if (mEnableLoadRetries) {
                var timeSinceLoadState = new Date().getTime() - mCssLoadStart;
                if (timeSinceLoadState > mPastLoadInfo.loadVersion * CSS_LOAD_INCREMENTS) return mPastLoadInfo.status = "failed", 
                storeLoadInfo(), GlobalConfig.isMobileApp && BidspiritLoader.displayDebugIfDev("Failed to load css"), 
                window.location.reload(), !0;
            }
            return !1;
        }
        function waitForCssLoad() {
            isCssLoaded() ? (mPastLoadInfo.status = "success", storeLoadInfo(), mDeferred.resolve(mPastLoadInfo)) : checkLoadTimeout() || setTimeout(waitForCssLoad, 50);
        }
        function getCssLoadVersion() {
            return mPastLoadInfo.cacheVersion == GlobalConfig.cssCacheVersion ? "failed" == mPastLoadInfo.status && mPastLoadInfo.loadVersion++ : (mPastLoadInfo.cacheVersion = GlobalConfig.cssCacheVersion, 
            mPastLoadInfo.loadVersion = 1), mPastLoadInfo.status = "init", storeLoadInfo(), 
            mPastLoadInfo.loadVersion;
        }
        function storeLoadInfo() {
            LocalStorageService.store("cssPastLoadInfo", JSON.stringify(mPastLoadInfo));
        }
        var CSS_LOAD_INCREMENTS = 2e4, mCssLoadStart = null, mEnableLoadRetries = !0, mPastLoadInfo = null, mDeferred = $q.defer();
        return {
            loadCss: loadCss,
            isCssLoaded: isCssLoaded
        };
    });
}), define("common/js/modules/system/settingsService", [ "./systemModule" ], function(module) {
    module.factory("SettingsService", function($rootScope) {
        function init(settings) {
            mSettings = settings, $rootScope.env = settings.envName, mServerTimeGap = new Date().getTime() - settings.serverTime;
        }
        function getAllSettings() {
            return mSettings;
        }
        function getByKey(key, defaultValue) {
            var val = mSettings[key];
            return null != val ? val : defaultValue;
        }
        function getRealServerTimeGap() {
            return mRealServerTimeGap;
        }
        function getServerTimeGap() {
            return mServerTimeGap;
        }
        function secondsSinceStart() {
            return Math.round((new Date().getTime() - GlobalConfig.pageLoadTime) / 1e3);
        }
        function getCacheVersion(cacheKey) {
            return mSettings.cacheVersions[cacheKey];
        }
        function timeUntil(time) {
            return time - (new Date().getTime() - mServerTimeGap);
        }
        var mSettings = null, mServerTimeGap = null;
        return {
            init: init,
            getAll: getAllSettings,
            get: getByKey,
            timeUntil: timeUntil,
            getCacheVersion: getCacheVersion,
            getServerTimeGap: getServerTimeGap,
            getRealServerTimeGap: getRealServerTimeGap,
            secondsSinceStart: secondsSinceStart
        };
    });
}), define("common/js/modules/system/sessionsService", [ "./systemModule" ], function(module) {
    module.value("SessionInfo", {}), module.factory("SessionsService", function($location, $rootScope, $timeout, ApiService, LogService, AnalyticsService, LocalStorageService, SettingsService, PathsService, SessionInfo, OsInfoService) {
        function getSessionUser() {
            return mSessionUser;
        }
        function setSessionUser(user, remember) {
            mSessionUser = user;
            var oldUser = $rootScope.currentUser;
            $rootScope.currentUser = user, userChanged(oldUser, user) && $rootScope.$broadcast("auth.newSessionUser"), 
            user ? ((-1 != user.email.indexOf("@bidspirit.com") || -1 != user.email.indexOf("liothedog") || -1 != user.email.indexOf("alexander.kislevsky")) && LocalStorageService.store("bidspiritEmployee", "true"), 
            remember ? LocalStorageService.store("persistentSession", "true") : LocalStorageService.remove("persistentSession"), 
            LocalStorageService.store("lastLogin", new Date().getTime()), LogService.logEvent({
                userSession: user.email
            }), AnalyticsService.trackDailyUniqueEvent("authAction", "login", "user login " + user.email), 
            handleMobileAppVersionUpdate(user)) : LocalStorageService.remove("persistent");
        }
        function userChanged(oldUser, newUser) {
            return !oldUser && newUser ? !0 : oldUser && !newUser ? !0 : oldUser || newUser ? oldUser.id != newUser.id ? !0 : oldUser.email != newUser.email ? !0 : oldUser.registrationStage != newUser.registrationStage ? !0 : !1 : !1;
        }
        function handleMobileAppVersionUpdate(user) {
            GlobalConfig.isMobileApp && user.mobileAppVersion != GlobalConfig.appVersion && $timeout(function() {
                ApiService.callApi("/users/updateMobileAppVersion", {
                    mobileAppVersion: GlobalConfig.appVersion
                });
            }, 5e3);
        }
        function getRegion() {
            return mClientRegion;
        }
        function setSessionId(sessionId) {
            LocalStorageService.isEnabled() ? LocalStorageService.store("sessionId", sessionId) : PathsService.getQueryParam("sessionId") != sessionId && (window.location = PathsService.newLocationWithParam("sessionId", sessionId)), 
            SessionInfo.sessionId = sessionId;
        }
        function loadPreviousSessionId() {
            var sessionId, querySessionId = PathsService.getQueryParam("sessionId");
            LocalStorageService.isEnabled() ? querySessionId ? (sessionId = querySessionId, 
            LocalStorageService.store("sessionId", querySessionId) && (window.location = PathsService.newLocationWithoutParam("sessionId"))) : sessionId = LocalStorageService.load("sessionId") : sessionId = querySessionId, 
            sessionId && setSessionId(sessionId);
        }
        function setSessionInfo(sessionInfo) {
            setSessionId(sessionInfo.sessionId), OsInfoService.setOsInfo(sessionInfo.osInfo), 
            mClientRegion = sessionInfo.region, -1 == sessionInfo.settings.regions.indexOf(mClientRegion) && (mClientRegion = "ALL"), 
            SettingsService.init(sessionInfo.settings), setSessionUser(sessionInfo.user, hasPersistentSession());
        }
        function hasPersistentSession() {
            return "true" == LocalStorageService.load("persistentSession");
        }
        function init() {
            return loadPreviousSessionId(), ApiService.callApi("/auth/initSession", {
                persistentSession: hasPersistentSession()
            }).success(setSessionInfo);
        }
        function logout() {
            var promise = ApiService.callApi("/auth/logout");
            return promise.success(function() {
                mSessionUser = null;
            }), LogService.logMessage("logout"), promise;
        }
        function refreshCurrentSession() {
            return ApiService.callApi("/auth/getCurrentSessionInfo").success(function(sessionInfo) {
                setSessionInfo(sessionInfo);
            });
        }
        var mSessionUser = null, mClientRegion = null;
        return $rootScope.$on("sessionEnded", function() {
            setSessionUser(null);
        }), {
            init: init,
            loadPreviousSessionId: loadPreviousSessionId,
            getSessionUser: getSessionUser,
            setSessionUser: setSessionUser,
            setSessionInfo: setSessionInfo,
            hasPersistentSession: hasPersistentSession,
            refreshCurrentSession: refreshCurrentSession,
            getRegion: getRegion,
            logout: logout
        };
    });
}), define("common/js/modules/system/osInfoService", [ "./systemModule" ], function(module) {
    module.factory("OsInfoService", function() {
        function isMobile() {
            return GlobalConfig.isMobileApp ? !0 : isIphone() || isIpad() || isAndroid() ? !0 : mOsInfo && mOsInfo.isMobile ? !0 : !1;
        }
        function isIe9() {
            return mOsInfo ? isIe() && parseInt(mOsInfo.version) < 10 : /MSIE\s/.test(navigator.userAgent) && parseFloat(navigator.appVersion.split("MSIE")[1]) < 10;
        }
        function checkUserAgentMatch(textToSearch) {
            return -1 != userAgent.indexOf(textToSearch);
        }
        function isIphone() {
            return checkUserAgentMatch("iphone");
        }
        function isIpad() {
            return checkUserAgentMatch("ipad");
        }
        function isAndroid() {
            return checkUserAgentMatch("android");
        }
        function isIos() {
            return isIphone() || isIpad();
        }
        function isOldIe() {
            return -1 != navigator.appVersion.indexOf("MSIE");
        }
        function isIe() {
            return mOsInfo ? "IE" == mOsInfo.browser : void 0;
        }
        function isMobileAppDebug() {
            return GlobalConfig.isMobileApp && 0 != window.location.href.indexOf("192.168.1.200");
        }
        function getOsInfo() {
            return mOsInfo;
        }
        function setOsInfo(osInfo) {
            mOsInfo = osInfo;
        }
        var mOsInfo = null, userAgent = navigator.userAgent ? navigator.userAgent.toLowerCase() : "unknown";
        return {
            isIe9: isIe9,
            isOldIe: isOldIe,
            isIe: isIe,
            isMobile: isMobile,
            isAndroid: isAndroid,
            isIphone: isIphone,
            isIpad: isIpad,
            isIos: isIos,
            isMobileAppDebug: isMobileAppDebug,
            getOsInfo: getOsInfo,
            setOsInfo: setOsInfo
        };
    });
}), define("common/js/modules/system/index", [ "./systemModule", "./localStorageService", "./cssLoaderService", "./settingsService", "./sessionsService", "./osInfoService" ], function() {}), 
define("common/js/modules/paths/pathsModule", [ "angular" ], function(ng) {
    return ng.module("commonModules.paths", []);
}), define("common/js/modules/paths/pathsService", [ "./pathsModule" ], function(module) {
    module.factory("PathsService", function($rootScope, $log, $uibModal, $state, $timeout, SessionInfo, SettingsService, OsInfoService) {
        function templatePath(templateName, pathType) {
            var baseName = "null";
            switch (pathType) {
              case "app":
                baseName = GlobalConfig.appName;
                break;

              case "common":
                baseName = "common";
                break;

              default:
                return $log.warn("Unknown path type: " + pathType), "";
            }
            return GlobalConfig.templatesBase + baseName + "/templates/" + templateName + ".html?" + GlobalConfig.templatesCacheVersion;
        }
        function commonTemplatePath(templateName) {
            return templatePath(templateName, "common");
        }
        function commonImagePath(imageName) {
            return GlobalConfig.staticFilesBase + "common/images/" + imageName;
        }
        function appImagePath(imageName) {
            return GlobalConfig.staticFilesBase + "/" + GlobalConfig.appName + "/images/" + imageName;
        }
        function appTemplatePath(templateName) {
            return templatePath(templateName, "app");
        }
        function state(name, options) {
            return mStatesProvider = mStatesProvider.state(name, options);
        }
        function childSubviewTemplateState(parentName, childName, template, options) {
            var _options = angular.copy(options);
            _options.views = {}, _options.views["@" + parentName] = {
                templateUrl: appTemplatePath(template)
            }, appTemplateState(parentName + "." + childName, null, _options);
        }
        function appTemplateState(name, template, options) {
            var _options = angular.copy(options);
            _options.templateUrl = appTemplatePath(template), state(name, _options);
        }
        function appModalState(name, template, options, size) {
            var _options = angular.copy(options), modal = null;
            _options.onEnter = function($uibModal) {
                modal = $uibModal.open({
                    templateUrl: appTemplatePath(template),
                    size: size || "lg",
                    backdrop: "static"
                });
            };
            var closeModal = function() {
                modal && (modal.close(), modal = null);
            };
            $rootScope.$on("notAllowed", closeModal), $rootScope.$on("sessionEnded", closeModal), 
            state(name, _options);
        }
        function currentStateSuffix() {
            var stateParts = $state.current.name.split(".");
            return stateParts[stateParts.length - 1];
        }
        function simpleChildStates(parentState, childStates) {
            angular.forEach(childStates, function(childState) {
                state(parentState + "." + childState, {
                    url: "/" + childState
                });
            });
        }
        function formActionPath(path) {
            return GlobalConfig.apiBase + path + "?sessionId=" + SessionInfo.sessionId;
        }
        function getAppSiteUrl(siteCode) {
            switch (siteCode) {
              case "dev":
                return "http://192.168.1.200:8080/BidSpirit";

              case "demo":
                return "https://demo.bidspirit.com";

              default:
                var domain = GlobalConfig.bidmoodEnv ? "bidmood.com" : "bidspirit.com";
                return "https://" + siteCode + "." + domain;
            }
        }
        function getPortalTextsUrl(lang) {
            var textsFilePath = "texts/texts." + lang + ".properties", pathBase = OsInfoService.isOldIe() ? GlobalConfig.apiBase : GlobalConfig.cachedApiBase;
            return pathBase + textsFilePath + "?cacheVersion=" + SettingsService.getCacheVersion("TEXTS");
        }
        function getRegionByDomain() {
            var region = getQueryParam("region");
            return region || (region = window.location.host.split(".")[0]), region = region.toUpperCase().replace(/[^A-Z]/g, ""), 
            -1 != [ "IL", "RU", "ALL" ].indexOf(region) ? region : null;
        }
        function validateHttps() {
            if (GlobalConfig.isMobileApp) return !0;
            if (GlobalConfig.devEnv || $rootScope.searchAgentRequest || 0 == window.location.host.indexOf("192")) return !0;
            if ("https:" == window.location.protocol && -1 == window.location.hostname.indexOf(".co.") && -1 == window.location.hostname.indexOf("www.")) return !0;
            var newHref = window.location.href.replace("http:", "https:");
            return newHref = newHref.replace("www.", ""), newHref = newHref.replace("bidspirit.co.il", "il.bidspirit.com"), 
            newHref = newHref.replace("bidmood.co.in", "bidmood.com"), window.location = newHref, 
            !1;
        }
        function reloadAfterDelay(delay) {
            $timeout.cancel(mReloadTimer), mReloadTimer = $timeout($state.reload, delay);
        }
        function getQueryParam(param, allowNull) {
            param = param.replace(/[\[]/, "\\[").replace(/[\]]/, "\\]");
            var regexS = "[\\?&]" + param + "=([^&#]*)", regex = new RegExp(regexS), results = regex.exec(window.location.href);
            return null == results ? allowNull ? null : "" : decodeURIComponent(results[1]);
        }
        function newLocationWithParam(key, val) {
            if (getQueryParam(key) == val) return window.location.href;
            var newQuery = getQueryStringWithoutKey(key);
            return newQuery += newQuery ? "&" : "?", newQuery += key + "=" + val, getLocationWithQuery(newQuery);
        }
        function newLocationWithoutParam(key) {
            return getLocationWithQuery(getQueryStringWithoutKey(key));
        }
        function getLocationWithQuery(query) {
            return window.location.protocol + "//" + window.location.host + window.location.pathname + query + window.location.hash;
        }
        function getQueryStringWithoutKey(key) {
            for (var queryStr = window.location.search, queryParams = queryStr.split(/\?|\&/), newQueryStr = "", firstParam = !0, i = 1; i < queryParams.length; i++) {
                var queryParamParts = queryParams[i].split("="), queryParamKey = queryParamParts[0], queryParamVal = queryParamParts[1];
                queryParamKey && queryParamKey != key && (newQueryStr += firstParam ? "?" : "&", 
                newQueryStr += queryParamKey + "=" + queryParamVal, firstParam = !1);
            }
            return newQueryStr;
        }
        return mStatesProvider = angular.module("commonModules").$stateProvider, mReloadTimer = null, 
        {
            commonTemplatePath: commonTemplatePath,
            appTemplatePath: appTemplatePath,
            templatePath: templatePath,
            commonImagePath: commonImagePath,
            appImagePath: appImagePath,
            formActionPath: formActionPath,
            state: state,
            appTemplateState: appTemplateState,
            appModalState: appModalState,
            simpleChildStates: simpleChildStates,
            childSubviewTemplateState: childSubviewTemplateState,
            currentStateSuffix: currentStateSuffix,
            getQueryParam: getQueryParam,
            newLocationWithParam: newLocationWithParam,
            newLocationWithoutParam: newLocationWithoutParam,
            getQueryStringWithoutKey: getQueryStringWithoutKey,
            validateHttps: validateHttps,
            getAppSiteUrl: getAppSiteUrl,
            getPortalTextsUrl: getPortalTextsUrl,
            getRegionByDomain: getRegionByDomain,
            reloadAfterDelay: reloadAfterDelay
        };
    });
}), define("common/js/modules/paths/filters", [ "./pathsModule" ], function(module) {
    return module.filter("appTemplate", [ "PathsService", function(PathsService) {
        return function(name) {
            return PathsService.appTemplatePath(name);
        };
    } ]).filter("commonTemplate", [ "PathsService", function(PathsService) {
        return function(name) {
            return PathsService.commonTemplatePath(name);
        };
    } ]).filter("commonImage", [ "PathsService", function(PathsService) {
        return function(name) {
            return PathsService.commonImagePath(name);
        };
    } ]).filter("formActionPath", [ "PathsService", function(PathsService) {
        return function(path) {
            return PathsService.formActionPath(path);
        };
    } ]);
}), define("common/js/modules/paths/index", [ "./pathsModule", "./pathsService", "./filters" ], function() {}), 
define("common/js/modules/i18n/i18nModule", [ "angular" ], function(ng) {
    return ng.module("commonModules.i18n", []);
}), define("common/js/modules/i18n/i18nFilter", [ "./i18nModule" ], function(module) {
    return module.filter("i18n", [ "I18nService", function(I18nService) {
        return function(key, params) {
            return I18nService.getText(key, params);
        };
    } ]).filter("sumInCurrency", [ "I18nService", function(I18nService) {
        return function(text, currency) {
            return I18nService.sumInCurrency(text, currency);
        };
    } ]).filter("i18nWithRegion", [ "I18nService", function(I18nService) {
        return function(key, params) {
            return I18nService.getTextWithRegion(key, params);
        };
    } ]);
}), define("common/js/modules/i18n/i18nService", [ "./i18nModule" ], function(module) {
    module.factory("I18nService", function($interpolate, $http, $log, $q, $filter, $rootScope, StringsService, LocalStorageService, PathsService, SettingsService, DateUtilsService, PortalMobileUtils) {
        function init(reourcePathFn, preferredLang) {
            mResourcePathFn = reourcePathFn;
            var lang;
            lang = $rootScope.searchAgentRequest ? getLangForSnapshot(preferredLang) : getLangForBrowser(preferredLang), 
            isSupportedLang(lang) || (lang = DEFAULT_LANG);
            var promise = setLang(lang);
            return lang != DEFAULT_LANG ? $q.all([ promise, loadLang(DEFAULT_LANG) ]) : promise;
        }
        function getLangForBrowser(preferredLang) {
            var lang = LocalStorageService.load("lastLang") || PathsService.getQueryParam("lang") || preferredLang;
            return lang || (lang = SettingsService.get("suggestedLanguage"), "other" == lang && (lang = DEFAULT_LANG)), 
            lang;
        }
        function getLangForSnapshot(preferredLang) {
            var queryLang = PathsService.getQueryParam("lang");
            if (queryLang) return StringsService.trim(queryLang).toLowerCase();
            var region = PathsService.getRegionByDomain();
            return region ? langByRegion(region) : preferredLang || DEFAULT_LANG;
        }
        function setLang(lang) {
            var defered = $q.defer();
            return mTextsByLang[lang] ? (mCurrentLang = lang, defered.resolve(), $rootScope.$broadcast("i18n.languageChanged")) : loadLang(lang).then(function() {
                setLang(lang), defered.resolve();
            }), defered.promise;
        }
        function loadLang(lang) {
            var promise;
            return promise = GlobalConfig.isMobileApp ? PortalMobileUtils.getTextsLoadPromise(lang) : $http({
                url: mResourcePathFn(lang),
                cache: !0
            }), promise.then(function(texts) {
                setTexts(lang, texts.data.split(/\n/m));
            }), promise;
        }
        function reloadTextsAfterDelay(delay) {
            clearTimeout(mTextReloadTimer), mTextReloadTimer = setTimeout(function() {
                loadLang(mCurrentLang).then(function() {
                    $rootScope.$broadcast("i18n.languageChanged");
                }), mCurrentLang != DEFAULT_LANG && loadLang(DEFAULT_LANG);
            }, delay);
        }
        function setTexts(lang, textLines) {
            for (var textsMap = {}, i = 0; i < textLines.length; i++) addTextLineToMap(textsMap, textLines[i]);
            mTextsByLang[lang] = textsMap;
        }
        function addTextLineToMap(textsMap, textLine) {
            var seperatorInd = textLine.indexOf("=");
            if (-1 == seperatorInd) StringsService.isBlank(textLine) || $log.warn("I18n: Failed to parse lang resource line:" + textLine); else {
                var key = StringsService.trim(textLine.substr(0, seperatorInd)), val = StringsService.trim(textLine.substr(seperatorInd + 1));
                textsMap[key] = val;
            }
        }
        function getCurrentLang() {
            return mCurrentLang;
        }
        function getSupportedLangs() {
            return mSupportedLangs;
        }
        function isSupportedLang(lang) {
            return -1 != mSupportedLangs.indexOf(lang);
        }
        function searchTextByKey(key, textsMap) {
            textsMap || (textsMap = mTextsByLang[mCurrentLang]);
            var text = textsMap[key];
            return !text && mTextsByLang[DEFAULT_LANG] && (text = mTextsByLang[DEFAULT_LANG][key]), 
            text || key == key.toLowerCase() || (text = searchTextByKey(key.toLowerCase(), textsMap)), 
            text;
        }
        function getText(key, params, textsMap) {
            if (!key) return "";
            var text = searchTextByKey(key, textsMap);
            return text ? (params && (translatedParams = {}, angular.forEach(params, function(paramVal, paramKey) {
                translatedParams[paramKey] = "string" == typeof paramVal ? searchTextByKey(paramVal, textsMap) || paramVal : paramVal;
            }), text = $interpolate(text)(translatedParams)), text) : ($log.warn("I18n: Failed to find text for key:" + key), 
            key);
        }
        function getTextWithRegion(key, params, region) {
            if (!region && params && (region = params.region), region || (region = $rootScope.currentRegion), 
            "ALL" == region && searchTextByKey(key + "_global")) return getText(key + "_global", params);
            var regionName = getText("region_" + region), paramsWithRegion = angular.copy(params) || {};
            return paramsWithRegion.region = regionName, paramsWithRegion.country = regionName, 
            getText(key, paramsWithRegion);
        }
        function getDateDisplay(date, time, options, textsMap) {
            if (options.withoutDayOfMonth) return getMonth(date.getMonth(), textsMap) + " " + $filter("date")(date, "yyyy");
            var dateStr = $filter("date")(date, "d.M.yy");
            if (!options.withoutDayOfWeek) {
                var day = getWeekDay(date.getDay(), textsMap);
                dateStr = day + ", " + dateStr;
            }
            return time && !options.withoutTime ? dateStr + ", " + time : dateStr;
        }
        function getTimeLeftDisplay(time) {
            function and(str) {
                return getText("time_and", {
                    text: str
                });
            }
            function timeText(timePart) {
                return " " + getText("time_" + timePart);
            }
            var timeDiff = DateUtilsService.parseMillisLeft(SettingsService.timeUntil(time)), timeDisplay = "";
            return timeDiff.days > 0 ? (timeDisplay = timeDiff.days + timeText("days"), timeDiff.hours > 0 && (timeDisplay += " " + and(timeDiff.hours + timeText("hours")))) : timeDiff.hours > 0 ? (timeDisplay = timeDiff.hours + timeText("hours"), 
            timeDiff.minutes > 0 && (timeDisplay += " " + and(timeDiff.minutes + timeText("minutes")))) : timeDisplay = timeDiff.minutes > 0 ? timeDiff.seconds > 45 ? timeDiff.minutes + 1 + timeText("minutes") : timeDiff.seconds > 15 && timeDiff.minutes < 5 ? timeDiff.minutes + timeText("minutes") + " " + and(30 + timeText("seconds")) : timeDiff.minutes + timeText("minutes") : timeDiff.seconds + timeText("seconds"), 
            timeDisplay;
        }
        function getLangField(field) {
            if (!field) return "";
            var fieldInCurrentLang = field[getCurrentLang()];
            if (fieldInCurrentLang) return fieldInCurrentLang;
            var fieldInDefaultLang = field[DEFAULT_LANG];
            if (fieldInDefaultLang) return fieldInDefaultLang;
            for (var lang in field) {
                var fieldInAnyLang = field[lang];
                if (fieldInAnyLang) return fieldInAnyLang;
            }
            return "";
        }
        function langNativeName(lang) {
            switch (lang) {
              case "en":
                return "English";

              case "ru":
                return "";

              case "he":
                return "";

              case "jp":
                return "";

              case "de":
                return "Deutsch";

              case "es":
                return "Espaol";

              case "pt":
                return "Portugus";

              case "zh":
                return "";
            }
        }
        function langEnglishName(lang) {
            switch (lang) {
              case "en":
                return "english";

              case "ru":
                return "russian";

              case "he":
                return "hebrew";

              case "jp":
                return "japanese";

              case "de":
                return "german";

              case "es":
                return "spanish";

              case "pt":
                return "portuguese";

              case "zh":
                return "chinese";
            }
        }
        function langByRegion(region) {
            switch (region) {
              case "IL":
                return "he";

              case "RU":
                return "ru";

              default:
                return mCurrentLang || DEFAULT_LANG;
            }
        }
        function setLangByRegion(region) {
            setLang(langByRegion(region));
        }
        function getWeekDay(day, textsMap) {
            var daysArr = getText("week_days", null, textsMap).split(",");
            return StringsService.trim(daysArr[day]);
        }
        function getMonth(month, textsMap) {
            var monthsArr = getText("months", null, textsMap).split(",");
            return StringsService.trim(monthsArr[month]);
        }
        function getPhoneForRegion(phone, region, lang) {
            return "IL" == region && "he" != lang && 0 == phone.indexOf("0") ? "(972) " + phone.substr(1) : phone;
        }
        function sumInCurrency(sum, currency) {
            var sumStr = StringsService.readableNumber(sum);
            switch (currency) {
              case "$":
              case "":
              case "":
              case "":
                return currency + sumStr;

              case "CHF":
              case "Rs.":
                return currency + " " + sumStr;

              default:
                return sumStr + currency;
            }
        }
        function isoCurrency(currency) {
            switch (currency) {
              case "$":
                return "USD";

              case "":
                return "ILS";

              case "p":
                return "RUB";

              case "":
              case "Rs.":
                return "INR";

              default:
                return currency;
            }
        }
        function parseCurrency(priceDisplay, currency) {
            var parsed = 1 * (priceDisplay + "").replace(currency, "").replace(/,|\s/g, "").replace(/\&nbsp\;/g, "");
            return isNaN(parsed) ? null : parsed;
        }
        var DEFAULT_LANG = "en", mCurrentLang = null, mTextsByLang = {}, mResourcePathFn = null, mTextReloadTimer = null, mSupportedLangs = [ "he", "en", "ru" ];
        return {
            init: init,
            getCurrentLang: getCurrentLang,
            getSupportedLangs: getSupportedLangs,
            setLang: setLang,
            setLangByRegion: setLangByRegion,
            reloadTextsAfterDelay: reloadTextsAfterDelay,
            langNativeName: langNativeName,
            langEnglishName: langEnglishName,
            getPhoneForRegion: getPhoneForRegion,
            getText: getText,
            getTextWithRegion: getTextWithRegion,
            getLangField: getLangField,
            searchTextByKey: searchTextByKey,
            getWeekDay: getWeekDay,
            getMonth: getMonth,
            getDateDisplay: getDateDisplay,
            getTimeLeftDisplay: getTimeLeftDisplay,
            sumInCurrency: sumInCurrency,
            parseCurrency: parseCurrency,
            isoCurrency: isoCurrency,
            DEFAULT_LANG: DEFAULT_LANG
        };
    });
}), define("common/js/modules/i18n/langFieldFilter", [ "./i18nModule" ], function(module) {
    return module.filter("langField", [ "I18nService", function(I18nService) {
        return function(field) {
            return I18nService.getLangField(field);
        };
    } ]);
}), define("common/js/modules/i18n/langNameFilter", [ "./i18nModule" ], function(module) {
    return module.filter("langName", [ "I18nService", "StringsService", function(I18nService, StringsService) {
        return function(langKey, displayLang) {
            return "english" == displayLang ? StringsService.capitalize(I18nService.langEnglishName(langKey)) : I18nService.langNativeName(langKey);
        };
    } ]);
}), define("common/js/modules/i18n/i18nContentWithLinks", [ "./i18nModule" ], function(module) {
    module.directive("i18nContentWithLinks", function($compile, $rootScope, I18nService) {
        return {
            restrict: "E",
            replace: !0,
            link: function(scope, element, attrs) {
                function parseMap(jsonStr) {
                    return jsonStr ? eval("(function(){return " + jsonStr + ";})()") : null;
                }
                function setHtml() {
                    var params = parseMap(attrs.params), linksActions = parseMap(attrs.linksActions), text = I18nService.getText(attrs.key, params);
                    for (key in linksActions) text = text.replace("<a " + key, "<a ng-click=" + linksActions[key]);
                    element.html(text), $compile(element.contents())(scope);
                }
                setHtml();
            }
        };
    });
}), define("common/js/modules/i18n/currentLangDirective", [ "./i18nModule" ], function(module) {
    module.directive("bsCurrentLang", function($rootScope, I18nService) {
        return {
            restrict: "A",
            link: function(scope, element) {
                function setLang() {
                    element.removeClass(currentLang), currentLang = I18nService.getCurrentLang(), element.addClass(currentLang);
                }
                var currentLang = null;
                $rootScope.$on("i18n.languageChanged", setLang), setLang();
            }
        };
    });
}), define("common/js/modules/i18n/index", [ "./i18nModule", "./i18nFilter", "./i18nService", "./langFieldFilter", "./langNameFilter", "./i18nContentWithLinks", "./currentLangDirective" ], function() {}), 
define("common/js/modules/dialogs/dialogsModule", [ "angular", "../utils/index" ], function(ng) {
    return ng.module("commonModules.dialogs", [ "commonModules.utils" ]);
}), define("common/js/modules/dialogs/dialogsService", [ "./dialogsModule", "../paths/index" ], function(module) {
    module.factory("DialogsService", function($uibModal, PathsService) {
        function showAlert(dataOrMessage) {
            return angular.isString(dataOrMessage) ? showAlertWithMessage(dataOrMessage) : showAlertWithData(dataOrMessage);
        }
        function showAlertWithMessage(message) {
            return showAlertWithData({
                message: message
            });
        }
        function showAlertWithData(data) {
            return newModalWindow({
                templateName: "alert",
                data: data
            });
        }
        function showConfirm(dataOrMessage) {
            return angular.isString(dataOrMessage) ? showConfirmWithMessage(dataOrMessage) : showConfirmWithData(dataOrMessage);
        }
        function showConfirmWithMessage(message) {
            return showConfirmWithData({
                message: message
            });
        }
        function showConfirmWithData(data) {
            return newModalWindow({
                templateName: "confirm",
                data: data
            });
        }
        function showImage(imageName, imagePath) {
            return newModalWindow({
                templateName: "image",
                data: {
                    imageName: imageName,
                    imagePath: imagePath
                },
                size: "lg"
            });
        }
        function newModalWindow(options) {
            return $uibModal.open({
                templateUrl: PathsService.commonTemplatePath("dialogs/" + options.templateName),
                controller: "DialogController",
                size: options.size || "sm",
                resolve: {
                    dialogData: function() {
                        return options.data;
                    }
                }
            }).result;
        }
        return {
            showAlert: showAlert,
            showConfirm: showConfirm,
            showImage: showImage
        };
    });
}), define("common/js/modules/dialogs/dialogController", [ "./dialogsModule" ], function(module) {
    module.controller("DialogController", [ "$scope", "$uibModalInstance", "dialogData", function($scope, $uibModalInstance, dialogData) {
        $scope.dialogData = dialogData, $scope.close = function() {
            $uibModalInstance.close(!1);
        }, $scope.ok = function() {
            $uibModalInstance.close(!0);
        };
    } ]);
}), define("common/js/modules/dialogs/bsScopeAlertDirective", [ "./dialogsModule" ], function(module) {
    module.directive("bsScopeAlert", function($animate, PathsService) {
        return {
            restrict: "E",
            replace: !0,
            templateUrl: PathsService.commonTemplatePath("dialogs/scopeAlert"),
            controller: function($scope) {
                $scope.alert = {
                    message: null,
                    type: null
                }, $scope.hideScopeAlert = function() {
                    $scope.alert.message = null;
                }, $scope.showScopeAlert = function(message, type) {
                    $scope.alert = {
                        message: message,
                        type: type || "info"
                    };
                };
            }
        };
    });
}), define("common/js/modules/dialogs/index", [ "./dialogsModule", "./dialogsService", "./dialogController", "./bsScopeAlertDirective" ], function() {}), 
define("common/js/modules/asyncButton/asyncButtonModule", [ "angular", "../utils/index" ], function(ng) {
    return ng.module("commonModules.asyncButton", [ "commonModules.utils" ]);
}), define("common/js/modules/asyncButton/asyncButtonDirective", [ "./asyncButtonModule" ], function(module) {
    module.directive("bsAsyncButton", function($log, PathsService, AsyncButtonService) {
        return {
            restrict: "E",
            transclude: !0,
            replace: !0,
            scope: {
                actionFn: "&",
                bsFormController: "=",
                name: "=",
                buttonClass: "=",
                label: "="
            },
            link: function(scope, elm, attrs) {
                function handleActionResult(result) {
                    result && result.then ? result.then(handleActionResult, unlock) : unlock();
                }
                function lock() {
                    scope.locked = !0;
                }
                function unlock() {
                    scope.locked = !1;
                }
                scope.locked = !1, scope.executeAction = function() {
                    scope.locked || (attrs.actionFn ? (lock(), handleActionResult(scope.actionFn())) : scope.bsFormController ? (lock(), 
                    scope.$on("bsFormSuccess", unlock), scope.$on("bsFormError", unlock), scope.bsFormController.submit() || unlock()) : ($log.warn("Nothing to do with async button"), 
                    $log.warn(scope)));
                }, AsyncButtonService.register(scope);
            },
            templateUrl: PathsService.commonTemplatePath("forms/asyncButton")
        };
    });
}), define("common/js/modules/asyncButton/asyncButtonService", [ "./asyncButtonModule" ], function(module) {
    module.factory("AsyncButtonService", function($log, $q) {
        function register(buttonScope) {
            buttonScope.name && (mButtonsRegistery[buttonScope.name] = buttonScope);
        }
        function invokeButton(asyncButtonName) {
            var buttonScope = mButtonsRegistery[asyncButtonName];
            buttonScope ? buttonScope.executeAction() : $log.warn("Trying to invoke an unknown async button " + asyncButtonName);
        }
        function fakeSuccess(asyncButtonName) {
            var buttonScope = mButtonsRegistery[asyncButtonName];
            return buttonScope.$broadcast("bsFormSuccess"), $q.defer().promise;
        }
        var mButtonsRegistery = {};
        return {
            register: register,
            invokeButton: invokeButton,
            fakeSuccess: fakeSuccess
        };
    });
}), define("common/js/modules/asyncButton/index", [ "./asyncButtonModule", "./asyncButtonDirective", "./asyncButtonService" ], function() {}), 
define("common/js/modules/bsForm/bsFormModule", [ "angular" ], function(ng) {
    return ng.module("commonModules.bsForm", []);
}), define("common/js/modules/bsForm/bsFormDirective", [ "./bsFormModule" ], function(module) {
    module.directive("bsForm", function($parse, $log, PathsService, FormConstants) {
        return {
            restrict: "A",
            replace: !0,
            require: [ "form" ],
            link: function(scope, element, attributes, controllers) {
                function updateFieldsAttentions() {
                    mFormController && !mFormController.$valid && angular.forEach(mInputsControllers, function(inputController, inputName) {
                        checkInputAttention(inputName);
                    }), scope.$$phase || scope.$digest(), angular.forEach(getSubForms(), function(subForm) {
                        subForm.updateFieldsAttentions();
                    });
                }
                function getSubForms() {
                    var subForms = [], subFormsElements = element.find("ng-form");
                    if (mFormController) for (var i = 0; i < subFormsElements.length; i++) {
                        var subFormController = mFormController[subFormsElements[i].attributes.name.value];
                        subFormController && subForms.push(subFormController);
                    }
                    return subForms;
                }
                function bindSumbit() {
                    mFormController.submit = submitForm;
                }
                function submitForm() {
                    return setTimeout(updateFieldsAttentions, 200), mFormController.$valid ? (scope.submitCall(scope).then(function() {
                        scope.$broadcast("bsFormSuccess", {
                            formName: mFormController.$name
                        });
                    }, function() {
                        scope.$broadcast("bsFormError", {
                            formName: mFormController.$name
                        });
                    }), !0) : (scope.$broadcast("bsFormError", {
                        formName: mFormController.$name
                    }), scope.$$phase || scope.$digest(), !1);
                }
                function checkInputAttention(inputName) {
                    var inputController = mInputsControllers[inputName];
                    return inputController.$valid ? inputController.attentionTouch = null : ($log.info("input " + inputName + " is invalid. (" + JSON.stringify(inputController.$error) + ")"), 
                    inputController.attentionTouch = new Date().getTime()), inputController.attentionTouch;
                }
                function removeAttentionIfValid(inputName) {
                    var inputController = mInputsControllers[inputName];
                    if (inputController.attentionTouch) {
                        if (inputController.$valid) return inputController.attentionTouch = null, !0;
                        inputController.attentionTouch = new Date().getTime();
                    }
                    return !1;
                }
                function setInputBehaviour(input) {
                    var inputName = input.attr("name");
                    input.bind("blur", function() {
                        checkInputAttention(inputName), setTimeout(function() {
                            scope.$digest();
                        });
                    }), angular.forEach([ "keyup", "change" ], function(eventKey) {
                        input.bind(eventKey, function() {
                            removeAttentionIfValid(inputName) && scope.$digest();
                        });
                    });
                }
                function addInputController(input) {
                    var inputName = input.attr("name");
                    if (inputName && scope.formController[inputName]) {
                        var inputController = scope.formController[inputName];
                        mInputsControllers[inputName] = inputController, function(_input) {
                            setInputBehaviour(_input);
                        }(input);
                    }
                }
                function initInputControllers() {
                    angular.forEach([ "input", "select", "textarea" ], function(tagName) {
                        for (var inputs = element.find(tagName), i = 0; i < inputs.length; i++) addInputController(angular.element(inputs[i]));
                    }), mFormController.updateFieldsAttentions = updateFieldsAttentions, mFormController.bsFormFirstErrorMessage = scope.bsFormFirstErrorMessage;
                }
                function initAction() {
                    element.attr("action") || element.attr("action", "javascript:null");
                }
                function initButtons() {
                    angular.forEach(element.find("button"), function(button) {
                        var buttonElement = angular.element(button);
                        buttonElement.attr("type") || buttonElement.attr("type", "button");
                    });
                }
                function init() {
                    mFormController = scope.formController, initAction(), initButtons(), bindSumbit(), 
                    initInputControllers();
                }
                scope.formController = controllers[0], scope.submitCall = $parse(attributes.bsSubmit), 
                scope.bsValidationPatterns = FormConstants.validationPatterns;
                var mFormController = null, mInputsControllers = {};
                scope.bsFormFirstErrorMessage = function() {
                    for (inputName in mInputsControllers) {
                        var inputController = mInputsControllers[inputName], errorMessage = inputController.errorMessage;
                        if (inputController.attentionTouch && errorMessage) return errorMessage;
                    }
                    for (var subForms = getSubForms(), i = 0; i < subForms.length; i++) {
                        var subFormError = subForms[i].bsFormFirstErrorMessage();
                        if (subFormError) return subFormError;
                    }
                    return null;
                }, setTimeout(function() {
                    init();
                }, 100);
            }
        };
    });
}), define("common/js/modules/bsForm/bsCheckListDirective", [ "./bsFormModule" ], function(module) {
    module.directive("bsChecklistModel", function($parse, $compile) {
        function contains(arr, item) {
            if (angular.isArray(arr)) for (var i = 0; i < arr.length; i++) if (angular.equals(arr[i], item)) return !0;
            return !1;
        }
        function add(arr, item) {
            arr = angular.isArray(arr) ? arr : [];
            for (var i = 0; i < arr.length; i++) if (angular.equals(arr[i], item)) return arr;
            return arr.push(item), arr;
        }
        function remove(arr, item) {
            if (angular.isArray(arr)) for (var i = 0; i < arr.length; i++) if (angular.equals(arr[i], item)) {
                arr.splice(i, 1);
                break;
            }
            return arr;
        }
        function postLinkFn(scope, elem, attrs) {
            $compile(elem)(scope);
            var getter = $parse(attrs.bsChecklistModel), setter = getter.assign, value = $parse(attrs.checklistValue)(scope.$parent);
            "true" == elem.parent().attr("check-on-click") && elem.parent().bind("click", function(e) {
                "INPUT" != e.target.tagName && (scope.checked = !scope.checked);
            }), scope.$watch("checked", function(newValue, oldValue) {
                if (newValue !== oldValue) {
                    var current = getter(scope.$parent);
                    newValue === !0 ? setter(scope.$parent, add(current, value)) : setter(scope.$parent, remove(current, value));
                }
            }), scope.$parent.$watch(attrs.bsChecklistModel, function(newArr) {
                scope.checked = contains(newArr, value);
            }, !0);
        }
        return {
            restrict: "A",
            priority: 1e3,
            terminal: !0,
            scope: !0,
            compile: function(tElement, tAttrs) {
                if ("INPUT" !== tElement[0].tagName || !tElement.attr("type", "checkbox")) throw 'bs-checklist-model should be applied to `input[type="checkbox"]`.';
                if (!tAttrs.checklistValue) throw "You should provide `checklist-value`.";
                return tElement.removeAttr("bs-checklist-model"), tElement.attr("ng-model", "checked"), 
                postLinkFn;
            }
        };
    });
}), define("common/js/modules/bsForm/bsDateFieldDirective", [ "./bsFormModule" ], function(module) {
    module.directive("bsDateField", function() {
        return {
            restrict: "A",
            replace: !0,
            require: "ngModel",
            link: function(scope, elem, attr, ngModel) {
            }
        };
    });
}), define("common/js/modules/bsForm/bsFormValidationMessage", [ "./bsFormModule" ], function(module) {
    module.directive("bsFormValidationMessage", function($rootScope, I18nService) {
        return mDefaultValidationMessages = {
            required: "error_mandatory",
            minlength: "error_too_short",
            pattern: "error_bad_pattern",
            email: "error_bad_email"
        }, {
            restrict: "E",
            require: [ "^form", "^bsFormGroup" ],
            replace: !0,
            template: '<div class="help-block {{helpCssClass}}"></div>',
            link: function($scope, el, attrs, controllers) {
                function checkErrors() {
                    var html = "", field = formController[fieldName];
                    if (debug("chcking " + fieldName), debug(field), field && field.attentionTouch) {
                        debug(field), field.errorMessage = null;
                        var errors = field.$error;
                        for (var error in errors) if (errors.hasOwnProperty(error) && errors[error]) {
                            var errorCode = attrs[error];
                            errorCode || (errorCode = mDefaultValidationMessages[error]), field.errorMessage = I18nService.getText(errorCode, {
                                field: fieldLabel
                            }), errorCode && !attrs.hidden && (html += "<span>" + field.errorMessage + "</span>");
                        }
                    }
                    el.html(html);
                }
                function debug() {
                    attrs.debug;
                }
                var formController = controllers[0], formGroupController = controllers[1];
                debug(formGroupController), debug(formController);
                var formName = formController.$name, fieldLabel = attrs.fieldLabel;
                fieldLabel || (fieldLabel = formGroupController.fieldLabel);
                var fieldName = formGroupController.fieldName;
                $scope[formName] = formController, $scope.helpCssClass = attrs.cssClass, $scope.$watch(formName + "." + fieldName + ".attentionTouch", function(attentionTouch) {
                    el.css("display", attentionTouch ? "" : "none"), checkErrors();
                });
            }
        };
    });
}), define("common/js/modules/bsForm/bsFormGroupDirective", [ "./bsFormModule" ], function(module) {
    module.directive("bsFormGroup", function($rootScope, I18nService, DomUtilsService, PathsService) {
        return {
            restrict: "EA",
            require: "^form",
            replace: !0,
            transclude: !0,
            scope: {
                label: "@",
                fieldName: "@",
                cssClass: "@"
            },
            templateUrl: PathsService.commonTemplatePath("forms/formGroup"),
            link: function(scope, element, attrs, formController) {
                function setLabel() {
                    scope.label && element.find("label").html(I18nService.getText(scope.label));
                }
                function debug() {
                    attrs.debug;
                }
                var formName = formController.$name;
                if (formName) {
                    scope[formName] = formController;
                    var watchExpression = formName + "." + scope.fieldName + ".attentionTouch";
                    scope.$watch(watchExpression, function(attentionTouch) {
                        if (attentionTouch) {
                            debug("attention!");
                            var field = scope[formName][scope.fieldName], hasError = !1, errors = field.$error;
                            for (var error in errors) if (errors.hasOwnProperty(error) && errors[error]) {
                                hasError = !0;
                                break;
                            }
                            hasError ? element.addClass("has-error") : element.removeClass("has-error");
                        } else element.removeClass("has-error");
                    }), setLabel();
                }
            },
            controller: function($scope) {
                this.fieldLabel = $scope.label, this.fieldName = $scope.fieldName;
            }
        };
    });
}), define("common/js/modules/bsForm/bsPlaceHolderDirective", [ "./bsFormModule" ], function(module) {
    module.directive("bsPlaceHolder", function(I18nService, OsInfoService) {
        return {
            restrict: "A",
            require: [ "ngModel", "^bsFormGroup" ],
            priority: 1,
            link: function(scope, elem, attrs, controllers) {
                function handleFocused(focused) {
                    elem.val() || !setDirection || focused ? !focused || "email" != elem.attr("type") && "password" != elem.attr("type") || (elem.attr("dir", "ltr"), 
                    setDirection = !0) : (elem.removeAttr("dir"), setDirection = !1), focused ? elem.attr("placeholder", "") : elem.attr("placeholder", text);
                }
                function setValue(val) {
                    val ? (elem.removeClass(emptyClassName), elem.val(val), is_pwd && hidePasswordPlaceholder()) : (elem.addClass(emptyClassName), 
                    is_pwd ? showPasswordPlaceholder() : elem.val(text));
                }
                function setupPasswordPlaceholder() {
                    clone = angular.element("<input/>").attr(angular.extend(extractAttributes(domElem), {
                        type: "text",
                        value: text,
                        placeholder: "",
                        id: "",
                        name: ""
                    })).addClass(emptyClassName).addClass("ng-hide").bind("focus", function() {
                        hidePasswordPlaceholder(), domElem.focus();
                    }), domElem.parentNode.insertBefore(clone[0], domElem);
                }
                function showPasswordPlaceholder() {
                    elem.addClass("ng-hide"), clone.removeClass("ng-hide");
                }
                function hidePasswordPlaceholder() {
                    clone.addClass("ng-hide"), elem.removeClass("ng-hide");
                }
                function extractAttributes(element) {
                    for (var attr = element.attributes, copy = {}, skip = /^jQuery\d+/, i = 0; i < attr.length; i++) attr[i].specified && !skip.test(attr[i].name) && (copy[attr[i].name] = attr[i].value);
                    return copy;
                }
                var clone, ngModel = controllers[0], bsFormGroup = controllers[1], orig_val = elem.val() || "", is_pwd = "password" === attrs.type, emptyClassName = "empty", domElem = elem[0], textKey = attrs.bsPlaceHolder;
                if (textKey || (textKey = bsFormGroup.fieldLabel), textKey) {
                    handleFocused(!1);
                    var text = I18nService.getText(textKey);
                    if (OsInfoService.isIe9()) {
                        is_pwd && setupPasswordPlaceholder(), setValue(orig_val), ngModel.$setViewValue(orig_val);
                        var setDirection = !1;
                        elem.bind("focus", function() {
                            handleFocused(!0), elem.hasClass(emptyClassName) && (elem.val(""), elem.removeClass(emptyClassName), 
                            elem.removeClass("error"));
                        }), elem.bind("blur", function() {
                            handleFocused(!1);
                            var val = elem.val();
                            scope.$apply(function() {
                                setValue(val), ngModel.$setViewValue(val);
                            });
                        }), ngModel.$render = function() {
                            setValue(ngModel.$viewValue);
                        };
                    } else elem.attr("placeholder", text), elem.bind("focus", function() {
                        handleFocused(!0);
                    }), elem.bind("blur", function() {
                        handleFocused(!1);
                    });
                }
            }
        };
    });
}), define("common/js/modules/bsForm/bsBlinkOnFormErrorDirective", [ "./bsFormModule" ], function(module) {
    module.directive("bsBlinkOnFormError", function($timeout) {
        return {
            restrict: "A",
            require: "^form",
            link: function(scope, element, attrs, formController) {
                function setBlinkOn(isOn, millis) {
                    $timeout(function() {
                        isOn ? element.addClass("blink") : element.removeClass("blink");
                    }, millis);
                }
                var formName = formController.$name;
                scope[formName] = formController;
                var firstTime = !0;
                scope.$on("bsFormError", function() {
                    var delayBefroeFirstBlink = 0;
                    firstTime && (delayBefroeFirstBlink = 1500, firstTime = !1), setBlinkOn(!0, delayBefroeFirstBlink), 
                    setBlinkOn(!1, delayBefroeFirstBlink + 2e3);
                });
            }
        };
    });
}), define("common/js/modules/bsForm/formConstants", [ "./bsFormModule" ], function(module) {
    module.factory("FormConstants", function() {
        return {
            validationPatterns: {
                alpha: /^[^0-9\\`\\~\\!\\@\\#\\$\\%\\^\\&\\*\\(\\)\\-\\=\\\\_\\+]*$/,
                phone: /^[0-9\\(\\)\\.\\-\\ \\\\\\-]*$/
            }
        };
    });
}), define("common/js/modules/bsForm/bsCheckboxDirective", [ "./bsFormModule" ], function(module) {
    module.directive("bsCheckbox", function() {
        return {
            restrict: "E",
            replace: !0,
            scope: {
                bsModel: "="
            },
            link: function(scope) {
                scope.toggleChecked = function() {
                    scope.bsModel = !scope.bsModel;
                };
            },
            template: '<div class="bs-checkbox" ng-class="{checked:bsModel}" ng-click="toggleChecked()">&nbsp;</div>'
        };
    });
}), define("common/js/modules/bsForm/index", [ "./bsFormModule", "./bsFormDirective", "./bsCheckListDirective", "./bsDateFieldDirective", "./bsFormValidationMessage", "./bsFormGroupDirective", "./bsPlaceHolderDirective", "./bsBlinkOnFormErrorDirective", "./formConstants", "./bsCheckboxDirective" ], function() {}), 
define("common/js/modules/validate/validateModule", [ "angular" ], function(ng) {
    return ng.module("commonModules.validate", []);
}), define("common/js/modules/validate/validateDirective", [ "./validateModule" ], function(module) {
    module.directive("bsValidate", function() {
        return {
            restrict: "A",
            require: "ngModel",
            link: function(scope, elm, attrs, ctrl) {
                function apply_watch(watch) {
                    return angular.isString(watch) ? void scope.$watchCollection(watch, function() {
                        angular.forEach(validators, function(validatorFn) {
                            validatorFn(ctrl.$modelValue);
                        });
                    }) : angular.isArray(watch) ? void angular.forEach(watch, function(expression) {
                        scope.$watch(expression, function() {
                            angular.forEach(validators, function(validatorFn) {
                                validatorFn(ctrl.$modelValue);
                            });
                        });
                    }) : void (angular.isObject(watch) && angular.forEach(watch, function(expression, validatorKey) {
                        angular.isString(expression) && scope.$watch(expression, function() {
                            validators[validatorKey](ctrl.$modelValue);
                        }), angular.isArray(expression) && angular.forEach(expression, function(intExpression) {
                            scope.$watch(intExpression, function() {
                                validators[validatorKey](ctrl.$modelValue);
                            });
                        });
                    }));
                }
                var validateFn, validators = {}, validateExpr = scope.$eval(attrs.bsValidate);
                validateExpr && (angular.isString(validateExpr) && (validateExpr = {
                    validator: validateExpr
                }), angular.forEach(validateExpr, function(exprssn, key) {
                    validateFn = function(valueToValidate) {
                        var expression = scope.$eval(exprssn, {
                            $value: valueToValidate
                        });
                        return angular.isObject(expression) && angular.isFunction(expression.then) ? (expression.then(function() {
                            ctrl.$setValidity(key, !0);
                        }, function() {
                            ctrl.$setValidity(key, !1);
                        }), valueToValidate) : expression ? (ctrl.$setValidity(key, !0), valueToValidate) : (ctrl.$setValidity(key, !1), 
                        valueToValidate);
                    }, validators[key] = validateFn, ctrl.$formatters.push(validateFn), ctrl.$parsers.push(validateFn);
                }), attrs.bsValidateWatch && apply_watch(scope.$eval(attrs.bsValidateWatch)));
            }
        };
    });
}), define("common/js/modules/validate/index", [ "./validateModule", "./validateDirective" ], function() {}), 
define("common/js/modules/animations/animationsModule", [ "angular" ], function(ng) {
    return ng.module("commonModules.animations", []);
}), define("common/js/modules/animations/markDirective", [ "./animationsModule" ], function(module) {
    module.directive("bsMark", function($animate) {
        return function(scope, elem, attributes) {
            scope.$watch(attributes.bsMark, function(newValue, oldValue) {
                if (newValue != oldValue) {
                    var cssClass = "mark-animation";
                    setTimeout(function() {
                        $animate.addClass(elem, cssClass, function() {
                            $animate.removeClass(elem, cssClass);
                        });
                    }, 300);
                }
            });
        };
    });
}), define("common/js/modules/animations/index", [ "./animationsModule", "./markDirective" ], function() {}), 
define("common/js/modules/cloudinary/cloudinaryModule", [ "angular" ], function(ng) {
    return ng.module("commonModules.cloudinary", []);
}), define("common/js/modules/cloudinary/cloudinaryService", [ "./cloudinaryModule" ], function(module) {
    module.factory("CloudinaryService", function() {
        function getSizePart(sizePart, extactSize) {
            if (-1 != sizePart.indexOf(".")) return sizePart;
            var sizePartInt = 1 * sizePart;
            return extactSize ? sizePartInt : 100 >= sizePartInt ? 100 : 400 >= sizePartInt ? 400 : 1e3;
        }
        function parseParams(params) {
            var commandParts = [];
            if (params) {
                if (params.size) {
                    commandParts.push("a_ignore"), commandParts.push("q_80");
                    var sizeParts = params.size.split("x"), sizeCommand = "";
                    sizeParts[0] && (sizeCommand = "w_" + getSizePart(sizeParts[0], params.exactSize)), 
                    sizeParts[1] && (sizeCommand += (sizeCommand ? "," : "") + "h_" + getSizePart(sizeParts[1], params.exactSize)), 
                    commandParts.push(sizeCommand), commandParts.push(params.mode ? "c_" + params.mode : "c_limit");
                }
                params.effect && commandParts.push("e_" + params.effect);
            }
            return commandParts.toString();
        }
        function getUrl(path, params) {
            if (!path) return null;
            var url = BASE_URL + parseParams(params) + "/" + path;
            return params && params.quality && (url += ".jpg"), url;
        }
        function jsonParamsToUrlParams(params) {
            var url = "";
            for (param in params) -1 == param.indexOf("$$") && (url += "," + param + "_" + params[param]);
            return url;
        }
        function getCollageUrl(imageUrls, collageSettings) {
            for (var result = "", i = 0; i < collageSettings.length && i < imageUrls.length; i++) i > 0 && (result += "/l_", 
            result += imageUrls[i].split("/")[1] + ","), result += "a_ignore,g_north_west,c_fill" + jsonParamsToUrlParams(collageSettings[i]);
            return result += "/" + imageUrls[0], BASE_URL + result;
        }
        return BASE_URL = "https://res.cloudinary.com/bidspirit/image/upload/", {
            getUrl: getUrl,
            getCollageUrl: getCollageUrl,
            BASE_URL: BASE_URL
        };
    });
}), define("common/js/modules/cloudinary/cloudinaryFilter", [ "./cloudinaryModule" ], function(module) {
    return module.filter("cloudinary", [ "CloudinaryService", function(CloudinaryService) {
        return function(path, params) {
            if (!path) return null;
            var url = CloudinaryService.getUrl(path, params);
            return params && params.asBg ? "background-image:url(" + url + ")" : url;
        };
    } ]);
}), define("common/js/modules/cloudinary/cloudinaryBgDirective", [ "./cloudinaryModule" ], function(module) {
    module.directive("bsCloudinaryBg", function(CloudinaryService) {
        return {
            restrict: "A",
            scope: {
                path: "@bsCloudinaryBg",
                params: "="
            },
            link: function(scope, element) {
                function setUrl() {
                    var url = CloudinaryService.getUrl(scope.path, scope.params);
                    url ? element.css("background-image", "url(" + url + ")") : element.css("background-image", "");
                }
                setUrl(), scope.$watch("path", setUrl);
            }
        };
    });
}), define("common/js/modules/cloudinary/index", [ "./cloudinaryModule", "./cloudinaryService", "./cloudinaryFilter", "./cloudinaryBgDirective" ], function() {}), 
define("common/js/modules/socialPlugins/socialPluginsModule", [ "angular" ], function(ng) {
    return ng.module("commonModules.socialPlugins", []);
}), define("common/js/modules/socialPlugins/facebookService", [ "./socialPluginsModule" ], function(module) {
    module.factory("FacbookService", function($q) {
        function loadFb(deferred) {
            window.fbAsyncInit = function() {
                FB.init({
                    appId: "542961752415314",
                    xfbml: !0,
                    version: "v2.3"
                }), mInitialized = !0, deferred.resolve();
            }, function(d, s, id) {
                var js, fjs = d.getElementsByTagName(s)[0];
                d.getElementById(id) || (js = d.createElement(s), js.id = id, js.src = "//connect.facebook.net/en_US/" + (DEBUG_MODE ? "sdk/debug.js" : "sdk.js"), 
                fjs.parentNode.insertBefore(js, fjs));
            }(document, "script", "facebook-jssdk");
        }
        function validateInitialized() {
            var deferred = $q.defer();
            return mInitialized ? deferred.resolve() : loadFb(deferred), deferred.promise;
        }
        function ensureLoggedIn() {
            var deferred = $q.defer();
            return validateInitialized().then(function() {
                FB.getLoginStatus(function(response) {
                    "connected" == response.status ? deferred.resolve(response) : FB.login(function(response) {
                        deferred.resolve(response);
                    }, {
                        scope: "publish_actions,publish_pages,manage_pages "
                    });
                });
            }), deferred.promise.then(function(response) {
                mCurrentUserFbId = response.authResponse.userID;
            }), deferred.promise;
        }
        function getPageData(pageId) {
            var deferred = $q.defer();
            return FB.api(mCurrentUserFbId + "/accounts", function(response) {
                for (var i = 0; i < response.data.length; i++) {
                    var pageData = response.data[i];
                    if (pageData.id == pageId) return void deferred.resolve(pageData);
                }
                console.warn("Faild to get page data for page id " + pageId), deferred.reject();
            }), deferred.promise;
        }
        function callPostImageApi(pageId, accessToken, imageUrl, caption) {
            var deferred = $q.defer();
            return FB.api("/" + pageId + "/photos", "POST", {
                access_token: accessToken,
                url: imageUrl,
                caption: caption
            }, function(response) {
                deferred.resolve(response);
            }), deferred.promise;
        }
        function postImageToPage(pageId, imageUrl, caption) {
            var deferred = $q.defer();
            return ensureLoggedIn().then(function() {
                getPageData(pageId).then(function(pageData) {
                    callPostImageApi(pageId, pageData.access_token, imageUrl, caption).then(function(response) {
                        deferred.resolve(response);
                    });
                });
            }), deferred.promise;
        }
        var mInitialized = !1, DEBUG_MODE = !1, mCurrentUserFbId = null;
        return {
            postImageToPage: postImageToPage
        };
    });
}), define("common/js/modules/socialPlugins/index", [ "./socialPluginsModule", "./facebookService" ], function() {}), 
define("common/js/modules/log/logModule", [ "angular" ], function(ng) {
    return ng.module("commonModules.log", []);
}), function(root, factory) {
    "function" == typeof define && define.amd ? define("common/js/lib/logEntries", [ root ], factory) : "object" == typeof exports ? module.exports = factory(root) : root.LE = factory(root);
}(this, function(window) {
    function LogStream(options) {
        var _traceCode = (Math.random() + Math.PI).toString(36).substring(2, 10), _doTrace = options.trace, _pageInfo = options.page_info, _token = options.token, _print = options.print, _endpoint = "js.logentries.com/v1", _shouldCall = !0, _SSL = function() {
            return "undefined" == typeof XDomainRequest ? options.ssl : "https:" === location.protocol ? !0 : !1;
        }(), _backlog = [], _active = !1, _sentPageInfo = !1;
        if (options.catchall) {
            var oldHandler = window.onerror, newHandler = function(msg, url, line) {
                return _rawLog({
                    error: msg,
                    line: line,
                    location: url
                }).level("ERROR").send(), oldHandler ? oldHandler(msg, url, line) : !1;
            };
            window.onerror = newHandler;
        }
        var _agentInfo = function() {
            var nav = window.navigator || {
                doNotTrack: void 0
            }, screen = window.screen || {}, _location = window.location || {};
            return {
                url: _location.pathname,
                referrer: document.referrer,
                screen: {
                    width: screen.width,
                    height: screen.height
                },
                window: {
                    width: window.innerWidth,
                    height: window.innerHeight
                },
                browser: {
                    name: nav.appName,
                    version: nav.appVersion,
                    cookie_enabled: nav.cookieEnabled,
                    do_not_track: nav.doNotTrack
                },
                platform: nav.platform
            };
        }, _getEvent = function() {
            var raw = null, args = Array.prototype.slice.call(arguments);
            if (0 === args.length) throw new Error("No arguments!");
            return raw = 1 === args.length ? args[0] : args;
        }, _rawLog = function() {
            var event = _getEvent.apply(this, arguments), data = {
                event: event
            };
            return "never" !== _pageInfo && (_sentPageInfo && "per-entry" !== _pageInfo || (_sentPageInfo = !0, 
            "undefined" == typeof event.screen && "undefined" == typeof event.browser && _rawLog(_agentInfo()).level("PAGE").send())), 
            _doTrace && (data.trace = _traceCode), {
                level: function(l) {
                    if (_print && "undefined" != typeof console && "PAGE" !== l) try {
                        console[l.toLowerCase()].call(console, data);
                    } catch (ex) {}
                    return data.level = l, {
                        send: function() {
                            var cache = [], serialized = JSON.stringify(data, function(key, value) {
                                var _indexOf = function(array, obj) {
                                    for (var i = 0; i < array.length; i++) if (obj === array[i]) return i;
                                    return -1;
                                };
                                if ("undefined" == typeof value) return "undefined";
                                if ("object" == typeof value && null !== value) {
                                    if (-1 !== _indexOf(cache, value)) return "<?>";
                                    cache.push(value);
                                }
                                return value;
                            });
                            _active ? _backlog.push(serialized) : _apiCall(_token, serialized);
                        }
                    };
                }
            };
        };
        this.log = _rawLog;
        var _apiCall = function(token, data) {
            _active = !0;
            var _getAjaxObject = function() {
                return "undefined" != typeof XDomainRequest ? new XDomainRequest() : new XMLHttpRequest();
            }, request = _getAjaxObject();
            if (_shouldCall) {
                request.constructor === XMLHttpRequest ? request.onreadystatechange = function() {
                    4 === request.readyState && (request.status >= 400 ? (console.error("Couldn't submit events."), 
                    410 === request.status && console.warn("This version of le_js is no longer supported!")) : (301 === request.status && console.warn("This version of le_js is deprecated! Consider upgrading."), 
                    _backlog.length > 0 ? _apiCall(token, _backlog.shift()) : _active = !1));
                } : request.onload = function() {
                    _backlog.length > 0 ? _apiCall(token, _backlog.shift()) : _active = !1;
                };
                var uri = (_SSL ? "https://" : "http://") + _endpoint + "/logs/" + _token;
                request.open("POST", uri, !0), request.constructor === XMLHttpRequest, request.send(data);
            }
        };
    }
    function Logger(options) {
        var logger, dict = {
            ssl: !0,
            catchall: !1,
            trace: !0,
            page_info: "never",
            print: !1,
            token: null
        };
        if ("object" != typeof options) throw new Error("Invalid parameters for createLogStream()");
        for (var k in options) dict[k] = options[k];
        if (null === dict.token) throw new Error("Token not present.");
        logger = new LogStream(dict);
        var _log = function() {
            if (logger) return logger.log.apply(this, arguments);
            throw new Error("You must call LE.init(...) first.");
        };
        return {
            log: function() {
                _log.apply(this, arguments).level("LOG").send();
            },
            warn: function() {
                _log.apply(this, arguments).level("WARN").send();
            },
            error: function() {
                _log.apply(this, arguments).level("ERROR").send();
            },
            info: function() {
                _log.apply(this, arguments).level("INFO").send();
            }
        };
    }
    var loggers = {}, _getLogger = function(name) {
        if (!loggers.hasOwnProperty(name)) throw new Error("Invalid name for logStream");
        return loggers[name];
    }, _createLogStream = function(options) {
        if ("string" != typeof options.name) throw new Error("Name not present.");
        if (loggers.hasOwnProperty(options.name)) throw new Error("Alrready exist this name for a logStream");
        return loggers[options.name] = new Logger(options), !0;
    }, _deprecatedInit = function(options) {
        var dict = {
            name: "default"
        };
        if ("object" == typeof options) for (var k in options) dict[k] = options[k]; else {
            if ("string" != typeof options) throw new Error("Invalid parameters for init()");
            dict.token = options;
        }
        return _createLogStream(dict);
    }, _destroyLogStream = function(name) {
        "undefined" == typeof name && (name = "default"), delete loggers[name];
    };
    return {
        init: _deprecatedInit,
        createLogStream: _createLogStream,
        to: _getLogger,
        destroy: _destroyLogStream,
        log: function() {
            for (var k in loggers) loggers[k].log.apply(this, arguments);
        },
        warn: function() {
            for (var k in loggers) loggers[k].warn.apply(this, arguments);
        },
        error: function() {
            for (var k in loggers) loggers[k].error.apply(this, arguments);
        },
        info: function() {
            for (var k in loggers) loggers[k].info.apply(this, arguments);
        }
    };
}), define("common/js/modules/log/logService", [ "./logModule", "common/js/lib/logEntries" ], function(module, LE) {
    module.factory("LogService", function($rootScope, $log, SettingsService, SessionInfo) {
        function init(token) {
            if (!$rootScope.searchAgentRequest) {
                if (!token) return void $log.warn("initializing log without token!");
                LE.init({
                    token: token,
                    ssl: !0
                }), mInitialized = !0, window.onerror = handleError;
            }
        }
        function logEvent(event) {
            if (mInitialized) {
                var message = "";
                if ("object" == typeof event) for (var key in event) message += "	" + key + ":" + event[key]; else message = event;
                logMessage(message);
            }
        }
        function logMessage(message) {
            mInitialized && LE.log(SessionInfo.sessionId + "	" + message);
        }
        function handleError(msg, url, line) {
            var message = msg + " Url: " + url + " Line: " + line;
            return GlobalConfig.devMode && GlobalConfig.isMobileApp && alert(message), printTrace(), 
            logError(message), GlobalConfig.devEnv ? !1 : !0;
        }
        function printTrace() {
            try {
                console.trace();
            } catch (e) {}
        }
        function exceptionMessage(e) {
            var message = e.message;
            return message || (message = e.toString()), e.stack && (message += " | stack: " + e.stack), 
            message;
        }
        function logError(errorStr, e) {
            try {
                if (-1 != navigator.userAgent.indexOf("Googlebot")) return;
                var errorToLog = errorStr;
                e && (errorToLog += exceptionMessage(e)), $log.warn(errorToLog), errorToLog = "(" + SettingsService.secondsSinceStart() + ") " + errorToLog, 
                5 > mLoggedErrors && (mLoggedErrors++, logEvent({
                    eventType: "jsError",
                    message: errorToLog
                }));
            } catch (e1) {
                $log.warn("failed to log message: " + exceptionMessage(e1)), printTrace();
            }
        }
        var mInitialized = !1, mLoggedErrors = 0;
        return {
            logEvent: logEvent,
            logMessage: logMessage,
            logError: logError,
            init: init
        };
    });
}), define("common/js/modules/log/bsLogClickDirective", [ "./logModule" ], function(module) {
    module.directive("bsLogClick", function(LogService) {
        return {
            restrict: "A",
            link: function(scope, elem, attributes) {
                elem.bind("click", function() {
                    LogService.logEvent({
                        click: attributes.bsLogClick
                    });
                });
            }
        };
    });
}), define("common/js/modules/log/analyticsService", [ "./logModule" ], function(module) {
    module.factory("AnalyticsService", function($http, PathsService, Analytics, LogService, LocalStorageService, SessionInfo) {
        function trackEvent(category, action, label, options) {
            if (new Date().getTime() - GlobalConfig.pageLoadTime > TRACKED_EVENTS_DELAY) {
                var key = category + "_" + action + "_" + label;
                try {
                    if (options) {
                        if (!LocalStorageService.isEnabled()) return;
                        var analyticsInfo = LocalStorageService.load("analyticsInfo");
                        analyticsInfo = analyticsInfo ? JSON.parse(analyticsInfo) : {};
                        var infoForKey = analyticsInfo[key];
                        if (options.dailyUnique && infoForKey && new Date().getTime() - infoForKey.time < 864e5) return;
                        analyticsInfo[key] = {
                            time: new Date().getTime()
                        }, LocalStorageService.store("analyticsInfo", JSON.stringify(analyticsInfo)), options.appSiteTrackInfo && trackAppSiteEvent(options.appSiteTrackInfo);
                    }
                    if (GlobalConfig.isMobileApp && window.analytics) window.analytics.trackEvent(category, action, label); else {
                        if (mIsBidspiritEmployee) return;
                        Analytics.trackEvent(category, action, label);
                    }
                } catch (e) {
                    LogService.logError("failed to log event in analyicts " + key + "," + JSON.stringify(options), e);
                }
            } else mDelayedTrackedEvent.push({
                category: category,
                action: action,
                label: label,
                options: options
            });
        }
        function trackDailyUniqueEvent(category, action, label) {
            trackEvent(category, action, label, {
                dailyUnique: !0
            });
        }
        function trackAppSiteEvent(appSiteTrackInfo) {
            var house = appSiteTrackInfo.house;
            if (house && house.site && house.site.code) {
                var siteCode = house.site.code, apiPath = PathsService.getAppSiteUrl(siteCode) + "/lgapi/" + appSiteTrackInfo.api + "?localId=" + SessionInfo.sessionId, params = appSiteTrackInfo.params;
                if (params) for (param in params) apiPath += "&" + param + "=" + params[param];
                $http.get(apiPath);
            }
        }
        function trackPage(page) {
            clearTimeout(mPageTrackDelay), mPageTrackDelay = setTimeout(function() {
                if (GlobalConfig.isMobileApp && window.analytics) window.analytics.trackView(page); else {
                    if (mIsBidspiritEmployee) return;
                    Analytics.trackPage(page);
                }
            }, 1e3);
        }
        function traceDelayedEvents() {
            for (var i = 0; i < mDelayedTrackedEvent.length; i++) {
                var event = mDelayedTrackedEvent[i];
                trackEvent(event.category, event.action, event.label, event.options);
            }
        }
        TRACKED_EVENTS_DELAY = GlobalConfig.devEnv ? 0 : 3e4;
        var mDelayedTrackedEvent = [], mIsBidspiritEmployee = "true" == LocalStorageService.load("bidspiritEmployee"), mPageTrackDelay = null;
        return setTimeout(traceDelayedEvents, TRACKED_EVENTS_DELAY + 200), {
            trackEvent: trackEvent,
            trackDailyUniqueEvent: trackDailyUniqueEvent,
            trackPage: trackPage
        };
    });
}), define("common/js/modules/log/index", [ "./logModule", "./logService", "./bsLogClickDirective", "./analyticsService" ], function() {}), 
define("common/js/modules/mobileApp/mobileAppModule", [ "angular" ], function(ng) {
    return ng.module("commonModules.mobileApp", []);
}), define("common/js/modules/mobileApp/puffinService", [ "./mobileAppModule" ], function(module) {
    module.factory("PuffinService", function() {
        function tryToLaunchWithPuffin(url) {
            var openNormally = function() {
                window.open(url, "_system");
            }, openWithProtocol = function(protocol) {
                window.open(url.replace("https", protocol), "_system");
            }, openWithPuffin = function() {
                openWithProtocol("puffin");
            }, openWithPuffinFree = function() {
                openWithProtocol("puffinFree");
            };
            "undefined" == typeof device ? openNormally() : checkPuffinExists(openWithPuffin, function() {
                checkPuffinFreeExists(openWithPuffinFree, openNormally);
            });
        }
        function checkSchemeExists(iosScheme, androidSceme, onFound, onNotFound) {
            var scheme = null;
            "undefined" != typeof device && ("iOS" === device.platform ? scheme = iosScheme : "Android" === device.platform && (scheme = androidSceme)), 
            scheme ? appAvailability.check(scheme, onFound, onNotFound) : onNotFound();
        }
        function checkPuffinExists(onFound, onNotFound) {
            return checkSchemeExists("puffin://", "com.cloudmosa.puffin", onFound, onNotFound);
        }
        function checkPuffinFreeExists(onFound, onNotFound) {
            return checkSchemeExists("puffinFree://", "com.cloudmosa.puffinFree", onFound, onNotFound);
        }
        return {
            tryToLaunchWithPuffin: tryToLaunchWithPuffin
        };
    });
}), define("common/js/modules/mobileApp/portalMobileUtils", [ "./mobileAppModule" ], function(module) {
    module.factory("PortalMobileUtils", function($rootScope, $http, $q, SettingsService, LocalStorageService, PathsService) {
        function displayFailure(message) {
            $rootScope.debug("Error:" + message), BidspiritLoader.addErrorInfo(message), BidspiritLoader.displayDebugIfDev();
        }
        function addToDebug(message) {
            $rootScope.debug(message);
        }
        function storeLocalData(fileName, data, onSuccess, onFail) {
            BidspiritLoader.mFileSystem.root.getFile(fileName, {
                create: !0,
                exclusive: !1
            }, function(entry) {
                entry.createWriter(function(fileWriter) {
                    fileWriter.onwriteend = function() {
                        fileWriter.seek(0), onSuccess && onSuccess();
                    }, fileWriter.write(data);
                }, onFail);
            }, onFail);
        }
        function loadLocalData(fileName, handleData, handleFailure) {
            return BidspiritLoader.mFileSystem ? void BidspiritLoader.mFileSystem.root.getFile(fileName, {
                create: !0,
                exclusive: !1
            }, function(entry) {
                entry.file(function(file) {
                    var reader = new FileReader();
                    reader.onloadend = function(evt) {
                        handleData(evt.target.result);
                    }, reader.readAsText(file);
                }, function() {
                    BidspiritLoader.addErrorInfo("get file failed " + fileName), handleFailure && handleFailure();
                });
            }, function() {
                BidspiritLoader.addErrorInfo("get file failed " + fileName), handleFailure && handleFailure();
            }) : (BidspiritLoader.addErrorInfo("file system not found"), void (handleFailure && handleFailure()));
        }
        function storeLocalTexts(lang) {
            var textsVersion = SettingsService.getAll().cacheVersions.TEXTS, deferred = $q.defer(), fileName = getLocalTextFileName(lang, textsVersion), url = PathsService.getPortalTextsUrl(lang);
            return addToDebug("loading lang from url " + url), $http({
                url: url,
                cache: !1
            }).then(function(textsData) {
                storeLocalData(fileName, textsData.data, function() {
                    addToDebug("stored at " + fileName), deferred.resolve();
                }, function(e) {
                    deferred.reject("failed to save file " + fileName + "," + JSON.stringify(e));
                });
            }, function(e) {
                deferred.reject("failed to load updated texts. " + JSON.stringify(e));
            }), deferred.promise;
        }
        function updateLocalTextsInAllLangs(newTextsVersion) {
            addToDebug("updating texts to " + newTextsVersion);
            var langs = SettingsService.get("languages"), deferred = $q.defer();
            return BidspiritLoader.mFileSystem.root.getDirectory("localTexts", {
                create: !0,
                exclusive: !1
            }, function() {
                for (var promises = [], i = 0; i < langs.length; i++) promises.push(storeLocalTexts(langs[i], newTextsVersion));
                return $q.all(promises).then(function() {
                    removeOldLocalTexts(newTextsVersion), deferred.resolve();
                }, function(error) {
                    displayFailure("error while storing local texts:" + error), deferred.reject();
                });
            }, function() {
                displayFailure("failed to get local text directory"), deferred.reject();
            }), deferred.promise;
        }
        function removeOldLocalTexts(currentTextsVersion) {
            BidspiritLoader.mFileSystem.root.getDirectory("localTexts", {
                create: !0,
                exclusive: !1
            }, function(directoryEntry) {
                directoryEntry.createReader().readEntries(function(entries) {
                    for (var i = 0; i < entries.length; i++) {
                        var entry = entries[i], isLatestTexts = -1 != entry.name.indexOf("." + currentTextsVersion + ".");
                        isLatestTexts || !function(_entry) {
                            addToDebug("removing " + _entry.name), entry.remove(function() {
                                addToDebug("removed " + _entry.name);
                            }, function() {
                                BidspiritLoader.addErrorInfo("failed to removed " + _entry.name);
                            });
                        }(entry);
                    }
                });
            });
        }
        function getLocalTextFileName(lang, version) {
            return "localTexts/" + lang + "." + version + ".properties";
        }
        function getTextsLoadPromise(lang) {
            function loadDefaultTexts() {
                $http({
                    url: appDefaultPath,
                    cache: !0
                }).success(function(texts) {
                    deferred.resolve({
                        data: texts
                    });
                });
            }
            var appDefaultPath = "texts/texts." + lang + ".properties", textsVersion = SettingsService.getAll().cacheVersions.TEXTS, deferred = $q.defer();
            return addToDebug("Loaded texts:" + GlobalConfig.loadedTextsVersion + ", settingTexts:" + textsVersion), 
            GlobalConfig.loadedTextsVersion == textsVersion ? loadDefaultTexts() : loadLocalData(getLocalTextFileName(lang, textsVersion), function(loadedTexts) {
                null != loadedTexts ? (addToDebug("loaded local texts for " + textsVersion), GlobalConfig.loadedTextsVersion = textsVersion, 
                deferred.resolve({
                    data: loadedTexts
                })) : (displayFailure("local texts not found, using default "), loadDefaultTexts());
            }, function() {
                displayFailure("failed to read local texts, using default "), loadDefaultTexts();
            }), deferred.promise;
        }
        function handleUpdateFailure(message) {
            displayFailure(message), BidspiritLoader.clear(), updateFailCounter = LocalStorageService.load("updateFailCounter") || 0, 
            LocalStorageService.store("updateFailCounter", updateFailCounter + 1);
        }
        function updateBidspiritDataAndTheme(appVersion) {
            addToDebug("updating version to " + appVersion);
            var contentUrl, styleUrl;
            GlobalConfig.devMode ? (contentUrl = SettingsService.get("portalAddress") + "debug/all.debug.js?v=" + appVersion, 
            styleUrl = SettingsService.get("portalAddress") + "/portal/styles/style.css?v=" + appVersion) : (contentUrl = "https:" + SettingsService.get("staticFileBase") + "/portal/js/all.js?v=" + appVersion, 
            styleUrl = "https:" + SettingsService.get("staticFileBase") + "/portal/styles/style.css?v=" + appVersion), 
            addToDebug("loading theme from url:" + styleUrl), $http.get(styleUrl).success(function(themeData) {
                addToDebug("got theme " + themeData.length + " ..." + themeData.substr(themeData.length - 100)), 
                themeData.length > 1e5 && themeData.match("}$") ? (addToDebug("storing theme..."), 
                storeLocalData(BidspiritLoader.THEME_FILE, themeData, function() {
                    addToDebug("getting content from url " + contentUrl), $http.get(contentUrl).success(function(data) {
                        addToDebug("got data of length" + data.length), data.length > 1e5 ? storeLocalData(BidspiritLoader.DATA_FILE, appVersion + "," + GlobalConfig.mobileAppVersion + "~" + data + ";\nBidspiritLoader.localContentLoaded=true", function() {
                            LocalStorageService.store("updateFailCounter", 0), GlobalConfig.devMode && alert("update data done. reloading..."), 
                            window.location.reload();
                        }, function() {
                            handleUpdateFailure("failed to write content");
                        }) : handleUpdateFailure("bad content. length:" + data.length + ", ..." + data.substr(data.length - 100));
                    }).error(function(error) {
                        handleUpdateFailure("failed to get content from url " + contentUrl + ", " + JSON.stringify(error).substr(0, 50) + "...");
                    });
                }, function() {
                    handleUpdateFailure("failed to get store theme");
                })) : handleUpdateFailure("bad theme data from url " + styleUrl + ": length:" + themeData.length + " ..." + themeData.substr(themeData.length - 100));
            }).error(function() {
                handleUpdateFailure("failed to get theme from url " + styleUrl);
            });
        }
        return {
            updateBidspiritDataAndTheme: updateBidspiritDataAndTheme,
            loadLocalData: loadLocalData,
            getTextsLoadPromise: getTextsLoadPromise,
            updateLocalTextsInAllLangs: updateLocalTextsInAllLangs
        };
    });
}), define("common/js/modules/mobileApp/index", [ "./mobileAppModule", "./puffinService", "./portalMobileUtils" ], function() {}), 
define("common/js/modules/catalogUtils/catalogUtilsModule", [ "angular" ], function(ng) {
    return ng.module("commonModules.catalogUtils", []);
}), define("common/js/modules/catalogUtils/catalogUtilsService", [ "./catalogUtilsModule" ], function(module) {
    module.factory("CatalogUtilsService", function(StringsService, ArraysService, I18nService, DateUtilsService) {
        function sortLots(items, options) {
            return items ? (items.sort(function(item1, item2) {
                return compareLots(item1, item2, options || {});
            }), items) : null;
        }
        function getPaddedIndex(index) {
            for (var digitCount = 0, stippedIndex = (index + "").replace(/^0+/, ""), i = 0; i < stippedIndex.length && stippedIndex.charAt(i) >= "0" && stippedIndex.charAt(i) <= "9"; i++) digitCount++;
            return StringsService.pad(stippedIndex.substr(0, digitCount), 10, "0") + stippedIndex.substr(digitCount);
        }
        function compareLots(item1, item2, options) {
            options || (options = {});
            var auctionDateCompare = 0;
            return item1.auctionDate != item2.auctionDate ? auctionDateCompare = item1.auctionDate > item2.auctionDate ? 1 : -1 : item1.auctionId != item2.auctionId && (auctionDateCompare = item1.auctionId > item2.auctionId ? 1 : -1), 
            options.reverseAuctionDate && (auctionDateCompare = -1 * auctionDateCompare), 0 != auctionDateCompare ? auctionDateCompare : compareIndexes(item1.itemIndex, item2.itemIndex);
        }
        function compareIndexes(index1, index2) {
            var paddedIndex1 = getPaddedIndex(index1), paddedIndex2 = getPaddedIndex(index2);
            return paddedIndex1 == paddedIndex2 ? 0 : paddedIndex1 > paddedIndex2 ? 1 : -1;
        }
        function getLotPage(items, lotId, itemsPerPage) {
            var lotInd = ArraysService.getIndById(items, lotId);
            return null == lotInd ? 1 : Math.ceil((lotInd + 1) / itemsPerPage);
        }
        function getPageItems(allItems, page, itemsPerPage) {
            if (!allItems) return [];
            var startInd = (page - 1) * itemsPerPage, endInd = startInd + 1 * itemsPerPage;
            return allItems.slice(startInd, endInd);
        }
        function checkLotMatchPhrase(lot, phrase) {
            var score = 0;
            if (getPaddedIndex(lot.itemIndex) == getPaddedIndex(phrase)) score = 20; else if (lot.itemIndex.indexOf(phrase) > -1) score = 4 - lot.itemIndex.indexOf(phrase); else if (phrase.length > 1) {
                for (var langFields = [ "artist", "name", "description", "details" ], i = 0; i < langFields.length; i++) {
                    var field = langFields[i], fieldValue = I18nService.getLangField(lot[field]);
                    fieldValue && fieldValue.indexOf(phrase) > -1 && (score += 4 - i / 2 + phrase.length / 2);
                }
                if (phrase.length > 3 || phrase.indexOf(lot.auction.catalogInfo.currency) > -1) {
                    var phraseDigits = phrase.replace(/[^\d]/g, "");
                    phraseDigits && (lot.startPrice && lot.startPrice == phraseDigits && (score += 1), 
                    lot.estimatedPrice && lot.estimatedPrice.replace(/[^\d]/g, "").indexOf(phraseDigits) > -1 && (score += 1));
                }
            }
            return {
                lot: lot,
                score: score
            };
        }
        function getAuctionTimeDisplay(auction, dateOnly, withoutDayOfWeek, textsMap) {
            if (!auction.date) return "";
            var auctionDate = DateUtilsService.parseServerDate(auction.date), time = dateOnly || auction.hideTime || "ENDED" == auction.state ? null : auction.time;
            return I18nService.getDateDisplay(auctionDate, time, {
                withoutTime: dateOnly,
                withoutDayOfMonth: auction.unknownExactDate,
                withoutDayOfWeek: withoutDayOfWeek
            }, textsMap);
        }
        return {
            sortLots: sortLots,
            getPaddedIndex: getPaddedIndex,
            compareLots: compareLots,
            compareIndexes: compareIndexes,
            getPageItems: getPageItems,
            getLotPage: getLotPage,
            getAuctionTimeDisplay: getAuctionTimeDisplay,
            checkLotMatchPhrase: checkLotMatchPhrase
        };
    });
}), define("common/js/modules/catalogUtils/index", [ "./catalogUtilsModule", "./catalogUtilsService" ], function() {}), 
define("commonModules", [ "angular", "ngdir/angular-ui-router", "common/js/modules/strings/index", "common/js/modules/utils/index", "common/js/modules/domUtils/index", "common/js/modules/api/index", "common/js/modules/system/index", "common/js/modules/paths/index", "common/js/modules/i18n/index", "common/js/modules/dialogs/index", "common/js/modules/asyncButton/index", "common/js/modules/bsForm/index", "common/js/modules/validate/index", "common/js/modules/animations/index", "common/js/modules/cloudinary/index", "common/js/modules/socialPlugins/index", "common/js/modules/log/index", "common/js/modules/mobileApp/index", "common/js/modules/catalogUtils/index" ], function(ng) {
    return ng.module("commonModules", [ "ui.router", "commonModules.strings", "commonModules.utils", "commonModules.api", "commonModules.system", "commonModules.paths", "commonModules.cloudinary", "commonModules.socialPlugins", "commonModules.dialogs", "commonModules.asyncButton", "commonModules.bsForm", "commonModules.i18n", "commonModules.validate", "commonModules.log", "commonModules.animations", "commonModules.domUtils", "commonModules.mobileApp", "commonModules.catalogUtils" ]).config(function($stateProvider, $sceDelegateProvider, $httpProvider, $sceProvider) {
        angular.module("commonModules").$stateProvider = $stateProvider, angular.module("ui.bootstrap.tooltip").value("$tooltipSuppressWarning", !0), 
        $sceDelegateProvider.resourceUrlWhitelist([ "self", GlobalConfig.staticFilesBase + "**", GlobalConfig.jsFilesBase + "**" ]), 
        $httpProvider.interceptors.push("ApiInterceptor"), $sceProvider.enabled(!1);
    }).run(function($rootScope, $state, $stateParams) {
        $rootScope.$on("$stateChangeSuccess", function(event, toState, toParams, fromState) {
            $state.previous = fromState;
        }), $rootScope.$state = $state, $rootScope.$stateParams = $stateParams;
    });
}), define("portal/js/modules/external/externalsModule", [ "angular" ], function(ng) {
    return ng.module("app.externals", []);
}), define("portal/js/modules/external/wallop/wallop-slider-directive", [ "../externalsModule" ], function(module) {
    module.directive("wallopSlider", function() {
        return {
            template: '<div class="wallop-slider {{animationClass}}"><ul class="wallop-slider__list"><li class="wallop-slider__item {{itemClasses[$index]}}" ng-repeat="i in images"><img ng-src="{{i}}"></li></ul></div>',
            restrict: "EA",
            transclude: !0,
            replace: !1,
            scope: {
                images: "=",
                animation: "@",
                currentItemIndex: "=",
                nextItemIndex: "=",
                onNext: "&",
                onPrevious: "&"
            },
            controller: function($scope) {
                function _nextDisabled() {
                    return $scope.currentItemIndex + 1 === $scope.images.length;
                }
                function _prevDisabled() {
                    return !$scope.currentItemIndex;
                }
                function _updatePagination() {
                    $scope.nextDisabled = _nextDisabled(), $scope.prevDisabled = _prevDisabled();
                }
                function _clearClasses() {
                    for (var i = 0; i < $scope.images.length; i++) $scope.itemClasses[i] = "";
                }
                function _goTo(index) {
                    if (index >= $scope.images.length || 0 > index || index === $scope.currentItemIndex) return void (index || ($scope.itemClasses[0] = _displayOptions.currentItemClass));
                    _clearClasses(), $scope.itemClasses[$scope.currentItemIndex] = index > $scope.currentItemIndex ? _displayOptions.hidePreviousClass : _displayOptions.hideNextClass;
                    var currentClass = index > $scope.currentItemIndex ? _displayOptions.showNextClass : _displayOptions.showPreviousClass;
                    $scope.itemClasses[index] = _displayOptions.currentItemClass + " " + currentClass, 
                    $scope.currentItemIndex = index, _updatePagination();
                }
                $scope.itemClasses = [], $scope.$watch("images", function(images) {
                    images.length && _goTo(0);
                }), $scope.animation && ($scope.animationClass = "wallop-slider--" + $scope.animation);
                var _displayOptions = {
                    btnPreviousClass: "wallop-slider__btn--previous",
                    btnNextClass: "wallop-slider__btn--next",
                    itemClass: "wallop-slider__item",
                    currentItemClass: "wallop-slider__item--current",
                    showPreviousClass: "wallop-slider__item--show-previous",
                    showNextClass: "wallop-slider__item--show-next",
                    hidePreviousClass: "wallop-slider__item--hide-previous",
                    hideNextClass: "wallop-slider__item--hide-next"
                };
                $scope.onPrevButtonClicked = function() {
                    _goTo($scope.currentItemIndex - 1);
                }, $scope.onNextButtonClicked = function() {
                    _goTo($scope.currentItemIndex + 1);
                }, $scope.$watch("nextItemIndex", function(newVal, oldVal) {
                    newVal != oldVal && _goTo(newVal);
                }), $scope.$watch("currentItemIndex", function(newVal, oldVal) {
                    oldVal > newVal ? "function" == typeof $scope.onPrevious && $scope.onPrevious() : "function" == typeof $scope.onNext && $scope.onNext();
                });
            }
        };
    });
}), define("portal/js/modules/external/magnify/ng-magnify", [ "../externalsModule" ], function(module) {
    module.directive("ngMagnify", function() {
        return {
            restrict: "EA",
            replace: !0,
            template: '<div class="magnify-container" data-ng-style="getContainerStyle()"><div class="magnify-glass" data-ng-style="getGlassStyle()"></div><img class="magnify-image" data-ng-src="{{ imageSrc }}"/></div>',
            scope: {
                imageSrc: "@",
                imageWidth: "=",
                imageHeight: "=",
                glassWidth: "=",
                glassHeight: "="
            },
            link: function(scope, element) {
                var el, nWidth, nHeight, magnifyCSS, glass = element.find("div"), image = element.find("img");
                "ontouchstart" in window || window.DocumentTouch && document instanceof DocumentTouch || (element.on("mousemove", function(evt) {
                    el = angular.extend(scope.getOffset(element[0]), {
                        width: element[0].offsetWidth,
                        height: element[0].offsetHeight,
                        imageWidth: image[0].offsetWidth,
                        imageHeight: image[0].offsetHeight,
                        glassWidth: glass[0].offsetWidth,
                        glassHeight: glass[0].offsetHeight
                    }), magnifyCSS = scope.magnify(evt), magnifyCSS && glass.css(magnifyCSS);
                }).on("mouseout", function() {
                    glass.on("mouseleave", function() {
                        glass.css({
                            opacity: 0,
                            filter: "alpha(opacity=0)"
                        });
                    });
                }), scope.magnify = function(evt) {
                    var mx, my, rx, ry, px, py, bgp, img;
                    return nWidth || nHeight ? (mx = evt.pageX ? evt.pageX - el.left : evt.x, my = evt.pageY ? evt.pageY - el.top : evt.y, 
                    mx < el.width && my < el.height && mx > 0 && my > 0 ? (glass.css({
                        opacity: 1,
                        "z-index": 1,
                        filter: "alpha(opacity=100)"
                    }), rx = -1 * Math.round(mx / el.imageWidth * nWidth - el.glassWidth / 2), ry = -1 * Math.round(my / el.imageHeight * nHeight - el.glassHeight / 2), 
                    bgp = rx + "px " + ry + "px", px = mx - el.glassWidth / 2, py = my - el.glassHeight / 2, 
                    {
                        left: px + "px",
                        top: py + "px",
                        backgroundPosition: bgp
                    }) : void glass.css({
                        opacity: 0,
                        "z-index": -1,
                        filter: "alpha(opacity=0)"
                    })) : (img = new Image(), img.onload = function() {
                        nWidth = img.width, nHeight = img.height;
                    }, img.src = scope.imageSrc, void 0);
                }, scope.getOffset = function(_el) {
                    var de = document.documentElement, box = _el.getBoundingClientRect(), top = box.top + window.pageYOffset - de.clientTop, left = box.left + window.pageXOffset - de.clientLeft;
                    return {
                        top: top,
                        left: left
                    };
                }, scope.getContainerStyle = function() {
                    return {
                        width: scope.imageWidth ? scope.imageWidth + "px" : "",
                        height: scope.imageHeight ? scope.imageHeight + "px" : ""
                    };
                }, scope.getGlassStyle = function() {
                    return {
                        background: "url(" + scope.imageSrc + ") no-repeat",
                        width: scope.glassWidth ? scope.glassWidth + "px" : "",
                        height: scope.glassHeight ? scope.glassHeight + "px" : ""
                    };
                });
            }
        };
    });
}), define("portal/js/modules/external/index", [ "./externalsModule", "./wallop/wallop-slider-directive", "./magnify/ng-magnify" ], function() {}), 
define("portal/js/modules/main/portalMainModule", [ "angular" ], function(ng) {
    return ng.module("app.main", []);
}), define("portal/js/modules/main/portalMainController", [ "./portalMainModule" ], function(module) {
    module.controller("MainController", [ "$scope", "$rootScope", "$state", "$timeout", "ArraysService", "I18nService", "CssLoaderService", "PathsService", "DomUtilsService", "LocalStorageService", "OsInfoService", "SessionsService", "LogService", "SettingsService", "ViewPortService", "DialogsService", "PortalNavigationService", "HeartBeatService", "PortalStates", "PortalInfoService", "PortalTextsService", "LegalApprovalService", function($scope, $rootScope, $state, $timeout, ArraysService, I18nService, CssLoaderService, PathsService, DomUtilsService, LocalStorageService, OsInfoService, SessionsService, LogService, SettingsService, ViewPortService, DialogsService, PortalNavigationService, HeartBeatService, PortalStates, PortalInfoService, PortalTextsService, LegalApprovalService) {
        function initDebug() {
            GlobalConfig.debugInfo = {
                lastDebugTime: GlobalConfig.pageLoadTime,
                count: 0
            }, $rootScope.debugMessage = "", $rootScope.debug = function(msg) {
                var now = new Date().getTime();
                $rootScope.debugMessage += "\n<Br> (" + (now - GlobalConfig.debugInfo.lastDebugTime) + ") " + msg, 
                GlobalConfig.debugInfo.lastDebugTime = now, GlobalConfig.isMobileApp && BidspiritLoader.addDebugInfo(msg);
            }, $rootScope.debug("debug init");
        }
        function onInit() {
            "loaded" != $rootScope.loadState && ($rootScope.loadState = "loaded", $rootScope.isMobile = OsInfoService.isMobile(), 
            PortalStates.init(), PortalTextsService.init(), onLangUpdate(), $scope.dataState = "loaded", 
            initLog(), initRegions(), HeartBeatService.init(), PortalNavigationService.init(), 
            LegalApprovalService.init(), hideSplash());
        }
        function hideSplash() {
            GlobalConfig.isMobileApp && setTimeout(function() {
                navigator.splashscreen && navigator.splashscreen.hide();
            }, 1e3);
        }
        function initLog() {
            LogService.init(SettingsService.get("logEntriesToken"));
            var osInfo = OsInfoService.getOsInfo();
            "unknown" == osInfo.browser && (osInfo = {
                agent: navigator.userAgent
            });
            var eventInfo = angular.extend({
                eventName: "enterPage",
                url: PortalStates.getInitialUrl(),
                referrer: document.referrer || "unknown"
            }, osInfo), user = SessionsService.getSessionUser();
            user && (eventInfo.user = user.email), LogService.logEvent(eventInfo), $rootScope.debugLog = "";
        }
        function initRegions() {
            $rootScope.regions = SettingsService.get("regions").slice();
            var domainRegion = PathsService.getRegionByDomain();
            $rootScope.devMode || "ALL" == domainRegion || ArraysService.remove($rootScope.regions, "ALL"), 
            $rootScope.currentRegion = -1 != $rootScope.regions.indexOf(domainRegion) ? domainRegion : SessionsService.getRegion();
        }
        function onLangUpdate() {
            $rootScope.currentLang = I18nService.getCurrentLang(), $rootScope.dir = DomUtilsService.getDirection($rootScope.currentLang);
        }
        function checkFirstVisit() {
            var lastVisit = LocalStorageService.load("lastVisit");
            $scope.firstVisit = lastVisit ? !1 : !0, LocalStorageService.store("lastVisit", new Date().getTime());
        }
        function getLoadStateInfo() {
            return "css :" + CssLoaderService.isCssLoaded() + ", lang:" + I18nService.getCurrentLang() + ", app:" + GlobalConfig.appVersion + ", caches:" + JSON.stringify(SettingsService.cacheVersions);
        }
        function checkAllResourcesLoaded() {
            $rootScope.debug(getLoadStateInfo()), CssLoaderService.isCssLoaded() && I18nService.getCurrentLang() && onInit();
        }
        function init() {
            initDebug(), ViewPortService.bindViewPortSizeToWindowWidth(), $rootScope.isMobileApp = GlobalConfig.isMobileApp, 
            $rootScope.bidmoodEnv = GlobalConfig.bidmoodEnv, PathsService.getQueryParam("searchAgentRequest") && ($rootScope.searchAgentRequest = !0), 
            ("active" == PathsService.getQueryParam("devMode") || GlobalConfig.devMode) && ($rootScope.devMode = !0), 
            checkFirstVisit(), $rootScope.$on("i18n.languageChanged", onLangUpdate), CssLoaderService.loadCss(GlobalConfig.staticFilesBase + GlobalConfig.appName + "/styles/style.css").then(checkAllResourcesLoaded), 
            PortalInfoService.init(PathsService.getRegionByDomain()).success(function() {
                I18nService.init(PathsService.getPortalTextsUrl).then(checkAllResourcesLoaded);
            }).error(function(error) {
                error && "BLOCKED" == error.errorType && window.document.write("<h3>You have been blocked.</h3> For support, please contact us at info@bidspirit.com");
            });
        }
        $rootScope.loadState = "loading", $scope.dataState = "loading", $scope.firstVisit = !1, 
        $rootScope.currentLang = null, $scope.showErrorPopup = function(messageData) {
            DialogsService.showAlert(messageData);
        }, $rootScope.showGeneralError = function(message) {
            DialogsService.showAlert({
                title: "dialogs_notice_title",
                message: message || "error_unknown",
                params: {
                    email: $scope.BidspiritInfo.emailLink,
                    phone: $scope.BidspiritInfo.phoneLink
                }
            });
        }, GlobalConfig.isMobileApp && !OsInfoService.isMobileAppDebug() ? document.addEventListener("deviceready", init, !1) : init();
    } ]);
}), define("portal/js/modules/main/portalInfoService", [ "./portalMainModule" ], function(module) {
    module.factory("PortalInfoService", function($q, $rootScope, $timeout, ApiService, ArraysService, I18nService, SettingsService, StringsService, LocalStorageService, LogService, DateUtilsService, OsInfoService, PortalNavigationService, SessionInfo, SessionsService, CachedApiService) {
        function resetData() {
            mHouses = [], mHousesMap = {}, mAuctions = [], mAuctionsMap = {}, mHousesAuctions = {}, 
            mInfo = {};
        }
        function initHouses(houses, sites, resourcesMap, housesDetails) {
            mHousesMap = ArraysService.listToMapById(houses);
            for (var sitesMap = ArraysService.listToMapById(sites), detailsMap = ArraysService.listToMap(housesDetails, "auctionHouseId"), i = 0; i < houses.length; i++) {
                var house = houses[i];
                ArraysService.addOrReplaceById(mHouses, house), house.site = sitesMap[house.bidspiritSiteId], 
                house.resources = resourcesMap[house.id] || {}, house.details = detailsMap[house.id] || {};
            }
        }
        function loadAuction(auctionId) {
            var auction = getAuction(auctionId), defered = $q.defer();
            return auction ? defered.resolve(auction) : ApiService.callApi("/portal/getAuctionInfo", {
                auctionId: auctionId
            }).success(function(auctionInfo) {
                var auction = auctionInfo.auction;
                auction && (auction.resources = auctionInfo.resources, auction.catalogInfo = auctionInfo.catalogInfo, 
                auction.house = getHouse(auction.houseId), auction.singleLoaded = !0, mAuctionsMap[auction.id] = auction), 
                defered.resolve(auction);
            }), defered.promise;
        }
        function initAuctions(auctions, resourcesMap) {
            for (var i = 0; i < auctions.length; i++) {
                var auction = auctions[i];
                auction.catalogInfo = mInfo.auctionsCatalogInfo[auction.id];
                var house = getHouse(auction.houseId);
                house && (auction.house = house, shouldShowAuction(auction) && ArraysService.addOrReplaceById(mAuctions, auction));
                var houseAuctions = mHousesAuctions[house.id];
                houseAuctions || (houseAuctions = [], mHousesAuctions[house.id] = houseAuctions), 
                shouldShowAuction(auction) && houseAuctions.push(auction);
            }
            mAuctionsMap = ArraysService.listToMapById(mAuctions), ArraysService.setPropertyFromMapById(mAuctions, "resources", resourcesMap, {});
        }
        function shouldShowAuction(auction) {
            return null != auction.catalogInfo && auction.house.site || "ENDED" != auction.state ? $rootScope.devMode ? !0 : auction.hidden || auction.house.hidden ? !1 : !0 : !1;
        }
        function getAllFutureAuctions() {
            var futureAuctions = ArraysService.filterWithFunction(mInfo.auctions, function(auction) {
                return "ENDED" == auction.state ? !1 : shouldShowAuction(auction) ? getMinutesUntilAuction(auction) < 0 ? !1 : !0 : !1;
            });
            return ArraysService.sort(futureAuctions, "date"), futureAuctions;
        }
        function loadLastStoredPortalInfo(region) {
            var lastStoredInfo = LocalStorageService.load("portalInfo_" + region);
            if (!lastStoredInfo) return null;
            var portalInfo = JSON.parse(lastStoredInfo);
            return portalInfo.sessionInfo.sessionId == SessionInfo.sessionId ? (handleLoadedPortalInfo(portalInfo, !1), 
            SessionsService.setSessionInfo(mInfo.sessionInfo), CachedApiService.cachedPromiseWrap(mInfo)) : void 0;
        }
        function init(region) {
            if (SessionsService.loadPreviousSessionId(), mInfo = {}, $rootScope.searchAgentRequest) return loadForRegion(region, !1).success(function(portalInfo) {
                SessionsService.setSessionInfo(portalInfo.sessionInfo);
            });
            var cachedDataPromise = loadLastStoredPortalInfo(region || "ALL"), freshDataPromise = loadForRegion(region, !1);
            return $timeout(function() {
                loadForRegion(region, !0);
            }, 5e3), cachedDataPromise || freshDataPromise;
        }
        function loadForRegion(region, includeOldAuctions) {
            var params = {
                persistentSession: SessionsService.hasPersistentSession(),
                region: region,
                includeOldAuctions: includeOldAuctions
            };
            return ApiService.callApi("/portal/getPortalInfo", params).success(function(portalInfo) {
                var storeInCache = !1;
                includeOldAuctions && (resetData(), storeInCache = !0), mLoadedRegion = region, 
                handleLoadedPortalInfo(portalInfo, storeInCache);
            });
        }
        function storeInfoInCache() {
            LocalStorageService.store("portalInfo_" + (mLoadedRegion || "ALL"), JSON.stringify(mInfo));
        }
        function handleLoadedPortalInfo(portalInfo, storeInCache) {
            angular.copy(portalInfo, mInfo), SessionsService.setSessionInfo(mInfo.sessionInfo), 
            SettingsService.init(mInfo.sessionInfo.settings), initHouses(portalInfo.houses, portalInfo.sites, portalInfo.housesResources, portalInfo.housesDetails), 
            initAuctions(mInfo.auctions, portalInfo.auctionsResources), $rootScope.$broadcast("portalInfo.infoUpdated"), 
            storeInCache && storeInfoInCache();
        }
        function getAuction(auctionId) {
            return mAuctionsMap[auctionId];
        }
        function getAuctions() {
            return mAuctions;
        }
        function getHouseAuctions(houseId) {
            return mHousesAuctions[houseId];
        }
        function getHouses() {
            return mHouses;
        }
        function getInfo() {
            return mInfo;
        }
        function getHouse(houseId) {
            return mHousesMap[houseId];
        }
        function getHouseByCode(code) {
            return ArraysService.getByKey(mHouses, "code", code);
        }
        function sendContactRequest(contactRequest) {
            return ApiService.callApi("/portal/sendContactRequest", contactRequest, "post");
        }
        function getProductInfo() {
            return CachedApiService.callCachableApi("productInfo", "/portal/getProductInfo");
        }
        function getHelpScreensInfo() {
            return CachedApiService.callCachableApi("helpeScreens", "/portal/getHelpScreensInfo");
        }
        function getHouseTermsUrl(houseId, lang) {
            return CachedApiService.callCachableApi("terms_" + houseId + "_" + lang, "/portal/getHouseTermsUrl", {
                houseId: houseId,
                lang: lang
            });
        }
        function getHouseIncrementsSteps(houseId) {
            var defered = $q.defer();
            return CachedApiService.callCachableApi("increments_" + houseId, "/portal/getHouseIncrements", {
                houseId: houseId
            }).success(function(incrementsInfo) {
                var steps = [];
                for (var price in incrementsInfo.steps) steps.push({
                    price: 1 * price,
                    increment: 1 * incrementsInfo.steps[price]
                });
                defered.resolve(steps);
            }), defered.promise;
        }
        function sortHouses() {
            mHouses.sort(function(house1, house2) {
                var house1Name = I18nService.getLangField(house1.details.name).toLowerCase(), house2Name = I18nService.getLangField(house2.details.name).toLowerCase();
                if (house1Name == house2Name) return 0;
                var isHouse1Heb = StringsService.isHebChar(house1Name.charAt(0)), isHouse2Heb = StringsService.isHebChar(house2Name.charAt(0));
                return isHouse1Heb && !isHouse2Heb ? -1 : !isHouse1Heb && isHouse2Heb ? 1 : house1Name > house2Name ? 1 : -1;
            });
        }
        function getBidSpiritHouses() {
            return sortHouses(), ArraysService.filteredByNonEmpty(mHouses, "bidspiritSiteId");
        }
        function sendLotInquiryRequest(lotId, lotTitle, content) {
            return ApiService.callApi("/portal/sendLotInquiryRequest", {
                lotId: lotId,
                lotTitle: lotTitle,
                content: content
            }, "postForm");
        }
        function getLegalDoc(code) {
            return ApiService.callApi("/portal/getLegalDocContent", {
                code: code,
                lang: I18nService.getCurrentLang(),
                cacheVersion: SettingsService.getCacheVersion("LEGAL_DOCS")
            });
        }
        function getMinutesUntilAuction(auction) {
            var auctionTime = auction.time;
            if (auctionTime || (auctionTime = "23:59"), auctionTime) {
                var auctionDate = DateUtilsService.parseServerDate(auction.date + " " + auctionTime), auctionUtcTime = DateUtilsService.utcDate(auctionDate, !0), auctionTimeInRegion = auctionUtcTime.getTime() + 1e3 * SettingsService.get("regionTimezoneDiff") * 60 * 60;
                return Math.round((auctionTimeInRegion + SettingsService.getServerTimeGap() - new Date().getTime()) / 6e4);
            }
        }
        function setCurrentUserPreferredLang(lang) {
            return ApiService.callApi("/users/setPreferredLang", {
                lang: lang
            });
        }
        function reloadInfoAfterDelay(delay) {
            clearTimeout(mReloadTimer), mReloadTimer = setTimeout(function() {
                loadForRegion($rootScope.mCurrentRegion, !0);
            }, delay);
        }
        return mHouses = [], mHousesMap = {}, mAuctions = [], mAuctionsMap = {}, mHousesAuctions = {}, 
        mInfo = {}, mLoadedRegion = null, mReloadTimer = null, $rootScope.$on("i18n.languageChanged", sortHouses), 
        {
            init: init,
            loadForRegion: loadForRegion,
            reloadInfoAfterDelay: reloadInfoAfterDelay,
            getHouses: getHouses,
            getBidSpiritHouses: getBidSpiritHouses,
            getHouse: getHouse,
            getHouseByCode: getHouseByCode,
            getAuctions: getAuctions,
            getAllFutureAuctions: getAllFutureAuctions,
            getAuction: getAuction,
            loadAuction: loadAuction,
            getMinutesUntilAuction: getMinutesUntilAuction,
            getHouseAuctions: getHouseAuctions,
            getProductInfo: getProductInfo,
            getHelpScreensInfo: getHelpScreensInfo,
            storeInfoInCache: storeInfoInCache,
            getPortalInfo: getInfo,
            getHouseTermsUrl: getHouseTermsUrl,
            getHouseIncrementsSteps: getHouseIncrementsSteps,
            sendContactRequest: sendContactRequest,
            getLegalDoc: getLegalDoc,
            sendLotInquiryRequest: sendLotInquiryRequest,
            setCurrentUserPreferredLang: setCurrentUserPreferredLang
        };
    });
}), define("portal/js/modules/main/portalTextsService", [ "./portalMainModule" ], function(module) {
    module.factory("PortalTextsService", function($rootScope, SessionsService, OsInfoService, SettingsService, DomUtilsService, I18nService, PortalNavigationService) {
        function init() {
            mInfo.email = SettingsService.get("supportEmail"), mInfo.phone = SettingsService.get("supportPhone"), 
            $rootScope.BidspiritInfo = mInfo, ajdustInfoToLang();
        }
        function ajdustInfoToLang() {
            mInfo.fullPhone = I18nService.getPhoneForRegion(mInfo.phone, SessionsService.getRegion(), I18nService.getCurrentLang());
            var phoneHtml = DomUtilsService.noWrap(mInfo.fullPhone, "ltr");
            mInfo.phoneLink = OsInfoService.isMobile() ? DomUtilsService.link("tel:" + mInfo.fullPhone, phoneHtml) : phoneHtml, 
            mInfo.emailLink = DomUtilsService.link("mailto:" + mInfo.email, mInfo.email);
        }
        function getGeneralErrorMessage() {
            return I18nService.getText("error_unknown", {
                email: mInfo.emailLink,
                phone: mInfo.phoneLink
            });
        }
        function getHouseConnectivityErrorParams(house) {
            return {
                email: $rootScope.BidspiritInfo.emailLink,
                phone: $rootScope.BidspiritInfo.phoneLink,
                house: house ? I18nService.getLangField(house.details.name) : ""
            };
        }
        function getHouseTextParams(house) {
            if (!house || !house.details) return {};
            var houseDetails = house.details, params = {
                name: I18nService.getLangField(houseDetails.name)
            }, email = houseDetails.email;
            email && (params.email = DomUtilsService.link("mailto:" + email, email));
            var phone = houseDetails.phone;
            phone && (params.phone = OsInfoService.isMobile() ? DomUtilsService.link("tel:" + phone, phone) : phone);
            var website = house.website;
            if (website) {
                var protocol = 0 == website.indexOf("https") ? "https" : "http", websiteNoProtocol = website.replace(protocol + "://", "").replace(/\/$/, "");
                params.link = DomUtilsService.link(protocol + "://" + websiteNoProtocol, websiteNoProtocol, PortalNavigationService.getNewWindowTarget());
            }
            return params;
        }
        function getHouseConnectivityError(house) {
            return I18nService.getText("my_account_unknown_error", getHouseConnectivityErrorParams(house));
        }
        var mInfo = {};
        return {
            init: init,
            getGeneralErrorMessage: getGeneralErrorMessage,
            getHouseConnectivityError: getHouseConnectivityError,
            getHouseConnectivityErrorParams: getHouseConnectivityErrorParams,
            getHouseTextParams: getHouseTextParams
        };
    });
}), define("portal/js/modules/main/heartBeatService", [ "./portalMainModule" ], function(module) {
    module.factory("HeartBeatService", function($rootScope, $interval, $log, $uibModal, ApiService, SettingsService, PathsService, I18nService, SessionsService, LocalStorageService, PortalMobileUtils, PortalInfoService) {
        function reloadPageAfterDelay() {
            clearTimeout(mPageReloadTimer), mPageReloadTimer = setTimeout(function() {
                window.location.reload();
            }, getNextReloadTime(0, 60));
        }
        function getNextReloadTime(secondsToWait, secondsToSpread) {
            return GlobalConfig.devEnv || GlobalConfig.isMobileApp && $rootScope.devMode ? 1e4 : 1e3 * secondsToWait + Math.round(1e3 * Math.random() * secondsToSpread);
        }
        function heartBeat(){						
			ApiService.callApi("/portal/heartBeat").success(function(heartBeatResponse){				
				var user = $rootScope.currentUser;				
				if (user){
					if(!heartBeatResponse.hasSession){
						$log.info("session ended.");
						SessionsService.setSessionUser(null);
					} else {
						if (user.registrationStage != heartBeatResponse.registrationStage){
							user.registrationStage = heartBeatResponse.registrationStage;
							$rootScope.$broadcast("auth.authStateChanged");
						}
					}
				} else if (heartBeatResponse.hasSession){
					SessionsService.refreshCurrentSession();
				}
				var settings = SettingsService.getAll();
				var currentCacheVersions = settings.cacheVersions;
				var newCacheVersions = heartBeatResponse.cacheVersions;
				var newTexts = false;
				if (currentCacheVersions.TEXTS != newCacheVersions.TEXTS){
					newTexts =  true;		
					currentCacheVersions.TEXTS = newCacheVersions.TEXTS; 
				}				
				
				if (currentCacheVersions.PORTAL_INFO != newCacheVersions.PORTAL_INFO){
					currentCacheVersions.PORTAL_INFO = newCacheVersions.PORTAL_INFO
					PortalInfoService.reloadInfoAfterDelay(getNextReloadTime(120,120));
				}
								
				if (GlobalConfig.isMobileApp){
					$rootScope.debug("heart beat");
					if (!mAppUpdateMessageDisplayed  && GlobalConfig.mobileAppVersion*1 <  heartBeatResponse.requiredMobileAppVersion*1){
						displayAppUpgradePopup();
					} else if (GlobalConfig.appVersion != heartBeatResponse.appVersion ){
						var updateFailCounter = LocalStorageService.load("updateFailCounter");						
						if (updateFailCounter>3 || localStorage.contentEmbedFailures>3){
							//displayAppUpgradePopup();							
							$rootScope.debug("failed to upgrade app");
							
						} else if (!mUpdatingMobileVersion){
							mUpdatingMobileVersion = true;
							$rootScope.debug("new version: "+heartBeatResponse.appVersion+". So far failed "+updateFailCounter);
							setTimeout(function(){
								$rootScope.debug("should update...");
								PortalMobileUtils.updateBidspiritDataAndTheme(heartBeatResponse.appVersion);
								
							}, getNextReloadTime(0,60));
						}
					}
					if (GlobalConfig.loadedTextsVersion != newCacheVersions.TEXTS && !mUpdatingMobileTexts){
						$rootScope.debug("should loat texts... "+newCacheVersions.TEXTS);
						mUpdatingMobileTexts = true;
						return;
						PortalMobileUtils.updateLocalTextsInAllLangs(newCacheVersions.TEXTS).then(function(){
							I18nService.reloadTextsAfterDelay(1000);
							PortalInfoService.storeInfoInCache();
							$rootScope.debug("lang updated");
							mUpdatingMobileTexts = false;
						},function(){
							$rootScope.debug("failed to update text");
						});
					}
					
				} else {					
					if (settings.appVersion!= heartBeatResponse.appVersion){
						settings.appVersion = heartBeatResponse.appVersion;
						reloadPageAfterDelay();
					}
					if (newTexts){
						I18nService.reloadTextsAfterDelay(getNextReloadTime(120,120));
						PortalInfoService.storeInfoInCache();
					}
				}
			});
		}
        function displayAppUpgradePopup() {
            mAppUpdateMessageDisplayed || (mAppUpdateMessageDisplayed = !0, $uibModal.open({
                templateUrl: PathsService.appTemplatePath("info/upgradeRequired"),
                backdrop: "static",
                controller: function($scope) {
                    $scope.redirectToUpgrade = function() {
                        window.open(SettingsService.get("portalAddress") + "/app", "_system");
                    };
                }
            }));
        }
        function init() {
            $rootScope.searchAgentRequest || (heartBeat(), $interval(heartBeat, 1e3 * mHeartBitRate), 
            GlobalConfig.isMobileApp && document.addEventListener("resume", function() {
                PortalInfoService.reloadInfoAfterDelay(5);
            }));
        }
        return mPageReloadTimer = null, mHeartBitRate = GlobalConfig.devEnv ? 10 : 60, mAppUpdateMessageDisplayed = !1, 
        mUpdatingMobileVersion = !1, mUpdatingMobileTexts = !1, {
            init: init,
            heartBeat: heartBeat
        };
    });
}), define("portal/js/modules/main/portalStates", [ "./portalMainModule" ], function(module) {
    module.factory("PortalStates", function($state, $timeout, LocalStorageService, PathsService, OsInfoService) {
        function init() {
            PathsService.validateHttps() && (mSavedStateHash = mSavedStateHash || window.location.hash || "!/home", 
            PathsService.appTemplateState("app", "portalMain", {
                url: "/"
            }), PathsService.appTemplateState("app.home", "auctions/home/homeMain", {
                url: "home"
            }), PathsService.appTemplateState("app.results", "auctions/results/auctionsResults", {
                url: "results/:house/:page"
            }), PathsService.appTemplateState("app.catalog", "auctions/catalogs/list/catalogMain", {
                url: "catalog/auction/:auctionId/:page"
            }), PathsService.appTemplateState("app.lotPage", "auctions/catalogs/lotPage/lotPageMain", {
                url: "lotPage/source/:source/auction/:auctionId/lot/:lotId"
            }), PathsService.childSubviewTemplateState("app.lotPage", "zoom", "auctions/catalogs/lotPage/mobile/lotZoomSubScene", {
                url: "/zoom/:imageInd"
            }), PathsService.appTemplateState("app.search", "auctions/catalogs/search/searchMain", {
                url: "search"
            }), PathsService.appTemplateState("app.houses", "houses/housesList", {
                url: "houses"
            }), PathsService.appTemplateState("app.house", "houses/housePage", {
                url: "houses/:houseCode"
            }), PathsService.appTemplateState("app.about", "info/about", {
                url: "about"
            }), PathsService.appTemplateState("app.product", "info/product/productMain", {
                url: "product"
            }), PathsService.appTemplateState("app.help", "info/helpScreen", {
                url: "help/:code"
            }), PathsService.appTemplateState("app.contact", "info/contact", {
                url: "contact"
            }), PathsService.simpleChildStates("app.contact", [ "thanks" ]), PathsService.appTemplateState("app.popupScene", "elements/popups/popupAsScene", {
                url: "popupAsScene/:code"
            }), PathsService.appTemplateState("app.houseApproval", "account/approval/houseApprovalScene", {
                url: "houseApproval/:houseId"
            }), PathsService.appTemplateState("app.userDetails", "userDetails/userDetailsMain", {
                url: "userDetails"
            }), PathsService.appTemplateState("app.myAccount", "account/myAccount/myAccountMain", {
                url: "myAccount/:itemsType/:houseId"
            }), PathsService.appTemplateState("app.favorites", "account/favorites/favoritesMain", {
                url: "favorites"
            }), PathsService.appTemplateState("app.alerts", "alerts/userAlertsMain", {
                url: "alerts"
            }), PathsService.appTemplateState("app.alerts.house", "alerts/userAlertsMain", {
                url: "alerts/:houseCode"
            }), PathsService.appTemplateState("app.auth", "auth/authScene", {
                url: "auth/:authScene/:args"
            }), PathsService.state("app.mobileMenu", {
                url: "mobileMenu"
            }), PathsService.appTemplateState("app.reload", "elements/navigation/reload", {
                url: "reload"
            }), -1 == window.location.href.indexOf("_escaped_fragment_") && loadSavedState(), 
            saveAcquisitionInfo());
        }
        function loadSavedState() {
            $state.go("app.home"), $timeout(function() {
                var parsed = manualStateParsing();
                parsed || OsInfoService.isIe() || (window.location.hash = mSavedStateHash);
            }, 100);
        }
        function manualStateParsing() {
            var hashParts = mSavedStateHash.split("/"), parsed = !0;
            return 2 == hashParts.length ? $state.go("app." + hashParts[1]) : "catalog" == hashParts[1] ? $state.go("app.catalog", {
                auctionId: hashParts[3],
                page: hashParts[4]
            }) : "lotPage" == hashParts[1] ? $state.go("app.lotPage", {
                source: hashParts[3],
                auctionId: hashParts[5],
                lotId: hashParts[7]
            }) : parsed = !1, parsed;
        }
        function saveAcquisitionInfo() {
            var initialReferer = LocalStorageService.load("initialReferer");
            if (!initialReferer) {
                var referer = GlobalConfig.referer;
                referer && "null" != referer && "true" != referer && (referer = "Unknown"), LocalStorageService.store("initialReferer", referer || "Unknown");
            }
            var initialSource = LocalStorageService.load("initialSource"), source = PathsService.getQueryParam("from") || "Unknown";
            initialSource || LocalStorageService.store("initialSource", source);
        }
        function getSavedStateHash() {
            return mSavedStateHash;
        }
        function getInitialUrl() {
            return mInitialUrl;
        }
        var mSavedStateHash = window.location.hash, mInitialUrl = window.location.href + "";
        return {
            init: init,
            loadSavedState: loadSavedState,
            getSavedStateHash: getSavedStateHash,
            getInitialUrl: getInitialUrl
        };
    });
}), define("portal/js/modules/main/index", [ "./portalMainModule", "./portalMainController", "./portalInfoService", "./portalTextsService", "./heartBeatService", "./portalStates" ], function() {}), 
define("portal/js/modules/auth/portalAuthModule", [ "angular" ], function(ng) {
    return ng.module("app.auth", [ "app.auth.login", "app.auth.register" ]);
}), define("portal/js/modules/auth/portalAuthService", [ "./portalAuthModule" ], function(module) {
    module.factory("PortalAuthService", function($q, $rootScope, $state, $log, $uibModal, $uibModalStack, AnalyticsService, LocalStorageService, PathsService, ApiService, PopupsService, SessionsService, PortalInfoService) {
        function register(registrationInfo) {
            return ApiService.callApi("/auth/register", registrationInfo, "post").success(function(user) {
                user.justRegistered = !0, SessionsService.setSessionUser(user), LocalStorageService.store("lastLoggedinEmail", user.email);
            });
        }
        function confirmEmail(emailConfirmationKey) {
            return ApiService.callApi("/auth/confirmEmail", {
                emailConfirmationKey: emailConfirmationKey
            }).success(function(user) {
                SessionsService.setSessionUser(user, SessionsService.hasPersistentSession()), LocalStorageService.store("lastLoggedinEmail", user.email);
            });
        }
        function login(email, password, lang, region, remember) {
            return ApiService.callApi("/auth/login", {
                email: email,
                password: password,
                lang: lang,
                region: region,
                remember: remember
            }).success(function(user) {
                SessionsService.setSessionUser(user, remember), LocalStorageService.store("lastLoggedinEmail", email);
            });
        }
        function sendPasswordRecovery(email) {
            return ApiService.callApi("/auth/sendPasswordRecovery", {
                email: email
            });
        }
        function resendEmailConfirmationRequest() {
            return ApiService.callApi("/auth/resendEmailConfirmationRequest");
        }
        function completeRegistration(completeRegistrationInfo) {
            return ApiService.callApi("/auth/completeRegistration", completeRegistrationInfo, "post").success(function() {
                AnalyticsService.trackEvent("authAction", "completeRegistration");
            });
        }
        function updateEmail(email) {
            return ApiService.callApi("/auth/updateEmail", {
                email: email
            });
        }
        function updatePassword(existingPassword, newPassword) {
            return ApiService.callApi("/auth/updatePassword", {
                existingPassword: existingPassword,
                newPassword: newPassword
            });
        }
        function validateUserLoggedIn() {
            return $rootScope.currentUser ? $rootScope.currentUser : void showAuthModalOrScene("login");
        }
        function getTempAuthInfo() {
            return mTempAuthInfo;
        }
        function logout() {
            return ApiService.callApi("/auth/logout").success(function() {
                SessionsService.setSessionUser(null);
            });
        }
        function showAuthModalOrScene(scene, subScene, args) {
            $rootScope.viewPort.pcMedia ? showAuthModalPopup(scene, subScene, args).result.then(function() {}) : $state.go("app.auth", {
                authScene: scene,
                authSubScene: subScene,
                args: args ? JSON.stringify(args) : "{}"
            });
        }
        function showAuthModalPopup(scene, subScene, args) {
            closeAuthModalPopup();
            var modalInstance = $uibModal.open({
                templateUrl: PathsService.appTemplatePath("auth/authModalPopup"),
                windowClass: "modal auth-modal-popup",
                controller: function($scope) {
                    $scope.authDisplayInfo = {
                        popupScene: scene,
                        popupSubScene: subScene || scene,
                        args: args || ""
                    }, mAuthPopupOn = !0;
                }
            });
            return modalInstance.result.then(function() {
                mAuthPopupOn = !1, $rootScope.$broadcast("auth.modalPopupClosed");
            }), modalInstance;
        }
        function closeAuthModalPopup() {
            $uibModalStack.dismissAll(), mAuthPopupOn = !1;
        }
        function setCurrentHouseApprovalState(houseId, state) {
            mCurrentHouseApprovalState = {
                houseId: houseId,
                state: state
            }, $rootScope.$broadcast("auth.houseApprovalChanged");
        }
        function isCurrentUserKnownAsApprovedToHouse(houseId) {
            var house = PortalInfoService.getHouse(houseId);
            return house && $rootScope.currentUser && $rootScope.currentUser.approvedHousesCodes ? -1 != $rootScope.currentUser.approvedHousesCodes.indexOf(house.code) : !1;
        }
        function getHouseApprovalState(houseId) {
            return houseId ? $rootScope.currentUser ? mCurrentHouseApprovalState && mCurrentHouseApprovalState.houseId == houseId ? mCurrentHouseApprovalState.state : isCurrentUserKnownAsApprovedToHouse(houseId) ? "APPROVED" : "UNKNOWN" : "NOT_LOGGED_IN" : null;
        }
        function createTokenForAppSite(houseId, token) {
            return ApiService.callApi("/auth/createTokenForAppSite", {
                houseId: houseId,
                token: token
            });
        }
        function isAuthPopupOn() {
            return mAuthNavBarPopupOn || mAuthPopupOn;
        }
        var mTempAuthInfo = {}, mCurrentHouseApprovalState = null, mAuthPopupOn = !1, mAuthNavBarPopupOn = !1;
        return $rootScope.$on("auth.upperNavPopupDisplay", function(event, navAuthPopupOn) {
            mAuthNavBarPopupOn = navAuthPopupOn;
        }), {
            register: register,
            login: login,
            validateUserLoggedIn: validateUserLoggedIn,
            confirmEmail: confirmEmail,
            sendPasswordRecovery: sendPasswordRecovery,
            resendEmailConfirmationRequest: resendEmailConfirmationRequest,
            updateEmail: updateEmail,
            updatePassword: updatePassword,
            completeRegistration: completeRegistration,
            createTokenForAppSite: createTokenForAppSite,
            getTempAuthInfo: getTempAuthInfo,
            showAuthModalOrScene: showAuthModalOrScene,
            showAuthModalPopup: showAuthModalPopup,
            closeAuthModalPopup: closeAuthModalPopup,
            setCurrentHouseApprovalState: setCurrentHouseApprovalState,
            getHouseApprovalState: getHouseApprovalState,
            isCurrentUserKnownAsApprovedToHouse: isCurrentUserKnownAsApprovedToHouse,
            logout: logout,
            isAuthPopupOn: isAuthPopupOn
        };
    });
}), define("portal/js/modules/auth/authUpperNavigationController", [ "./portalAuthModule" ], function(module) {
    module.controller("AuthUpperNavigationController", [ "$rootScope", "$scope", "$timeout", "$state", "PortalAuthService", function($rootScope, $scope, $timeout, $state) {
        function checkUserWarningDisplay() {
            var user = $rootScope.currentUser;
            user && "COMPLETE" != user.registrationStage ? (clearTimeout(mWarningPopupTimer), 
            mWarningPopupTimer = $timeout(function() {
                var stateName = $state.current.name;
                "app.postRegistrationDetails" != stateName && "app.userDetails" != stateName && "app.auth" != stateName && $scope.setAuthScene("warning");
            }, 1e3)) : $scope.hidePopup();
        }
        function onSessionUserChanged() {
            $scope.hidePopup(), checkUserWarningDisplay();
        }
        mWarningPopupTimer = null, $scope.authDisplayInfo = {
            popupScene: null,
            popupSubScene: null,
            menuVisible: !1
        }, $rootScope.debugAuth = $scope.authDisplayInfo, $scope.setAuthScene = function(sceneName) {
            $scope.authDisplayInfo.popupScene = sceneName, $scope.setAuthSubScene(sceneName), 
            $scope.authDisplayInfo.menuVisible = !1, $rootScope.$broadcast("auth.upperNavPopupDisplay", !0);
        }, $scope.setAuthSubScene = function(subScene) {
            $scope.authDisplayInfo.popupSubScene = subScene;
        }, $scope.hidePopup = function() {
            clearTimeout(mWarningPopupTimer), $scope.authDisplayInfo.popupScene = null, $scope.authDisplayInfo.popupSubScene = null, 
            $rootScope.$broadcast("auth.upperNavPopupDisplay", !1);
        }, $scope.togglePopupView = function(popupAuthScene) {
            popupAuthScene == $scope.authDisplayInfo.popupScene ? $scope.hidePopup() : $scope.setAuthScene(popupAuthScene);
        }, $scope.toggleAuthMenu = function() {
            $scope.hidePopup(), $scope.authDisplayInfo.menuVisible = !$scope.authDisplayInfo.menuVisible, 
            $rootScope.$broadcast("auth.menuVisible", $scope.authDisplayInfo.menuVisible);
        }, $rootScope.$on("auth.newSessionUser", onSessionUserChanged), $rootScope.$on("auth.authStateChanged", checkUserWarningDisplay), 
        $rootScope.$on("$stateChangeStart", $scope.hidePopup), $rootScope.$on("auth.modalPopupDisplay", function(event, isOn) {
            isOn && $scope.hidePopup();
        }), checkUserWarningDisplay();
    } ]);
}), define("portal/js/modules/auth/authModalPopupController", [ "./portalAuthModule" ], function(module) {
    module.controller("AuthModalPopupController", [ "$rootScope", "$scope", "$timeout", "$state", "PortalAuthService", function($rootScope, $scope, $timeout, $state, PortalAuthService) {
        function close() {
            PortalAuthService.closeAuthModalPopup();
        }
        function init() {
            $rootScope.$broadcast("auth.modalPopupDisplay", !0), $rootScope.$on("auth.authStateChanged", close), 
            $rootScope.$on("auth.newSessionUser", close), $rootScope.$on("$stateChangeStart", close);
        }
        $scope.setAuthScene = function(sceneName) {
            $scope.authDisplayInfo.popupScene = sceneName, $scope.setAuthSubScene(sceneName);
        }, $scope.setAuthSubScene = function(subScene) {
            $scope.authDisplayInfo.popupSubScene = subScene;
        }, $scope.titleKey = function() {
            var suffix;
            switch ($scope.authDisplayInfo.popupScene) {
              case "login":
                suffix = "login";
                break;

              case "warning":
                suffix = "notice";
                break;

              case "approval":
                suffix = "notice";
                break;

              default:
                suffix = "register";
            }
            return "auth_title_" + suffix;
        }, init();
    } ]);
}), define("portal/js/modules/auth/authSceneController", [ "./portalAuthModule" ], function(module) {
    module.controller("AuthSceneController", [ "$scope", "$rootScope", "$state", "$stateParams", "PortalAuthService", "PortalNavigationService", function($scope, $rootScope, $state, $stateParams, PortalAuthService, PortalNavigationService) {
        function init() {
            var sceneName = $stateParams.authScene;
            if (!$rootScope.currentUser || "login" != sceneName && "register" != sceneName) {
                $scope.authDisplayInfo.authScene = sceneName, $scope.setAuthSubScene(sceneName);
                var args = $stateParams.args;
                args && 0 == args.indexOf("{") && (args = JSON.parse(args)), $scope.authDisplayInfo.args = args, 
                PortalNavigationService.setBackFn(onBackPress);
            } else $state.go("app.home");
            window.scrollTo(0, 0);
        }
        function onBackPress() {
            $scope.authDisplayInfo.authSubScene != $scope.authDisplayInfo.authScene ? $scope.setAuthSubScene($scope.authDisplayInfo.authScene) : PortalNavigationService.goBack(!0);
        }
        function redirectUserToNextScene() {
            var user = $rootScope.currentUser;
            if (user && !user.shouldApproveLegal) switch (user.registrationStage) {
              case "UNCONFIRMED_EMAIL":
                $scope.setAuthScene("warning");
                break;

              case "INCOMPLETE_PROFILE":
                $scope.setAuthScene("postRegistrationDetails");
                break;

              case "COMPLETE":
                ("login" == $scope.authDisplayInfo.authScene || "warning" == $scope.authDisplayInfo.authScene) && ($rootScope.$previousState && "app.auth" != $rootScope.$previousState.name ? $state.go($rootScope.$previousState.name, $rootScope.$previousState.args) : $state.go("app.home"));
            }
        }
        function onAuthSceneChanged() {
            "postRegistrationDetails" != $scope.authDisplayInfo.authScene && $state.go("app.home");
        }
        $scope.authDisplayInfo = {
            authScene: null,
            authSubScene: null
        }, $scope.setAuthScene = function(authScene, arg) {
            $state.go("app.auth", {
                authScene: authScene,
                arg: arg
            });
        }, $scope.setAuthSubScene = function(subScene) {
            $scope.authDisplayInfo.authSubScene = subScene;
        }, $scope.titleKey = function() {
            var suffix;
            switch ($scope.authDisplayInfo.authScene) {
              case "login":
                suffix = "login";
                break;

              default:
                suffix = "register";
            }
            return "auth_title_" + suffix;
        }, $scope.$on("auth.newSessionUser", redirectUserToNextScene), $scope.$on("auth.authStateChanged", onAuthSceneChanged), 
        init();
    } ]);
}), define("portal/js/modules/auth/legalApprovalService", [ "./portalAuthModule" ], function(module) {
    module.factory("LegalApprovalService", function($rootScope, $document, $timeout, $state, $uibModal, $uibModalStack, ApiService, PopupsService, SessionsService) {
        function checkLegalApproval() {
            var user = $rootScope.currentUser;
            user && user.shouldApproveLegal && "app.popupScene" != $state.$current.name && ($uibModalStack.dismissAll(), 
            PopupsService.showPopup({
                contentInclude: "auth/legalApproval/legalApprovalRequired",
                titleKey: "legal_reapproval_title",
                size: "sm",
                showLegalDoc: PopupsService.showLegalDocPopup,
                code: "legalApproval",
                buttons: [ {
                    type: "default",
                    text: "legal_reapproval_not_confrim",
                    action: rejectLegalTerms
                }, {
                    type: "primary",
                    text: "legal_reapproval_confrim",
                    action: acceptLegalTerms
                } ],
                unclosable: !0
            }), bindShowAgainOnEscape());
        }
        function bindShowAgainOnEscape() {
            mEscapeKeyHandled || (mEscapeKeyHandled = !0, $document.bind("keydown", function(evt) {
                27 === evt.which && $timeout(checkLegalApproval, 1e3);
            }));
        }
        function rejectLegalTerms() {
            ApiService.callApi("/auth/setLegalDocsApprovalState", {
                approvalState: "NOT_APPROVED"
            }).then(function() {
                $state.go("app.home"), SessionsService.setSessionUser(null), $uibModalStack.dismissAll(), 
                $timeout(function() {
                    PopupsService.showPopup({
                        contentInclude: "auth/legalApproval/legalTermsRejected",
                        titleKey: "legal_reapproval_title",
                        size: "sm",
                        code: "legalTermsRejected",
                        buttons: [ {
                            type: "primary",
                            text: "dialogs_close",
                            isCloseButton: !0
                        } ]
                    });
                }, 1e3);
            });
        }
        function acceptLegalTerms() {
            ApiService.callApi("/auth/setLegalDocsApprovalState", {
                approvalState: "APPROVED"
            }).then(function() {
                $rootScope.currentUser.shouldApproveLegal = !1, $uibModalStack.dismissAll(), $rootScope.viewPort.mobileMedia && $state.go("app.home");
            });
        }
        function onNewSessionUser() {
            $rootScope.currentUser && checkLegalApproval();
        }
        function init() {
            $rootScope.$on("$stateChangeSuccess", function() {
                $timeout(checkLegalApproval, 1e3);
            }), $rootScope.$on("auth.newSessionUser", onNewSessionUser);
        }
        return mEscapeKeyHandled = !1, {
            init: init,
            checkLegalApproval: checkLegalApproval
        };
    });
}), define("portal/js/modules/auth/login/portalLoginModule", [ "angular" ], function(ng) {
    return ng.module("app.auth.login", []);
}), define("portal/js/modules/auth/login/portalLoginController", [ "./portalLoginModule" ], function(module) {
    module.controller("PortalLoginController", [ "$scope", "$timeout", "StringsService", "LocalStorageService", "I18nService", "SessionsService", "LogService", "PortalAuthService", function($scope, $timeout, StringsService, LocalStorageService, I18nService, SessionsService, LogService, PortalAuthService) {
        $scope.loginInfo = {}, $scope.loginErrorVisible = !1, $scope.loginHelpVisible = !1, 
        $scope.passwordVisible = !1, $scope.focusOnPassword = !1, $timeout(function() {
            $scope.loginInfo = PortalAuthService.getTempAuthInfo(), GlobalConfig.devEnv && ($scope.loginInfo = {
                email: "zemer@bidspirit.com",
                password: "zzzzzzz",
                remember: !1
            }), $scope.loginInfo.email || ($scope.loginInfo.email = LocalStorageService.load("lastLoggedinEmail"));
        }, 100), $scope.login = function() {
            return PortalAuthService.login($scope.loginInfo.email, $scope.loginInfo.password, I18nService.getCurrentLang(), $scope.currentRegion, $scope.loginInfo.remember).success(function(user) {
                user ? LogService.logMessage("Login success for email:" + $scope.loginInfo.email) : LogService.logError("Empty user response for email:" + $scope.loginInfo.email + ", password: " + StringsService.mask($scope.loginInfo.password));
            }).error(function(error) {
                LogService.logMessage("Login failed for email:" + $scope.loginInfo.email + ", password: " + StringsService.mask($scope.loginInfo.password) + " - " + JSON.stringify(error)), 
                $scope.loginErrorVisible = !0;
            });
        }, $scope.hideLoginError = function() {
            $scope.loginErrorVisible && ($scope.loginErrorVisible = !1, $scope.loginHelpVisible = !1);
        }, $scope.toggleHelpVisible = function() {
            $scope.loginHelpVisible = !$scope.loginHelpVisible;
        }, $scope.togglePasswordVisible = function() {
            $scope.passwordVisible = !$scope.passwordVisible, $scope.focusOnPassword = !0, $timeout(function() {
                $scope.focusOnPassword = !1;
            }, 100);
        }, $scope.$on("$destroy", function() {
            $scope.loginInfo.password = "";
        });
    } ]);
}), define("portal/js/modules/auth/login/recoverPasswordController", [ "./portalLoginModule" ], function(module) {
    module.controller("RecoverPasswordController", [ "$scope", "$timeout", "I18nService", "PortalAuthService", function($scope, $timeout, I18nService, PortalAuthService) {
        $scope.email = null, $scope.stage = 1, $scope.info = {}, $scope.data = {}, $scope.info = PortalAuthService.getTempAuthInfo(), 
        $scope.sendPassword = function() {
            return PortalAuthService.sendPasswordRecovery($scope.info.email).success(function() {
                $scope.stage = 2;
            }).error(function() {
                $scope.data.emailUnknown = !0;
            });
        };
    } ]);
}), define("portal/js/modules/auth/login/index", [ "./portalLoginModule", "./portalLoginController", "./recoverPasswordController" ], function() {}), 
define("portal/js/modules/auth/register/registerModule", [ "angular" ], function(ng) {
    return ng.module("app.auth.register", []);
}), define("portal/js/modules/auth/register/registerController", [ "./registerModule" ], function(module) {
    module.controller("RegisterController", [ "$rootScope", "$scope", "$timeout", "LogService", "I18nService", "LocalStorageService", "PortalInfoService", "PortalAuthService", "PopupsService", function($rootScope, $scope, $timeout, LogService, I18nService, LocalStorageService, PortalInfoService, PortalAuthService, PopupsService) {
        function setRegistrationEnvInfo() {
            $scope.registrationInfo.lang = I18nService.getCurrentLang(), $scope.registrationInfo.region = $rootScope.currentRegion;
            var acquisitionInfo = {
                initialReferer: LocalStorageService.load("initialReferer")
            };
            LocalStorageService.load("initialSource") && (acquisitionInfo.initialSource = LocalStorageService.load("initialSource")), 
            $scope.registrationInfo.acquisitionInfo = acquisitionInfo;
        }
        $scope.registrationInfo = {}, $scope.scrollToFisrtLine = !1, $timeout(function() {
            $scope.registrationInfo = PortalAuthService.getTempAuthInfo(), "dev" == GlobalConfig.envName && angular.extend($scope.registrationInfo, {
                firstName: "zzzz",
                lastName: "zzzz",
                email: "zemer@bidspirit.com",
                password: "zzzzzzz",
                passwordConfirm: "zzzzzzz",
                terms: !0,
                over18: !0
            }), window.innerHeight < 1e3 && "register" == $scope.authDisplayInfo.authScene && ($scope.scrollToFisrtLine = !0);
        }, 100), $scope.existingEmails = [], $scope.register = function() {
            return setRegistrationEnvInfo(), LogService.logEvent({
                attemptRegistration: $scope.registrationInfo.email
            }), PortalAuthService.register($scope.registrationInfo).success(function() {
                LogService.logEvent({
                    successRegistration: $scope.registrationInfo.email
                });
            }).error(function(error) {
                switch (LogService.logEvent({
                    failedRegistration: error.errorType
                }), error.errorType) {
                  case "ALREADY_EXISTS":
                    $scope.existingEmails.push($scope.registrationInfo.email), $timeout(function() {
                        $scope.registerForm.updateFieldsAttentions();
                    }, 150);
                    break;

                  default:
                    $scope.showGeneralError();
                }
            });
        }, $scope.emailExists = function(email) {
            return -1 != $scope.existingEmails.indexOf(email);
        }, $scope.passwordConfirmedMatch = function() {
            var info = $scope.registrationInfo;
            return info.passwordConfirm == info.password ? !0 : !1;
        }, $scope.displayLoginLink = function() {
            return $scope.registerForm && $scope.registerForm.email ? $scope.registerForm.email.attentionTouch && $scope.registerForm.email.$error.exists : void 0;
        }, $scope.showTerms = function() {
            PopupsService.showLegalDocPopup("terms");
        }, $scope.$on("$destroy", function() {});
    } ]);
}), define("portal/js/modules/auth/register/postRegistrationDetailsController", [ "./registerModule" ], function(module) {
    module.controller("PostRegistrationDetailsController", [ "$rootScope", "$timeout", "$scope", "$state", "PortalAuthService", "UserDetailsService", function($rootScope, $timeout, $scope, $state, PortalAuthService, UserDetailsService) {
        function load() {
            $scope.userDetails = angular.copy($rootScope.currentUser), UserDetailsService.getUserDetails().success(function(details) {
                angular.extend($scope.userDetails, details), $scope.userDataLoaded = !0;
            });
        }
        function init() {
            $rootScope.currentUser ? load() : $timeout(function() {
                $rootScope.currentUser ? load() : $state.go("app.home");
            }, 2e3);
        }
        $scope.userDataLoaded = !1, $scope.formSubmitted = !1, $scope.save = function() {
            return PortalAuthService.completeRegistration($scope.userDetails).success(function(userDetails) {
                $scope.userDetails.addresses = userDetails.addresses, $scope.currentUser.phone = userDetails.phone, 
                $scope.currentUser.registrationStage = "COMPLETE", $scope.currentUser.residenceIsShipping = userDetails.shippingAddress.residenceIsShipping, 
                $scope.currentUser.company = userDetails.company, $scope.formSubmitted = !0, $rootScope.$broadcast("auth.authStateChanged"), 
                window.scrollTo(0, 0);
            });
        }, $scope.$on("auth.authStateChanged", function() {
            "COMPLETE" == $scope.currentUser.registrationStage && ($scope.formSubmitted = !0);
        }), $scope.$on("$destroy", function() {
            $scope.currentUser && ($scope.currentUser.justConfirmed = !1);
        }), init();
    } ]);
}), define("portal/js/modules/auth/register/authWarningController", [ "./registerModule" ], function(module) {
    module.controller("AuthWarningController", [ "$scope", "$rootScope", "$stateParams", "PortalAuthService", function($scope, $rootScope) {
        function init() {
            var user = $rootScope.currentUser;
            if (user) switch (user.registrationStage) {
              case "UNCONFIRMED_EMAIL":
                $scope.warning = "unconfirmedEmail";
                break;

              case "INCOMPLETE_PROFILE":
                $scope.warning = "incompleteProfile";
            }
        }
        init(), $rootScope.$on("auth.authStateChanged", init);
    } ]);
}), define("portal/js/modules/auth/register/index", [ "./registerModule", "./registerController", "./postRegistrationDetailsController", "./authWarningController" ], function() {}), 
define("portal/js/modules/auth/index", [ "./portalAuthModule", "./portalAuthService", "./authUpperNavigationController", "./authModalPopupController", "./authSceneController", "./legalApprovalService", "./login/index", "./register/index" ], function() {}), 
define("portal/js/modules/userDetails/userDetailsModule", [ "angular" ], function(ng) {
    return ng.module("app.userDetails", []);
}), define("portal/js/modules/userDetails/userDetailsController", [ "./userDetailsModule" ], function(module) {
    module.controller("UserDetailsController", [ "$scope", "$rootScope", "$state", "$filter", "ArraysService", "I18nService", "OsInfoService", "UserDetailsService", "PortalAuthService", function($scope, $rootScope, $state, $filter, ArraysService, I18nService, OsInfoService, UserDetailsService) {
        function init() {
            $scope.currentUser ? (UserDetailsService.getUserDetails().success(function(userDetails) {
                $scope.data.savedDetails = userDetails, resetData(), initSections(), openEmailSectionIfUnconfirmed();
            }), $rootScope.$on("auth.newSessionUser", function() {
                $state.go("app.home");
            })) : $state.go("app.home");
        }
        function initSections() {
            var sections;
            sections = "COMPLETE" == $scope.currentUser.registrationStage ? [ "email", "password", "name", "phone", "company", "residence", "shipping" ] : [ "email", "password", "name" ], 
            ArraysService.replaceContent($scope.sections, sections);
        }
        function resetData() {
            $scope.data.user = angular.copy($scope.currentUser), $scope.data.userDetails = angular.copy($scope.data.savedDetails);
        }
        function openEmailSectionIfUnconfirmed() {
            $scope.opened.email = "UNCONFIRMED_EMAIL" == $scope.currentUser.registrationStage ? !0 : !1;
        }
        function getPasswordSummry() {
            var lastUpdate = $scope.currentUser.lastPasswordUpdate;
            if (lastUpdate) {
                var updateTime = $filter("date")(lastUpdate, "HH:mm:ss");
                return I18nService.getText("user_details_password_updated_on", {
                    updateTime: updateTime
                });
            }
            return "********";
        }
        function addressSummary(addressName) {
            if (!$scope.data.savedDetails) return "";
            var address = $scope.data.savedDetails[addressName + "Address"];
            if (!address) return "";
            var summary = "";
            return address.address && (summary += address.address + ", "), address.city && (summary += address.city + ", "), 
            address.state && (summary += address.state + ", "), address.country && (summary += address.country + ", "), 
            address.zipCode && (summary += address.zipCode + ", "), summary && (summary = summary.substr(0, summary.lastIndexOf(","))), 
            summary;
        }
        $scope.sections = [], $scope.data = {}, $scope.opened = {}, $scope.updateUserInfo = function(section) {
            return UserDetailsService.updateUserInfo($scope.data.user).success(function(user) {
                angular.extend($scope.currentUser, user), $scope.onUpdateDone(section);
            });
        }, $scope.updateResidenceAddress = function() {
            return UserDetailsService.updateAddress($scope.data.userDetails.residenceAddress).success(function(updatedAddress) {
                angular.extend($scope.data.savedDetails.residenceAddress, updatedAddress), $scope.onUpdateDone("residence");
            });
        }, $scope.updateShippingAddress = function() {
            var address = $scope.data.userDetails.shippingAddress;
            return UserDetailsService.updateAddress(address).success(function(updatedAddress) {
                angular.extend($scope.data.savedDetails.shippingAddress, updatedAddress), $scope.currentUser.residenceIsShipping = updatedAddress.residenceIsShipping, 
                $scope.onUpdateDone("shipping");
            });
        }, $scope.onUpdateDone = function(section) {
            $scope.opened[section] = !1, resetData(), "email" == section && openEmailSectionIfUnconfirmed(), 
            OsInfoService.isMobile() && window.scrollTo(0, 50);
        }, $scope.$on("userDetails.updateCanceled", function(event, section) {
            $scope.onUpdateDone(section);
        }), $scope.$on("auth.authStateChanged", function() {
            initSections(), openEmailSectionIfUnconfirmed();
        }), $scope.getSectionSummary = function(section) {
            if ($scope.opened[section]) return "";
            switch (section) {
              case "email":
                return $scope.currentUser.email;

              case "password":
                return getPasswordSummry();

              case "name":
                return $scope.currentUser.firstName + " " + $scope.currentUser.lastName;

              case "phone":
                return $scope.currentUser.phone;

              case "company":
                return $scope.currentUser.company;

              case "residence":
                return addressSummary("residence");

              case "shipping":
                return addressSummary($scope.currentUser.residenceIsShipping ? "residence" : "shipping");

              default:
                return "";
            }
        }, init();
    } ]);
}), define("portal/js/modules/userDetails/userDetailsService", [ "./userDetailsModule" ], function(module) {
    module.factory("UserDetailsService", function($rootScope, $log, ApiService) {
        function getUserDetails() {
            return ApiService.callApi("/users/getUserDetails");
        }
        function updateUserInfo(user) {
            return ApiService.callApi("/users/updateUserInfo", user, "post");
        }
        function updateAddress(address) {
            return ApiService.callApi("/users/updateAddress", address, "post");
        }
        function updateAlertsPreferences(preferences) {
            return ApiService.callApi("/users/updateAlertsPreferences", preferences, "post");
        }
        return {
            getUserDetails: getUserDetails,
            updateUserInfo: updateUserInfo,
            updateAddress: updateAddress,
            updateAlertsPreferences: updateAlertsPreferences
        };
    });
}), define("portal/js/modules/userDetails/editEmailDirective", [ "./userDetailsModule" ], function(module) {
    module.directive("bsEditEmail", function($rootScope, AsyncButtonService, PathsService, PortalAuthService) {
        return {
            restrict: "E",
            replace: !0,
            scope: {},
            link: function(scope) {
                scope.sendingConfirmationAgain = !1, scope.sentConfirmationAgain = !1, scope.existingEmails = [], 
                scope.stage = "UNCONFIRMED_EMAIL" == $rootScope.currentUser.registrationStage ? "not_confirmed" : "edit", 
                scope.data = {
                    email: $rootScope.currentUser.email
                }, scope.notConfirmedTitle = "email_not_confirmed_title_post_login", $rootScope.currentUser.justRegistered && (scope.notConfirmedTitle = "email_not_confirmed_title_post_register", 
                $rootScope.currentUser.justRegistered = !1), scope.sendEmailConfirmationAgain = function() {
                    scope.sendingConfirmationAgain || (scope.sentConfirmationAgain = !1, scope.sendingConfirmationAgain = !0, 
                    PortalAuthService.resendEmailConfirmationRequest().success(function() {
                        scope.sentConfirmationAgain = !0, scope.sendingConfirmationAgain = !1;
                    }));
                }, scope.emailExists = function(email) {
                    return -1 != scope.existingEmails.indexOf(email);
                }, scope.getEmail = function() {
                    return $rootScope.currentUser.email;
                }, scope.updateEmail = function() {
                    return $rootScope.currentUser.email != scope.data.email ? PortalAuthService.updateEmail(scope.data.email).success(function() {
                        $rootScope.currentUser.email = scope.data.email, $rootScope.currentUser.registrationStage = "UNCONFIRMED_EMAIL", 
                        scope.stage = "not_confirmed", scope.notConfirmedTitle = "email_not_confirmed_title_email_updated", 
                        scope.$emit("auth.authStateChanged");
                    }).error(function(error) {
                        switch (error.errorType) {
                          case "ALREADY_EXISTS":
                            scope.existingEmails.push(scope.email);
                        }
                    }) : (scope.cancelEdit(), AsyncButtonService.fakeSuccess("changeEmail"));
                }, scope.cancelEdit = function() {
                    "UNCONFIRMED_EMAIL" == $rootScope.currentUser.registrationStage && (scope.stage = "not_confirmed"), 
                    scope.data.email = $rootScope.currentUser.email, scope.$emit("userDetails.updateCanceled", "email");
                };
            },
            templateUrl: PathsService.appTemplatePath("userDetails/reusableElements/editEmail")
        };
    });
}), define("portal/js/modules/userDetails/addressDirective", [ "./userDetailsModule" ], function(module) {
    module.directive("bsUserDetailsAddress", function($q, $http, PathsService, FormConstants) {
        return {
            restrict: "E",
            scope: {
                address: "="
            },
            link: function(scope) {
                scope.bsValidationPatterns = FormConstants.validationPatterns;
            },
            templateUrl: PathsService.appTemplatePath("userDetails/reusableElements/address")
        };
    });
}), define("portal/js/modules/userDetails/passwordUpdateController", [ "./userDetailsModule" ], function(module) {
    module.controller("PasswordUpdateController", [ "$scope", "$timeout", "PortalAuthService", function($scope, $timeout, PortalAuthService) {
        function initData() {
            $scope.data = {}, $scope.wrongPasswords = [];
        }
        $scope.updatePassword = function() {
            return PortalAuthService.updatePassword($scope.data.existingPassword, $scope.data.newPassword).success(function() {
                $scope.currentUser.lastPasswordUpdate = new Date(), $scope.updateDone();
            }).error(function(error) {
                "BAD_CREDENTIALS" == error.errorType && $scope.wrongPasswords.push($scope.data.existingPassword);
            });
        }, $scope.updateDone = function() {
            $scope.onUpdateDone("password"), initData();
        }, $scope.wrongPassword = function(password) {
            return -1 != $scope.wrongPasswords.indexOf(password);
        }, $scope.passwordConfirmedMatch = function() {
            return $scope.data.passwordConfirm == $scope.data.newPassword ? !0 : !1;
        }, initData();
    } ]);
}), define("portal/js/modules/userDetails/index", [ "./userDetailsModule", "./userDetailsController", "./userDetailsService", "./editEmailDirective", "./addressDirective", "./passwordUpdateController" ], function() {}), 
define("portal/js/modules/alerts/userAlertsModule", [ "angular" ], function(ng) {
    return ng.module("app.userAlerts", []);
}), define("portal/js/modules/alerts/userAlertsController", [ "./userAlertsModule" ], function(module) {
    module.controller("UserAlertsController", [ "$scope", "$rootScope", "$state", "$stateParams", "ArraysService", "PortalAuthService", "PortalInfoService", "UserDetailsService", function($scope, $rootScope, $state, $stateParams, ArraysService, PortalAuthService, PortalInfoService, UserDetailsService) {
        function init() {
            $scope.currentUser ? ($scope.data = $scope.currentUser.alertsPreferences ? angular.copy($scope.currentUser.alertsPreferences) : {
                userId: $scope.currentUser.id,
                housesToAlert: [],
                housesAlertChoice: null
            }, $scope.data.region = $rootScope.currentRegion, $scope.houses = PortalInfoService.getHouses(), 
            $scope.saved = !1, $scope.setChoice($scope.data.housesAlertChoice), $stateParams.houseCode && ($scope.setChoice("SOME_HOUSES_ALERTS"), 
            ArraysService.addIfNotExists($scope.data.housesToAlert, $stateParams.houseCode))) : PortalAuthService.showAuthModalOrScene("login"), 
            $rootScope.$on("auth.modalPopupClosed", initIfLoggedIn), $rootScope.$on("auth.newSessionUser", init);
        }
        function initIfLoggedIn() {
            $scope.currentUser ? init() : $state.go("app.home");
        }
        $scope.setChoice = function(choice) {
            switch ($scope.data.housesAlertChoice = choice, choice) {
              case "SOME_HOUSES_ALERTS":
                $scope.housesListVisible = !0;
                break;

              default:
                $scope.housesListVisible = !1;
            }
        }, $scope.save = function() {
            UserDetailsService.updateAlertsPreferences($scope.data).success(function(preferences) {
                $scope.data = preferences, $scope.currentUser.alertsPreferences = preferences, $scope.saved = !0, 
                window.scroll(0, 0);
            });
        }, init();
    } ]);
}), define("portal/js/modules/alerts/index", [ "./userAlertsModule", "./userAlertsController" ], function() {}), 
define("portal/js/modules/info/infoScenesModule", [ "angular" ], function(ng) {
    return ng.module("app.info", [ "app.info.contact", "app.info.product", "app.info.helpScreen" ]);
}), define("portal/js/modules/info/contact/contactModule", [ "angular" ], function(ng) {
    return ng.module("app.info.contact", []);
}), define("portal/js/modules/info/contact/contactController", [ "./contactModule" ], function(module) {
    module.controller("ContactController", [ "$scope", "$state", "PortalInfoService", function($scope, $state, PortalInfoService) {
        $scope.contact = {}, $scope.send = function() {
            return PortalInfoService.sendContactRequest($scope.contact).success(function() {
                $state.go(".thanks"), window.scroll(0, 0);
            });
        }, $scope.gotoAuctionHouses = function() {
            $state.go("app.houses");
        };
    } ]);
}), define("portal/js/modules/info/contact/index", [ "./contactModule", "./contactController" ], function() {}), 
define("portal/js/modules/info/product/productModule", [ "angular" ], function(ng) {
    return ng.module("app.info.product", []);
}), define("portal/js/modules/info/product/productController", [ "./productModule" ], function(module) {
    module.controller("ProductController", [ "$scope", "$rootScope", "ArraysService", "PortalInfoService", "AppSiteWinodwsService", function($scope, $rootScope, ArraysService, PortalInfoService, AppSiteWinodwsService) {
        function init() {
            $scope.mainFeature = {}, PortalInfoService.getProductInfo().success(function(productInfo) {
                $scope.features = productInfo.features, ArraysService.setPropertyFromMapById($scope.features, "resources", productInfo.resources, {}), 
                angular.copy(ArraysService.getByKey($scope.features, "code", "main"), $scope.mainFeature);
            });
        }
        $scope.showDemo = function(demoCode) {
            AppSiteWinodwsService.showDemo(demoCode);
        }, init();
    } ]);
}), define("portal/js/modules/info/product/index", [ "./productModule", "./productController" ], function() {}), 
define("portal/js/modules/info/helpScreens/helpScreensModule", [ "angular" ], function(ng) {
    return ng.module("app.info.helpScreen", []);
}), define("portal/js/modules/info/helpScreens/helpScreensController", [ "./helpScreensModule" ], function(module) {
    module.controller("HelpScreensController", [ "$scope", "$rootScope", "$stateParams", "ArraysService", "PortalInfoService", "PortalAuthService", "SearchService", "AppSiteWinodwsService", function($scope, $rootScope, $stateParams, ArraysService, PortalInfoService, PortalAuthService, SearchService, AppSiteWinodwsService) {
        function setScreenshot() {
            $scope.sceenshot = $scope.data.helpScreensInfo.resources[$scope.helpScreen.id][$rootScope.currentLang];
        }
        function init() {
            $scope.code = {}, PortalInfoService.getHelpScreensInfo().success(function(helpScreensInfo) {
                $scope.data.helpScreensInfo = helpScreensInfo, $scope.helpScreen = ArraysService.getByKey(helpScreensInfo.screens, "code", $stateParams.code), 
                ArraysService.setPropertyFromMapById($scope.helpScreens, "resources", helpScreensInfo.resources, {}), 
                setScreenshot();
            });
        }
        $scope.data = {}, $scope.showDemo = function(demoCode) {
            AppSiteWinodwsService.showDemo(demoCode);
        }, $scope.gotoSearch = function() {
            SearchService.gotoSearchScene($scope.data.searchToken);
        }, $scope.showRegistration = function() {
            PortalAuthService.showAuthModalOrScene("register");
        }, init();
    } ]);
}), define("portal/js/modules/info/helpScreens/index", [ "./helpScreensModule", "./helpScreensController" ], function() {}), 
define("portal/js/modules/info/index", [ "./infoScenesModule", "./contact/index", "./product/index", "./helpScreens/index" ], function() {}), 
define("portal/js/modules/auctions/auctionsModule", [ "angular" ], function(ng) {
    return ng.module("app.auctions", [ "app.auctions.home", "app.auctions.catalogs", "app.auctions.lists" ]);
}), define("portal/js/modules/auctions/home/homeModule", [ "angular" ], function(ng) {
    return ng.module("app.auctions.home", []);
}), define("portal/js/modules/auctions/home/homeController", [ "./homeModule" ], function(module) {
    module.controller("HomeController", [ "$scope", "$rootScope", "$timeout", "$window", "ArraysService", "I18nService", "ViewPortService", "OsInfoService", "LocalStorageService", "SessionsService", "PortalInfoService", "SearchService", function($scope, $rootScope, $timeout, $window, ArraysService, I18nService, ViewPortService, OsInfoService, LocalStorageService, SessionsService, PortalInfoService, SearchService) {
        function setUpperMessage() {
            var textImageName = GlobalConfig.bidmoodEnv ? "bidmood" : "bidspirit", textImagePath = GlobalConfig.staticFilesBase + GlobalConfig.appName + "/images/home/text/" + textImageName + ".png";
            $scope.upperMessage = I18nService.getTextWithRegion("home_upper_message", {
                logo: '<img class="logo-text ' + textImageName + '" src="' + textImagePath + '" alt="' + textImageName + '" >'
            });
        }
        function adjustUpperPartHeight() {
            $scope.screenHeightClass = "normal", ViewPortService.clientHeight() < 650 && ($scope.screenHeightClass = "narrow-screen"), 
            $scope.featuresAsLinks = ViewPortService.clientWidth() >= 1200;
        }
        function scrollToAuctions() {
            $scope.scrollToAuctions = !1, $timeout(function() {
                $scope.auctionScrollOffset = -80, $rootScope.currentUser && ($scope.auctionScrollOffset -= 30), 
                $scope.scrollToAuctions = !0;
            }, 100);
        }
        function scrollToAuctionsIfNotFirstVisits() {
            if (OsInfoService.isMobile()) {
                if ($rootScope.lastAuctionClick && "app.home" == $rootScope.lastAuctionClick.state) return;
                var homeVisits = LocalStorageService.load("homeVisits") || 0;
                homeVisits > 2 && (scrollToAuctions(), $timeout(scrollToAuctions, 500)), LocalStorageService.store("homeVisits", homeVisits + 1);
            }
        }
        function init() {
            $scope.data.auctions = PortalInfoService.getAuctions(), setUpperMessage(), adjustUpperPartHeight(), 
            OsInfoService.isMobile() && ($scope.minimizedView = !0);
        }
        $scope.data = {}, $scope.gotoSearch = function() {
            SearchService.gotoSearchScene($scope.data.searchToken);
        }, init(), scrollToAuctionsIfNotFirstVisits(), $rootScope.$on("settings.regionChanged", init), 
        $rootScope.$on("portalInfo.infoUpdated", init), $window.addEventListener("resize", adjustUpperPartHeight);
    } ]);
}), define("portal/js/modules/auctions/home/index", [ "./homeModule", "./homeController" ], function() {}), 
define("portal/js/modules/auctions/catalogs/catalogsModule", [ "angular" ], function(ng) {
    return ng.module("app.auctions.catalogs", [ "app.auctions.catalogs.list", "app.auctions.catalogs.lotPage", "app.auctions.catalogs.auctionInfo", "app.auctions.catalogs.search", "app.auctions.catalogs.lotElements" ]);
}), define("portal/js/modules/auctions/catalogs/catalogsService", [ "./catalogsModule" ], function(module) {
    module.factory("CatalogsService", function($q, $rootScope, $filter, ApiService, I18nService, StringsService, ArraysService, DateUtilsService, LocalStorageService, CloudinaryService, CatalogUtilsService, ViewPortService) {
        function getNavState() {
            return mNavState;
        }
        function resetNavState(auction, items) {
            mNavState.data.auction = auction, mNavState.data.items = items, mNavState.pagesData.visibleItems = items, 
            mNavState.pagesData.itemsCount = items.length, mNavState.pagesData.currentPage = 1, 
            mNavState.filterData.category = "all", mNavState.filterData.phrase = "", mNavState.filterData.soldState = "all";
            var storedItemsPerPage = LocalStorageService.load("itemsPerPage");
            storedItemsPerPage && (mNavState.pagesData.itemsPerPage = 1 * storedItemsPerPage);
        }
        function updatePageItems() {
            var pagesData = mNavState.pagesData;
            pagesData.visibleItems && (pagesData.pageItems = CatalogUtilsService.getPageItems(pagesData.visibleItems, pagesData.currentPage, pagesData.itemsPerPage), 
            LocalStorageService.store("itemsPerPage", pagesData.itemsPerPage));
        }
        function getAuctionItems(auction) {
            var deferred = $q.defer();
            return mCurrentAuctionCache.auctionId == auction.id ? deferred.resolve(mCurrentAuctionCache.items) : ApiService.callApi({
                api: "/portal/getAuctionItems",
                data: {
                    auctionId: auction.id,
                    cacheVersion: auction.catalogInfo.catalogCacheVersion
                },
                useCdnCache: !0
            }).success(function(items) {
                setCurrentItemsCache(auction, items), deferred.resolve(mCurrentAuctionCache.items);
            }), deferred.promise;
        }
        function setCurrentItemsCache(auction, items) {
            mCurrentAuctionCache.auctionId = auction.id, mCurrentAuctionCache.itemsById = {}, 
            mCurrentAuctionCache.itemsByIdInApp = {}, angular.forEach(items, function(item) {
                item.auction = auction, mCurrentAuctionCache.itemsById[item.id] = item, mCurrentAuctionCache.itemsByIdInApp[item.idInApp] = item;
            }), CatalogUtilsService.sortLots(items), mCurrentAuctionCache.items = items;
        }
        function getAuctionItem(auction, itemId) {
            var deferred = $q.defer();
            return getAuctionItems(auction).then(function(items) {
                mNavState.data.auction && mNavState.data.auction.id == auction.id || resetNavState(auction, items), 
                deferred.resolve(getAuctionItemFromCache(itemId));
            }), deferred.promise;
        }
        function getAuctionItemFromCache(itemId) {
            return mCurrentAuctionCache.itemsById[itemId];
        }
        function getItemByIdInApp(auction, itemIdInApp) {
            return mCurrentAuctionCache.auctionId == auction.id ? mCurrentAuctionCache.itemsByIdInApp[itemIdInApp] : null;
        }
        function getLotImageUrl(lot, imageInd, size, imageMode) {
            imageInd || (imageInd = 0);
            var imageName = lot.imagesList[imageInd];
            if (!imageName) return null;
            var catalogInfo = lot.auction.catalogInfo, imagePath = "v" + catalogInfo.imagesVersion + "/" + catalogInfo.imagesBase + "_" + lot.itemIndex + "_" + imageName;
            return CloudinaryService.getUrl(imagePath, {
                size: size,
                mode: imageMode
            });
        }
        function filterListWithPhrase(lotItems, phrase) {
            if (!phrase) return lotItems;
            for (var matches = [], result = [], i = 0; i < lotItems.length; i++) {
                var lotMatch = CatalogUtilsService.checkLotMatchPhrase(lotItems[i], phrase);
                lotMatch.score > 0 && matches.push(lotMatch);
            }
            ArraysService.sort(matches, "score", !0);
            for (var i = 0; i < matches.length; i++) matches[i].lot.score = matches[i].score, 
            result.push(matches[i].lot);
            return result;
        }
        function filterListWithCategory(lotItems, category) {
            for (var result = [], i = 0; i < lotItems.length; i++) {
                var lotItem = lotItems[i], lotCategory = lotItem.category[I18nService.getCurrentLang()];
                lotCategory == category && result.push(lotItem);
            }
            return result;
        }
        function filterListWithSoldState(lotItems, soldState) {
            for (var result = [], i = 0; i < lotItems.length; i++) {
                var lotItem = lotItems[i];
                ("all" == soldState || lotItem.soldLotBid && "sold" == soldState || !lotItem.soldLotBid && "unsold" == soldState) && result.push(lotItem);
            }
            return result;
        }
        function getBidLabel(lot) {
            var bid, labelKey = null, bidType = null;
            return lot.selfSoldLotBid ? (bidType = "self-sold", bid = lot.selfSoldLotBid, labelKey = "lot_self_sold_bid") : lot.soldLotBid ? (bidType = "sold", 
            bid = lot.soldLotBid, labelKey = "lot_sold_bid") : lot.selfAbsenteeBid && (bidType = "self-absentee", 
            bid = lot.selfAbsenteeBid, labelKey = "lot_self_absentee_bid"), bid ? {
                text: I18nService.getText(labelKey),
                price: I18nService.sumInCurrency(bid.price, lot.auction.catalogInfo.currency),
                type: bidType
            } : void 0;
        }
        function getCategoriesList(lotItems) {
            for (var catagoriesCount = {}, i = 0; i < lotItems.length; i++) {
                var category = lotItems[i].category[I18nService.getCurrentLang()];
                if (!StringsService.isBlank(category)) {
                    var count = catagoriesCount[category];
                    catagoriesCount[category] = count ? catagoriesCount[category] + 1 : 1;
                }
            }
            var catagories = [];
            for (category in catagoriesCount) {
                var count = catagoriesCount[category];
                catagories.push({
                    name: category + " (" + count + ")",
                    value: category
                });
            }
            return ArraysService.sort(catagories, "name"), catagories;
        }
        function getMobileElementsDimensions(recalc) {
            return (!mMobileElementsDimensions.infoWidth || recalc) && (mMobileElementsDimensions.infoWidth = Math.min(Math.max(ViewPortService.clientWidth(), 500), 995) - 220), 
            mMobileElementsDimensions;
        }
        function isLastPageRelevantToAuction(auctionId) {
            if (!mNavState.data.auction) return !1;
            if (mNavState.data.auction.id != auctionId) return !1;
            var previusStateUrl = $rootScope.$previousState.url;
            return 0 == previusStateUrl.indexOf("catalog") || 0 == previusStateUrl.indexOf("lotPage") ? !0 : !1;
        }
        var mCurrentAuctionCache = {
            auctionId: null,
            items: null,
            itemsById: null,
            itemsByIdInApp: null
        }, mNavState = {
            data: {
                auction: null,
                items: null
            },
            pagesData: {
                currentPage: 1,
                itemsPerPage: 20
            },
            filterData: {
                category: "all"
            }
        }, mMobileElementsDimensions = {};
        return $rootScope.$on("viewPort.windowSizeChanged", function() {
            getMobileElementsDimensions(!0);
        }), {
            getAuctionItems: getAuctionItems,
            getAuctionItem: getAuctionItem,
            getAuctionItemFromCache: getAuctionItemFromCache,
            getItemByIdInApp: getItemByIdInApp,
            getLotImageUrl: getLotImageUrl,
            filterListWithPhrase: filterListWithPhrase,
            filterListWithCategory: filterListWithCategory,
            filterListWithSoldState: filterListWithSoldState,
            getCategoriesList: getCategoriesList,
            getNavState: getNavState,
            resetNavState: resetNavState,
            isLastPageRelevantToAuction: isLastPageRelevantToAuction,
            updatePageItems: updatePageItems,
            getBidLabel: getBidLabel,
            getMobileElementsDimensions: getMobileElementsDimensions
        };
    });
}), define("portal/js/modules/auctions/catalogs/catalogAccountService", [ "./catalogsModule" ], function(module) {
    module.factory("CatalogAccountService", function($q, $log, $rootScope, $uibModal, ArraysService, ApiService, PathsService, CatalogUtilsService, PortalAuthService, CatalogsService, PortalInfoService, AccountService) {
        function loadForAuction(auction) {
            var deferred = $q.defer(), currentUserId = $rootScope.currentUser ? $rootScope.currentUser.id : null;
            return isCurrentCacheAuction(auction) && currentUserId == mCachedCatalogAccountInfo.userId ? deferred.resolve() : (mCachedCatalogAccountInfo = null, 
            CatalogsService.getAuctionItems(auction).then(function() {
                ApiService.callApi("/account/getAccountInfoAndSoldLotsForAuction", {
                    auctionId: auction.id
                }).success(function(info) {
                    info.accountInfo && (info.accountInfo.soldLotsBids = ArraysService.getFilteredList(info.auctionSoldLotsBids, "userIdInApp", !0, info.accountInfo.userIdInApp), 
                    parseAccountInfo(auction, info.accountInfo)), AccountService.addBidsInfoToItems(auction, info.auctionSoldLotsBids, "soldLotBid"), 
                    mCachedCatalogAccountInfo = info, mCachedCatalogAccountInfo.auction = auction, mCachedCatalogAccountInfo.userId = currentUserId, 
                    auction.absenteeBidsEnabled = info.absenteeBidsEnabled, auction.house && (auction.house.increments = mCachedCatalogAccountInfo.increments), 
                    $rootScope.$broadcast("account.dataLoaded"), deferred.resolve();
                });
            })), deferred.promise;
        }
        function isCurrentCacheAuction(auction) {
            return mCachedCatalogAccountInfo && mCachedCatalogAccountInfo.auction.id == auction.id;
        }
        function parseAccountInfo(auction, accountInfo) {
            PortalAuthService.setCurrentHouseApprovalState(auction.houseId, accountInfo.approvalState), 
            AccountService.addBidsInfoToItems(auction, accountInfo.absenteeBids, "selfAbsenteeBid"), 
            AccountService.addBidsInfoToItems(auction, accountInfo.soldLotsBids, "selfSoldLotBid"), 
            AccountService.addFavoriteFlagToItems(auction, accountInfo.favoriteLotIdsInApp);
        }
        function reloadAccountInfo() {
            return mCachedCatalogAccountInfo ? (CatalogsService.getAuctionItems(mCachedCatalogAccountInfo.auction).then(function(items) {
                for (var i = 0; i < items.length; i++) AccountService.setBidInfoForItem(items[i], "selfAbsenteeBid", null), 
                AccountService.setBidInfoForItem(items[i], "selfSoldLotBid", null);
            }), loadForAuction(mCachedCatalogAccountInfo.auction)) : void 0;
        }
        var mCachedCatalogAccountInfo = null;
        return $rootScope.$on("auth.newSessionUser", reloadAccountInfo), {
            loadForAuction: loadForAuction
        };
    });
}), define("portal/js/modules/auctions/catalogs/lotElements/lotElementModule", [ "angular" ], function(ng) {
    return ng.module("app.auctions.catalogs.lotElements", []);
}), define("portal/js/modules/auctions/catalogs/lotElements/lotFilters", [ "./lotElementModule" ], function(module) {
    return module.filter("lotText", [ "LotTextsService", function(LotTextsService) {
        return function(lot, length) {
            return LotTextsService.getLotText(lot, length);
        };
    } ]).filter("lotImage", [ "CatalogsService", function(CatalogsService) {
        return function(lot, size) {
            return window.location.protocol + CatalogsService.getLotImageUrl(lot, 0, size);
        };
    } ]);
}), define("portal/js/modules/auctions/catalogs/lotElements/lotImageDirective", [ "./lotElementModule" ], function(module) {
    module.directive("bsLotImage", function($timeout, $rootScope, PathsService, StringsService, DomUtilsService, CatalogsService, LotTextsService) {
        return {
            restrict: "E",
            replace: !0,
            scope: {
                lot: "=",
                size: "@",
                imageInd: "=",
                asBg: "=",
                imageMode: "=",
                watchable: "=",
                loadedImageInfo: "=",
                enableMagnifier: "@",
                moveInFrame: "=",
                debug: "="
            },
            link: function(scope, element) {
                function loadImage() {
                    function displayImage() {
                        scope.asBg ? element.css({
                            "background-image": "url(" + imageUrl + ")",
                            "background-repeat": "no-repeat"
                        }) : (scope.loadedImageSrc = imageUrl, setImgSize()), scope.stateVisible = !1;
                    }
                    debug("start"), imageLoaded = !1, scope.stateVisible = !1, scope.stateInfo = null, 
                    scope.narrowHeight = !1, rect = null;
                    $rootScope.search;
                    $timeout(function() {
                        imageLoaded || scope.stateInfo || $rootScope.searchAgentRequest || (scope.stateInfo = "image_load", 
                        scope.stateVisible = !0), debug("timer");
                    }, 100), scope.loadedImageSrc = "", element.css({
                        "background-image": "none"
                    }), setImgAlt();
                    var imageUrl = CatalogsService.getLotImageUrl(scope.lot, scope.imageInd, scope.size, scope.imageMode);
                    imageUrl ? $rootScope.searchAgentRequest ? displayImage() : (debug("loading"), DomUtilsService.loadImage(imageUrl).then(function(imageInfo) {
                        !imageInfo.src != imageUrl && (loadedImageSize = imageInfo.size, debug(JSON.stringify(imageInfo.size)), 
                        displayImage(), scope.moveInFrame && setElementPositionInFrame(0, 0), element.addClass("loaded"), 
                        scope.loadedImageInfo && (scope.loadedImageInfo.loaded = !0, scope.loadedImageInfo.size = imageInfo.size), 
                        debug("image loaded"), imageLoaded = !0, $timeout(function() {
                            debug(element[0].offsetHeight), element[0].offsetHeight && element[0].offsetHeight < 250 && (scope.narrowHeight = !0);
                        }, 50));
                    }, function() {
                        setMissingImage();
                    })) : setMissingImage();
                }
                function getImgElement() {
                    return angular.element(element[0].querySelector("img"));
                }
                function setImgSize() {
                    if (scope.size) {
                        var img = getImgElement(), sizeParts = scope.size.split("x");
                        sizeParts[0] && (sizeParts[0] < 100 && (scope.smallImage = !0), img.css({
                            "max-width": sizeParts[0] + "px"
                        })), sizeParts[1] && img.css({
                            "max-height": sizeParts[1] + "px"
                        });
                    }
                }
                function setImgAlt() {
                    var img = getImgElement(), text = LotTextsService.getLotText(scope.lot, 50).split("...")[0];
                    text = StringsService.stripTags(text), img.attr({
                        alt: text
                    });
                }
                function setMissingImage() {
                    $rootScope.searchAgentRequest || (scope.stateInfo = scope.smallImage ? "image_missing" : "image_available_soon", 
                    scope.stateVisible = !0);
                }
                function debug() {
                    scope.debug;
                }
                function getRatio(offset, size) {
                    var margin = 50, ratio = Math.round((100 + margin) * offset / size) - margin / 2;
                    return ratio = Math.max(0, ratio), ratio = Math.min(100, ratio), ratio + "%";
                }
                function moveBg(e) {
                    rect || (rect = DomUtilsService.getBoundingRect(element));
                    var offsetX = (e.pageX || e.targetTouches[0].pageX) - rect.left, offsetY = (e.pageY || e.targetTouches[0].pageY) - rect.top, ratioX = getRatio(offsetX, rect.width), ratioY = getRatio(offsetY, rect.height);
                    setElementPositionInFrame(ratioX, ratioY), e.preventDefault();
                }
                function setElementPositionInFrame(ratioX, ratioY) {
                    var xPos = loadedImageSize.width < $rootScope.viewPort.innerWidth ? "center" : ratioX, yPos = loadedImageSize.height < $rootScope.viewPort.innerHeight - 200 ? "center" : ratioY;
                    element.css({
                        backgroundPosition: xPos + " " + yPos
                    });
                }
                var rect = null, loadedImageSize = null, imageLoaded = !1;
                scope.watchable ? (scope.$watch("imageInd", function() {
                    loadImage();
                }), scope.$watch("imageMode", function() {
                    loadImage();
                })) : loadImage(), scope.moveInFrame && (element.bind("touchmove", moveBg), element.bind("mousedown", moveBg));
            },
            templateUrl: PathsService.appTemplatePath("auctions/catalogs/elements/lotImage")
        };
    });
}), define("portal/js/modules/auctions/catalogs/lotElements/lotPriceDirective", [ "./lotElementModule" ], function(module) {
    module.directive("bsLotPrice", function($timeout, PathsService, I18nService, DomUtilsService, CatalogsService, StructuredDataService) {
        return {
            restrict: "E",
            replace: !0,
            scope: {
                lot: "=",
                maxWidth: "=",
                breakOnRow: "=",
                singleRow: "="
            },
            link: function(scope) {
                var lot = scope.lot, currency = lot.auction.catalogInfo.currency;
                lot.auction.catalogInfo.startPriceHidden ? (scope.showStartPrice = !1, scope.showNoPrice = !1, 
                lot.estimatedPrice ? (scope.showEstimatedPrice = !0, scope.estimatedPrice = StructuredDataService.getPriceStructuredDataTag(lot.estimatedPrice, currency)) : scope.showEstimatedPrice = !1) : (lot.startPrice ? (scope.showStartPrice = !0, 
                scope.showNoPrice = !1, scope.startPrice = I18nService.sumInCurrency(lot.startPrice, currency), 
                scope.startPrice = StructuredDataService.getPriceStructuredDataTag(scope.startPrice, currency)) : (scope.showStartPrice = !1, 
                scope.showNoPrice = !0), lot.estimatedPrice && !scope.singleRow && (scope.showEstimatedPrice = !0, 
                scope.estimatedPrice = lot.estimatedPrice, scope.startPrice || (scope.estimatedPrice = StructuredDataService.getPriceStructuredDataTag(scope.estimatedPrice, currency))));
            },
            templateUrl: PathsService.appTemplatePath("auctions/catalogs/elements/lotPrice")
        };
    });
}), define("portal/js/modules/auctions/catalogs/lotElements/lotTextsService", [ "./lotElementModule" ], function(module) {
    module.factory("LotTextsService", function(StringsService, I18nService) {
        function trimmedItemParts(item, maxLen, noHtml) {
            {
                var artist = I18nService.getLangField(item.artist), name = I18nService.getLangField(item.name), description = I18nService.getLangField(item.description);
                I18nService.getLangField(item.details);
            }
            (noHtml || maxLen < (description + " " + artist + " " + name).length) && (description = StringsService.stripTags(description)), 
            name && 0 != description.indexOf(name) || (name = description, description = "");
            var descMaxLen = maxLen ? maxLen - (artist + " " + name).length : description.length, nameMaxLen = maxLen ? maxLen - artist.length : name.length;
            return name = StringsService.trimToWord(name, nameMaxLen), description = StringsService.trimToWord(description, descMaxLen), 
            {
                name: name,
                artist: artist,
                description: description
            };
        }
        function getLotText(lot, length) {
            var text = "", trimmedParts = trimmedItemParts(lot, length, !0);
            return trimmedParts.description && (text = trimmedParts.description), trimmedParts.name && (text && !trimmedParts.name.match(/\.$/) && (trimmedParts.name = trimmedParts.name + "."), 
            text = "<span class='lot-name'>" + trimmedParts.name + " </span>" + text), trimmedParts.artist && (text = "<span class='lot-artist'>" + trimmedParts.artist + "</span>" + (text ? " - " + text : "")), 
            text;
        }
        return {
            getLotText: getLotText
        };
    });
}), define("portal/js/modules/auctions/catalogs/lotElements/lotBidFormDirective", [ "./lotElementModule" ], function(module) {
    module.directive("bsLotBidForm", function($timeout, $rootScope, $state, PathsService, DialogsService, I18nService, PopupsService, PortalTextsService, PortalAuthService, AppSiteWinodwsService, CatalogsService, BidRulesService, AccountService, CatalogAccountService) {
        return mRecentBidInputValue = {}, {
            restrict: "E",
            replace: !0,
            scope: {
                lot: "="
            },
            link: function(scope) {
                function showBidConfirmation() {
                    PopupsService.showPopup({
                        contentInclude: "auctions/catalogs/lotPage/common/confirmation/confirmBid",
                        code: "confirmBid",
                        title: I18nService.getText("confirm_bid_title"),
                        data: {
                            lot: scope.lot,
                            bidPrice: scope.model.bidPrice,
                            hideTopBackButton: !0
                        }
                    });
                }
                function handleError(errorResponse) {
                    var house = scope.lot.auction.house;
                    "LOT_CLOSED_FOR_BIDDING" == errorResponse.errorKey ? $rootScope.showGeneralError("bid_error_closed_for_bidding") : "AUCTION_CLOSED_FOR_BIDDING" == errorResponse.errorKey ? ($rootScope.showGeneralError("bid_error_closed_for_bidding"), 
                    scope.lot.auction.absenteeBidsEnabled = !1, init()) : "USER_NOT_FOUND" == errorResponse.errorKey ? (PortalAuthService.setCurrentHouseApprovalState(house.id, "NOT_REGISTERED"), 
                    AccountService.showApprovalPopup(house)) : "USER_NOT_APPROVED" == errorResponse.errorKey ? (PortalAuthService.setCurrentHouseApprovalState(house.id, errorResponse.approvalState), 
                    AccountService.showApprovalPopup(house)) : PopupsService.showHouseConnectivityErrorPopup(house);
                }
                function initLabel() {
                    scope.bidLabel = CatalogsService.getBidLabel(scope.lot);
                }
                function initMode() {
                    scope.lot.soldLotBid ? scope.mode = "sold" : "READY" == scope.lot.auction.state ? scope.mode = 0 == scope.lot.auction.absenteeBidsEnabled || scope.lot.auction.catalogOnly ? "disabled" : scope.lot.selfAbsenteeBid ? "existing" : "new" : "RUNNING" == scope.lot.auction.state ? scope.mode = 0 == scope.lot.auction.absenteeBidsEnabled ? "disabled" : "running" : "ENDED" == scope.lot.auction.state && (scope.mode = "ended");
                }
                function checkIfShouldScrollToForm() {
                    return mRecentBidInputValue.lotId == scope.lot.id && new Date().getTime() < mRecentBidInputValue.time + 12e4 ? !0 : void 0;
                }
                function checkIfShouldShowRecentBidInputValue() {
                    return mRecentBidInputValue.lotId != scope.lot.id ? !1 : new Date().getTime() > mRecentBidInputValue.time + 12e4 ? !1 : "running" == scope.mode || "disabled" == scope.mode ? !1 : scope.lot.selfAbsenteeBid && scope.lot.selfAbsenteeBid.price == mRecentBidInputValue.price ? !1 : !0;
                }
                function loadRecentBidInputValue() {
                    checkIfShouldShowRecentBidInputValue() && (scope.model.bidPrice = mRecentBidInputValue.price, 
                    "new" != scope.mode && (scope.mode = "edit")), checkIfShouldScrollToForm() && (scope.scrollToForm = !0);
                }
                function init() {
                    initMode(), initLabel(), loadRecentBidInputValue();
                }
                scope.model = {}, scope.tryToPlaceBid = function() {
                    var house = scope.lot.auction.house;
                    AccountService.validateRegisteredInHouseAndThen(house, {}, function() {
                        BidRulesService.validBid(scope.lot, scope.model.bidPrice) && showBidConfirmation(house, scope.lot, scope.model.bidPrice);
                    });
                }, scope.removeBidIfConfirmed = function() {
                    var bid = scope.lot.selfAbsenteeBid;
                    if (bid) return DialogsService.showConfirm({
                        message: "bid_confirm_remove",
                        title: "dialogs_notice_title",
                        params: {
                            lotIndex: scope.lot.itemIndex,
                            price: I18nService.sumInCurrency(bid.price, scope.lot.auction.catalogInfo.currency)
                        }
                    }).then(function(confirmed) {
                        confirmed && (mRecentBidInputValue.lotId = null, AccountService.removeAbsenteeBid(scope.lot.auction.houseId, scope.lot).success(function(response) {
                            response.success ? (scope.model.bidPrice = null, scope.mode = "new", scope.bidLabel = null) : handleError(response);
                        }).error(handleError));
                    });
                }, scope.openAuctionSite = function() {
                    AppSiteWinodwsService.openAuctionSiteWindow(scope.lot.auction);
                }, scope.setEditMode = function() {
                    scope.mode = "edit", scope.model.bidPrice = scope.lot.selfAbsenteeBid.price, scope.bidLabel = null, 
                    scope.focusNow = !0, $timeout(function() {
                        scope.focusNow = !1;
                    }, 50);
                }, scope.cancelEdit = function() {
                    scope.mode = "existing", scope.model.bidPrice = null, scope.bidLabel = CatalogsService.getBidLabel(scope.lot);
                }, scope.gotoHousePage = function() {
                    $state.go("app.house", {
                        houseCode: scope.lot.auction.house.code
                    });
                }, scope.getDisabledMessage = function() {
                    var disabledMessageKey, houseParams = PortalTextsService.getHouseTextParams(scope.lot.auction.house);
                    return disabledMessageKey = scope.lot.auction.catalogOnly ? "bid_form_catalog_only" : "bid_form_disabled", 
                    I18nService.getText(disabledMessageKey, houseParams);
                }, scope.saveRecentBidInputValue = function() {
                    isNaN(scope.model.bidPrice) && "" != scope.model.bidPrice || (mRecentBidInputValue = {
                        lotId: scope.lot.id,
                        price: scope.model.bidPrice,
                        time: new Date().getTime()
                    });
                }, init(), scope.$watch("lot.lastBidUpdate", init), $rootScope.$on("account.dataLoaded", init), 
                $rootScope.$on("auth.newSessionUser", function() {
                    CatalogAccountService.loadForAuction(scope.lot.auction);
                });
            },
            templateUrl: PathsService.appTemplatePath("auctions/catalogs/elements/bidForm")
        };
    });
}), define("portal/js/modules/auctions/catalogs/lotElements/confirmBidController", [ "./lotElementModule" ], function(module) {
    module.controller("ConfirmBidController", [ "$scope", "$rootScope", "$window", "StringsService", "I18nService", "AnalyticsService", "PortalAuthService", "PortalInfoService", "PopupsService", "AccountService", function($scope, $rootScope, $window, StringsService, I18nService, AnalyticsService, PortalAuthService, PortalInfoService, PopupsService, AccountService) {
        function handleError(errorResponse) {
            var house = $scope.lot.auction.house;
            "LOT_CLOSED_FOR_BIDDING" == errorResponse.errorKey ? $rootScope.showGeneralError("bid_error_closed_for_bidding") : "AUCTION_CLOSED_FOR_BIDDING" == errorResponse.errorKey ? ($rootScope.showGeneralError("bid_error_closed_for_bidding"), 
            scope.lot.auction.absenteeBidsEnabled = !1) : "USER_NOT_APPROVED" == errorResponse.errorKey ? (PortalAuthService.setCurrentHouseApprovalState(house.id, errorResponse.approvalState), 
            AccountService.showApprovalPopup(house)) : $rootScope.showGeneralError();
        }
        $scope.init = function() {
            $scope.options.buttons = [ {
                text: "confrim_bid_dont_agree",
                type: "warning",
                isCloseButton: !0
            }, {
                text: "confrim_bid_agree",
                action: $scope.submitBid
            } ], $scope.lot = $scope.options.data.lot, $scope.house = $scope.lot.auction.house, 
            $scope.bidPrice = $scope.options.data.bidPrice, $scope.initialized = !0;
        }, $scope.submitBid = function() {
            return AccountService.placeAbsenteeBid($scope.house.id, $scope.lot, $scope.bidPrice).success(function(response) {
                response.errorKey ? handleError(response) : (PortalAuthService.setCurrentHouseApprovalState($scope.house.id, "APPROVED"), 
                AnalyticsService.trackEvent("catalogAction", "bidInHouse", "absentee bid in house " + $scope.house.code), 
                $scope.options.isModal ? $scope.$close() : $window.history.back());
            }).error(function(response) {
                handleError(response);
            });
        }, $scope.showTerms = function() {
            PopupsService.showHouseTerms($scope.lot.auction.house);
        };
    } ]);
}), define("portal/js/modules/auctions/catalogs/lotElements/lotBadgeDirective", [ "./lotElementModule" ], function(module) {
    module.directive("bsLotBadge", function($rootScope, PathsService, I18nService, CatalogsService, StringsService) {
        return {
            restrict: "E",
            replace: !0,
            scope: {
                lot: "="
            },
            link: function(scope, element) {
                function update() {
                    var bidLabel = CatalogsService.getBidLabel(scope.lot);
                    scope.lot.houseBadge ? (scope.badgeType = "house", scope.text = scope.lot.houseBadge.text, 
                    StringsService.stripTags(scope.text).length > 25 && (scope.longText = !0), scope.visible = !0, 
                    element.css({
                        "background-color": scope.lot.houseBadge.color || "#aaaaaa"
                    }), bidLabel && (scope.badgeType += " with-bid", scope.text += "<br><b>" + bidLabel.text + ": " + bidLabel.price + "</b>")) : bidLabel && (scope.badgeType = bidLabel.type, 
                    scope.text = bidLabel.text + ": " + bidLabel.price, scope.visible = !0);
                }
                scope.lot.expireTime && $rootScope.devMode, scope.$watch("lot.lastBidUpdate", update);
            },
            templateUrl: PathsService.appTemplatePath("auctions/catalogs/elements/lotBadge")
        };
    });
}), define("portal/js/modules/auctions/catalogs/lotElements/lotExpirationDirective", [ "./lotElementModule" ], function(module) {
    module.directive("bsLotExpiration", function($rootScope, PathsService, I18nService, SettingsService) {
        return {
            restrict: "E",
            replace: !0,
            scope: {
                lot: "="
            },
            link: function(scope, element) {
                function updateDisplay() {
                    var timeLeft = SettingsService.timeUntil(scope.lot.expireTime);
                    0 > timeLeft || scope.lot.soldLotBid ? (scope.expirationState = "past", scope.text = I18nService.getText("lot_expired")) : (scope.text = I18nService.getTimeLeftDisplay(scope.lot.expireTime), 
                    6e4 > timeLeft && (scope.expirationState = "expires-soon"));
                }
                $rootScope.devMode ? updateDisplay() : element.css({
                    display: "none"
                });
            },
            templateUrl: PathsService.appTemplatePath("auctions/catalogs/elements/lotExpiration")
        };
    });
}), define("portal/js/modules/auctions/catalogs/lotElements/lotFavoriteFlagDirective", [ "./lotElementModule" ], function(module) {
    module.directive("bsLotFavoriteFlag", function($rootScope, $timeout, PathsService, AccountService, PortalAuthService) {
        return {
            restrict: "E",
            replace: !0,
            scope: {
                lot: "="
            },
            link: function(scope) {
                var clearJustSetTimet = null;
                scope.toggleFavorite = function() {
                    $timeout.cancel(clearJustSetTimet);
                    var user = PortalAuthService.validateUserLoggedIn();
                    if (user) {
                        var isFavorite;
                        isFavorite = scope.lot.isFavorite ? !1 : !0, AccountService.setFavoriteItem(scope.lot.auction.house, scope.lot, isFavorite).then(function() {
                            scope.justChanged = !0, clearJustSetTimet = $timeout(function() {
                                scope.justChanged = !1;
                            }, 2e3);
                        });
                    }
                }, scope.onMouseOut = function() {
                    scope.justChanged = !1, scope.lot.onFavoriteFlag = !1;
                }, scope.onMouseOver = function() {
                    scope.justChanged = !1, scope.lot.onFavoriteFlag = !0;
                };
            },
            templateUrl: PathsService.appTemplatePath("auctions/catalogs/elements/lotFavoriteFlag")
        };
    });
}), define("portal/js/modules/auctions/catalogs/lotElements/lotShareButtons", [ "./lotElementModule" ], function(module) {
    module.directive("bsLotShareButtons", function(StringsService, OsInfoService, SettingsService, PathsService, CatalogsService, AnalyticsService, PortalNavigationService) {
        return {
            restrict: "E",
            replace: !0,
            scope: {
                lot: "=",
                text: "="
            },
            link: function(scope) {
                function trackShare(button) {
                    var item = scope.lot, auction = item.auction, eventCategory = "ENDED" == auction.state ? "pastCatalogAction" : "catalogAction", house = auction ? auction.house : null;
                    house && (AnalyticsService.trackEvent(eventCategory, "lotShareInHouse", "lot share in house " + house.code), 
                    AnalyticsService.trackEvent(eventCategory, "lotShareWith", "lot share with " + button), 
                    AnalyticsService.trackEvent(eventCategory, "lotShare", "lot shared in house: " + house.code + ", auction:" + item.auctionDate + ", item:" + item.itemIndex + " button:" + button));
                }
                function getShareUrl(button) {
                    var shortUrl = SettingsService.get("portalAddress").replace("https", "http") + "/share/?s=" + button + "&a=" + scope.lot.auction.intKey + "&l=" + scope.lot.idInApp, encodedUrl = encodeURIComponent(PathsService.newLocationWithParam("s", button)), encodedShortUrl = encodeURIComponent(shortUrl), fixedTitle = scope.text.replace("<br>", " "), title = encodeURIComponent(fixedTitle), shortTitle = encodeURIComponent(StringsService.trimToWord(fixedTitle, 130 - shortUrl.length)), imageUrl = encodeURIComponent(CatalogsService.getLotImageUrl(scope.lot));
                    switch (button) {
                      case "fb":
                        return "//www.facebook.com/sharer/sharer.php?u=" + encodedUrl + "&title=" + title;

                      case "twitter":
                        return "//twitter.com/intent/tweet?status=" + shortTitle + "%0A" + encodedShortUrl;

                      case "pinterest":
                        return "//pinterest.com/pin/create/bookmarklet/?media=" + imageUrl + "&url=" + encodedUrl + "&is_video=false&description=" + title;

                      case "google":
                        return "//plus.google.com/share?url=" + encodedUrl;

                      case "email":
                        return "mailto:?subject=" + title + "&body=" + encodedShortUrl;
                    }
                }
                scope.share = function(button) {
                    trackShare(button);
                    var shareUrl = getShareUrl(button);
                    "email" == button ? window.location = shareUrl : PortalNavigationService.openWindow(shareUrl, "menubar=no,toolbar=no,resizable=yes,scrollbars=yes,height=600,width=600");
                }, scope.buttonName = function(button) {
                    switch (button) {
                      case "fb":
                        return "Facebook";

                      case "twitter":
                        return "Twitter";

                      case "pinterest":
                        return "Pinterest";

                      case "google":
                        return "Google plus";

                      case "email":
                        return "Email";
                    }
                };
            },
            templateUrl: PathsService.appTemplatePath("auctions/catalogs/elements/shareButtons")
        };
    });
}), define("portal/js/modules/auctions/catalogs/lotElements/index", [ "./lotElementModule", "./lotFilters", "./lotImageDirective", "./lotPriceDirective", "./lotTextsService", "./lotBidFormDirective", "./confirmBidController", "./lotBadgeDirective", "./lotExpirationDirective", "./lotFavoriteFlagDirective", "./lotShareButtons" ], function() {}), 
define("portal/js/modules/auctions/catalogs/auctionInfo/auctionInfoModule", [ "angular" ], function(ng) {
    return ng.module("app.auctions.catalogs.auctionInfo", []);
}), define("portal/js/modules/auctions/catalogs/auctionInfo/auctionInfoDirective", [ "./auctionInfoModule" ], function(module) {
    module.directive("bsAuctionInfo", function($rootScope, I18nService, DialogsService, PopupsService, PathsService) {
        return {
            restrict: "E",
            replace: !0,
            scope: {
                auction: "="
            },
            link: function(scope, element) {
                scope.currentLang = $rootScope.currentLang, angular.element(element[0].querySelector(".auction-texts")).css({
                    width: element[0].offsetWidth - 220 + "px"
                }), scope.showDisplayHours = function() {
                    DialogsService.showAlert({
                        title: "catalog_display_hours",
                        message: I18nService.getLangField(scope.auction.displayHours)
                    });
                }, scope.showHouseTerms = function() {
                    PopupsService.showHouseTerms(scope.auction.house);
                };
            },
            templateUrl: PathsService.appTemplatePath("auctions/catalogs/elements/auctionInfo")
        };
    });
}), define("portal/js/modules/auctions/catalogs/auctionInfo/registrationPromotionDirective", [ "./auctionInfoModule" ], function(module) {
    module.directive("bsHouseRegisrationPromotion", function($rootScope, I18nService, PathsService, AppSiteWinodwsService, PortalTextsService, PortalAuthService, AccountService) {
        return {
            restrict: "E",
            replace: !0,
            scope: {
                auction: "=",
                house: "="
            },
            link: function(scope) {
                function updateUserState() {
                    scope.auction && (house = scope.auction.house), house && (scope.userState = PortalAuthService.getHouseApprovalState(house.id));
                }
                scope.requestInProgress = !1;
                var house = scope.house;
                scope.openAuctionSite = function() {
                    AppSiteWinodwsService.openAuctionSiteWindow(scope.auction);
                }, updateUserState(), $rootScope.$on("auth.authStateChanged", updateUserState), 
                $rootScope.$on("auth.newSessionUser", updateUserState), $rootScope.$on("auth.houseApprovalChanged", updateUserState), 
                scope.$watch("auction", updateUserState), scope.setAuthScene = function(authScene) {
                    PortalAuthService.showAuthModalOrScene(authScene);
                }, scope.requestApproval = function() {
                    "COMPLETE" != $rootScope.currentUser.registrationStage ? PortalAuthService.showAuthModalOrScene("warning") : house.requestUserStateIdForApproval ? AccountService.showApprovalPopup(house) : scope.requestInProgress || (scope.requestInProgress = !0, 
                    AccountService.requestApprovalFromHouse(house).success(function() {
                        scope.requestInProgress = !1;
                    }).error(function() {
                        scope.requestInProgress = !1, $rootScope.showGeneralError();
                    }));
                }, scope.text = function(key) {
                    return I18nService.getText(scope.auction && scope.auction.absenteeBidsOnly ? key + "_absentee_only" : key);
                }, scope.houseParams = PortalTextsService.getHouseTextParams(house);
            },
            templateUrl: PathsService.appTemplatePath("auctions/catalogs/elements/registrationPromotion")
        };
    });
}), define("portal/js/modules/auctions/catalogs/auctionInfo/auctionStructuredDataDirective", [ "./auctionInfoModule" ], function(module) {
    module.directive("bsAuctionStructuredData", function(StructuredDataService) {
        return {
            restrict: "E",
            replace: !0,
            scope: {
                auction: "="
            },
            link: function(scope, element) {
                var auction = scope.auction;
                if (!auction.unknownExactDate && !auction.hideTime && "PENDING" != auction.state && auction.catalogInfo) {
                    var html = '<script type="application/ld+json">' + JSON.stringify(StructuredDataService.getAuctionStructuredData(scope.auction), null, 2) + "</script>";
                    element.html(html);
                }
            }
        };
    });
}), define("portal/js/modules/auctions/catalogs/auctionInfo/index", [ "./auctionInfoModule", "./auctionInfoDirective", "./registrationPromotionDirective", "./auctionStructuredDataDirective" ], function() {}), 
define("portal/js/modules/auctions/catalogs/list/catalogListModule", [ "angular" ], function(ng) {
    return ng.module("app.auctions.catalogs.list", []);
}), define("portal/js/modules/auctions/catalogs/list/catalogListController", [ "./catalogListModule" ], function(module) {
    module.controller("CatalogListController", [ "$rootScope", "$scope", "$timeout", "$state", "$stateParams", "AnalyticsService", "ArraysService", "LocalStorageService", "I18nService", "DomUtilsService", "ViewPortService", "PortalNavigationService", "CatalogUtilsService", "StructuredDataService", "PortalInfoService", "CatalogsService", "CatalogAccountService", function($rootScope, $scope, $timeout, $state, $stateParams, AnalyticsService, ArraysService, LocalStorageService, I18nService, DomUtilsService, ViewPortService, PortalNavigationService, CatalogUtilsService, StructuredDataService, PortalInfoService, CatalogsService, CatalogAccountService) {
        function loadNavStateInfo(navState) {
            navState.pagesData.currentPage = $stateParams.page ? $stateParams.page : 1, $scope.data = navState.data, 
            $scope.filterData = navState.filterData, $scope.pagesData = navState.pagesData, 
            $scope.currency = navState.data.auction.catalogInfo.currency;
            var phrase = CatalogsService.getNavState().filterData.phrase;
            $timeout(function() {
                CatalogsService.getNavState().filterData.phrase = phrase;
            }, 100), setScroll(), udpateDocumentInfo();
        }
        function udpateDocumentInfo() {
            var auction = $scope.data.auction;
            document.title = "bidspirit";
            var description = "";
            if (auction.house) {
                var houseName = I18nService.getLangField(auction.house.details.name);
                document.title += " - " + houseName, description = houseName + " - ";
            }
            var auctionStructuredData = StructuredDataService.getAuctionStructuredData(auction);
            description += auctionStructuredData.name, DomUtilsService.setMetaTag("name", "description", description), 
            DomUtilsService.setMetaTag("property", "og:description", description), DomUtilsService.setMetaTag("name", "twitter:description", description), 
            DomUtilsService.setMetaTag("property", "og:image", auctionStructuredData.image), 
            DomUtilsService.setMetaTag("name", "twitter:image", "https:" + auctionStructuredData.image), 
            DomUtilsService.setMetaTag("name", "twitter:card", "product"), DomUtilsService.setMetaTag("name", "twitter:data1", CatalogUtilsService.getAuctionTimeDisplay(auction, !1)), 
            DomUtilsService.setMetaTag("name", "twitter:label1", I18nService.getText("auction_date"));
        }
        function setScroll() {
            if (0 == mPreviousState.url.indexOf("lotPage") && $scope.pagesData) {
                var lotId = mPreviousState.args.lotId;
                $scope.pagesData.currentPage = CatalogUtilsService.getLotPage($scope.pagesData.visibleItems, lotId, $scope.pagesData.itemsPerPage), 
                $scope.scrollTo = lotId;
            } else lastSceneIsOfPageFromThisAuction() ? scrollToPagination() : window.scrollTo(0, 0);
        }
        function scrollToPagination() {
            $scope.scrollToPagination = !0, $timeout(function() {
                $scope.scrollToPagination = !1;
            }, 10);
        }
        function lastSceneIsOfPageFromThisAuction() {
            return CatalogsService.isLastPageRelevantToAuction($stateParams.auctionId);
        }
        function showFakeLoader() {
            clearTimeout(mFakeLoaderTimer), setScroll(), $scope.displayeItemsLoader = !0, mFakeLoaderTimer = $timeout(function() {
                $scope.displayeItemsLoader = !1, setScroll();
            }, 400);
        }
        function init() {
            mPreviousState = $rootScope.$previousState;
            var navState = CatalogsService.getNavState();
            $scope.mobileElementsDimensions = CatalogsService.getMobileElementsDimensions(), 
            lastSceneIsOfPageFromThisAuction(navState) ? (loadNavStateInfo(navState), showFakeLoader()) : (window.scrollTo(0, 0), 
            PortalInfoService.loadAuction($stateParams.auctionId).then(function(auction) {
                auction ? ($scope.auction = auction, CatalogsService.getAuctionItems(auction).then(function(items) {
                    CatalogsService.resetNavState(auction, items), loadNavStateInfo(navState), CatalogAccountService.loadForAuction(auction), 
                    CatalogsService.updatePageItems();
                }), trackEvents()) : $state.go("app.home");
            })), watchNavParams();
        }
        function onNavParamChange() {
            CatalogsService.updatePageItems(), showFakeLoader();
        }
        function watchNavParams() {
            $scope.$watch("pagesData.itemsPerPage", onNavParamChange), $scope.$watch("pagesData.currentPage", onNavParamChange), 
            $scope.$watch("filterData.lastSearchTime", onNavParamChange);
        }
        function trackEvents() {
            var auction = $scope.auction, house = auction ? auction.house : null;
            if (auction && house) {
                var eventCategory = "ENDED" == auction.state ? "pastCatalogAction" : "catalogAction";
                AnalyticsService.trackDailyUniqueEvent(eventCategory, "viewItemsListOfAuction", "Catalog viewed in hose:" + house.code + ", auction:" + auction.date + " " + auction.time), 
                AnalyticsService.trackEvent(eventCategory, "viewItemsListOfHouse", "Catalog viewed in house:" + house.code, {
                    appSiteTrackInfo: {
                        dailyUnique: !0,
                        house: house,
                        api: "system/logs/saveEnterPortalPage.api",
                        params: {
                            email: $rootScope.currentUser ? $rootScope.currentUser.email : ""
                        }
                    }
                });
            }
        }
        var mPreviousState = null, mFakeLoaderTimer = null;
        init();
    } ]);
}), define("portal/js/modules/auctions/catalogs/list/catalogListItemsDirective", [ "./catalogListModule" ], function(module) {
    module.directive("bsCatalogListItems", function(CatalogsService, PathsService) {
        return {
            restrict: "E",
            replace: !0,
            templateUrl: PathsService.appTemplatePath("auctions/catalogs/list/catalogItems")
        };
    });
}), define("portal/js/modules/auctions/catalogs/list/catalogListFilterDirective", [ "./catalogListModule" ], function(module) {
    module.directive("bsCatalogListFilter", function($rootScope, $timeout, PathsService, I18nService, CatalogsService, DomUtilsService) {
        return {
            restrict: "E",
            replace: !0,
            link: function(scope, element) {
                function searchIfChanged() {
                    var phrase = scope.filterData.phrase;
                    phrase != mLastSearchPhrase && (mLastSearchPhrase = phrase, phrase && (scope.filterData.category = "all"), 
                    scope.pagesData.foundItems = CatalogsService.filterListWithPhrase(scope.data.items, phrase), 
                    scope.applySoldStateFilter(), scrollToInput());
                }
                function scrollToInput() {
                    DomUtilsService.scrollToElementTop(element.find("input"), -130);
                }
                function setCategories() {
                    var categories = CatalogsService.getCategoriesList(scope.data.items);
                    categories.length > 0 && categories.unshift({
                        value: "all",
                        name: I18nService.getText("catalog_filter_all_categories")
                    }), scope.filterData.categories = categories;
                }
                var mLastSearchPhrase = "", mTimeout = null;
                scope.scrollToInput = !1, element.bind("keydown keypress", function(event) {
                    13 == event.which && element.find("input")[0].blur();
                }), scope.searchAfterDelay = function() {
                    $timeout.cancel(mTimeout), mTimeout = $timeout(searchIfChanged, 150);
                }, scope.filterByCategory = function() {
                    var category = scope.filterData.category;
                    "all" != category ? (scope.filterData.phrase = "", scope.pagesData.foundItems = CatalogsService.filterListWithCategory(scope.data.items, category)) : scope.filterData.phrase ? scope.searchAfterDelay() : scope.pagesData.foundItems = scope.data.items, 
                    scope.applySoldStateFilter();
                }, scope.applySoldStateFilter = function() {
                    scope.pagesData.visibleItems = CatalogsService.filterListWithSoldState(scope.pagesData.foundItems || scope.data.items, scope.filterData.soldState), 
                    scope.pagesData.itemsCount = scope.pagesData.visibleItems.length, scope.pagesData.currentPage = 1, 
                    scope.filterData.lastSearchTime = new Date().getTime();
                }, $rootScope.$on("i18n.languageChanged", function() {
                    setCategories();
                }), setCategories();
            },
            templateUrl: PathsService.appTemplatePath("auctions/catalogs/list/catalogFilterPanel")
        };
    });
}), define("portal/js/modules/auctions/catalogs/list/catalogListPaginationDirective", [ "./catalogListModule" ], function(module) {
    module.directive("bsCatalogListPagination", function($timeout, $rootScope, $stateParams, PathsService) {
        return {
            restrict: "E",
            replace: !0,
            scope: {
                pagesData: "=",
                positionInPage: "=",
                hrefPages: "=",
                onCurrentPageChange: "&"
            },
            link: function(scope, element) {
                function adjustWidth() {
                    var parent = element.parent()[0];
                    if (parent) {
                        var parentWidth = parent.offsetWidth, availableWidth = Math.min(850, parentWidth);
                        parentWidth > 800 && "upper" == scope.positionInPage && $rootScope.viewPort.pcMedia ? (scope.data.availableWidth = availableWidth - 350, 
                        scope.data.lifted = !0, element.css({
                            width: scope.data.availableWidth + "px"
                        })) : (scope.data.availableWidth = availableWidth, scope.data.lifted = !1);
                    }
                }
                scope.data = {}, adjustWidth(), element.addClass(scope.positionInPage), $rootScope.$on("viewPort.windowSizeChanged", function() {
                    adjustWidth(), $timeout(adjustWidth, 100);
                });
            },
            templateUrl: PathsService.appTemplatePath("auctions/catalogs/list/catalogPagination")
        };
    });
}), define("portal/js/modules/auctions/catalogs/list/index", [ "./catalogListModule", "./catalogListController", "./catalogListItemsDirective", "./catalogListFilterDirective", "./catalogListPaginationDirective" ], function() {}), 
define("portal/js/modules/auctions/catalogs/search/searchModule", [ "angular" ], function(ng) {
    return ng.module("app.auctions.catalogs.search", []);
}), define("portal/js/modules/auctions/catalogs/search/searchService", [ "./searchModule" ], function(module) {
    module.factory("SearchService", function($q, $rootScope, $state, ApiService, I18nService, StringsService, ArraysService, PortalInfoService) {
        function searchAllCatalogs(token, time, limit, page) {
            var deferred = $q.defer();
            return ApiService.callApi("/portal/searchItems/", {
                token: token,
                time: time,
                region: $rootScope.currentRegion,
                lang: I18nService.getCurrentLang(),
                limit: limit,
                skip: (page - 1) * limit,
                allowHidden: $rootScope.devMode
            }).success(function(response) {
                setSoldLotsBids(response.results, response.soldLots);
                var allAuctionsFound = setItemsAuctions(response.results);
                allAuctionsFound && !mTriedToLoadAll ? deferred.resolve(response) : (mTriedToLoadAll = !0, 
                PortalInfoService.loadForRegion($rootScope.currentRegion, !0).then(function() {
                    setItemsAuctions(response.results), deferred.resolve(response);
                }));
            }), deferred.promise;
        }
        function setItemsAuctions(items) {
            for (var i = 0; i < items.length; i++) {
                var item = items[i];
                if (item.auction = PortalInfoService.getAuction(item.auctionId), !item.auction) return !1;
            }
            return !0;
        }
        function setSoldLotsBids(items, soldLotBids) {
            if (soldLotBids) {
                for (var bidsMap = {}, i = 0; i < soldLotBids.length; i++) {
                    var bid = soldLotBids[i];
                    bidsMap[bid.lotId] = bid;
                }
                for (var i = 0; i < items.length; i++) {
                    var item = items[i], soldBid = bidsMap[item.id];
                    soldBid && (item.soldLotBid = soldBid);
                }
            }
        }
        function getLastSearchInfo() {
            return mLastSearchInfo;
        }
        function getNewSearchInfo() {
            return mNewSearchInfo;
        }
        function gotoSearchScene(token) {
            mNewSearchInfo.token = token, $state.go("app.search");
        }
        var mLastSearchInfo = {}, mNewSearchInfo = {}, mTriedToLoadAll = !1;
        return {
            searchAllCatalogs: searchAllCatalogs,
            gotoSearchScene: gotoSearchScene,
            getLastSearchInfo: getLastSearchInfo,
            getNewSearchInfo: getNewSearchInfo
        };
    });
}), define("portal/js/modules/auctions/catalogs/search/searchController", [ "./searchModule" ], function(module) {
    module.controller("SearchController", [ "$scope", "$timeout", "$state", "CatalogUtilsService", "AnalyticsService", "ArraysService", "I18nService", "LogService", "StringsService", "CatalogsService", "AppSiteWinodwsService", "AccountService", "SearchService", "PortalInfoService", function($scope, $timeout, $state, CatalogUtilsService, AnalyticsService, ArraysService, I18nService, LogService, StringsService, CatalogsService, AppSiteWinodwsService, AccountService, SearchService) {
        function getSearchResultsForCurrentPage() {
            return mSearchInfo.searchTime = new Date().getTime(), $scope.loadState = "loading", 
            SearchService.searchAllCatalogs($scope.data.token, $scope.data.searchTime, $scope.pagesData.itemsPerPage, $scope.pagesData.currentPage);
        }
        function trackSearch(token) {
            if ($scope.data.lastTrackedToken != token || $scope.data.searchTime != $scope.data.lastSearchTime) {
                var eventCatagory = "PAST" == $scope.data.searchTime ? "pastCatalogAction" : "catalogAction";
                AnalyticsService.trackEvent(eventCatagory, "search", "search for token '" + token + "'"), 
                $scope.data.lastTrackedToken = token, $scope.data.lastSearchTime = $scope.data.searchTime;
            }
        }
        function setItems(items) {
            angular.forEach(items, function(item) {
                item.auction && (item.houseBadge = {
                    text: StringsService.trimToWord(I18nService.getLangField(item.auction.house.details.name), 20) + " <span dir='ltr'>(" + CatalogUtilsService.getAuctionTimeDisplay(item.auction, !0, !0) + ")</span>",
                    color: item.auction.house.details.brandColor
                });
            }), $scope.pagesData.pageItems = ArraysService.filteredByNonEmpty(items, "auction").slice(0, $scope.pagesData.itemsPerPage), 
            $scope.loadState = "loaded";
        }
        function initToken(token, reloadSearch) {
            $timeout(function() {
                $scope.data.token = token, reloadSearch && $scope.doSearch();
            }, 100);
        }
        function init() {
            mSearchInfo = SearchService.getLastSearchInfo(), $scope.mobileElementsDimensions = CatalogsService.getMobileElementsDimensions();
            var newSearchInfo = SearchService.getNewSearchInfo();
            $scope.loadState = "idle", $scope.scrollToPagination = !1, null != newSearchInfo.token ? (initToken(newSearchInfo.token, !0), 
            mSearchInfo.data = $scope.data, mSearchInfo.pagesData = $scope.pagesData, window.scroll(0, 0)) : mSearchInfo.lastLot && CatalogsService.isLastPageRelevantToAuction(mSearchInfo.lastLot.auctionId) && new Date().getTime() - mSearchInfo.searchTime < 6e5 ? ($scope.data = mSearchInfo.data, 
            $scope.pagesData = mSearchInfo.pagesData, $scope.scrollTo = mSearchInfo.lastLot ? mSearchInfo.lastLot.id : null, 
            $scope.loadState = "loaded", initToken($scope.data.token, !1)) : (mSearchInfo.data = $scope.data, 
            mSearchInfo.pagesData = $scope.pagesData, window.scroll(0, 0)), $scope.$watch("data.searchTime", $scope.doSearch), 
            newSearchInfo.token = null;
        }
        mSearchInfo = null, $scope.data = {
            searchTime: "FUTURE"
        }, $scope.pagesData = {
            itemsPerPage: 20,
            currentPage: 1
        }, $scope.doSearch = function() {
            $scope.data.token && ($scope.pagesData.currentPage = 1, $scope.pagesData.itemsCount = 0, 
            $scope.searching = !0, LogService.logEvent({
                search: $scope.data.token,
                time: $scope.data.searchTime
            }), trackSearch($scope.data.token), getSearchResultsForCurrentPage().then(function(response) {
                setItems(response.results), $scope.searching = !1, $scope.pagesData.itemsCount = response.count, 
                $scope.data.searchedToken = $scope.data.token;
            }), document.activeElement.blur());
        }, $scope.onPageChange = function() {
            $scope.scrollToPagination = !1, getSearchResultsForCurrentPage().then(function(response) {
                setItems(response.results), $timeout(function() {
                    $scope.scrollToPagination = !0;
                }, 100);
            });
        }, $scope.gotoLot = function(lot) {
            mSearchInfo.lastLot = lot;
            var auction = lot.auction;
            (auction.timedAuction || auction.showLeadingBids) && "ENDED" != auction.state ? AccountService.validateRegisteredInHouseAndThen(auction.house, {
                message: "auth_timed_auction"
            }, function() {
                AppSiteWinodwsService.openAuctionSiteWindow(auction, !1, lot);
            }) : $state.go("app.lotPage", {
                source: "search",
                auctionId: lot.auctionId,
                lotId: lot.id
            });
        }, init();
    } ]);
}), define("portal/js/modules/auctions/catalogs/search/index", [ "./searchModule", "./searchService", "./searchController" ], function() {}), 
define("portal/js/modules/auctions/catalogs/lotPage/lotPageModule", [ "angular" ], function(ng) {
    return ng.module("app.auctions.catalogs.lotPage", []);
}), define("portal/js/modules/auctions/catalogs/lotPage/lotPageController", [ "./lotPageModule" ], function(module) {
    module.controller("LotPageController", [ "$scope", "$state", "$stateParams", "$uibModal", "$rootScope", "$timeout", "$window", "AnalyticsService", "StringsService", "PathsService", "I18nService", "PortalAuthService", "PortalInfoService", "DomUtilsService", "CatalogUtilsService", "StructuredDataService", "PopupsService", "AccountService", "CatalogsService", "CatalogAccountService", "MyAccountService", function($scope, $state, $stateParams, $uibModal, $rootScope, $timeout, $window, AnalyticsService, StringsService, PathsService, I18nService, PortalAuthService, PortalInfoService, DomUtilsService, CatalogUtilsService, StructuredDataService, PopupsService, AccountService, CatalogsService, CatalogAccountService, MyAccountService) {
        function initTexts() {
            var item = $scope.data.item;
            if (item) {
                var artist = I18nService.getLangField(item.artist), name = I18nService.getLangField(item.name), description = I18nService.getLangField(item.description), details = I18nService.getLangField(item.details), title = "", lotDesc = description + "<br>" + details;
                artist ? (title = StringsService.stripTags(artist), name && (title += "<br>", name.length > 60 ? (title += StringsService.trimToWord(name, 60), 
                $scope.showMore = !0, lotDesc = name + "<br>" + lotDesc) : title += name)) : name ? name.length > 120 ? (title = StringsService.trimToWord(name, 120), 
                $scope.showMore = !0, lotDesc = name + "<br>" + lotDesc) : title = name : description && (title = StringsService.trimToWord(description, 120), 
                description.length > 100 && ($scope.showMore = !0)), item.lotTitle = title, $scope.data.lotTitle = title, 
                $scope.data.lotDesc = lotDesc, StringsService.isBlank(StringsService.stripTags($scope.data.lotDesc)) && ($scope.data.lotDesc = "");
            }
        }
        function initFavoriteMessageWatch() {
            $scope.$watch("data.item.isFavorite", function(isFavorite, oldValue) {
                "undefined" != typeof oldValue && isFavorite != oldValue && ($scope.favoriteToastMessage = isFavorite ? "lot_page_added_to_favorites" : "lot_page_removed_from_favorites", 
                $timeout(function() {
                    $scope.favoriteToastMessage = null;
                }, 15e3));
            });
        }
        function displayInquiryToast() {
            $scope.showInquiryToast = !0, $timeout(function() {
                $scope.showInquiryToast = !1;
            }, 15e3);
        }
        function setDocumentTitle() {
            var item = $scope.data.item, textForTitle = I18nService.getLangField(item.artist);
            textForTitle || (textForTitle = I18nService.getLangField(item.name)), textForTitle || (textForTitle = I18nService.getLangField(item.description)), 
            textForTitle || (textForTitle = ""), textForTitle = StringsService.stripTags(textForTitle);
            var titleWords = textForTitle.split(/\s/), documentTitle = "bidspirit";
            $scope.data.auction.house && (documentTitle += " - " + I18nService.getLangField($scope.data.auction.house.details.name));
            for (var addedWords = 0, i = 0; i < titleWords.length && 5 > addedWords; i++) {
                var word = titleWords[i];
                word && (0 == addedWords && (documentTitle += " -"), documentTitle += " " + word, 
                addedWords++);
            }
            document.title = documentTitle;
        }
        function setDocumentDescriptionTags() {
            var item = $scope.data.item, description = (I18nService.getLangField(item.artist) || "") + " ";
            description += (I18nService.getLangField(item.name) || "") + " ", description += (I18nService.getLangField(item.description) || "") + " ", 
            description += (I18nService.getLangField(item.details) || "") + " ", description = StringsService.stripTags(description), 
            description = StringsService.trimToWord(description, 155), DomUtilsService.setMetaTag("name", "description", description), 
            DomUtilsService.setMetaTag("property", "og:description", description), DomUtilsService.setMetaTag("name", "twitter:description", description), 
            DomUtilsService.setMetaTag("property", "og:type", "og:product"), DomUtilsService.setMetaTag("name", "twitter:card", "product"), 
            DomUtilsService.setMetaTag("property", "og:image", CatalogsService.getLotImageUrl(item, 0, "400x400", "pad")), 
            DomUtilsService.setMetaTag("property", "og:image:width", "400"), DomUtilsService.setMetaTag("property", "og:image:height", "400"), 
            DomUtilsService.setMetaTag("name", "twitter:image", CatalogsService.getLotImageUrl(item, 0, "400x400", "pad")), 
            StructuredDataService.setPriceStructuredDataMetaTags($scope.data.item), DomUtilsService.setMetaTag("name", "twitter:data2", CatalogUtilsService.getAuctionTimeDisplay(item.auction, !1)), 
            DomUtilsService.setMetaTag("name", "twitter:label2", I18nService.getText("auction_date"));
        }
        function initDisplay() {
            $window.scrollTo(0, 0), initTexts(), CatalogAccountService.loadForAuction($scope.data.auction), 
            setDocumentTitle(), setDocumentDescriptionTags(), initFavoriteMessageWatch(), trackEvents();
        }
        function trackEvents() {
            var auction = $scope.data.auction, item = $scope.data.item, house = auction ? auction.house : null;
            if (item && auction && house && !$scope.eventTracked) {
                $scope.eventTracked = !0;
                var eventCategory = "ENDED" == auction.state ? "pastCatalogAction" : "catalogAction";
                AnalyticsService.trackEvent(eventCategory, "lotPageViewInHouse", "lot viewed in house " + house.code), 
                AnalyticsService.trackEvent(eventCategory, "lotPageViewInAuction", "lot viewed in house: " + house.code + ", auction: " + item.auctionDate), 
                AnalyticsService.trackEvent(eventCategory, "lotPageViewInAuctionForItem", "lot viewed in house: " + house.code + ", auction:" + item.auctionDate + ", item:" + item.itemIndex, {
                    appSiteTrackInfo: {
                        house: house,
                        api: "auctions/catalog/logLotPageView.api",
                        params: {
                            auctionId: auction.auctionIdInApp,
                            lotId: item.idInApp
                        }
                    }
                });
            }
        }
        function handleMissingAuction() {
            $state.go("account" == $stateParams.source && $rootScope.currentUser ? "app.myAccount" : "app.home");
        }
        function handleMissingItem() {
            "account" == $stateParams.source && $rootScope.currentUser ? $state.go("app.myAccount", {
                houseId: $scope.data.auction.houseId
            }) : $state.go("app.catalog", {
                auctionId: $stateParams.auctionId
            });
        }
        function getItem() {
            switch ($stateParams.source) {
              case "account":
                return MyAccountService.getAccountItem($scope.data.auction, $stateParams.lotId);

              case "search":
              case "favorites":
              case "catalog":
                return CatalogsService.getAuctionItem($scope.data.auction, $stateParams.lotId);
            }
        }
        function loadItem() {
            getItem().then(function(item) {
                item ? ($scope.data.item = item, initDisplay()) : handleMissingItem(item);
            }), $rootScope.$on("viewPort.windowSizeChanged", function() {
                PathsService.reloadAfterDelay(200);
            }), $rootScope.$on("catalog.inquirySent", displayInquiryToast);
        }
        function init() {
            PortalInfoService.loadAuction($stateParams.auctionId).then(function(auction) {
                auction ? ($scope.data.auction = PortalInfoService.getAuction($stateParams.auctionId), 
                loadItem()) : handleMissingAuction();
            });
        }
        $scope.data = {
            auction: null,
            item: null,
            focusedImage: 0
        }, $scope.scrollToDescriptionFlag = !1, $scope.showInquiryToast = !1, $scope.favoriteToastMessage = null, 
        $scope.openAuctionHouseTerms = function() {
            PopupsService.showHouseTerms($scope.data.auction.house);
        }, $scope.scrollToDescription = function() {
            $scope.scrollToDescriptionFlag = !0, $timeout(function() {
                $scope.scrollToDescriptionFlag = !1;
            });
        }, $scope.showIncrements = function() {
            var title = I18nService.getText("house_increments_title", {
                house: I18nService.getLangField($scope.data.auction.house.details.name)
            }), currency = $scope.data.item.auction.catalogInfo.currency;
            PortalInfoService.getHouseIncrementsSteps($scope.data.auction.houseId).then(function(steps) {
                PopupsService.showInfoPopup({
                    title: title,
                    contentInclude: "auctions/catalogs/lotPage/common/increments",
                    code: "increments",
                    backText: "dialogs_back",
                    data: {
                        steps: steps,
                        currency: currency
                    }
                });
            });
        }, $scope.showInquiryForm = function() {
            $scope.showInquiryToast = !1;
            var user = PortalAuthService.validateUserLoggedIn();
            user && ("UNCONFIRMED_EMAIL" == user.registrationStage ? PortalAuthService.showAuthModalOrScene("warning") : PopupsService.showPopup({
                contentInclude: "auctions/catalogs/lotPage/common/inquiry/inquiryForm",
                code: "inquiry",
                title: I18nService.getText("inquiry_form_title"),
                data: {
                    item: $scope.data.item,
                    user: user,
                    hideTopBackButton: !0,
                    house: I18nService.getLangField($scope.data.auction.house.details.name)
                }
            }));
        }, $scope.toggleFavorite = function() {
            var user = PortalAuthService.validateUserLoggedIn();
            if ($scope.favoriteToastMessage = null, user) {
                var isFavorite;
                isFavorite = $scope.data.item.isFavorite ? !1 : !0, AccountService.setFavoriteItem($scope.data.auction.house, $scope.data.item, isFavorite);
            }
        }, init();
    } ]);
}), define("portal/js/modules/auctions/catalogs/lotPage/lotPageNavigationDirective", [ "./lotPageModule" ], function(module) {
    module.directive("bsLotPageNavigation", function($stateParams, PathsService, CatalogsService, ArraysService) {
        return {
            restrict: "E",
            replace: !0,
            scope: {
                lot: "="
            },
            link: function(scope) {
                if (scope.source = $stateParams.source, "catalog" == scope.source) {
                    var items = CatalogsService.getNavState().pagesData.visibleItems, lotInd = ArraysService.getIndById(items, scope.lot.id);
                    lotInd > 0 && (scope.previousLotId = items[lotInd - 1].id), lotInd < items.length - 1 && (scope.nextLotId = items[lotInd + 1].id);
                }
            },
            templateUrl: PathsService.appTemplatePath("auctions/catalogs/lotPage/common/navigation/lotPageNavigation")
        };
    });
}), define("portal/js/modules/auctions/catalogs/lotPage/lotPageNavLinkDirective", [ "./lotPageModule" ], function(module) {
    module.directive("bsLotPageNavLink", function($rootScope, PathsService) {
        return {
            restrict: "E",
            replace: !0,
            scope: {
                name: "="
            },
            link: function(scope) {
                scope.direction = $rootScope.dir, scope.lang = $rootScope.currentLang, scope.showText = $rootScope.viewPort.pcMedia;
            },
            templateUrl: PathsService.appTemplatePath("auctions/catalogs/lotPage/common/navigation/lotPageNavLink")
        };
    });
}), define("portal/js/modules/auctions/catalogs/lotPage/lotPageZoomDirective", [ "./lotPageModule" ], function(module) {
    module.directive("bsLotPageZoom", function($stateParams, $rootScope, PathsService, ViewPortService) {
        return {
            restrict: "E",
            replace: !0,
            scope: {
                lot: "=",
                initialImageInd: "="
            },
            link: function(scope, element) {
                function init() {
                    window.scroll(0, 0), ViewPortService.updateViewportInfo(), scope.selectedImageInd = null != $stateParams.imageInd ? $stateParams.imageInd : scope.initialImageInd, 
                    scope.loadedImageInfo = {}, scope.enableImageModeSwitch = !1, $rootScope.viewPort.pcMedia ? scope.options = {
                        enableMagnifier: !0,
                        size: "2.5x",
                        imageMode: "pad"
                    } : (scope.options = {
                        moveInFrame: !0,
                        imageMode: "limit",
                        asBg: !0
                    }, $rootScope.$on("viewPort.windowSizeChanged", setThumbScrollPosition));
                }
                function waitForImageToLoad() {
                    scope.loadedImageInfo.loaded = !1, scope.cursorZoomClass = null;
                }
                function setThumbScrollPosition() {
                    var thumbsParent = angular.element(element[0].querySelector(".thumbs")), thumb = element[0].querySelectorAll(".thumb")[scope.selectedImageInd], nonImageHeight = 192;
                    if (thumb && (thumbsParent[0].scrollLeft = thumb.offsetLeft - thumb.offsetWidth - 100, 
                    nonImageHeight += 100), scope.options.moveInFrame) {
                        var css = {
                            height: $rootScope.viewPort.clientHeight - nonImageHeight + "px"
                        };
                        angular.element(element[0].querySelector(".big-image")).css(css), GlobalConfig.isMobileApp && (scope.debugInfo = {
                            imageHeight: css.height,
                            innerHeight: window.innerHeight,
                            clientHeight: $rootScope.viewPort.clientHeight
                        });
                    }
                }
                scope.setZoomImage = function(ind) {
                    var length = scope.lot.imagesList.length;
                    scope.selectedImageInd = (1 * ind + length) % length, waitForImageToLoad(), setThumbScrollPosition();
                }, scope.prevImage = function() {
                    scope.setZoomImage(scope.selectedImageInd - 1);
                }, scope.nextImage = function() {
                    scope.setZoomImage(scope.selectedImageInd + 1);
                }, scope.toggleImageMode = function() {
                    scope.enableImageModeSwitch && (scope.options.imageMode = "limit" == scope.options.imageMode ? "fit" : "limit", 
                    waitForImageToLoad());
                }, scope.$watch("loadedImageInfo.loaded", function() {
                    if (scope.loadedImageInfo.loaded) if ("limit" == scope.options.imageMode) {
                        {
                            scope.loadedImageInfo.size.width;
                        }
                        scope.enableImageModeSwitch = !1, scope.cursorZoomClass = null, setThumbScrollPosition();
                    } else scope.enableImageModeSwitch = !0;
                }), init();
            },
            templateUrl: PathsService.appTemplatePath("auctions/catalogs/lotPage/common/images/lotPageZoom")
        };
    });
}), define("portal/js/modules/auctions/catalogs/lotPage/lotPageImagesDirective", [ "./lotPageModule" ], function(module) {
    module.directive("bsLotPageImages", function($rootScope, $state, $uibModal, PathsService, ArraysService, CloudinaryService, ViewPortService) {
        return {
            restrict: "E",
            replace: !0,
            scope: {
                lot: "="
            },
            link: function(scope) {
                function zoomInScene(lot, imageInd) {
                    $state.go(".zoom", {
                        imageInd: imageInd
                    });
                }
                function zoomInModal(lot, imageInd) {
                    $uibModal.open({
                        templateUrl: PathsService.appTemplatePath("auctions/catalogs/lotPage/pc/lotZoomModal"),
                        windowClass: "modal huge",
                        controller: function($scope) {
                            $scope.data = {
                                item: lot,
                                imageInd: imageInd
                            };
                        }
                    });
                }
                scope.mainImagewidth = Math.min(ViewPortService.clientWidth() - 30, 600), scope.zoomImage = function(lot, imageInd) {
                    $rootScope.viewPort.pcMedia ? zoomInModal(lot, imageInd) : zoomInScene(lot, imageInd);
                };
            },
            templateUrl: PathsService.appTemplatePath("auctions/catalogs/lotPage/common/images/lotPageImages")
        };
    });
}), define("portal/js/modules/auctions/catalogs/lotPage/inquiryFormController", [ "./lotPageModule" ], function(module) {
    module.controller("InquiryFormController", [ "$scope", "$rootScope", "$timeout", "$window", "StringsService", "I18nService", "PortalInfoService", "PopupsService", function($scope, $rootScope, $timeout, $window, StringsService, I18nService, PortalInfoService) {
        $scope.init = function() {
            $scope.options.buttons = [ {
                text: "dialogs_send",
                action: $scope.submitInquiryForm
            }, {
                text: "dialogs_close",
                type: "warning",
                isCloseButton: !0
            } ];
            var item = $scope.options.data.item;
            $scope.inquiryData = {
                subject: I18nService.getText("inquiry_form_subject_content", {
                    lotIndex: item.itemIndex,
                    lotName: item.lotTitle
                })
            };
        }, $scope.submitInquiryForm = function() {
            $scope.inquiryForm.submit();
        }, $scope.sendInquiry = function() {
            var item = $scope.options.data.item;
            return PortalInfoService.sendLotInquiryRequest(item.id, item.lotTitle, $scope.inquiryData.content).then(function() {
                $timeout(function() {
                    $rootScope.$broadcast("catalog.inquirySent", item);
                }, 500), $scope.options.isModal ? $scope.$close() : $window.history.back();
            });
        };
    } ]);
}), define("portal/js/modules/auctions/catalogs/lotPage/index", [ "./lotPageModule", "./lotPageController", "./lotPageNavigationDirective", "./lotPageNavLinkDirective", "./lotPageZoomDirective", "./lotPageImagesDirective", "./inquiryFormController" ], function() {}), 
define("portal/js/modules/auctions/catalogs/index", [ "./catalogsModule", "./catalogsService", "./catalogAccountService", "./lotElements/index", "./auctionInfo/index", "./list/index", "./search/index", "./lotPage/index" ], function() {}), 
define("portal/js/modules/auctions/lists/auctionsListsModule", [ "angular" ], function(ng) {
    return ng.module("app.auctions.lists", []);
}), define("portal/js/modules/auctions/lists/auctionsListDirective", [ "./auctionsListsModule" ], function(module) {
    module.directive("bsAuctionsList", function($timeout, $rootScope, $state, PathsService, CloudinaryService, SessionsService, ArraysService, DateUtilsService, SettingsService, ViewPortService, AccountService, AppSiteWinodwsService, PortalInfoService) {
        return {
            restrict: "E",
            replace: !0,
            scope: {
                auctions: "=",
                view: "=",
                houseNameAsLink: "="
            },
            
            link: function (scope, element, attr) {            	
            	
            	function getAuctionToScrollTo(){
            		
            		if (!$rootScope.$previousState || !$rootScope.lastAuctionClick) return;
            		
            		if ($rootScope.lastAuctionClick.state != $state.current.name) return;
            		
            		if ($rootScope.lastAuctionClick.auctionId != $rootScope.$previousState.args.auctionId) return;
            		
            		return $rootScope.lastAuctionClick.auctionId;
            	}            	
            	
            	scope.scrollTo = getAuctionToScrollTo();
            	
            	if (!scope.scrollTo){
            		window.scrollTo(0,0);
            	}
            	
                scope.devMode = $rootScope.devMode;
                
                scope.viewPort = $rootScope.viewPort;
                
                scope.w = ViewPortService.getViewPortWidth();
                
            	
            	
                scope.isAuctionClickable = function(auction){
            		if (auction.state=="PENDING") return false;
            		if (auction.house.bidspiritSiteId && !auction.catalogInfo) return false;
            		return true;
            	};
            	
            	scope.isAuctionHouseLink = function(auction){
            		if (!scope.houseNameAsLink) return false;
            		if (!auction.house.orderInd) return false;            		
            		return true;
            	}
            	
            	
            	scope.onAuctionClick  = function(auction){
            		
            		setClickedRecently(auction);
            		if (!scope.isAuctionClickable(auction)) return;            		
            		var house = auction.house;
            		$rootScope.lastAuctionClick={
            			state:$state.current.name,
            			auctionId:auction.id
            		}
            		
            		if (house.bidspiritSiteId){
            			if (auction.state=="RUNNING"){
            				AppSiteWinodwsService.openAuctionSiteWindow(auction);
            			} else if ((auction.timedAuction || auction.showLeadingBids)){
            				handleTimedAutionClick(auction);            				
            			} else {
            				$state.go("app.catalog", {auctionId:auction.id,page:1});
            			}  
            		} else if (auction.externalUrl){
            			window.open(auction.externalUrl, "_system");
            		}
            	};
            	
            	function setClickedRecently(auction){
            		auction.clickedRecently = true;
            		$timeout(function(){
            			auction.clickedRecently = false;
            		},2000);
            	}
            	
            	function handleTimedAutionClick(auction){
            		if(auction.state=="ENDED" && auction.catalogInfo){
            			$state.go("app.catalog", {auctionId:auction.id});
            		} else {
            			AccountService.validateRegisteredInHouseAndThen(auction.house,{message:"auth_timed_auction"}, function(){
            				AppSiteWinodwsService.openAuctionSiteWindow(auction);
            			});
            		}
            	}
            	
            	function initTimeInfo(){
            		 scope.today = DateUtilsService.formatToServerDate(new Date());            		 
            	 	 angular.forEach(scope.auctions,function(auction){
            	 		 var minutes = PortalInfoService.getMinutesUntilAuction(auction);
            	 		 auction.minutesUntilStart = minutes;            	 		 
            	 		 if (!auction.house.bidspiritSiteId && auction.date<scope.today){ 
 	        	 			auction.hidden = true;        	 			
 	        	 		 }
            	 		 
            	 	 });
            	 }
            	
            	function getImageSize(){ 
            		return '400x400';
            	}
            	
            	function initDisplayInfo(){            		 
            		 if (!$rootScope.viewPort.isWideDevice){
                     	scope.screenView = "narrow";
                     }  else {
                     	scope.screenView = "wide";
                     }
            		 scope.imageSize = getImageSize();
	           	 	 
           	 	}
            	
            	scope.auctionButtonClass=function(auction){
            		var catalogOpenText = 'home_auction_catalog_open';
          	 		 var buttonClass = "orange";
          	 		 switch (auction.state){
	          	 		 case 'PENDING': return "disabled";	          	 		 
	          	 		 case 'READY':
	          	 			if (auction.timedAuction && auction.minutesUntilStart<30){          	 		 		
	          	 				return "darkBlue";
	          	 			} else if (auction.externalUrl || auction.catalogInfo){
	          	 				return "orange";
	          	 		 	} else {
	          	 		 		return "disabled";
	          	 		 	}
	          	 		 case 'RUNNING': return "live darkBlue";	          	 		 
	          	 		 case 'ENDED': return "yellow";
          	 		 }	           	 		
          	 		 return "orange";
            	}
            	
            	
            	scope.auctionButtonText=function(auction){            		 
          	 		 switch (auction.state){
	          	 		 case 'PENDING':return  'home_auction_catalog_not_ready';
	          	 		 
	          	 		 case 'READY':
	          	 			if (auction.timedAuction && auction.minutesUntilStart<30){
	          	 				return 'home_auction_to_the_auction';
	          	 			} else if (auction.externalUrl || auction.catalogInfo){
	          	 		 		return 'home_auction_catalog_open';
	          	 		 	} else {
	          	 		 		return 'home_auction_catalog_not_ready';
	          	 		 	}          	 		 
          	 			
	          	 		 case 'RUNNING': return 'home_auction_enter';
          	 		 
	          	 		 case 'ENDED': return catalogOpenText = 'home_auction_catalog_result';
          	 		 }	           	 		
          	 		 
          	 		 return 'home_auction_catalog_open';
            	}
            	
            	
            	
            	scope.isLinkbutton=function(auction){            		
            		 if (!auction.catalogInfo) return false;
         	 		 switch (auction.state){
         	 		 case 'PENDING': return false;         	 		 
         	 		 case 'READY':
         	 			if ((auction.externalUrl || auction.catalogInfo) && !(auction.timedAuction || auction.showLeadingBids)){
         	 				return true;
         	 		 	} else {
         	 		 		return false;
         	 		 	}
         	 		 
         	 		 case 'RUNNING': return false;
         	 		 	
         	 		 case 'ENDED':   return true;
         	 		 		
         	 		 }	          
            	}
            	
            	
            	scope.$watch("auctions", function(){
            		initTimeInfo();
                	initDisplayInfo();
            	});
            	
            	
            	
            },
            templateUrl: PathsService.appTemplatePath("auctions/lists/auctionsList")
        };
    });
}), define("portal/js/modules/auctions/lists/auctionsListsGroupDirective", [ "./auctionsListsModule" ], function(module) {
    module.directive("bsAuctionsListsGroup", function($timeout, $rootScope, $state, PathsService, PortalInfoService, SessionsService, ArraysService, DateUtilsService, SettingsService) {
        return {
            restrict: "E",
            replace: !0,
            scope: {
                auctionsData: "=",
                showRegionSelection: "=",
                showAllPastAuctions: "=",
                showAllFutureAuctions: "=",
                futureHouseNameAsLink: "=",
                minimizedView: "="
            },
            link: function(scope) {
                function updateDisplay() {
                    scope.regions = $rootScope.regions, scope.currentRegion = $rootScope.currentRegion, 
                    scope.currentLang = $rootScope.currentLang, scope.data = {
                        nextAuctions: [],
                        recentAuctions: [],
                        futureAuctions: []
                    };
                    var daysToFutureAuctions = SettingsService.get("daysToFutureAuctions") || 14, recentAuctionsToShow = SettingsService.get("recentAuctionsToShow") || 10, auctions = scope.auctionsData.auctions;
                    if (auctions) {
                        for (var addedFutureAuctionsForHouse = {}, i = 0; i < auctions.length; i++) {
                            var auction = auctions[i], hoursTillAuction = Math.round(PortalInfoService.getMinutesUntilAuction(auction) / 60), catalogReady = auction.catalogInfo && auction.catalogInfo.appAuctionId;
                            if (auctionsList = null, auction.hoursTillAuction = hoursTillAuction, "ENDED" == auction.state) catalogReady && (auctionsList = scope.data.recentAuctions); else if (catalogReady || 24 * daysToFutureAuctions > hoursTillAuction) hoursTillAuction > -24 && (auctionsList = scope.data.nextAuctions); else {
                                var addedAuctionNumberForHouse = addedFutureAuctionsForHouse[auction.houseId];
                                (scope.showAllFutureAuctions || !addedFutureAuctionsForHouse[auction.houseId] || auction.number == addedAuctionNumberForHouse) && (addedFutureAuctionsForHouse[auction.houseId] = auction.number || "foo", 
                                auctionsList = scope.data.futureAuctions);
                            }
                            auctionsList && auctionsList.push(auction);
                        }
                        ArraysService.inverse(scope.data.recentAuctions), scope.showAllPastAuctions || (scope.data.recentAuctions = scope.data.recentAuctions.slice(0, recentAuctionsToShow)), 
                        setListsVisibility();
                    }
                }
                function setListsVisibility() {
                    scope.nextAuctionsVisible = scope.data.nextAuctions.length > 0, scope.data.futureAuctions.length > 0 && (scope.minimizedView && !scope.futureAuctionsVisible ? scope.futureAuctionsButtonVisible = !0 : scope.futureAuctionsVisible = !0), 
                    scope.recentAuctionsVisible = scope.data.recentAuctions.length > 0 && !scope.minimizedView;
                }
                scope.showFutureAuctions = function() {
                    scope.futureAuctionsVisible = !0, scope.futureAuctionsButtonVisible = !1, scope.scrollToFutureAuctions = !1, 
                    $timeout(function() {
                        scope.scrollToFutureAuctions = !0;
                    }, 100);
                }, scope.regionLink = function(region) {
                    var url = "//";
                    if (-1 == window.location.href.indexOf("bidspirit")) return PathsService.newLocationWithParam("region", region.toLowerCase());
                    var url = "//";
                    "ALL" != region && (url += region.toLowerCase() + "."), url += "bidspirit.com/";
                    var separator = "?";
                    return "ALL" == region && (url += separator + "region=all", separator = "&"), $rootScope.devMode && (url += separator + "devMode=active", 
                    separator = "&"), url;
                }, scope.$watch("auctionsData.auctions", updateDisplay);
            },
            templateUrl: PathsService.appTemplatePath("auctions/lists/auctionsListsGroup")
        };
    });
}), define("portal/js/modules/auctions/lists/auctionsResultsController", [ "./auctionsListsModule" ], function(module) {
	   module.controller('AuctionsResultsController', [
	                                                   '$scope', '$rootScope', '$timeout', '$state', '$stateParams',
	                                                   	'ArraysService', 'I18nService',  
	                                                   		'SessionsService', 'PortalInfoService',   
	                                         function ( $scope,   $rootScope,  $timeout, 	  $state,  $stateParams,
	                                      		   		 ArraysService,   I18nService, 
	                                      		   		 	 SessionsService,   PortalInfoService) {
	                                                  	 
	                                          	 $scope.data={
	                                          		selectedHouseCode : "all"  		    		 
	                                        		 };      		   	 
	                                               
	                                                  	 
	                                               function setAuctions(){
	                                              	 $scope.pastAuctions = ArraysService.filterWithFunction(PortalInfoService.getAuctions(), function(auction){
	                                                  	 if (!auction.catalogInfo) return false;
	                                                  	 if (auction.state=="ENDED") return true;
	                                                  	 return false;
	                                                   });
	                                              	 ArraysService.inverse($scope.pastAuctions);                 
	                                                   $scope.displayedAuctions = $scope.data.currentHouse ? getHouseAuctions($scope.data.currentHouse) : $scope.pastAuctions ;
	                                                   setPagesData();
	                                                   $rootScope.debug("got auctions");
	                                               }
	                                               
	                                               function setPagesData(){            	 
	                                              	 $scope.pagesData={
	                                              		itemsCount:  $scope.displayedAuctions.length,
	                                              		currentPage: $stateParams.page,
	                                              		itemsPerPage:20        		
	                                              	 };
	                                              	 $scope.pageAuctions = [];
	                                              	 for (var i=0;i<$scope.pagesData.itemsPerPage;i++){
	                                              		 var auctionInd = $scope.pagesData.itemsPerPage * ($scope.pagesData.currentPage-1) + i;
	                                              		 var auction = $scope.displayedAuctions[auctionInd];
	                                              		 if (auction){
	                                              			 $scope.pageAuctions.push(auction);
	                                              		 }
	                                              	 }
	                                              	$rootScope.debug("page data set");
	                                               }
	                                               
	                                               
	                                               function shouldShowHouse(house){            	 
	                                              	 if ($rootScope.devMode) return true;
	                                              	 if (house.hidden) return false;
	                                              	 if (getHouseAuctions(house).length==0) return false;
	                                              	 return true;
	                                               }
	                                               
	                                               
	                                               function setHouses(){
	                                              	 var houses = PortalInfoService.getBidSpiritHouses().slice();
	                                              	 $scope.houses = [];
	                                              	 for (var i=0;i<houses.length;i++){
	                                              		 var house = houses[i];
	                                              		 if (shouldShowHouse(house)){
	                                              			 $scope.houses.push(house);
	                                              		 }
	                                              	 }                 
	                                               }
	                                               
	                                                            
	                                               function getHouseAuctions(house){
	                                              	 return ArraysService.filteredBy($scope.pastAuctions,"houseId",house.id);
	                                               }
	                                               
	                                               $scope.showHouseAuctions = function(houseCode){
	                                              	 $state.go('app.results', {house:houseCode,page:1});
	                                               }             
	                                                          
	                                               
	                                                
	                                               $scope.onMobileDropDownChange = function(newval){
	                                              	 $scope.showHouseAuctions($scope.data.selectedHouseCode);
	                                              	 
	                                               }
	                                               
	                                               function init(){
	                                            	   $rootScope.debug("results init");
	                                              	 $scope.displayeAuctionsLoader = true;      		     
	                                        		     $timeout(function(){
	                                        		    	 $rootScope.debug("loader done");
	                                        		    	 $scope.displayeAuctionsLoader = false;
	                                        		     },200);
	                                        		     $scope.data.currentHouse = PortalInfoService.getHouseByCode($stateParams.house);
	                                        		     $scope.data.selectedHouseCode = $scope.data.currentHouse ? $scope.data.currentHouse.code : "all"; 
	                                        		     
	                                              	 setAuctions();
	                                              	 setHouses();            	 
	                                               }
	                                               
	                                               
	                                               init();
	                                                       
	                                      }]);
}), define("portal/js/modules/auctions/lists/auctionBadgeDirective", [ "./auctionsListsModule" ], function(module) {
    module.directive("auctionBadge", function(PathsService, I18nService) {
        return {
            restrict: "E",
            replace: !0,
            scope: {
                auction: "=",
                isToday: "="
            },
            link: function(scope, element) {
                scope.isToday ? (scope.shouldShow = !0, scope.text = I18nService.getText("auction_today") + "!", 
                element.addClass("today")) : (scope.text = I18nService.getLangField(scope.auction.badge), 
                scope.text && scope.auction.textColors.badge && "ENDED" != scope.auction.state && (scope.shouldShow = !0, 
                element.css({
                    "background-color": scope.auction.textColors.badge
                })));
            },
            templateUrl: PathsService.appTemplatePath("auctions/lists/auctionBadge")
        };
    });
}), define("portal/js/modules/auctions/lists/auctionTimeFilter", [ "./auctionsListsModule" ], function(module) {
    return module.filter("auctionTime", [ "CatalogUtilsService", function(CatalogUtilsService) {
        return function(auction, dateOnly) {
            return CatalogUtilsService.getAuctionTimeDisplay(auction, dateOnly);
        };
    } ]);
}), define("portal/js/modules/auctions/lists/index", [ "./auctionsListsModule", "./auctionsListDirective", "./auctionsListsGroupDirective", "./auctionsResultsController", "./auctionBadgeDirective", "./auctionTimeFilter" ], function() {}), 
define("portal/js/modules/auctions/index", [ "./auctionsModule", "./home/index", "./catalogs/index", "./lists/index" ], function() {}), 
define("portal/js/modules/houses/housesModule", [ "angular" ], function(ng) {
    return ng.module("app.houses", []);
}), define("portal/js/modules/houses/housesListController", [ "./housesModule" ], function(module) {
    module.controller("HousesListController", [ "$scope", "ArraysService", "I18nService", "PortalInfoService", function($scope, ArraysService, I18nService, PortalInfoService) {
        $scope.houses = PortalInfoService.getHouses().slice(), ArraysService.sort($scope.houses, "orderInd", !1, "emptyLast"), 
        document.title = I18nService.getTextWithRegion("auction_houses_title");
    } ]);
}), define("portal/js/modules/houses/housePageController", [ "./housesModule" ], function(module) {
    module.controller("HousePageController", [ "$scope", "$rootScope", "$stateParams", "ViewPortService", "I18nService", "AnalyticsService", "PortalTextsService", "PopupsService", "PortalInfoService", "MyAccountService", function($scope, $rootScope, $stateParams, ViewPortService, I18nService, AnalyticsService, PortalTextsService, PopupsService, PortalInfoService, MyAccountService) {
        function loadAccountInfo() {
            $rootScope.currentUser && MyAccountService.loadForHouse($scope.house.id).then(null, function() {
                window.scroll(0, 0);
            });
        }
        function init() {
            $scope.house = PortalInfoService.getHouseByCode($stateParams.houseCode), $scope.house && ($scope.houseTextParams = PortalTextsService.getHouseTextParams($scope.house), 
            $scope.housePic = ViewPortService.clientWidth() > 1024 && $scope.house.resources ? $scope.house.resources.picForHousePage : "", 
            $scope.auctions = PortalInfoService.getHouseAuctions($scope.house.id), loadAccountInfo(), 
            AnalyticsService.trackDailyUniqueEvent("houseAction", "visitHousePage", "visit house page " + $scope.house.code), 
            document.title = I18nService.getLangField($scope.house.details.name), $rootScope.$on("auth.newSessionUser", loadAccountInfo), 
            $rootScope.$on("portalInfo.infoUpdated", function() {
                $scope.auctions = PortalInfoService.getHouseAuctions($scope.house.id);
            }));
        }
        $scope.openTerms = function() {
            PopupsService.showHouseTerms($scope.house);
        }, init();
    } ]);
}), define("portal/js/modules/houses/houseAlertsPromotionDirective", [ "./housesModule" ], function(module) {
    module.directive("bsHouseAlertsPromotion", function($rootScope, ArraysService, PathsService) {
        return {
            restrict: "E",
            replace: !0,
            scope: {
                house: "="
            },
            link: function(scope) {
                function checkShouldDisplay() {
                    if (!$rootScope.currentUser) return !1;
                    var alertsPreferences = $rootScope.currentUser.alertsPreferences;
                    if (!alertsPreferences) return !0;
                    if ("SOME_HOUSES_ALERTS" != alertsPreferences.housesAlertChoice) return !1;
                    var houseConfigedToBeAlerted = !ArraysService.contains(alertsPreferences.housesToAlert, scope.house.code);
                    return houseConfigedToBeAlerted;
                }
                function updateDisplay() {
                    scope.shouldDisplay = checkShouldDisplay();
                }
                updateDisplay(), $rootScope.$on("auth.newSessionUser", updateDisplay);
            },
            templateUrl: PathsService.appTemplatePath("houses/houseAlertsPromotion")
        };
    });
}), define("portal/js/modules/houses/index", [ "./housesModule", "./housesListController", "./housePageController", "./houseAlertsPromotionDirective" ], function() {}), 
define("portal/js/modules/account/accountModule", [ "angular" ], function(ng) {
    return ng.module("app.account", [ "app.account.myAccount", "app.account.favorites" ]);
}), define("portal/js/modules/account/accountService", [ "./accountModule" ], function(module) {
    module.factory("AccountService", function($q, $log, $rootScope, $uibModal, $uibModalStack, $state, AnalyticsService, ArraysService, ApiService, PathsService, DialogsService, CatalogUtilsService, I18nService, PopupsService, PortalAuthService, CatalogsService, PortalInfoService) {
        function requestApprovalFromHouse(house, userStateId) {
            return ApiService.callApi("/account/requestApprovalFromHouse", {
                houseId: house.id,
                userStateId: userStateId
            }).success(function(response) {
                PortalAuthService.setCurrentHouseApprovalState(house.id, response.approvalState), 
                AnalyticsService.trackEvent("houseAction", "requestApprovalFromHouse", "request approval from house " + house.code);
            });
        }
        function addBidsInfoToItems(auction, bids, bidFieldName) {
            if (bids) for (var i = 0; i < bids.length; i++) {
                var bid = bids[i], item = CatalogsService.getItemByIdInApp(auction, bid.lotIdInApp);
                setBidInfoForItem(item, bidFieldName, bid);
            }
        }
        function setBidInfoForItem(item, bidFieldName, bid) {
            item && (item[bidFieldName] = bid, item.lastBidUpdate = new Date().getTime());
        }
        function addFavoriteFlagToItems(auction, itemIds) {
            if (itemIds) for (var i = 0; i < itemIds.length; i++) {
                var item = CatalogsService.getItemByIdInApp(auction, itemIds[i]);
                item && updateItemLocalFavoriteStatus(item, !0);
            }
        }
        function checkIfActionWaitingAfterHouseApprovalRequest() {
            var approvalState = PortalAuthService.getHouseApprovalState(mWaitingActionAfterHouseApprovalRequest.houseId);
            ("APPROVED" == approvalState || "PENDING" == approvalState || "INCOMPLETE_PROFILE" == approvalState) && new Date().getTime() - mWaitingActionAfterHouseApprovalRequest.time < 3e4 && mWaitingActionAfterHouseApprovalRequest.action();
        }
        function validateRegisteredInHouseAndThen(house, args, actionFn) {
            function handleApprovalState(approvalState) {
                switch (approvalState) {
                  case "APPROVED":
                  case "PENDING":
                    actionFn();
                    break;

                  case "NOT_REGISTERED":
                  case "INCOMPLETE_PROFILE":
                  case "REJECTED":
                    mWaitingActionAfterHouseApprovalRequest = {
                        houseId: house.id,
                        time: new Date().getTime(),
                        action: actionFn
                    }, showApprovalPopup(house);
                }
            }
            var user = $rootScope.currentUser;
            if (user) if ("COMPLETE" != user.registrationStage) PortalAuthService.showAuthModalOrScene("warning", null, args); else {
                var approvalState = PortalAuthService.getHouseApprovalState(house.id);
                "UNKNOWN" != approvalState ? handleApprovalState(approvalState) : ApiService.callApi("/account/getAccountInfoForHouse", {
                    houseId: house.id
                }).success(function(info) {
                    approvalState = info.accountInfo.approvalState, PortalAuthService.setCurrentHouseApprovalState(house.id, approvalState), 
                    handleApprovalState(approvalState);
                }).error(function() {
                    PopupsService.showHouseConnectivityErrorPopup(house);
                });
            } else PortalAuthService.showAuthModalOrScene("login", null, args);
        }
        function showApprovalPopup(house, args) {
            $rootScope.viewPort.mobileMedia ? showApprovalScene(house, args) : showApprovalModalPopup(house, args);
        }
        function showApprovalScene(house) {
            $state.go("app.houseApproval", {
                houseId: house.id
            });
        }
        function showApprovalModalPopup(house) {
            closeApprovalPopup(), $uibModal.open({
                templateUrl: PathsService.appTemplatePath("account/approval/houseApprovalPopup"),
                windowClass: "modal auth-modal-popup",
                controller: function($scope) {
                    $scope.houseId = house.id;
                }
            });
        }
        function closeApprovalPopup() {
            $uibModalStack.dismissAll();
        }
        function handleFailure(response) {
            response.errorMessage && $log.warn(response.errorMessage);
        }
        function placeAbsenteeBid(houseId, lot, price) {
            return ApiService.callApi("/account/placeAbsenteeBid", {
                houseId: houseId,
                lotId: lot.id,
                price: price
            }).success(function(response) {
                response.success ? setBidInfoForItem(lot, "selfAbsenteeBid", response.bid) : handleFailure(response);
            });
        }
        function removeAbsenteeBid(houseId, lot) {
            return ApiService.callApi("/account/removeAbsenteeBid", {
                houseId: houseId,
                lotId: lot.id
            }).success(function(response) {
                response.success ? setBidInfoForItem(lot, "selfAbsenteeBid", null) : handleFailure(response);
            });
        }
        function setFavoriteItem(house, lot, isOn) {
            return isOn && AnalyticsService.trackEvent("catalogAction", "favoriteInHouse", "favorite in house " + house.code), 
            ApiService.callApi("/account/setFavoriteItem", {
                houseId: house.id,
                lotId: lot.id,
                isOn: isOn
            }).success(function() {
                updateItemLocalFavoriteStatus(lot, isOn);
            });
        }
        function updateItemLocalFavoriteStatus(lot, isOn) {
            lot.isFavorite = isOn, mFavoritesSceneInfo.items && (isOn ? ("unloaded" != mFavoritesSceneInfo.pastItemState || "ENDED" != lot.auction.state) && ArraysService.addOrReplaceById(mFavoritesSceneInfo.items, lot) : ArraysService.removeById(mFavoritesSceneInfo.items, lot.id));
        }
        function getFavoriteItems(time) {
            var deferred = $q.defer();
            return ApiService.callApi("/account/getFavoriteItems", {
                region: $rootScope.currentRegion,
                time: time
            }).success(function(lotItems) {
                for (var itemsWithAuctions = [], i = 0; i < lotItems.length; i++) {
                    var item = lotItems[i], auction = PortalInfoService.getAuction(item.auctionId);
                    auction && (item.auction = auction, item.isFavorite = !0, itemsWithAuctions.push(item));
                }
                deferred.resolve(itemsWithAuctions);
            }), deferred.promise;
        }
        var mFavoritesSceneInfo = {}, mWaitingActionAfterHouseApprovalRequest = {};
        return $rootScope.$on("auth.houseApprovalChanged", checkIfActionWaitingAfterHouseApprovalRequest), 
        {
            addBidsInfoToItems: addBidsInfoToItems,
            setBidInfoForItem: setBidInfoForItem,
            requestApprovalFromHouse: requestApprovalFromHouse,
            closeApprovalPopup: closeApprovalPopup,
            showApprovalPopup: showApprovalPopup,
            validateRegisteredInHouseAndThen: validateRegisteredInHouseAndThen,
            placeAbsenteeBid: placeAbsenteeBid,
            removeAbsenteeBid: removeAbsenteeBid,
            setFavoriteItem: setFavoriteItem,
            getFavoriteItems: getFavoriteItems,
            addFavoriteFlagToItems: addFavoriteFlagToItems,
            favoritesSceneInfo: mFavoritesSceneInfo
        };
    });
}), define("portal/js/modules/account/houseApprovalDirective", [ "./accountModule" ], function(module) {
    module.directive("bsHouseApproval", function($stateParams, $rootScope, PathsService, I18nService, PortalInfoService, PortalTextsService, AccountService, PortalAuthService) {
        return {
            restrict: "E",
            replace: !0,
            scope: {
                houseId: "=",
                inPopup: "="
            },
            link: function(scope) {
                function getText(textKey) {
                    var textParams = PortalTextsService.getHouseTextParams(scope.house);
                    return I18nService.getText(textKey, textParams);
                }
                function init() {
                    var firstParagraphKey, secondParagraphKey;
                    switch (scope.approvalState) {
                      case "NOT_REGISTERED":
                        firstParagraphKey = "approval_not_approved";
                        break;

                      case "INCOMPLETE_PROFILE":
                      case "PENDING":
                        firstParagraphKey = "approval_not_approved", secondParagraphKey = "approval_pending";
                        break;

                      case "REJECTED":
                        firstParagraphKey = "approval_rejected";
                    }
                    scope.firstParagraph = getText(firstParagraphKey), secondParagraphKey && (scope.secondParagraph = getText(secondParagraphKey));
                }
                function validateApprovalRequest() {
                    if (scope.formData.error = null, scope.house.requestUserStateIdForApproval) {
                        var field = "approval_request_user_id_label", stateId = scope.formData.userStateId;
                        stateId ? (stateId + "").match(/^\d{8,15}$/) || (scope.formData.error = I18nService.getText("error_bad_pattern", {
                            field: field
                        })) : scope.formData.error = I18nService.getText("error_mandatory", {
                            field: field
                        });
                    }
                    return null == scope.formData.error;
                }
                scope.formData = {}, scope.currentLang = $rootScope.currentLang;
                var houseId = scope.houseId;
                houseId || (houseId = $stateParams.houseId), scope.house = PortalInfoService.getHouse(houseId), 
                scope.requestApproval = function() {
                    return "COMPLETE" != $rootScope.currentUser.registrationStage ? PortalAuthService.showAuthModalPopup("warning") : validateApprovalRequest() ? AccountService.requestApprovalFromHouse(scope.house, scope.formData.userStateId).success(function(response) {
                        scope.approvalState = response.approvalState, scope.firstParagraph = getText("approval_request_sent"), 
                        scope.secondParagraph = "";
                    }).error(function() {
                        $rootScope.showGeneralError();
                    }) : void 0;
                }, scope.closePopup = function() {
                    AccountService.closeApprovalPopup();
                }, scope.approvalState = PortalAuthService.getHouseApprovalState(scope.house.id), 
                init();
            },
            templateUrl: PathsService.appTemplatePath("account/approval/houseApproval")
        };
    });
}), define("portal/js/modules/account/bidRulesService", [ "./accountModule" ], function(module) {
    module.factory("BidRulesService", function($q, $rootScope, $uibModal, ArraysService, StringsService, I18nService, PopupsService) {
        function validBid(lot, price) {
            var errorKey = null, currency = lot.auction.catalogInfo.currency, minPrice = lot.startPrice, textParams = {
                price: price
            };
            if (StringsService.isBlank(price)) errorKey = "empty"; else {
                var parsedPrice = I18nService.parseCurrency(price, currency);
                if (parsedPrice) if (parsedPrice == minPrice) errorKey = null; else if (minPrice > parsedPrice) errorKey = "low"; else {
                    var increments = getNearIncrementPrices(lot, parsedPrice);
                    if (increments.prev == parsedPrice) return !0;
                    if (0 == increments.prev) minPrice = increments.next, errorKey = "low"; else if (parsedPrice < increments.prev) errorKey = "low", 
                    minPrice = increments.prev; else {
                        errorKey = "increment";
                        var minIncreement = Math.max(increments.prev, minPrice);
                        textParams.prev = I18nService.sumInCurrency(minIncreement, currency), textParams.next = I18nService.sumInCurrency(increments.next, currency);
                    }
                } else errorKey = "illegal";
            }
            if (errorKey) {
                textParams.minPrice = I18nService.sumInCurrency(minPrice, currency);
                var message = I18nService.getText("bid_error_" + errorKey, textParams);
                return PopupsService.showErrorPopup(message), !1;
            }
            return !0;
        }
        function getNearIncrementPrices(lot, price) {
            for (var increments = lot.auction.house.increments, step = getStepForPrice(increments, price), stepPrice = 1 * increments[step], prevIncrementPrice = 1 * step, nextIncrementPrice = prevIncrementPrice + stepPrice; price >= nextIncrementPrice; ) prevIncrementPrice = nextIncrementPrice, 
            nextIncrementPrice += stepPrice;
            return {
                prev: prevIncrementPrice,
                next: nextIncrementPrice
            };
        }
        function getStepForPrice(increments, price) {
            var prevStep = null;
            for (var step in increments) {
                if (step >= price) return prevStep ? prevStep : step;
                prevStep = step;
            }
            return prevStep;
        }
        return {
            validBid: validBid
        };
    });
}), define("portal/js/modules/account/favorites/favoritesModule", [ "angular" ], function(ng) {
    return ng.module("app.account.favorites", []);
}), define("portal/js/modules/account/favorites/favoritesController", [ "./favoritesModule" ], function(module) {
    module.controller("FavoritesController", [ "$rootScope", "$scope", "$filter", "$state", "$timeout", "ArraysService", "I18nService", "StringsService", "PortalInfoService", "AccountService", "CatalogUtilsService", "AppSiteWinodwsService", "CatalogsService", function($rootScope, $scope, $filter, $state, $timeout, ArraysService, I18nService, StringsService, PortalInfoService, AccountService, CatalogUtilsService, AppSiteWinodwsService, CatalogsService) {
        function setPageItems() {
            $scope.pagesData.pageItems = CatalogUtilsService.getPageItems($scope.data.sceneInfo.items, $scope.pagesData.currentPage, $scope.pagesData.itemsPerPage);
        }
        function scrollToLastClickedLot() {
            var lotToScrollTo = $scope.data.sceneInfo.lastClickedLot;
            lotToScrollTo && (lotToScrollTo.isFavorite || (lotToScrollTo = $scope.data.sceneInfo.items[$scope.data.sceneInfo.lastClickedLotInd - 1]), 
            lotToScrollTo && ($scope.pagesData.currentPage = CatalogUtilsService.getLotPage($scope.data.sceneInfo.items, lotToScrollTo.id, $scope.pagesData.itemsPerPage), 
            $scope.scrollTo = lotToScrollTo.id), $scope.data.sceneInfo.lastClickedLot = null);
        }
        function setHousesBadges(items) {
            angular.forEach(items, function(item) {
                item.loadPastLinkFakeItem || (item.houseBadge = {
                    text: StringsService.trimToWord(I18nService.getLangField(item.auction.house.details.name), 20) + " <span dir='ltr'>(" + CatalogUtilsService.getAuctionTimeDisplay(item.auction, !0, !0) + ")</span>",
                    color: item.auction.house.details.brandColor
                });
            });
        }
        function sortItems() {
            function breakCompare(item1, item2) {
                return item1.loadPastLinkFakeItem ? "ENDED" == item2.auction.state ? -1 : 1 : item2.loadPastLinkFakeItem ? "ENDED" == item1.auction.state ? 1 : -1 : 0;
            }
            function stateCompare(state1, state2) {
                return state1 == state2 ? 0 : "ENDED" != state1 && "ENDED" != state2 ? 0 : "ENDED" == state1 ? 1 : "ENDED" == state2 ? -1 : 0;
            }
            function itemsCompare(item1, item2) {
                var options = {};
                "ENDED" == item1.auction.state && (options.reverseAuctionDate = !0);
                var itemsCompareValue = CatalogUtilsService.compareLots(item1, item2, options);
                return itemsCompareValue;
            }
            $scope.data.sceneInfo.items.sort(function(item1, item2) {
                return breakCompare(item1, item2) || stateCompare(item1.auction.state, item2.auction.state) || itemsCompare(item1, item2);
            });
        }
        function initItems(items) {
            items.push({
                loadPastLinkFakeItem: !0,
                id: "pastItemsLink"
            }), $scope.data.sceneInfo.pastItemState = "unloaded", $scope.data.sceneInfo.items = items, 
            displayItems();
        }
        function displayItems() {
            sortItems(), setHousesBadges($scope.data.sceneInfo.items), $scope.pagesData.itemsCount = $scope.data.sceneInfo.items.length, 
            new Date().getTime() - $scope.data.sceneInfo.lastClickedLotTime < 6e4 && scrollToLastClickedLot(), 
            setPageItems(), $scope.loadState = "loaded";
        }
        function init() {
            $scope.currentUser ? ($scope.loadState = "loading", $scope.data.sceneInfo = AccountService.favoritesSceneInfo, 
            $scope.scrollToPagination = !1, $scope.mobileElementsDimensions = CatalogsService.getMobileElementsDimensions(), 
            $scope.pagesData = {
                itemsPerPage: 20,
                currentPage: 1
            }, $scope.data.sceneInfo.items ? displayItems() : AccountService.getFavoriteItems("FUTURE").then(initItems)) : $state.go("app.home");
        }
        $scope.data = {}, $scope.onPageChange = function() {
            $scope.scrollToPagination = !0, $scope.loadState = "loading", setPageItems(), $timeout(function() {
                $scope.loadState = "loaded", $scope.scrollToPagination = !1;
            }, 300);
        }, $scope.gotoLot = function(lot) {
            if (!lot.onFavoriteFlag) {
                $scope.data.sceneInfo.lastClickedLot = lot, $scope.data.sceneInfo.lastClickedLotInd = ArraysService.getIndById($scope.data.sceneInfo.items, lot.id), 
                $scope.data.sceneInfo.lastClickedLotTime = new Date().getTime();
                var auction = lot.auction;
                (auction.timedAuction || auction.showLeadingBids) && "ENDED" != auction.state ? AccountService.validateRegisteredInHouseAndThen(auction.house, {
                    message: "auth_timed_auction"
                }, function() {
                    AppSiteWinodwsService.openAuctionSiteWindow(auction, !1, lot);
                }) : $state.go("app.lotPage", {
                    source: "favorites",
                    auctionId: lot.auctionId,
                    lotId: lot.id
                });
            }
        }, $scope.loadPastItems = function() {
            "unloaded" == $scope.data.sceneInfo.pastItemState && ($scope.data.sceneInfo.pastItemState = "loading", 
            AccountService.getFavoriteItems("PAST").then(function(pastItems) {
                $timeout(function() {
                    if (pastItems.length > 0) {
                        for (var i = 0; i < pastItems.length; i++) $scope.data.sceneInfo.items.push(pastItems[i]);
                        $scope.pagesData.currentPage = CatalogUtilsService.getLotPage($scope.data.sceneInfo.items, pastItems[0].id, $scope.pagesData.itemsPerPage), 
                        displayItems(), $timeout(function() {
                            $scope.scrollTo = "pastItemsLink";
                        }, 10);
                    }
                    $scope.data.sceneInfo.pastItemState = "loaded";
                }, 300);
            }));
        }, init();
    } ]);
}), define("portal/js/modules/account/favorites/index", [ "./favoritesModule", "./favoritesController" ], function() {}), 
define("portal/js/modules/account/myAccount/myAccountModule", [ "angular" ], function(ng) {
    return ng.module("app.account.myAccount", []);
}), define("portal/js/modules/account/myAccount/myAccountContoller", [ "./myAccountModule" ], function(module) {
    module.controller("MyAccountController", [ "$rootScope", "$scope", "$state", "$stateParams", "$uibModal", "ArraysService", "I18nService", "PortalTextsService", "PortalInfoService", "PortalAuthService", "AccountService", "MyAccountService", function($rootScope, $scope, $state, $stateParams, $uibModal, ArraysService, I18nService, PortalTextsService, PortalInfoService, PortalAuthService, AccountService, MyAccountService) {
        function setItemsType() {
            $scope.itemsType = $stateParams.itemsType, $scope.titleKey = "link_" + $scope.itemsType, 
            $scope.messageKey = "my_account_message_" + $scope.itemsType, $scope.viewKey = "my_account_view_" + $scope.itemsType;
        }
        function setHouseEntries(houseId, houseAccountInfo) {
            var currentAuctions = [], soldAuctions = [], empty = !0;
            for (var auctionId in houseAccountInfo.auctionsInfo) {
                var auctionInfo = houseAccountInfo.auctionsInfo[auctionId];
                if (auctionInfo.lotsWithAbsenteeBids && "absentee" == $scope.itemsType) {
                    var filteredList = ArraysService.filteredByNonEmpty(auctionInfo.lotsWithAbsenteeBids, "selfAbsenteeBid");
                    0 != filteredList.length && (filteredList = ArraysService.filteredByEmpty(filteredList, "selfSoldLotBid"), 
                    auctionInfo.lotsWithAbsenteeBids = filteredList, currentAuctions.push(auctionInfo), 
                    empty = !1);
                }
                auctionInfo.wonLots && "won" == $scope.itemsType && (soldAuctions.push(auctionInfo), 
                empty = !1);
            }
            ArraysService.inverse(soldAuctions), houseEntry = {
                auctions: {
                    current: currentAuctions,
                    sold: soldAuctions
                },
                approvalState: houseAccountInfo.approvalState,
                house: PortalInfoService.getHouse(houseId),
                empty: empty
            }, $scope.data.housesEntries[houseId] = houseEntry;
        }
        function handleError(houseId) {
            $scope.error = PortalTextsService.getHouseConnectivityError(PortalInfoService.getHouse(houseId));
        }
        function initHouseList() {
            $scope.houses = PortalInfoService.getBidSpiritHouses().slice();
            $scope.currentUser.approvedHousesCodes || [];
        }
        function loadNewOpenedHouse() {
            var allClosed = !0;
            $scope.error = null;
            for (houseId in $scope.data.opened) $scope.data.opened[houseId] && !$scope.data.loading[houseId] && ($scope.data.loading[houseId] = !0, 
            allClosed = !1, $scope.loadAccountEntryForHouse(houseId));
            allClosed && $state.go("app.myAccount", {
                houseId: null
            });
        }
        function init() {
            $scope.currentUser ? (setItemsType(), initHouseList(), $stateParams.houseId ? $scope.loadAccountEntryForHouse($stateParams.houseId) : "app.lotPage" == $rootScope.$previousState.name ? $scope.loadAccountEntryForHouse(MyAccountService.getCurrentHouse()) : MyAccountService.clearCache(), 
            $scope.$watchCollection("data.opened", function() {
                loadNewOpenedHouse();
            })) : $state.go("app.home");
        }
        $scope.data = {
            housesEntries: {},
            opened: {},
            loading: {},
            openedHouseId: null
        }, $scope.loadAccountEntryForHouse = function(houseId) {
            houseId && ($scope.data.opened[houseId] = !0, $scope.data.openedHouseId = houseId, 
            $scope.error = null, $scope.data.housesEntries[houseId] || MyAccountService.loadForHouse(houseId).then(function(houseAccountInfo) {
                setHouseEntries(houseId, houseAccountInfo);
            }, function() {
                handleError(houseId);
            }));
        }, init();
    } ]);
}), define("portal/js/modules/account/myAccount/myAccountHouseEntryDirective", [ "./myAccountModule" ], function(module) {
    module.directive("bsMyAccountHouseEntry", function($rootScope, $timeout, PathsService) {
        return {
            restrict: "E",
            replace: !0,
            scope: {
                houseInfo: "=",
                itemsType: "="
            },
            link: function(scope) {
                scope.currentUser = $rootScope.currentUser;
            },
            templateUrl: PathsService.appTemplatePath("account/myAccount/myAccountHouseEntry")
        };
    });
}), define("portal/js/modules/account/myAccount/myAccountAuctionsSectionDirective", [ "./myAccountModule" ], function(module) {
    module.directive("bsMyAccountAuctionsSection", function($rootScope, $timeout, PathsService) {
        return {
            restrict: "E",
            replace: !0,
            scope: {
                auctionsInfo: "=",
                lotsField: "=",
                itemsType: "=",
                label: "="
            },
            link: function() {},
            templateUrl: PathsService.appTemplatePath("account/myAccount/myAccountAuctionsSection")
        };
    });
}), define("portal/js/modules/account/myAccount/myAccountAuctionBidsDirective", [ "./myAccountModule" ], function(module) {
    module.directive("bsMyAccountAuctionBids", function($rootScope, $filter, $uibModal, $state, PathsService, I18nService, CatalogUtilsService, AppSiteWinodwsService, AccountService) {
        return {
            restrict: "E",
            replace: !0,
            scope: {
                auction: "=",
                lots: "=",
                countLabel: "="
            },
            link: function(scope) {
                function updateDisplay() {
                    if (auction.number) scope.auctionName = I18nService.getText("auction_label_number", {
                        number: number
                    }); else {
                        var dateStr = $filter("auctionTime")({
                            date: auction.date,
                            unknownExactDate: !0
                        });
                        scope.auctionName = I18nService.getText("auction_label_date", {
                            date: dateStr
                        });
                    }
                    auction.part && (scope.auctionName += ", " + I18nService.getText("auction_part_" + auction.part)), 
                    scope.auctionName += ": " + I18nService.getText("my_account_" + scope.countLabel, {
                        count: scope.lots.length
                    });
                }
                var auction = scope.auction, number = auction.number;
                scope.currency = auction.catalogInfo.currency, scope.scrollTo = $rootScope.$previousState.args.lotId, 
                CatalogUtilsService.sortLots(scope.lots), scope.gotoLot = function(lot) {
                    var auction = lot.auction;
                    (auction.timedAuction || auction.showLeadingBids) && "ENDED" != auction.state ? AccountService.validateRegisteredInHouseAndThen(auction.house, {
                        message: "auth_timed_auction"
                    }, function() {
                        AppSiteWinodwsService.openAuctionSiteWindow(auction, !1, lot);
                    }) : $state.go("app.lotPage", {
                        source: "account",
                        auctionId: lot.auction.id,
                        lotId: lot.id
                    });
                }, updateDisplay();
            },
            templateUrl: PathsService.appTemplatePath("account/myAccount/myAccountAuctionBids")
        };
    });
}), define("portal/js/modules/account/myAccount/myAccountService", [ "./myAccountModule" ], function(module) {
    module.factory("MyAccountService", function($q, $rootScope, $uibModal, LogService, ArraysService, ApiService, PathsService, CatalogUtilsService, PortalInfoService, PortalAuthService) {
        function loadForHouse(houseId) {
            if ($rootScope.currentUser) {
                var deferred = $q.defer();
                return isCurrentCacheHouse(houseId) ? deferred.resolve(mCachedAccountInfoForHouse) : (clearCache(), 
                ApiService.callApi("/account/getAccountInfoForHouse", {
                    houseId: houseId
                }).success(function(info) {
                    PortalAuthService.setCurrentHouseApprovalState(houseId, info.accountInfo.approvalState);
                    var lotsMap = ArraysService.listToMap(info.lots, "idInApp"), auctionsInfo = {};
                    if (PortalInfoService.getHouse(houseId).increments = info.increments, "APPROVED" == info.accountInfo.approvalState) {
                        var auctionsById = ArraysService.listToMapById(PortalInfoService.getHouseAuctions(houseId));
                        addBidsToAuctionInfo(auctionsInfo, auctionsById, lotsMap, info.accountInfo.absenteeBids, "lotsWithAbsenteeBids"), 
                        addBidsToAuctionInfo(auctionsInfo, auctionsById, lotsMap, info.accountInfo.soldLotsBids, "wonLots");
                    }
                    mCachedAccountInfoForHouse = {
                        houseId: houseId,
                        auctionsInfo: auctionsInfo,
                        approvalState: info.accountInfo.approvalState,
                        lotsMap: ArraysService.listToMapById(info.lots)
                    }, $rootScope.$broadcast("account.dataLoaded"), deferred.resolve(mCachedAccountInfoForHouse);
                }).error(function(error) {
                    deferred.reject(error);
                })), deferred.promise;
            }
        }
        function addBidsToAuctionInfo(auctionsInfo, auctionsById, lotsMap, bids, fieldName) {
            for (var i = 0; i < bids.length; i++) {
                var bid = bids[i], lot = lotsMap[bid.lotIdInApp], auction = auctionsById[bid.auctionId];
                addBidToAuctionInfo(auctionsInfo, auction, lot, bid, fieldName);
            }
        }
        function getAccountItemFromCache(itemId) {
            return mCachedAccountInfoForHouse.lotsMap[itemId];
        }
        function getAccountItem(auction, itemId) {
            var deferred = $q.defer();
            return isCurrentCacheHouse(auction.houseId) ? deferred.resolve(getAccountItemFromCache(itemId)) : loadForHouse(auction.houseId).then(function() {
                deferred.resolve(getAccountItemFromCache(itemId));
            }), deferred.promise;
        }
        function addBidToAuctionInfo(auctionsInfo, auction, lot, bid, fieldName) {
            if (auction && lot) {
                var auctionInfo = auctionsInfo[auction.id];
                auctionInfo || (auctionInfo = {
                    auction: auction
                }, auctionsInfo[auction.id] = auctionInfo);
                var lots = auctionInfo[fieldName];
                switch (lots || (lots = [], auctionInfo[fieldName] = lots), lot.auction = auction, 
                fieldName) {
                  case "wonLots":
                    lot.soldLotBid = lot.selfSoldLotBid = bid;
                    break;

                  case "lotsWithAbsenteeBids":
                    lot.selfAbsenteeBid = bid;
                }
                lots.push(lot);
            } else LogService.logError("failed to get auction with id " + bid.auctionId + ", auction or lot not found.");
        }
        function isCurrentCacheHouse(houseId) {
            return mCachedAccountInfoForHouse && mCachedAccountInfoForHouse.houseId == houseId;
        }
        function clearCache() {
            mCachedAccountInfoForHouse = null;
        }
        function getCurrentHouse() {
            return mCachedAccountInfoForHouse ? mCachedAccountInfoForHouse.houseId : null;
        }
        var mCachedAccountInfoForHouse = null;
        return {
            loadForHouse: loadForHouse,
            getAccountItem: getAccountItem,
            getAccountItemFromCache: getAccountItemFromCache,
            clearCache: clearCache,
            getCurrentHouse: getCurrentHouse
        };
    });
}), define("portal/js/modules/account/myAccount/index", [ "./myAccountModule", "./myAccountContoller", "./myAccountHouseEntryDirective", "./myAccountAuctionsSectionDirective", "./myAccountAuctionBidsDirective", "./myAccountService" ], function() {}), 
define("portal/js/modules/account/index", [ "./accountModule", "./accountService", "./houseApprovalDirective", "./bidRulesService", "./favorites/index", "./myAccount/index" ], function() {}), 
define("portal/js/modules/nudges/nudgesModule", [ "angular" ], function(ng) {
    return ng.module("app.nudges", []);
}), define("portal/js/modules/nudges/nudgeNavbarPopupDirective", [ "./nudgesModule" ], function(module) {
    module.directive("bsNudgeNavbarPopup", function($rootScope, $timeout, PathsService, NudgesService) {
        return {
            restrict: "E",
            replace: !0,
            scope: {
                house: "="
            },
            link: function(scope) {
                function setNudgeType(nudgeType) {
                    $rootScope.nudgePopupVisible = !0, scope.isVisible = !0, scope.nudgeType = nudgeType, 
                    NudgesService.setNudgedRecently();
                }
                function updateDisplay() {
                    switch (scope.hide(), scope.featureToNudate = NudgesService.getNextFeatureToNudgeUser(), 
                    scope.featureToNudate) {
                      case "HOUSES_ALERTS":
                        setNudgeType("housesAlerts");
                    }
                }
                scope.hide = function() {
                    scope.isVisible = !1, $rootScope.nudgePopupVisible = !1;
                }, scope.onClick = function() {
                    scope.hide(), NudgesService.rememberNudgedFeature(scope.featureToNudate);
                }, $rootScope.$on("auth.menuVisible", function(e, menuVisible) {
                    menuVisible && scope.hide();
                }), updateDisplay(), $rootScope.$on("auth.newSessionUser", updateDisplay);
            },
            templateUrl: PathsService.appTemplatePath("nudges/navbar/nudgeNavbarPopup")
        };
    });
}), define("portal/js/modules/nudges/nudgesService", [ "./nudgesModule" ], function(module) {
    module.factory("NudgesService", function($rootScope, $timeout, $log, StringsService, PathsService, ApiService, SessionsService, LocalStorageService, PopupsService, PortalAuthService, SettingsService) {
        function rememberNudgedFeature(feature) {
            return ApiService.callApi("/users/rememberNudgedFeature", {
                feature: feature
            });
        }
        function shouldNudgeUserOnFeature(feature) {
            var user = $rootScope.currentUser;
            return user ? isUserNudgedOnFeature(user, feature) ? !1 : checkIfNudgeNeededForUser(user, feature) : !1;
        }
        function isUserNudgedOnFeature(user, feature) {
            var nudgedFeatures = user.nudgedFeatures;
            return nudgedFeatures ? null != nudgedFeatures[feature] ? !0 : void 0 : !1;
        }
        function checkIfNudgeNeededForUser(user, feature) {
            switch (feature) {
              case "HOUSES_ALERTS":
                return checkIfShouldNudgeOnHouseAlerts(user);
            }
            return !1;
        }
        function checkIfShouldNudgeOnHouseAlerts(user) {
            var alertsPreferences = user.alertsPreferences;
            return alertsPreferences && alertsPreferences.housesAlertChoice ? !1 : !0;
        }
        function getNextFeatureToNudgeUser() {
            if (!checkIfNeedsToNudgeUser()) return null;
            var feature = "HOUSES_ALERTS";
            return shouldNudgeUserOnFeature(feature) ? feature : void 0;
        }
        function checkIfNeedsToNudgeUser() {
            return $rootScope.currentUser ? "COMPLETE" != $rootScope.currentUser.registrationStage ? !1 : !nudgedRecently : !1;
        }
        function setNudgedRecently() {
            nudgedRecently = !0;
        }
        function daysSinceLastBrowserNudge(feature) {
            var timeSinceLastNudge = LocalStorageService.load("nudge_" + feature);
            return timeSinceLastNudge ? (new Date().getTime() - timeSinceLastNudge) / 864e5 : void 0;
        }
        function getNextFeatureToNudgeNonUser() {
            if (!checkIfNeedsToNudgeNonUser()) return null;
            var feature = "HOUSES_ALERTS", daysSinceLastNudge = daysSinceLastBrowserNudge(feature);
            return !daysSinceLastNudge || daysSinceLastNudge > SettingsService.get("daysToWaitCatalogsAlertRenudge", 30) ? feature : void 0;
        }
        function checkIfNeedsToNudgeNonUser() {
            return PortalAuthService.isAuthPopupOn() ? !1 : $rootScope.currentUser ? !1 : $rootScope.searchAgentRequest ? !1 : $rootScope.viewPort.mobileMedia ? !1 : LocalStorageService.isEnabled() ? LocalStorageService.load("lastLogin") ? !1 : !0 : !1;
        }
        function showNudgeForNonUser() {
            var feature = getNextFeatureToNudgeNonUser();
            if (feature) {
                {
                    StringsService.upUnderscoreTocamelCase(feature);
                }
                PopupsService.showPopup({
                    contentInclude: "nudges/modal/housesAlertsModal",
                    code: "nudge",
                    size: "sm",
                    showRegisterForm: function() {
                        PortalAuthService.showAuthModalOrScene("register");
                    }
                }), nudgedRecently = !0, LocalStorageService.store("nudge_" + feature, new Date().getTime());
            }
        }
        var nudgedRecently = !1;
        return $timeout(showNudgeForNonUser, 3e4), {
            getNextFeatureToNudgeUser: getNextFeatureToNudgeUser,
            rememberNudgedFeature: rememberNudgedFeature,
            setNudgedRecently: setNudgedRecently
        };
    });
}), define("portal/js/modules/nudges/index", [ "./nudgesModule", "./nudgeNavbarPopupDirective", "./nudgesService" ], function() {}), 
define("portal/js/modules/components/componentsModule", [ "angular" ], function(ng) {
    return ng.module("app.components", []);
}), define("portal/js/modules/components/houseCarouselDirective", [ "./componentsModule" ], function(module) {
    module.directive("bsHousesCarousel", function($window, $timeout, $interval, $rootScope, PathsService, PortalInfoService, ArraysService, CloudinaryService, OsInfoService, ViewPortService) {
        return {
            restrict: "E",
            replace: !0,
            scope: {},
            link: function(scope, element) {
                function getHouseImageUrl(house) {
                    var picResource = house.resources ? house.resources.hallPicture : "";
                    return CloudinaryService.getUrl(picResource, {
                        quality: 10,
                        size: ViewPortService.clientWidth() + "x600",
                        mode: "fill",
                        exactSize: !0
                    });
                }
                function initBgPics() {
                    scope.bgPics.length = 0, $interval.cancel(mTimer), scope.houses = [];
                    for (var houses = PortalInfoService.getHouses(), i = 0; i < houses.length; i++) {
                        var house = houses[i];
                        getHouseImageUrl(house) && scope.houses.push(house);
                    }
                    ArraysService.shuffle(scope.houses), angular.forEach(scope.houses, function(house) {
                        scope.bgPics.push(getHouseImageUrl(house));
                    }), scope.elementHeight = element[0].offsetHeight, mTimer = $interval(changePic, PIC_SWITCH_INTERVAL);
                }
                function changePic() {
                    scope.elementHeight = element[0].offsetHeight, 0 != scope.bgPics.length && scope.animationOn && (scope.currentPicInd = (scope.currentPicInd + 1) % scope.bgPics.length);
                }
                var mTimer = null, mAnimationDisabled = !1;
                if (PIC_SWITCH_INTERVAL = 15e3, scope.bgPics = [], scope.currentPicInd = 0, scope.elementHeight = element[0].offsetHeight, 
                OsInfoService.isMobile() && (mAnimationDisabled = !0), scope.animationOn = !mAnimationDisabled, 
                $timeout(function() {
                    $interval.cancel(mTimer);
                }, 3e5), element.on("$destroy", function() {
                    $interval.cancel(mTimer);
                }), !mAnimationDisabled) {
                    var windowElement = angular.element($window), handleScroll = function() {
                        var scrollTop = ViewPortService.getWindowScroll().top;
                        scope.elementHeight && scrollTop > scope.elementHeight ? element.addClass("hidden") : element.removeClass("hidden");
                    };
                    windowElement.on("scroll", scope.$apply.bind(scope, handleScroll)), $rootScope.$on("viewPort.orientationChange", initBgPics);
                }
                $rootScope.$on("auth.upperNavPopupDisplay", function(event, isOn) {
                    isOn && (scope.animationOn = !1);
                }), initBgPics();
            },
            templateUrl: PathsService.appTemplatePath("elements/carousel/housesCarousel")
        };
    });
}), define("portal/js/modules/components/contentLoaderDirective", [ "./componentsModule" ], function(module) {
    module.directive("bsContentLoader", function(PathsService) {
        return {
            restrict: "E",
            scope: {
                loaded: "="
            },
            link: function(scope, element) {
                scope.$watch("loaded", function(loaded) {
                    loaded && element.attr("done", !0);
                });
            },
            templateUrl: PathsService.appTemplatePath("elements/contentLoader")
        };
    });
}), define("portal/js/modules/components/pageFooterDirective", [ "./componentsModule" ], function(module) {
    module.directive("bsPageFooter", function($rootScope, $state, $uibModal, $timeout, I18nService, ArraysService, PopupsService, PathsService, OsInfoService, ViewPortService, PortalInfoService, PortalNavigationService) {
        return {
            restrict: "E",
            link: function(scope, element) {
                function setWidth() {
                    element.css({
                        width: ViewPortService.getMaxWidth() + "px"
                    });
                }
                function init() {
                    switch ($rootScope.currentRegion) {
                      case "IL":
                        scope.fbPage = "pages/Bidspirit-Israel/280735812128712", scope.twitterPage = "BidspiritIsrael";
                        break;

                      case "RU":
                        scope.fbPage = "bidspirit.russia", scope.twitterPage = "BidspiritRussia";
                        break;

                      default:
                        scope.fbPage = "bidspirit", scope.twitterPage = "bidspirit";
                    }
                }
                function refresh() {
                    scope.showFooter = !1, $timeout(function() {
                        scope.showFooter = !0;
                    }, 100);
                }
                scope.bidmoodEnv = $rootScope.bidmoodEnv, GlobalConfig.isMobileApp && OsInfoService.isAndroid() && setWidth(), 
                scope.shouldDisplay = function() {
                    return 0 == $state.current.name.indexOf("app.lotPage.") ? !1 : !0;
                }, scope.shouldHideContactUs = function() {
                    switch ($state.current.name) {
                      case "app.contact":
                      case "app.about":
                      case "app.prdouct":
                      case "app.popupScene":
                        return !0;
                    }
                    return !1;
                }, scope.showInfoPopup = function(code) {
                    PopupsService.showLegalDocPopup(code);
                }, scope.showAllFutureAuctions = function() {
                    PopupsService.showPopup({
                        contentInclude: "info/allFutureAuctions",
                        code: "allFutureAuctions",
                        title: I18nService.getText("all_future_auctions"),
                        data: {
                            auctions: PortalInfoService.getAllFutureAuctions(),
                            hideTopBackButton: !0
                        }
                    });
                }, scope.showFooter = !0, scope.linkTarget = PortalNavigationService.getNewWindowTarget(), 
                $rootScope.$on("i18n.languageChanged", refresh), init();
            },
            templateUrl: PathsService.appTemplatePath("elements/pageFooter")
        };
    });
}), define("portal/js/modules/components/popupsService", [ "./componentsModule" ], function(module) {
    var mPopupSceneOptions = {};
    module.factory("PopupsService", function($http, $rootScope, $state, $uibModal, $uibModalStack, PathsService, I18nService, DialogsService, PortalInfoService, PortalTextsService) {
        function showLegalDocPopup(code) {
            PortalInfoService.getLegalDoc(code).success(function(docContent) {
                showInfoPopup({
                    contentHtml: docContent.val,
                    code: code
                });
            });
        }
        function showPopupAsModal(options) {
            options.isModal = !0, $uibModal.open({
                templateUrl: PathsService.appTemplatePath("elements/popups/popupModal"),
                size: options.size || "lg",
                backdrop: options.unclosable ? "static" : !0,
                controller: function($scope) {
                    $scope.options = options;
                }
            });
        }
        function showInfoPopup(options) {
            options.buttons = [ {
                text: "dialogs_ok",
                isCloseButton: !0
            } ], showPopup(options);
        }
        function showPopup(options) {
            $rootScope.viewPort.mobileMedia ? (showPopupAsScene(options), window.scroll(0, 0)) : showPopupAsModal(options);
        }
        function showPopupAsScene(options) {
            mPopupSceneOptions[options.code] = options, options.isModel = !1, options.contentUrl ? $http.get(options.contentUrl).success(function(content) {
                options.contentUrl = "", options.contentHtml = content, $state.go("app.popupScene", {
                    code: options.code
                });
            }) : $state.go("app.popupScene", {
                code: options.code
            });
        }
        function showErrorPopup(message, title) {
            showInfoPopup({
                contentHtml: message,
                title: title || I18nService.getText("dialogs_notice_title"),
                code: "error",
                size: "sm"
            });
        }
        function showHouseTerms(house) {
            PortalInfoService.getHouseTermsUrl(house.id, I18nService.getCurrentLang()).success(function(url) {
                showInfoPopup({
                    contentUrl: url.val,
                    backText: "dialogs_back",
                    code: "houseTerms"
                });
            });
        }
        function showHouseConnectivityErrorPopup(house) {
            DialogsService.showAlert({
                title: "dialogs_notice_title",
                message: "my_account_unknown_error",
                params: PortalTextsService.getHouseConnectivityErrorParams(house)
            });
        }
        return {
            showPopup: showPopup,
            showInfoPopup: showInfoPopup,
            showLegalDocPopup: showLegalDocPopup,
            showErrorPopup: showErrorPopup,
            showHouseTerms: showHouseTerms,
            showHouseConnectivityErrorPopup: showHouseConnectivityErrorPopup
        };
    }), module.controller("PopupController", [ "$scope", "$state", "$stateParams", function($scope, $state, $stateParams) {
        mPopupSceneOptions && mPopupSceneOptions[$stateParams.code] ? $scope.options = mPopupSceneOptions[$stateParams.code] : $state.go("app.home");
    } ]);
}), define("portal/js/modules/components/structuredDataService", [ "./componentsModule" ], function(module) {
    module.factory("StructuredDataService", function($rootScope, SettingsService, StringsService, I18nService, DomUtilsService, CloudinaryService) {
        function getAuctionName(auction) {
            var auctionName = "";
            return auction.number && (auctionName = I18nService.getText("auction_label_number_public", {
                number: auction.number
            }), auction.part && (auctionName += " " + I18nService.getText("auction_part_" + auction.part)), 
            auctionName += " - "), auctionName += I18nService.getLangField(auction.name);
        }
        function getAuctionIsoTime(auction) {
            if (!auction.time) return "";
            var time = (1 * auction.time.split(":")[0], auction.date + "T" + auction.time), tz = 1 * SettingsService.get("regionTimezoneDiff");
            return time += tz >= 0 ? "+" : "-", time += StringsService.pad(tz, 2, "0") + ":00";
        }
        function setAuctionImage(structuredData, auction) {
            var imgPath = auction.resources && auction.resources.topItem;
            imgPath || (imgPath = auction.house && auction.house.resources.mainPageLogo), structuredData.image = imgPath ? "https:" + CloudinaryService.getUrl(imgPath) : BIDSPIRIT_LOGO_PATH;
        }
        function getAuctionStructuredData(auction) {
            var structuredData = {}, auctionHref = window.location.href.split("#")[0] + "#!/catalog/auction/" + auction.id;
            return structuredData = {
                "@context": "http://schema.org",
                "@type": "SaleEvent",
                name: getAuctionName(auction),
                url: auctionHref,
                location: {
                    "@type": "Place",
                    name: auction.house ? I18nService.getLangField(auction.house.details.name) : "",
                    address: I18nService.getLangField(auction.address)
                }
            }, setAuctionImage(structuredData, auction), !auction.time || auction.hideTime || auction.unknownExactDate || (structuredData.startDate = getAuctionIsoTime(auction)), 
            structuredData;
        }
        function setPriceStructuredDataMetaTags(lot) {
            var currency = lot.auction.catalogInfo.currency, price = lot.startPrice;
            price ? (DomUtilsService.setMetaTag("name", "twitter:data1", I18nService.sumInCurrency(price, currency)), 
            DomUtilsService.setMetaTag("name", "twitter:label1", I18nService.getText("lot_start_price"))) : lot.estimatedPrice && (price = lot.estimatedPrice.split(/\s|\-/)[0].replace(/[^\d]/g, ""), 
            DomUtilsService.setMetaTag("name", "twitter:data1", lot.estimatedPrice), DomUtilsService.setMetaTag("name", "twitter:label1", I18nService.getText("lot_estimated_price"))), 
            price && (DomUtilsService.setMetaTag("property", "og:price:amount", price + ".00"), 
            DomUtilsService.setMetaTag("property", "og:price:currency", I18nService.isoCurrency(currency)));
        }
        function resetStructuredDataMetaTags() {
            DomUtilsService.setMetaTag("property", "og:image", BIDSPIRIT_LOGO_PATH), DomUtilsService.removeMetaTag("property", "og:price:amount"), 
            DomUtilsService.removeMetaTag("property", "og:price:currency"), DomUtilsService.removeMetaTag("name", "twitter:data1"), 
            DomUtilsService.removeMetaTag("name", "twitter:label1"), DomUtilsService.removeMetaTag("name", "twitter:data2"), 
            DomUtilsService.removeMetaTag("name", "twitter:label2");
            var title = I18nService.getTextWithRegion("page_default_title");
            document.title = GlobalConfig.bidmoodEnv ? "Bidmood" : "Bidspirit", document.title += title ? " - " + title : "";
            var description = I18nService.getTextWithRegion("page_default_description");
            DomUtilsService.setMetaTag("name", "description", description), DomUtilsService.setMetaTag("property", "og:description", description), 
            DomUtilsService.setMetaTag("name", "twitter:description", description), DomUtilsService.setMetaTag("property", "og:type", "article"), 
            DomUtilsService.setMetaTag("name", "twitter:card", "summary"), setTimeout(function() {
                var canonicalUrl = (window.location + "").replace(/[\&\?]searchAgentRequest=true/, "").replace(/[\&\?]sessionId[^\&\#]+/, "").replace(/[\&\?]s=[^\&\#]+/, "").replace(/[\&\?]_escaped_fragment_=/, "#!").replace(/\%2F/gi, "/");
                DomUtilsService.setMetaTag("bidspirit-property", "originalUrl", window.location + ""), 
                DomUtilsService.setMetaTag("property", "og:url", canonicalUrl), DomUtilsService.setMetaTag("property", "og:title", document.title + ""), 
                DomUtilsService.setMetaTag("name", "twitter:title", document.title + ""), DomUtilsService.setTagProp("link", "rel", "canonical", "href", canonicalUrl);
            }, 20);
        }
        function getPriceStructuredDataTag(price, currency) {
            var suffix, tagHtml = price.replace(new RegExp(currency + " ", "ig"), currency), rangeSepInd = tagHtml.search(/\s|\-/);
            -1 == rangeSepInd ? suffix = "" : (tagHtml = price.substr(0, rangeSepInd + 1), suffix = price.substr(rangeSepInd + 1));
            var priceNumber, currencyInd = tagHtml.indexOf(currency);
            return priceNumber = -1 == currencyInd ? tagHtml : 0 == currencyInd ? tagHtml.substr(currencyInd + currency.length) : price.substr(0, currencyInd), 
            tagHtml = tagHtml.replace(currency, '<meta itemprop="priceCurrency" content="' + I18nService.isoCurrency(currency) + '" />' + currency), 
            tagHtml = tagHtml.replace(priceNumber, '<meta  itemprop="price" content="' + priceNumber.replace(/[^\d]/g, "") + '" />' + priceNumber), 
            tagHtml + suffix;
        }
        var BIDSPIRIT_LOGO_PATH = "http://s3.amazonaws.com/bidspirit-portal/images/logo.png";
        return {
            getAuctionStructuredData: getAuctionStructuredData,
            getPriceStructuredDataTag: getPriceStructuredDataTag,
            setPriceStructuredDataMetaTags: setPriceStructuredDataMetaTags,
            resetStructuredDataMetaTags: resetStructuredDataMetaTags
        };
    });
}), define("portal/js/modules/components/upperPartDirective", [ "./componentsModule" ], function(module) {
    module.directive("upperPart", function($rootScope, ViewPortService, OsInfoService) {
        return {
            restrict: "C",
            link: function(scope, element) {
                function setWidth() {
                    element.css({
                        width: ViewPortService.getMaxWidth() + "px"
                    });
                }
                GlobalConfig.isMobileApp && OsInfoService.isAndroid() && setWidth();
            }
        };
    });
}), define("portal/js/modules/components/index", [ "./componentsModule", "./houseCarouselDirective", "./contentLoaderDirective", "./pageFooterDirective", "./popupsService", "./structuredDataService", "./upperPartDirective" ], function() {}), 
define("portal/js/modules/navigation/navigationModule", [ "angular" ], function(ng) {
    return ng.module("app.navigation", []);
}), define("portal/js/modules/navigation/upperNavigationController", [ "./navigationModule" ], function(module) {
    module.controller("UpperNavigationController", [ "$scope", "$rootScope", "$window", "$state", "$timeout", "SettingsService", "I18nService", "LocalStorageService", "ViewPortService", "OsInfoService", "PortalNavigationService", "PortalAuthService", "PortalInfoService", "SearchService", function($scope, $rootScope, $window, $state, $timeout, SettingsService, I18nService, LocalStorageService, ViewPortService, OsInfoService, PortalNavigationService, PortalAuthService, PortalInfoService, SearchService) {
        function handleMobileButtonsDisplay() {
            $scope.data.mobileButtons.length;
            switch ($state.current.name) {
              case "app.home":
                $scope.data.mobileButtons = [ "search" ];
                break;

              case "app.search":
                $scope.data.mobileButtons = [ "back", "home" ];
                break;

              default:
                $scope.data.mobileButtons = [ "back", "search", "home" ];
            }
        }
        function updateContainer() {
            $scope.data.showContainer = !1, $timeout(function() {
                $scope.data.showContainer = !0;
            }, 10);
        }
        mLinksLocked = !1, $scope.data = {
            mobileButtons: [],
            showMobileSearch: !1,
            lastSceneStart: null,
            langs: SettingsService.get("languages"),
            infoLinks: [ "contact", "houses", "home" ],
            showContainer: !0,
            searchToken: ""
        }, $scope.setLanguage = function(lang) {
            I18nService.setLang(lang), LocalStorageService.store("lastLang", lang), $rootScope.currentUser && PortalInfoService.setCurrentUserPreferredLang(lang);
        }, $scope.logout = function() {
            PortalAuthService.logout().success(function() {
                $state.go("app.home");
            });
        }, $scope.gotoSearch = function() {
            SearchService.gotoSearchScene($scope.data.searchToken);
        }, $scope.nextRegistrationStep = function() {
            switch ($scope.currentUser.registrationStage) {
              case "UNCONFIRMED_EMAIL":
                $state.go("app.auth", {
                    authScene: "warning"
                });
                break;

              case "INCOMPLETE_PROFILE":
                $state.go("app.auth", {
                    authScene: "postRegistrationDetails"
                });
            }
        }, $scope.handleMobileButtonClick = function(button) {
            mLinksLocked || (mLinksLocked = !0, $timeout(function() {
                switch (button) {
                  case "home":
                    PortalNavigationService.goHome();
                    break;

                  case "search":
                    SearchService.gotoSearchScene();
                    break;

                  case "back":
                    PortalNavigationService.goBack();
                }
                mLinksLocked = !1, OsInfoService.isAndroid() && GlobalConfig.isMobileApp && updateContainer();
            }, 300));
        }, $scope.state = $state, $scope.$on("$stateChangeStart", function() {
            $scope.data.searchToken = "", $scope.data.lastSceneStart = new Date().getTime();
        }), $scope.$on("$stateChangeSuccess", function() {
            handleMobileButtonsDisplay();
        }), $rootScope.$on("i18n.languageChanged", updateContainer), handleMobileButtonsDisplay();
    } ]);
}), define("portal/js/modules/navigation/mobileMenuController", [ "./navigationModule" ], function(module) {
    module.controller("MobileMenuController", [ "$scope", "$rootScope", "$timeout", "$state", "I18nService", "LocalStorageService", "PortalAuthService", function($scope, $rootScope, $timeout, $state) {
        function handleMenuDisplay() {
            var currentState = $state.current.name;
            if ($scope.langMenuAtBottom = $rootScope.currentUser ? !0 : !1, "app.mobileMenu" == currentState) {
                $scope.data.infoLinks = [ "contact", "houses" ];
                var timeSinceLastClick = new Date().getTime() - $scope.data.lastMenuClick;
                100 > timeSinceLastClick || !mMenuWasHidden ? $rootScope.mobileMenuOn = !0 : window.history.back(), 
                window.scrollTo(0, 0);
            } else mMenuWasHidden = !0, $rootScope.mobileMenuOn = !1;
        }
        function hideMenuIfOn() {
            $rootScope.mobileMenuOn && (mMenuWasHidden ? window.history.back() : $state.go("app.home"));
        }
        mMenuWasHidden = !1, mButtonTouchTimer = null, $scope.toggleMenu = function() {
            var currentState = $state.current.name;
            $scope.menuTouched = !0, clearTimeout(mButtonTouchTimer), mButtonTouchTimer = $timeout(function() {
                $scope.menuTouched = !1, "app.mobileMenu" == currentState ? ($rootScope.mobileMenuOn = !1, 
                $timeout(function() {
                    window.history.back();
                }, 10)) : ($scope.data.lastMenuClick = new Date().getTime(), $state.go("app.mobileMenu"));
            }, 300);
        }, $scope.onLanguageClick = function() {
            $scope.langMenuAtBottom && $timeout(function() {
                window.scrollTo(0, 1e4);
            }, 300);
        }, $rootScope.$on("$stateChangeSuccess", handleMenuDisplay), $rootScope.$on("i18n.languageChanged", hideMenuIfOn), 
        handleMenuDisplay();
    } ]);
}), define("portal/js/modules/navigation/reloadController", [ "./navigationModule" ], function(module) {
    module.controller("ReloadController", [ "$scope", "$window", "$timeout", function($scope, $window, $timeout) {
        $timeout(function() {
            $window.history.back();
        }, 300);
    } ]);
}), define("portal/js/modules/navigation/appSiteWinodwsService", [ "./navigationModule" ], function(module) {
    module.factory("AppSiteWinodwsService", function($rootScope, PathsService, StringsService, I18nService, PortalAuthService, SessionsService, PuffinService) {
        function getAuctionSiteUrl(auction, sessionToken) {
            if (!auction.house) return null;
            var siteCode = auction.house.site.code, query = "?code=" + auction.house.code, url = PathsService.getAppSiteUrl(siteCode) + "/";
            sessionToken && (query += (query ? "&" : "?") + "pt=" + sessionToken);
            var hash;
            return hash = "RUNNING" == auction.state ? "live" : "catalog~" + auction.auctionIdInApp + "~" + auction.dayIdInApp, 
            /iPad|iPhone|iPod/.test(navigator.userAgent) && (query += (query ? "&" : "?") + "hashValue=" + hash), 
            url + query + "#" + hash;
        }
        function showDemo(demoCode) {
            var url = "https://demo.bidspirit.com/?demoMode=1&";
            switch (demoCode) {
              case "classic":
                url += "avatars=0";
                break;

              case "unique":
                url += "avatars=1";
                break;

              case "virtualAuctioneer":
                url += "avatarAuctioneer=1";
            }
            switch (I18nService.getCurrentLang()) {
              case "ru":
                url += "&code=demo-russian&lang=ru";
                break;

              case "he":
                url += "&code=demo-site&lang=he";
                break;

              case "en":
                url += "&code=demo-site&lang=en";
            }
            window.open(url, "_system");
        }
        function openAuctionSiteWindow(auction, noAutoLogin, lot) {
            if (auction) {
                var token = null;
                $rootScope.currentUser && "UNCONFIRMED_EMAIL" != $rootScope.currentUser.registrationStage && !noAutoLogin && (token = StringsService.randomString(10));
                var url = getAuctionSiteUrl(auction, token) + (lot ? "~" + lot.idInApp : "");
                GlobalConfig.isMobileApp && "RUNNING" == auction.state ? PuffinService.tryToLaunchWithPuffin(url) : window.open(url, "_system"), 
                token && PortalAuthService.createTokenForAppSite(auction.houseId, token);
            }
        }
        return {
            openAuctionSiteWindow: openAuctionSiteWindow,
            showDemo: showDemo
        };
    });
}), define("portal/js/modules/navigation/portalNavigationService", [ "./navigationModule" ], function(module) {
    module.factory("PortalNavigationService", function($timeout, $rootScope, $state, OsInfoService, LogService, AnalyticsService, StructuredDataService) {
        function init() {
            $rootScope.$on("$stateChangeStart", function(event, toState, toArgs, fromState, fromArgs) {
                "app.mobileMenu" != fromState.name && ($rootScope.$previousState = fromState, $rootScope.$previousState.args = fromArgs, 
                mBackFn = null), "app.home" == toState.name && (mHomePageVisited = !0), trackPageView(), 
                StructuredDataService.resetStructuredDataMetaTags();
            }), $rootScope.$on("viewPort.orientationChange", function() {
                $state.go("app.reload");
            }), $rootScope.$on("i18n.languageChanged", function() {
                $state.go("app.reload");
            }), AnalyticsService.trackEvent("init", GlobalConfig.isMobileApp ? "mobile" : "web");
        }
        function openWindow(url) {
            GlobalConfig.isMobileApp ? window.open(url, "_system") : OsInfoService.isMobile() ? window.location = url : window.open(url, "_blank", "menubar=no,toolbar=no,resizable=yes,scrollbars=yes,height=600,width=600");
        }
        function getNewWindowTarget() {
            return GlobalConfig.isMobileApp ? "_system" : OsInfoService.isMobile() ? "_self" : "_blank";
        }
        function trackPageView() {
            if (!$rootScope.searchAgentRequest) {
                var hash = window.location.hash;
                if (hash) {
                    var scene = hash.substr(hash.indexOf("/") + 1);
                    mLastTrackedScene != scene && "reload" != scene && (LogService.logEvent({
                        scene: scene
                    }), AnalyticsService.trackPage(scene), mLastTrackedScene = scene);
                }
            }
        }
        function goBack(ignoreBackFn) {
            mBackFn && !ignoreBackFn ? mBackFn() : history.back();
        }
        function goHome() {
            $state.go("app.home");
        }
        function setBackFn(backFn) {
            mBackFn = backFn;
        }
        return mBackFn = null, mHomePageVisited = !1, mLastTrackedScene = null, mSceneToGoBackTo = null, 
        {
            init: init,
            goBack: goBack,
            setBackFn: setBackFn,
            goHome: goHome,
            openWindow: openWindow,
            getNewWindowTarget: getNewWindowTarget
        };
    });
}), define("portal/js/modules/navigation/index", [ "./navigationModule", "./upperNavigationController", "./mobileMenuController", "./reloadController", "./appSiteWinodwsService", "./portalNavigationService" ], function() {}), 
define("portal/js/modules/portalModules", [ "angular", "commonModules", "./main/index", "./auth/index", "./userDetails/index", "./alerts/index", "./info/index", "./auctions/index", "./houses/index", "./account/index", "./nudges/index", "./components/index", "./navigation/index" ], function(ng) {
    return ng.module("app.portalModules", [ "app.main", "app.auth", "app.userDetails", "app.userAlerts", "app.info", "app.auctions", "app.houses", "app.account", "app.nudges", "app.components", "app.navigation" ]);
}), define("app", [ "angular", "ngdir/angular-animate", "ngdir/angular-ui-router", "ngdir/angular-ui-bootstrap", "ngdir/angular-upload", "ngdir/angular-google-analytics", "commonModules", "portal/js/modules/external/index", "portal/js/modules/portalModules" ], function(angular) {
    function initAnalytics(AnalyticsProvider) {
        GlobalConfig.isMobileApp ? document.addEventListener("deviceready", function() {
            window.analytics.startTrackerWithId("UA-56607963-1");
        }, !1) : -1 == window.location.href.indexOf("searchAgentRequest") && -1 != window.location.href.indexOf("bidspirit") && (AnalyticsProvider.setAccount("UA-56607963-1"), 
        AnalyticsProvider.useAnalytics(!0));
    }
    return angular.module("app", [ "ngAnimate", "ngUpload", "angular-google-analytics", "commonModules", "app.portalModules", "app.externals", "ui.router", "ui.bootstrap" ]).config(function($locationProvider, AnalyticsProvider) {
        $locationProvider.hashPrefix("!"), initAnalytics(AnalyticsProvider);
    }).run(function($templateCache) {
        $templateCache.put("/common/templates/forms/asyncButton.html?0.565", '<button   class="bs-async-button" ng-class="buttonClass + (locked ? \' waiting\' : \'\')"  ng-click="executeAction()">  <div class="text">{{label | i18n }}</div>  <div ng-transclude></div>  </button>   '), 
        $templateCache.put("/common/templates/forms/formGroup.html?0.565", '<div class="form-group {{cssClass}}"> <div> <div ng-transclude></div> </div>  </div> '), 
        $templateCache.put("/common/templates/dialogs/scopeAlert.html?0.565", "<div style=\"display:{{alert.message?'block':'none'}}\"> <uib-alert  type=\"{{alert.type || 'info'}}\" close=\"hideScopeAlert()\"> {{alert.message | i18n}} </uib-alert> </div> "), 
        $templateCache.put("/common/templates/dialogs/alert.html?0.565", '<div bs-text-direction> <div class="modal-header"> <div class="modal-title">{{((dialogData.title || "dialogs_notice_title") | i18n) | capitalize}}</div>  </div>  <div class="modal-body" ng-bind-html="dialogData.message | i18n:dialogData.params"></div>  <div class="modal-footer"> <button class="btn btn-primary" ng-click="close()">{{(dialogData.ok || "dialogs_ok") | i18n}}</button> </div> </div>  '), 
        $templateCache.put("/common/templates/dialogs/image.html?0.565", '<div class="modal-header"> <button type="button" class="close" ng-click="$close()">&times;</button> <h4 class="modal-title">{{dialogData.imageName}}</h4> </div>  <div class="modal-body"><img ng-src="{{dialogData.imagePath | cloudinary}}" class="img-responsive"> </ </div>  <div class="modal-footer"> <button class="btn btn-primary" ng-click="close()">{{(dialogData.close || "dialogs_close") | i18n}}</button> </div> '), 
        $templateCache.put("/common/templates/dialogs/confirm.html?0.565", '<div bs-text-direction> <div class="modal-header"> <div class="modal-title">{{(dialogData.title || "dialogs_confirm_title") | i18n}}</div>  </div>  <div class="modal-body">{{dialogData.message | i18n:dialogData.params}}</div>  <div class="modal-footer"> <button class="btn btn-danger" ng-click="ok()">{{(dialogData.ok || "dialogs_ok") | i18n}}</button> <button class="btn btn-warning" ng-click="close()">{{(dialogData.cancel || "dialogs_cancel") | i18n}}</button> </div> </div>  '), 
        $templateCache.put("/common/templates/elements/pagination.html?0.565", '<div class="bs-pagination" dir="ltr">  <a class="link" ng-repeat="link in links" ng-href="{{baseHref && link.page && !link.isCurrent ? baseHref+link.page : \'\'}}"  ng-click="onLinkClick(link)" ng-bind-html="link.html" ng-class="{ current:link.isCurrent, disabled:!link.page, enabled:link.page && !link.isCurrent, needsclick:link.isPrev || link.isNext,  prev:link.isPrev,  next:link.isNext}"> </a>   </div>   '), 
        $templateCache.put("/portal/templates/info/allFutureAuctions.html?0.565", '<div class="all-future-auctions"> <table class="table table-striped default-align" bs-text-direction> <tr> <th>{{"future_auction_house" | i18n}}</th> <th>{{"future_auction_time" | i18n}}</th> <th>{{"future_auction_name" | i18n}}</th> </tr> <tr ng-repeat="auction in options.data.auctions"> <td>{{auction.house.details.name | langField}}</td> <td>{{auction| auctionTime}}</td> <td>{{auction.name | langField}}</td> </tr>  </table> </div>  '), 
        $templateCache.put("/portal/templates/info/contact.html?0.565", '<div  class="contact scene" ng-controller="ContactController" bs-scroll-to-top> <div class="upper-part">  <div class="dark overlay">  <div class="message center-block container"> <H1>{{\'link_contact\' | i18n}}</H1> <div class="short-separator"></div> <h4 class="message-line">{{\'contact_message_line_1\' | i18n}}</h4> <h4 class="message-line">{{\'contact_message_line_2\' | i18n}}</h4>  <bs-linkable-text class="sell-message" options="{ textKey:\'contact_message_sell\',  onLinkClick:gotoAuctionHouses }" > </bs-linkable-text> </div> </div> </div> <div class="content container col-lg-5 col-md-7  col-xs-12" > <form name=\'contactForm\' novalidate bs-form  bs-submit="send()" ng-show="$state.current.name!=\'app.contact.thanks\'"> <div class="row"> <bs-form-group field-name="name" label="user_details_name" css-class="col-md-5  col-xs-11 float"> <label class="float"></label> <span class="float star">*</span><div><!-- this empty div is needed for ie8 --></div>  <bs-form-validation-message required="error_name_mandatory" css-class="float"> </bs-form-validation-message> <div class="clearfix"></div> <input  name="name" class="form-control" ng-model="contact.name" required /><div><!-- this empty div is needed for ie8 --></div>  </bs-form-group> <div class="col-md-2 float col-xs-0"></div> <bs-form-group field-name="email" label="user_details_email" css-class="col-md-5 col-xs-11 float"> <label class="float"></label> <span class="float star">*</span><div><!-- this empty div is needed for ie8 --></div> <bs-form-validation-message css-class="float"> </bs-form-validation-message> <div class="clearfix"></div> <input  dir="ltr" type="email" name="email" class="form-control" ng-model="contact.email" required /><div><!-- this empty div is needed for ie8 --></div>  </bs-form-group>  </div> <div class="row"> <bs-form-group field-name="phone" label="user_details_phone" css-class="col-md-5  col-xs-11 float"> <label></label> <input dir="ltr"   name="phone" class="form-control" ng-model="contact.phone" /><div><!-- this empty div is needed for ie8 --></div> <bs-form-validation-message css-class="float"> </bs-form-validation-message> </bs-form-group>  <div class="col-md-2 float col-xs-0"></div> <bs-form-group field-name="state" label="user_details_country" css-class="col-md-5 col-xs-11 float"> <label></label> <input  name="state" class="form-control" ng-model="contact.state" /><div><!-- this empty div is needed for ie8 --></div> <bs-form-validation-message css-class="float"> </bs-form-validation-message> </bs-form-group>   </div> <div class="row">  <bs-form-group field-name="message" label="contact_message_body" css-class="col-md-12 col-xs-11 float" > <label class="float"></label> <span class="float star">*</span><div><!-- this empty div is needed for ie8 --></div> <bs-form-validation-message css-class="float" required="error_message_mandatory"> </bs-form-validation-message> <div class="clearfix"></div> <textarea  name="message" class="form-control" ng-model="contact.message" required ></textarea><div><!-- this empty div is needed for ie8 --></div> </bs-form-group>  </div>  <div class="row"> <div class="orange common-button col-sm-3 float" ng-click="contactForm.submit()" > <div class="text">{{"dialogs_send" | i18n }}</div> </div>   </div> </form> <div class="thanks .container animate-show" ng-show="$state.current.name==\'app.contact.thanks\'"> {{"contact_thanks" | i18n }} </div> </div>  <div class="direct-contact"> <div class="text" ng-bind-html=\'"contact_direct" | i18n:{phone:BidspiritInfo.phoneLink, email:BidspiritInfo.emailLink}\'>  </div> </div> </div> '), 
        $templateCache.put("/portal/templates/info/product/productMain.html?0.565", '<div ng-controller="ProductController" bs-scroll-to-top> <div class="product scene"> <div class="upper-part">  <div class="dark overlay"> </div> </div>  <div class="main center-block "> <h1 class="center-block col-md-5 col-xs-12" ng-bind-html="mainFeature.title | langField"></h1>  <div class="short-separator"></div> <div class="image center-block  col-md-7 col-xs-12" ng-if="mainFeature.resources!=null" bs-cloudinary-bg="{{mainFeature.resources[\'productsPagePic\']}}"  >  </div> <div class="info center-block  col-md-9 col-lg-7 col-xs-12" ng-bind-html="mainFeature.info | langField">  </div> <div class="orange contact-us common-button center-block center-block"  ui-sref="app.contact"> <div class="text">{{"link_contact" | i18n }}</div> </div>  <div class="gray-separator col-md-9 col-lg-7 col-xs-12 center-block"></div> </div>  <div class="features"> <h3 class="section-title">{{\'product_features\' | i18n}}</h3> <div class="short-separator"></div> <div ng-include src="\'info/product/productFeatures\' | appTemplate"></div> </div>  <div class="gray-separator col-md-9 col-lg-7 col-xs-12 center-block"></div>  <div class="contact"> <div class="container col-lg-4 col-md-5 col-sm-6 col xs-10 center-block"> <h3 class="caption">{{\'product_contact_caption\' | i18n}}</h3> <div class="short-separator"></div> <div class="message-line">{{\'product_contact\' | i18n}}</div> <div class="orange contact-us common-button center-block" ui-sref="app.contact"> <div class="text">{{"link_contact" | i18n }}</div> </div> </div>  </div> </div>  </div> '), 
        $templateCache.put("/portal/templates/info/product/productFeatures.html?0.565", '<div class="list container-fluid"> <div class="row"> <div class="item col-md-3 col-xs-10"  ng-repeat="feature in features" ng-if  = "feature.code!=\'main\'"> <div class="frame" ng-class="[feature.code,currentLang]"> <div class="image"  bs-cloudinary-bg="{{feature.resources[\'productsPagePic\']}}"  params=" {imageMode:\'fill\',size:\'360x226\'} ">  </div>  <div class="texts"> <h2 class="caption"> {{feature.title | langField}} </h2>   <div class="short-separator"></div> <div class="info" ng-bind-html="feature.info | langField"> </div>  </div> <div ng-if="feature.code==\'bidder\'"> <div class="orange  common-button pull-left"  ng-click="showDemo(\'classic\')">  <div class="text"> {{\'product_demo_classic\' | i18n}}  </div> </div> <div class="orange  common-button pull-right" ng-click="showDemo(\'unique\')" >  <div class="text"> {{\'product_demo_unique\' | i18n}}  </div> </div> </div>  <div ng-if="feature.code==\'virtualAuctioneer\' && !isMobile">  <div class="orange  common-button center-block" ng-click="showDemo(\'virtualAuctioneer\')" >  <div class="text"> {{\'product_demo_virtual_auctioneer\' | i18n}}  </div> </div> </div>  </div>  </div> </div>  </div> '), 
        $templateCache.put("/portal/templates/info/helpScreen.html?0.565", '<div class="help-screen scene" ng-controller="HelpScreensController" bs-scroll-to-top> <div class="content container">  <div class="float texts"> <h2 class="caption"> {{helpScreen.title | langField}} </h2> <div class="info" ng-bind-html="helpScreen.info | langField">  </div>  <div ng-switch="helpScreen.code"> <div ng-switch-when="live">  <div class="orange  common-button pull-left"  ng-click="showDemo(\'classic\')">  <div class="text"> {{\'product_demo_classic\' | i18n}}  </div> </div> <div class="orange  common-button pull-right" ng-click="showDemo(\'unique\')" >  <div class="text"> {{\'product_demo_unique\' | i18n}}  </div> </div> <div class="clearfix"></div> </div> <div ng-switch-when="bids"> <div class="orange common-button center-block" ng-click="showRegistration()" ng-if="!currentUser">  <div class="text"> {{\'help_register\' | i18n}}  </div> </div>  </div> <div ng-switch-when="search"> <form name=\'searchForm\' novalidate bs-form  bs-submit="gotoSearch()" class="global-search-form center-block" bs-text-direction> <bs-form-group field-name="phrase" label="catalog_search_all" > <input bs-place-holder name="phrase" class="form-control" ng-model="data.searchToken" bs-enter-key-action="gotoSearch()"/> </bs-form-group> <div class="button" ng-click="gotoSearch()"></div> <div class="clearfix"></div> </form> </div> </div> </div>   <div class="opposite float screenshot" bs-cloudinary-bg="{{sceenshot}}"></div> <div class="clearfix"></div> <div class="btn home btn-link center-block" ui-sref="app.home"> {{"home_back_to" | i18n }} </div> </div>   </div> '), 
        $templateCache.put("/portal/templates/info/about.html?0.565", '<div  class="about scene" bs-scroll-to-top> <div class="wide upper-part" >  <div class="dark overlay">  <div class="message center-block container col-lg-7 col-md-7 col-sm-8 col xs-12"> <H1>{{\'about_upper_caption\' | i18n}}</H1> <div class="short-separator"></div> <h2 class="text">{{\'about_upper_text\' | i18n}}</h2> </div> </div> </div> <div class="content container col-lg-6 col-md-6 col-sm-8 col xs-12"> <div class="portal-info"> <div class="line">{{\'about_portal_info_line_1\' | i18n}}</div> <div class="line">{{\'about_portal_info_line_2\' | i18n}}</div> </div>  <div class="short-separator"></div>  <div class="company-info"> <div class="line">{{\'about_company_info\' | i18n}}</div> </div> </div> <div class="contact"> <div class="container col-lg-6 col-md-6 col-sm-8 col xs-12"> <div class="caption">{{\'about_contact_caption\' | i18n}}</div> <div class="short-separator"></div> <div class="message-line">{{\'contact_message_line_1\' | i18n}}</div> <div class="message-line">{{\'contact_message_line_2\' | i18n}}</div> <div class="orange common-button center-block" ui-sref="app.contact"> <div class="text">{{"link_contact" | i18n }}</div> </div> </div>  </div> </div> '), 
        $templateCache.put("/portal/templates/info/upgradeRequired.html?0.565", '<div bs-text-direction> <div class="modal-header"> <div class="modal-title">{{"dialogs_notice_title" | i18n}}</div>  </div>  <div class="modal-body" ng-bind-html="\'upgrade_required_message\' | i18n"></div>  <div class="modal-footer"> <div class="text-center"> <button class="btn btn-primary" ng-click="redirectToUpgrade()">{{"upgrade_required_upgrade_now" | i18n}}</button> </div>  </div> </div>  '), 
        $templateCache.put("/portal/templates/alerts/userAlertsMain.html?0.565", '<div ng-controller="UserAlertsController" class="userAlerts scene" bs-scroll-to-top> <div class="narrow upper-part">  <div class="dark overlay">  <div class="message center-block container col-lg-7 col-md-7 col-sm-8 col xs-12"> <h1>{{"user_alerts_title" | i18n}}</h1> <div class="short-separator"></div> </div> </div> </div>  <div class="content container">  <div ng-if="currentUser" > <div ng-if="!saved">  <h4>{{"user_alerts_message" | i18n}}</h4>  <div class="alerts-choice-form" > <div class="form-group" ng-click="setChoice(\'ALL_HOUSES_FOR_REGION_ALERTS\')"> <input  type="radio"  ng-model="data.housesAlertChoice" value="ALL_HOUSES_FOR_REGION_ALERTS"/> <label ><span></span>{{"user_alerts_all_houses" | i18nWithRegion }}</label>  </div>    <div ng-show="false" class="form-group" ng-click="setChoice(\'SOME_HOUSES_ALERTS\')"> <input  type="radio"  ng-model="data.housesAlertChoice" value="SOME_HOUSES_ALERTS"/>  <label><span></span>{{"user_alerts_some_houses" | i18n }}</label>  <div class="housesList" ng-show="housesListVisible"> <div class="caption">{{"user_alerts_choose_houses" | i18n }} </div>  <div class="float house" ng-repeat="house in houses" check-on-click="true" ng-if="devMode || (house.site.code && house.site.code!=\'demo\')" > <input type="checkbox" bs-checklist-model="data.housesToAlert" checklist-value="house.code" > {{house.details.name | langField}} </div> <div class="clearfix"></div>  </div> </div>   <div class="form-group" ng-click="setChoice(\'NO_HOUSES_ALERTS\')"> <input type="radio"  ng-model="data.housesAlertChoice" value="NO_HOUSES_ALERTS"/> <label><span></span>{{"user_alerts_no_houses" | i18n }}</label>  </div>    <div class="clearfix"></div> </div>  <div class="buttons-row"> <bs-async-button button-class="\'float orange common-button\'"   action-fn="save()" label="\'dialogs_save\'" > </bs-async-button> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <div bs-back-button class="btn btn-link btn-lg">{{"dialogs_cancel" | i18n}}</div> <div class="clearfix"></div> </div>  </div>   <div ng-if="saved" class="text-center"> <h3>{{"user_alerts_saved" | i18n}}</h3> <br><br> <div bs-back-button class="btn btn-link btn-lg">{{"dialogs_continue" | i18n}}</div> </div>  </div>  </div>   </div> '), 
        $templateCache.put("/portal/templates/portalMain.html?0.565", '   <div ng-include src="\'elements/navigation/upperNavigation\' | appTemplate"></div>   <div  class="page-body" ui-view dir="{{dir}}" ng-show="dataState==\'loaded\'" style="min-height:{{viewPort.innerHeight-300+\'px\'}}"></div>  <bs-content-loader loaded="dataState==\'loaded\'"></bs-content-loader>   <bs-page-footer dir="{{dir}}" ng-show="!mobileMenuOn"></bs-page-footer> '), 
        $templateCache.put("/portal/templates/nudges/modal/housesAlertsModal.html?0.565", '<div class="title">{{\'nudges_houses_alert_catalog_title\' | i18n}}</div>    <div class="action orange common-button"  ng-click="options.showRegisterForm()"> <div class="text">{{\'link_register\' | i18n}}</div></div>  '), 
        $templateCache.put("/portal/templates/nudges/modal/nudgeModalPopup.html?0.565", '<div class="nudge-modal-popup" ng-class="nudgeType" bs-text-direction> <div class="content" ng-include src="(\'nudges/modal/\'+options.data.nudgeType+\'Modal\') | appTemplate" ng-class="nudgeType"> </div>  </div> '), 
        $templateCache.put("/portal/templates/nudges/navbar/nudgeNavbarPopup.html?0.565", '<div class="nudge-navbar-popup" ng-show="isVisible" ng-class="nudgeType" ng-click="onClick()" bs-text-direction> <div class="close button">x</div> <div class="content" ng-if="isVisible" ng-include src="(\'nudges/navbar/\'+nudgeType+\'NavBar\') | appTemplate" ng-class="nudgeType">  </div>   </div> '), 
        $templateCache.put("/portal/templates/nudges/navbar/housesAlertsNavBar.html?0.565", '<div class="title">{{\'nudges_houses_alert_catalog_title\' | i18n}}</div>   <div class="action orange common-button"  ui-sref="app.alerts"> <div class="text">{{\'alerts_promotion_configure_command\' | i18n}}</div></div>  '), 
        $templateCache.put("/portal/templates/auctions/results/houseSelection.html?0.565", '<div class="house-selection" > <div class="space hidden-sm"> </div> <h3 class="caption"> {{\'auctions_results_select_house\' | i18n}}</h3> <uib-dropdown  class="btn-group"  is-open="housesListOpen" ng-if="viewPort.pcMedia">  <div uib-dropdown-toggle type="button" class="default-align selected entry" > <div class="float"> <div ng-if="data.currentHouse"> <div class="float icon"  bs-cloudinary-bg="{{data.currentHouse.resources[\'mainPageLogo\']}}"  params="{size:\'60x15\'}"></div> <div class="float text">{{data.currentHouse.details.name | langField }}</div> <div class="clearfix"></div> </div> <div ng-if="!data.currentHouse">  <div class="text">{{"auctions_results_all_houses" | i18n }}</div> </div> </div> <div class="opposite float caret {{dir}}" ></div> <div class="clearfix"></div> </div>   <ul class="uib-dropdown-menu" role="menu">  <li ng-if="data.selectedHouseCode!=\'all\'" ng-click="showHouseAuctions(\'all\')"> <div class="default-align entry"> <div class="text">{{"auctions_results_all_houses" | i18n }}</div> </div> </li>  <li ng-repeat="house in houses" ng-click="showHouseAuctions(house.code)"> <div class="default-align entry"> <div class="float icon" bs-cloudinary-bg="{{house.resources[\'mainPageLogo\']}}"  params="{size:\'60x15\'}"></div> <div class="float text">{{house.details.name | langField}}</div> <div class="clearfix"></div> </div>  </li> </ul> </uib-dropdown> <div ng-if="viewPort.mobileMedia" class="mobile-dropdown"> <select ng-model="data.selectedHouseCode" ng-change="onMobileDropDownChange()" bs-text-direction> <option value="all">{{"auctions_results_all_houses" | i18n }}</option> <option ng-repeat="house in houses" value="{{house.code}}"  ng-selected="house.code == data.selectedHouseCode">{{house.details.name | langField | trim:20 }}</option> </select> </div> <div class="short-separator"></div> </div> '), 
        $templateCache.put("/portal/templates/auctions/results/auctionsResults.html?0.565", '<div ng-controller="AuctionsResultsController" class="auctions-results scene"> <div class="narrow upper-part">  <div class="dark overlay">  <div class="message center-block container col-lg-7 col-md-7 col-sm-8 col xs-12"> <h1>{{"auction_results_title" | i18n }}</h1> <div class="short-separator"></div> </div> </div> </div>  <div class="content"> <div  ng-include src="\'auctions/results/houseSelection\' | appTemplate"></div>  <bs-pagination	pages-data="pagesData"	href-pages="true"> </bs-pagination> <div class="clearfix"></div> <bs-content-loader loaded="!displayeAuctionsLoader"></bs-content-loader> <div class="auctions-lists-group" ng-show="!displayeAuctionsLoader">  <bs-auctions-list  auctions="pageAuctions"  view="\'recent\'"> </bs-auctions-list> </div>  <bs-pagination	pages-data="pagesData"	href-pages="true" ng-show="!displayeAuctionsLoader"> </bs-pagination> </div>  </div> '), 
        $templateCache.put("/portal/templates/auctions/catalogs/list/catalogItemWide.html?0.565", ' <div >  <bs-lot-image lot="lot" size="220x220" as-bg="true" image-mode="\'fit\'">  </bs-lot-image> <meta itemprop="image" content="{{lot | lotImage:\'220x220\'}}"></meta>  <div ng-if="lot.expireTime"> <bs-lot-expiration lot="lot" ></bs-lot-expiration> </div>  <bs-lot-badge lot="lot" ></bs-lot-badge>     <div class="item-bottom-part">  <div class="above-separator"> <span class="lot-number" itemprop="sku"> {{"lot_number" | i18n:{number:lot.itemIndex} }} </span> <span itemprop="name" ng-bind-html="lot | lotText:60 "></span>  </div>  <div class="short-separator"></div>  <div class="below-separator" bs-text-direction> <bs-lot-price lot="lot" max-width="\'125\'" single-row="true" break-on-row="false"></bs-lot-price>  <div class="orange common-button"> <div class="text"> {{"catalog_view_lot" | i18n }} </div> </div> </div>  </div>  </div>    '), 
        $templateCache.put("/portal/templates/auctions/catalogs/list/catalogMain.html?0.565", '<div ng-controller="CatalogListController" > <div class="catalog scene"> <div class="content col-xs-12" > <bs-auction-info ng-if="data.auction" auction="data.auction" ></bs-auction-info> <bs-catalog-list-filter ng-if="data.auction && data.items"></bs-catalog-list-filter> <div ng-if="pagesData.pageItems.length>0">  <bs-catalog-list-pagination pages-data="pagesData"  position-in-page="\'upper\'" href-pages="true" ></bs-catalog-list-pagination> <div  bs-scroll-on watched-value="scrollToPagination" offset="-200"></div> <div ng-if="!displayeItemsLoader"  ng-include src="\'auctions/catalogs/list/catalogItems\' | appTemplate"  ></div> <bs-content-loader loaded="!displayeItemsLoader"></bs-content-loader> <bs-catalog-list-pagination pages-data="pagesData"  position-in-page="\'lower\'" href-pages="true"></bs-catalog-list-pagination>  <bs-house-regisration-promotion ng-show="!displayeItemsLoader" auction="data.auction" class="promotion-bottom"> </bs-house-regisration-promotion>  </div> <bs-content-loader loaded="pagesData.pageItems!=null"></bs-content-loader>  </div>  <div ng-if="isIe8" ie8-warning></div>  </div> </div>  '), 
        $templateCache.put("/portal/templates/auctions/catalogs/list/catalogItems.html?0.565", '<div class="list" ng-class="{\'mobile-list\':!viewPort.isWideDevice}">  <div class="row">  <div class="item" itemscope itemtype="http://schema.org/Product" bs-text-direction ng-repeat="lot in pagesData.pageItems" ng-class="{\'pc-item\':viewPort.isWideDevice,\'mobile-item\':!viewPort.isWideDevice}" bs-scroll-on="lot.id == scrollTo" offset="-200"  > <a  itemprop="url"  class="link" ng-href="#!/lotPage/source/catalog/auction/{{lot.auctionId}}/lot/{{lot.id}}" > <div  ng-if="viewPort.isWideDevice"     ng-include src="\'auctions/catalogs/list/catalogItemWide\' | appTemplate" class="frame"> </div> <div  ng-if="!viewPort.isWideDevice" ng-include src="\'auctions/catalogs/list/catalogItemNarrow\' | appTemplate"> </div> </a> <bs-lot-favorite-flag lot="lot"></bs-lot-favorite-flag> </div> <div class="clearfix"></div> </div>   <div class="clearfix"></div> </div>  '), 
        $templateCache.put("/portal/templates/auctions/catalogs/list/catalogItemNarrow.html?0.565", '<div class="lot-row">  <bs-lot-badge lot="lot"  ng-style="{width:mobileElementsDimensions.infoWidth+\'px\'}"></bs-lot-badge>  <bs-lot-image lot="lot" size="260x176" as-bg="true" image-mode="\'fit\'" class="lot-pic"></bs-lot-image>  <div class="info" ng-style="{width:mobileElementsDimensions.infoWidth+\'px\'}"> <div class="item-index"> {{"lot_number" | i18n:{number:lot.itemIndex} }}</div>  <div class="lot-text" ng-bind-html="lot | lotText:100 "></div>   <bs-lot-price lot="lot"  single-row="true" break-on-row="true"></bs-lot-price>    </div>  </div>  '), 
        $templateCache.put("/portal/templates/auctions/catalogs/list/catalogPagination.html?0.565", ' <div class="catalog-pagination text-center" ng-class="[currentLang, positionInPage, {\'lifted\':data.lifted}]" bs-text-direction  >  <bs-pagination  ng-if="data.availableWidth" pages-data="pagesData"  href-pages="hrefPages" on-current-page-change="onCurrentPageChange()"  available-width="data.availableWidth"  >  </bs-pagination>   </div>  '), 
        $templateCache.put("/portal/templates/auctions/catalogs/list/catalogFilterPanel.html?0.565", '<div class="filter-panel" >  <div class="float section" > <form name=\'searchForm\' novalidate bs-form  bs-submit="search()" class="search-form"> <bs-form-group field-name="phrase" label="catalog_search_placeholder"> <input  bs-place-holder  name="phrase"  class="form-control"  ng-model="filterData.phrase"  ng-keyup="searchAfterDelay()"  ng-focus="onInputFocus()" /> </bs-form-group> </form> <div class="result" >{{"catalog_results_count" | i18n:{count:pagesData.visibleItems.length} }}</div> <div class="sold-state" ng-if="data.auction.state==\'ENDED\'"> <select  ng-model="filterData.soldState" ng-change="applySoldStateFilter()"  ng-options="(\'catalog_sold_state_\'+ soldState) | i18n for soldState  in [\'all\',\'sold\',\'unsold\']"> </select> </div> </div>  <div class="opposite float section"> <div class="categories" ng-class="{invisible:filterData.categories.length==0}"> <select  ng-model="filterData.category" ng-change="filterByCategory()" ng-options="category.value as category.name for category in filterData.categories"> </select> </div> <div class="lots-per-page"> <div class="float label" >{{"catalog_lots_per_page" | i18n}}:</div> <select class="float" ng-model="pagesData.itemsPerPage"  ng-options="count for count in [20,50,100,200]" dir="ltr" >  </select> <div class="clearfix"></div> </div>  </div>    <div class="clearfix"></div>  </div> '), 
        $templateCache.put("/portal/templates/auctions/catalogs/search/searchItems.html?0.565", ' <div class="list"  ng-class="{\'mobile-list\':viewPort.mobileMedia}">   <div class="row">  <div class="item" bs-text-direction ng-repeat="lot in pagesData.pageItems" ng-class="{\'pc-item\':viewPort.pcMedia,\'mobile-item\':viewPort.mobileMedia}" bs-log-click="search-lot-{{lot.auction.house.code}}-{{lot.auction.date | date :\'dd.MM.yy\'}}-{{lot.itemIndex}}" ng-click="gotoLot(lot)">  <div class="link"  bs-scroll-on="lot.id == scrollTo" > <div ng-if="viewPort.pcMedia"     ng-include src="\'auctions/catalogs/list/catalogItemWide\' | appTemplate" class="frame"></div> <div ng-if="viewPort.mobileMedia" ng-include src="\'auctions/catalogs/list/catalogItemNarrow\' | appTemplate"  ></div> </div>    </div> <div class="clearfix"></div> </div>   <div class="clearfix"></div> </div>  '), 
        $templateCache.put("/portal/templates/auctions/catalogs/search/searchMain.html?0.565", '<div ng-controller="SearchController" > <div class="catalog search scene"> <div class="content col-xs-12" >   <form name=\'searchForm\' novalidate bs-form  bs-submit="doSearch()" class="float global-search-form" bs-text-direction bs-enter-key-action="doSearch()"> <bs-form-group field-name="phrase" label="catalog_search_all" > <input bs-place-holder name="phrase" class="form-control" debug="true" ng-model="data.token"  /> </bs-form-group> <div class="button noselect" ng-click="doSearch()"> <div class="icon"> </div> </div> <div class="clearfix"></div> </form>  <div class="opposite float home btn-link" ui-sref="app.home">{{"home_back_to" | i18n }}</div>  <div class="clearfix"></div>  <div class="result" ng-class="{invisible:!data.searchedToken}" >  <span ng-if="searching">{{"search_searching" | i18n}}</span> <span ng-if="!searching"> {{ (pagesData.itemsCount ? "search_results" : "search_no_results") | i18n:{count:pagesData.itemsCount, token:data.searchedToken}  }} </span>  </div>  <div class="time-form"> <div class="radio" ng-click="data.searchTime=\'FUTURE\'"> <label> <input type="radio"  ng-model="data.searchTime" value="FUTURE"> {{"search_future" | i18n }} </label> </div> <div clas="clearfix"></div> <div class="radio" ng-click="data.searchTime=\'PAST\'"> <label> <input type="radio"   ng-model="data.searchTime" value="PAST"> {{"search_past" | i18n }} </label> </div> </div>  <bs-catalog-list-pagination data="data" pages-data="pagesData"  position-in-page="currentLang==\'ru\' ? \'\' : \'upper\'" on-current-page-change="onPageChange()" ></bs-catalog-list-pagination> <div bs-scroll-on watched-value="scrollToPagination" offset="-200"></div> <div ng-if="loadState==\'loaded\'"> <br>  <div  ng-include src="\'auctions/catalogs/search/searchItems\' | appTemplate"  ></div>  </div>   <div ng-if="loadState==\'loading\'"> <bs-content-loader ></bs-content-loader> </div>  <bs-catalog-list-pagination data="data" pages-data="pagesData"  position-in-page="\'lower\'" on-current-page-change="onPageChange()"></bs-catalog-list-pagination>   </div> </div> </div>   '), 
        $templateCache.put("/portal/templates/auctions/catalogs/lotPage/lotPageMain.html?0.565", '<div ng-controller="LotPageController" > <div class="catalog  scene lotPage">  <div class="content col-xs-12" >   <div ng-if="data.item "> <div ng-include src="\'auctions/catalogs/lotPage/pc/lotPagePc\' | appTemplate" ng-if="viewPort.pcMedia"></div> <div ng-include src="\'auctions/catalogs/lotPage/mobile/lotPageMobile\' | appTemplate" ng-if="viewPort.mobileMedia"></div> </div> <bs-content-loader loaded="data.item!=null"></bs-content-loader> <div class="clearfix"></div>  </div> </div> </div>   '), 
        $templateCache.put("/portal/templates/auctions/catalogs/lotPage/pc/lotPagePc.html?0.565", '<div  itemscope itemtype="http://schema.org/Product"> <bs-auction-info auction="data.auction" ng-if="data.auction" ></bs-auction-info>   <table> <tr> <td class="info-td"> <div class="lot-number" itemprop="sku"> {{"lot_number" | i18n:{number:data.item.itemIndex} }} </div> <div class="upper-title"> <h2 class="lot-name"  itemprop="name" ng-bind-html="data.lotTitle"> </h2> <div ng-if="showMore" bs-text-direction class="btn btn-link more-link" ng-click="scrollToDescription()"> {{"more" | i18n }}... </div> </div>  </td>   <td class="float actions-td"> <bs-lot-page-navigation lot="data.item"></bs-lot-page-navigation> <bs-lot-favorite-flag class="float" lot="data.item"></bs-lot-favorite-flag> </td> </tr> <tr>  <td class="info-td">  <bs-lot-page-images lot="data.item"></bs-lot-page-images> </td> <td class="float actions-td"> <bs-lot-bid-form lot="data.item"></bs-lot-bid-form> <bs-lot-share-buttons class="opposite float" lot="data.item" text="data.lotTitle" ></bs-lot-share-buttons> <div class="clearfix"></div>  <div ng-include src="\'auctions/catalogs/elements/lotPageInfoLinks\' | appTemplate" ></div>   <div class="clearfix"></div> </td>  </tr>  </table>  <div class="lot-description-section" itemprop="description" ng-if="data.lotDesc" bs-scroll-on watched-value="scrollToDescriptionFlag">   <h4 class="description-text" ng-bind-html="data.lotDesc"></h4> </div>  <bs-lot-page-navigation lot="data.item"></bs-lot-page-navigation> </div>  '), 
        $templateCache.put("/portal/templates/auctions/catalogs/lotPage/pc/lotZoomModal.html?0.565", '<div class="zoom-image noselect"> <div class="modal-header"> <button type="button" class="close" ng-click="$close()">&times;</button>  <bs-lot-page-zoom lot="data.item" initial-image-ind="data.imageInd"> </bs-lot-page-zoom> </div>  </div>   '), 
        $templateCache.put("/portal/templates/auctions/catalogs/lotPage/mobile/lotZoomSubScene.html?0.565", '<div class="lot-sub-scene zoom" ng-style="{height:viewPort.clientHeight-150}" bs-scroll-to-top>  <a class="btn btn-link back" ui-sref="^">{{"lot_back" | i18n : {number:data.item.itemIndex} }}</a> <bs-lot-page-zoom lot="data.item"> </bs-lot-page-zoom>  </div>   '), 
        $templateCache.put("/portal/templates/auctions/catalogs/lotPage/mobile/lotPageMobile.html?0.565", '<div> <div ng-show="\'app.lotPage\' | isState"> <bs-auction-info auction="data.auction" ng-if="$stateParams.source==\'search\' && data.auction" ></bs-auction-info>  <div class="first-row"> <bs-lot-page-navigation lot="data.item" class="opposite float"></bs-lot-page-navigation> <bs-lot-favorite-flag class="float" lot="data.item"></bs-lot-favorite-flag> <div class="clearfix"></div> </div> <div class="second-row">  <div class="float lot-number"> {{"lot_number" | i18n:{number:data.item.itemIndex} }} </div>  <div class="clearfix"></div> </div> <div class="upper-title"> <div class="lot-name" ng-bind-html="data.lotTitle"> </div> <div ng-if="showMore" bs-text-direction class="btn btn-link more-link" ng-click="scrollToDescription()"> {{"more" | i18n }}... </div> </div>  <bs-lot-page-images lot="data.item"></bs-lot-page-images>  <bs-lot-share-buttons lot="data.item" text="data.lotTitle" ></bs-lot-share-buttons>  <bs-lot-bid-form lot="data.item" ></bs-lot-bid-form>    <div class="lot-description-section" ng-if="data.lotDesc" bs-scroll-on watched-value="scrollToDescriptionFlag"> <div class="description-text" ng-bind-html="data.lotDesc"></div> </div>  <div ng-include src="\'auctions/catalogs/elements/lotPageInfoLinks\' | appTemplate" ></div>  <div class="clearfix"></div> <br><br> <div class="float">  <bs-lot-page-navigation lot="data.item"  ></bs-lot-page-navigation> </div>  <div class="clearfix"></div> </div>   <div ui-view > </div>   </div>  '), 
        $templateCache.put("/portal/templates/auctions/catalogs/lotPage/common/confirmation/confirmBid.html?0.565", '<div class="confirm-bid" ng-controller="ConfirmBidController"  ng-init="init()" > <table> <tr> <td class="pic-columm" rowspan="3"> <bs-lot-image lot="lot" size="120x120" image-ind="0"  image-mode="\'fit\'"> </bs-lot-image> </td> <td class="caption"> {{"confirm_bid_lot" | i18n}}: </td> <td class="value"> {{lot.itemIndex}} </td>  </tr>  <tr> <td class="caption"> {{"confirm_bid_desc" | i18n}}: </td> <td class="value" ng-bind-html="lot | lotText:60"> </td> </tr> <tr> <td class="caption"> {{"confirm_bid_price" | i18n}}: </td> <td class="price value"> {{bidPrice | sumInCurrency:lot.auction.catalogInfo.currency}} </td> </tr> </table>  <div class="clearFix"></div>  <div class="terms-message"> <bs-linkable-text options="{ textKey:\'confirm_bid_terms_message\', textParams:{houseName:(lot.auction.house.details.name | langField)}, onLinkClick:showTerms  }" > </bs-linkable-text> </div>     </div>   '), 
        $templateCache.put("/portal/templates/auctions/catalogs/lotPage/common/images/lotPageImages.html?0.565", '<div class="lot-images-section"> <div class="big-image zoom-in-cursor" > <bs-lot-image lot="lot" size="{{mainImagewidth}}x" image-ind="0" ng-click="zoomImage(lot, 0)" ></bs-lot-image> </div>   <div class="thumbs" ng-if="lot.imagesList.length>1"> <div ng-repeat = "imageName in lot.imagesList" class="float thumb zoom-in-cursor" ng-click="zoomImage(lot, $index)" ng-if="!$first"> <bs-lot-image   lot="lot" size="x80" image-ind="$index"> </bs-lot-image> </div> <div class="clearfix"></div> </div>  </div>    '), 
        $templateCache.put("/portal/templates/auctions/catalogs/lotPage/common/images/lotPageZoom.html?0.565", '<div> <div class="lot-page-zoom-image-navigation" ng-if="lot.imagesList.length>1" dir="ltr"> <div class="prev link " ng-click="prevImage()"><div class="text"></div></div> <div class="thumbs" bs-width-limit="{lessThen:\'screenWidth - 150\'}"> <div ng-repeat = "imageName in lot.imagesList"  class="thumb"  thumb-ind="$index" ng-click="setZoomImage($index)" ng-class="{selected:selectedImageInd == $index}"> <bs-lot-image   lot="lot" size="x50" image-ind="$index"> </bs-lot-image> </div> </div> <div class="prev link noselect" ng-click="nextImage()"><div class="text"></div></div> <div class="clearfix"></div> </div>  <div class="big-image" ng-class="cursorZoomClass"> <bs-lot-image  lot="lot" image-ind="selectedImageInd" watchable="true" enable-magnifier="{{options.enableMagnifier}}"  size="{{options.size}}" move-in-frame="options.moveInFrame"  as-bg="options.asBg"  image-mode="options.imageMode" debug="true"  ng-click="toggleImageMode()"  loaded-image-info="loadedImageInfo"> </bs-lot-image> </div>   </div>  '), 
        $templateCache.put("/portal/templates/auctions/catalogs/lotPage/common/increments.html?0.565", '<div class="increments-table">  <table class="table table-striped table-bordered table-hover" dir="{{dir}}"> <tr> <th class="default-align">{{"increment_price" | i18n}}</th> <th class="default-align">{{"increment_step" | i18n}}</th> </tr> <tr ng-repeat="step in options.data.steps"> <td class="default-align">{{step.price | sumInCurrency:options.data.currency}}</th> <td class="default-align">{{step.increment | sumInCurrency:options.data.currency}}</th> </tr> </table>  </div>   '), 
        $templateCache.put("/portal/templates/auctions/catalogs/lotPage/common/inquiry/inquiryForm.html?0.565", '<div class="inquiry-form" ng-controller="InquiryFormController"  ng-init="init()">  <p> <label>{{"inquiry_form_to" | i18n }}:&nbsp;</label>{{"inquiry_form_house" | i18n:{house:options.data.house} }} </p>  <br> <p> <label>{{"inquiry_form_subject" | i18n }}:&nbsp;</label><span ng-bind-html="inquiryData.subject"></span> </p>  <br>  <form name=\'inquiryForm\'  novalidate bs-form  bs-submit="sendInquiry()"> <bs-form-group field-name="content" label="inquiry_form_content"> <label></label> <bs-form-validation-message  ></bs-form-validation-message> <textarea  rows="7"  class="form-control"  required name="content" ng-model="inquiryData.content"> </textarea>  </bs-form-group>  </form>     </div>   '), 
        $templateCache.put("/portal/templates/auctions/catalogs/lotPage/common/navigation/lotPageNavLink.html?0.565", '<div class="float">  <div ng-if="name==\'previous\'"> <div class="float arrow {{lang}}" ng-class="{\'point-left\':direction==\'ltr\', \'point-right\':direction==\'rtl\'}"></div> <div class="float text" ng-if="showText">&nbsp; {{"catalog_nav_previous" | i18n  }}</div> </div>  <div ng-if="name==\'next\'"> <div class="float text" ng-if="showText">{{"catalog_nav_next" | i18n  }}&nbsp;</div> <div class="float arrow {{lang}}" ng-class="{\'point-right\':direction==\'ltr\', \'point-left\':direction==\'rtl\'}"></div> </div>    </div>     '), 
        $templateCache.put("/portal/templates/auctions/catalogs/lotPage/common/navigation/lotPageNavigation.html?0.565", '<div class="opposite float lot-page-navigation" >  <div ng-switch="source"> <div ng-switch-when="catalog"> <a class="float btn " ng-href="#!/catalog/auction/{{lot.auctionId}}/"> {{"catalog_nav_catalog" | i18n  }} </a>  <a  ng-if="previousLotId" class="float btn btn-link" ng-href="#!/lotPage/source/catalog/auction/{{lot.auctionId}}/lot/{{previousLotId}}" > <div> <bs-lot-page-nav-link name="\'previous\'"> </bs-lot-page-nav-link> </div>  </a> <div ng-if="!previousLotId" class="disabled btn float" > <bs-lot-page-nav-link name="\'previous\'"> </bs-lot-page-nav-link> </div>  <a ng-if="nextLotId" class="float btn btn-link"  ng-href="#!/lotPage/source/catalog/auction/{{lot.auctionId}}/lot/{{nextLotId}}" > <bs-lot-page-nav-link name="\'next\'"> </bs-lot-page-nav-link> </a>  <div ng-if="!nextLotId" class="disabled btn float" > <bs-lot-page-nav-link name="\'next\'"> </bs-lot-page-nav-link> </div>  <div class="clearfix"></div> </div>  <div ng-switch-when="account">  <div class="float btn btn-link" ui-sref="app.myAccount({houseId:lot.auction.house.id})"> {{"my_account_back_to" | i18n  }} </div>  </div>  <div ng-switch-when="search">  <a class="float btn btn-link" ui-sref="app.search"> {{"search_back_to" | i18n  }} </a> <a class="float btn btn-link"   ng-href="#!/catalog/auction/{{lot.auctionId}}/"> {{"catalog_nav_full_catalog" | i18n  }} </a>  </div>  <div ng-switch-when="favorites">  <a class="float btn " ui-sref="app.favorites"> {{"favorites_back_to" | i18n  }} </a> <a class="float btn "   ng-href="#!/catalog/auction/{{lot.auctionId}}/"> {{"catalog_nav_full_catalog" | i18n  }} </a>  </div>   </div> </div> '), 
        $templateCache.put("/portal/templates/auctions/catalogs/elements/lotImage.html?0.565", '<div class="lot-image" ng-class="{\'narrow-height\':narrowHeight}"> <div class="state-info" ng-if="stateVisible" bs-text-direction>{{stateInfo | i18n}}</div> <img ng-if="!enableMagnifier" ng-src="{{loadedImageSrc}}"  ng-show="loadedImageSrc && !stateVisible">  <div  ng-if="enableMagnifier && loadedImageSrc && !stateVisible"  data-ng-magnify  image-src="{{loadedImageSrc}}"  data-glass-width="250" data-glass-height="250" ></div> {{scope.stateVisible}}  </div> '), 
        $templateCache.put("/portal/templates/auctions/catalogs/elements/lotExpiration.html?0.565", '<div class="lot-expiration" ng-class="expirationState" > {{text}} </div> '), 
        $templateCache.put("/portal/templates/auctions/catalogs/elements/lotPageInfoLinks.html?0.565", '<div class="info-link default-align" ng-click="toggleFavorite()"> <span ng-if="!data.item.isFavorite"> <span class="plus">+</span>&nbsp;<span class="btn btn-link">{{"lot_page_add_to_favorites" | i18n }}</span> </span>  <span ng-if="data.item.isFavorite" class="btn btn-link">{{"lot_page_remove_from_favorites" | i18n }}</span> <span class="fade-in-out fade toast" ng-animate  ng-class="{on:favoriteToastMessage,off:!favoriteToastMessage}">{{favoriteToastMessage | i18n}}</span> </div>  <div class="btn btn-link info-link default-align" ng-click="openAuctionHouseTerms()" > {{"house_terms" | i18n:{house:(data.auction.house.details.name | langField)} }}</div>  <div class="btn btn-link info-link default-align animation" ng-click="showIncrements()" > {{"house_increments" | i18n }}</div>  <div class="info-link default-align" ng-click="showInquiryForm()"  > <span class="btn btn-link">  {{"lot_page_inquiry" | i18n }} </span>  <span class="fade-in-out fade toast" ng-animate  ng-class="{on:showInquiryToast,off:!showInquiryToast}">{{"lot_page_inquiry_sent" | i18n}}</span> </div> '), 
        $templateCache.put("/portal/templates/auctions/catalogs/elements/lotPrice.html?0.565", '<div class="lot-price" itemprop="offers" itemscope itemtype="http://schema.org/Offer">  <div class="lot-price-row" ng-if="showStartPrice"> <div class="lot-price-label start-price">{{"lot_start_price" | i18n}}:</div> <div class="lot-price-value" bs-auto-font-size="{grow:false,minSize:7,maxWidth:maxWidth}" ng-bind-html="startPrice"></div> <div class="clearfix" ng-if="breakOnRow"></div> </div> <div class="lot-price-row" ng-if="showNoPrice"> <div class="lot-price-label no-price" itemprop="price">{{"lot_no_price" | i18n}}</div> <div class="clearfix" ng-if="breakOnRow"></div>  </div> <div class="lot-price-row" ng-if="showEstimatedPrice"> <div class="lot-price-label estimated-price"  >{{"lot_estimated_price" | i18n}}:</div> <div class="lot-price-value" dir="ltr" bs-auto-font-size="{grow:false,minSize:7,maxWidth:maxWidth}" max-width="maxWidth" ><div ng-bind-html="estimatedPrice"></div></div> <div class="clearfix" ng-if="breakOnRow"></div> </div> </div> '), 
        $templateCache.put("/portal/templates/auctions/catalogs/elements/registrationPromotion.html?0.565", '<div class="registration-promotion"> <div ng-if="auction "> <div ng-if="auction.state==\'ENDED\'"> <span class="text" > {{\'promotion_auction_ended\' | i18n}}</span> </div> <div ng-if="auction.state!=\'ENDED\'"> <div ng-if="auction.catalogOnly">  <span class="text" > {{\'promotion_catalog_only\' | i18n:houseParams}}</span> </div>  <div ng-if="!auction.catalogOnly">  <div ng-if="auction.state==\'RUNNING\'" > <div class="float button" ng-click="openAuctionSite()"> <div class="text">{{text(\'promotion_live_auction\')}}</div> </div> <div class="clearfix"></div>  </div>  <div ng-if="auction.state==\'READY\'" ng-switch="userState"> <div ng-switch-when="NOT_LOGGED_IN"> {{text(\'promotion_not_logged_in_auction\')}}&nbsp-&nbsp; <span class="no-break"> <span><span class="button" ng-click="setAuthScene(\'login\')"> <span class="text">{{\'link_login\' | i18n}}</span></span>  <span class="">&nbsp;/&nbsp;</span>  <span class="button" ng-click="setAuthScene(\'register\')"> <span class="text"> {{\'link_register\' | i18n}}</span></span> <span class="clearfix"></span> </span>  </div> <div ng-switch-when="NOT_REGISTERED"> <span class="float text"> {{text(\'promotion_not_registered_to_auction\')}}&nbsp-&nbsp;</span> <div class="float button" ng-class="{\'disabled waiting\':requestInProgress}" ng-click="requestApproval()"> <div class="text">  {{\'promotion_register_to_house\' | i18n}} </div>  </div> <span class="clearfix"></span> </div> <div ng-switch-when="PENDING"> <span class="text">  {{\'promotion_pending\' | i18n}}</span> </div>  <div ng-switch-when="INCOMPLETE_PROFILE"> <span class="text">  {{\'promotion_pending\' | i18n}}</span> </div>  <div ng-switch-when="APPROVED"> <span class="text" > {{text(\'promotion_approved\')}}</span> </div> </div> </div> </div> </div>  <div ng-if="!auction && house && !house.site.down">  <div ng-switch="userState"> <div ng-switch-when="NOT_LOGGED_IN"> {{\'promotion_not_logged_in_house\' | i18n:{house:(house.details.name | langField)} }}&nbsp-&nbsp; <span class="no-break"> <span><span class="button" ng-click="setAuthScene(\'login\')"> <span class="text">{{\'link_login\' | i18n}}</span></span>  <span class="">&nbsp;/&nbsp;</span>  <span class="button" ng-click="setAuthScene(\'register\')"> <span class="text"> {{\'link_register\' | i18n}}</span></span> <span class="clearfix"></span> </span> </div> <div ng-switch-when="NOT_REGISTERED"> <span class="float text"> {{\'promotion_not_registered_to_house\' | i18n }}&nbsp-&nbsp;</span> <div class="float button" ng-class="{\'disabled waiting\':requestInProgress}" ng-click="requestApproval()"> <div class="text">  {{\'promotion_register_to_house\' | i18n}} </div>  </div> <span class="clearfix"></span> </div> <div ng-switch-when="PENDING"> <span class="text">  {{\'promotion_pending\' | i18n}}</span> </div>  <div ng-switch-when="INCOMPLETE_PROFILE"> <span class="text">  {{\'promotion_pending\' | i18n}}</span> </div>  <div ng-switch-when="APPROVED"> <span class="text" > {{text(\'promotion_approved\')}}</span> </div> </div> </div> </div>    '), 
        $templateCache.put("/portal/templates/auctions/catalogs/elements/auctionInfo.html?0.565", '<div class="auction-info center-block" > <div class="float auction-texts"> <h3 class="auction-name" id="auctionInfo" ui-sref="app.catalog({auctionId:auction.id})">  <span ng-if="auction.number"> {{"auction_label_number_public" | i18n:{number:auction.number} }} <span ng-if="auction.part"> {{("auction_part_"+auction.part) | i18n}}  </span> - </span>  <span> {{auction.name | langField}} </span> </h3> <h2 class="house-name"> <a ng-href="#!/houses/{{auction.house.code}}" class="btn-link" ng-if="auction.house.orderInd">{{ "catalog_house_name" | i18n:{name:(auction.house.details.name | langField)} }}</a> <span ng-if="!auction.house.orderInd">{{ "catalog_house_name" | i18n:{name:(auction.house.details.name | langField)} }}</span>  </h2>   <div class="time-and-location"> <span>{{auction | auctionTime}}</span> <span ng-if="auction.address | langField"> , {{auction.address | langField}} </span>  </div> <div ng-if="auction.state!=\'ENDED\'"> <span class="terms btn-link" ng-click="showHouseTerms()">{{"house_terms_short" | i18n}}</span>  &nbsp;&nbsp;&nbsp;&nbsp; <span ng-if="auction.state!=\'ENDED\' && auction.displayHours[currentLang]" class="display-hours btn-link" ng-click="showDisplayHours()">{{"catalog_display_hours" | i18n}}</span> </div>    </div> <div class="opposite float logo" bs-cloudinary-bg="{{(auction.house.resources[\'mainPageLogo\'])}}" params="{size:\'188x74\'}"></div> <div class="clearfix"></div>  <div class="long-details" ng-if="auction.longDetails | langField" style="color:{{auction.textColors.details}}" ng-bind-html="\'<BR>\'+(auction.longDetails | langField)"> </div>   <bs-house-regisration-promotion auction="auction" > </bs-house-regisration-promotion> <hr>  <bs-auction-structured-data auction="auction"></bs-auction-structured-data>   </div>  '), 
        $templateCache.put("/portal/templates/auctions/catalogs/elements/lotBadge.html?0.565", '<div class="lot-badge" ng-class="badgeType" > <div class="text" ng-class="{\'long-text\':longText}" ng-if="visible" ng-bind-html="text | capitalize"  ></div> </div> '), 
        $templateCache.put("/portal/templates/auctions/catalogs/elements/lotFavoriteFlag.html?0.565", '<div  class="favorite-flag"  ng-class="{on:lot.isFavorite,off:!lot.isFavorite,\'just-changed\':justChanged}"  ng-click="toggleFavorite()"  title="{{(lot.isFavorite ? \'lot_page_remove_from_favorites\' : \'lot_page_add_to_favorites\' ) | i18n}}"  ng-mouseout="onMouseOut()" ng-mouseover="onMouseOver()" > </div> '), 
        $templateCache.put("/portal/templates/auctions/catalogs/elements/shareButtons.html?0.565", '  <div class="share-buttons" > <div ng-repeat="button in [\'fb\',\'twitter\',\'google\',\'pinterest\',\'email\']" class="float button" ng-class="button"  ng-click="share(button)" title="{{buttonName(button)}}"></div> <div class="clearfix"></div> </div>  '), 
        $templateCache.put("/portal/templates/auctions/catalogs/elements/bidForm.html?0.565", '  <div class="bid-form" bs-text-direction > <div ng-if="scrollToForm" bs-scroll-on="scrollToForm" offset="-200">&nbsp;</div>  <div class="bid-info" ng-if="bidLabel" > <table> <tr> <td class=\'bid-label\'>{{bidLabel.text}}:</td> <td class=\'bid-label-space\'></td> <td class=\'bid-price\'>{{bidLabel.price}}</td> </tr> <tr ng-if="mode==\'existing\'" > <td></td> <td class=\'bid-label-space\'></td> <td> <div class="links"> <div class="float btn-link" ng-click="setEditMode()">{{"dialogs_edit" | i18n}}</div> <div class="float bid-link-space"></div> <bs-async-button button-class="\'left btn-link\'" action-fn="removeBidIfConfirmed()" label="\'dialogs_remove\'" ></bs-async-button> <div class="clearfix"></div> </div> </td> </tr> </table> </div>  <div class="edit-mode" ng-if="mode==\'edit\' || mode==\'new\'"> <label> {{"lot_leave_bid" | i18n }}</label> <form> <input dir="ltr" ng-model="model.bidPrice" class="float form-control" type="number" ng-blur="saveRecentBidInputValue()" bs-focus-on="focusNow"> <div class="float currency">{{lot.auction.catalogInfo.currency}}	</div>  <bs-async-button button-class="\'float orange common-button \'+currentLang" action-fn="tryToPlaceBid()" bs-current-lang label="\'lot_submit_bid\'" ></bs-async-button>  <div class="clearfix"></div> <div ng-if="mode==\'edit\'" class="cancel btn btn-link lowercase" ng-click="cancelEdit()">{{"dialogs_cancel" | i18n}}</div> </form> <div class="clearfix"></div> </div>    <div class="bid-info disabled-mode" ng-if="mode==\'disabled\'"> <label ng-bind-html="getDisabledMessage()"></label> </div>  <div class="bid-info ended-mode" ng-if="mode==\'ended\'"> <label ng-if="!lot.soldLotBid"> {{"lot_not_sold" | i18n }} </label> </div>  <div class="bid-info runnung-mode" ng-if="mode==\'running\'"> <label>{{"auction_running" | i18n }}</label> <div class="center-block common-button live darkBlue" ng-click="openAuctionSite()"> <div class="text"> {{"home_auction_enter" | i18n }} </div> </div> </div>  <bs-lot-price lot="lot"  single-row="false" break-on-row="true"></bs-lot-price>  <div class="past-lot" ng-if="mode==\'ended\'"> <bs-linkable-text options="{ textKey:\'lot_past_info\', textParams:{house:(lot.auction.house.details.name | langField), date:(lot.auction.date | date:\'dd/MM/yyyy\')}, onLinkClick:gotoHousePage  }" > </bs-linkable-text> </div> </div>  '), 
        $templateCache.put("/portal/templates/auctions/home/homeMain.html?0.565", '<div ng-controller="HomeController"  > <div class="home scene"> <div class="upper-part" ng-class="screenHeightClass" > <bs-houses-carousel></bs-houses-carousel> <div class="overlay">  <div class="message center-block fluid-container col-md-9 col-lg-7 col-xs-12"> <div class="logo-icon" bs-check-bidmood></div>  <h1  ng-bind-html="upperMessage"></h1>  <h4 class="features with-links" ng-if="featuresAsLinks" >  <a href="#!/help/search"> {{\'home_upper_feature_search\' | i18n}}</a> <span class="bullet"></span> <a href="#!/help/live">{{\'home_upper_feature_live\' | i18n}}</a> <span class="bullet"></span> <a href="#!/help/bids">{{\'home_upper_feature_bid\' | i18n}}</a> </h4>  <h4 class="features" ng-if="!featuresAsLinks" >  *{{\'home_upper_feature_search\' | i18n}} <span class="bullet"></span> {{\'home_upper_feature_live\' | i18n}} <span class="bullet"></span> {{\'home_upper_feature_bid\' | i18n}} </h4> </div>  </div>  </div>  <div class="content" ng-class="screenHeightClass">  <bs-content-loader loaded="data.auctions"></bs-content-loader>  <div ng-if="data.auctions" > <form name=\'searchForm\' novalidate bs-form  bs-submit="gotoSearch()" class="global-search-form" bs-text-direction> <bs-form-group field-name="phrase" label="catalog_search_all" > <input bs-place-holder name="phrase" class="form-control" ng-model="data.searchToken" bs-enter-key-action="gotoSearch()"/> </bs-form-group> <div class="button" ng-click="gotoSearch()"></div> <div class="clearfix"></div> </form>  <div bs-scroll-on="scrollToAuctions" watched-value="scrollToAuctions" offset="auctionScrollOffset"> </div>  <bs-auctions-lists-group  auctions-data="data"  show-region-selection="!bidmoodEnv"  future-house-name-as-link="true"  minimized-view="minimizedView"  ng-class="screenHeightClass"  >  </bs-auctions-lists-group>   <div ng-if="data.auctions.length"> <a g-style="{display:data.auctions.length ? \'block\' : \'none\'}" href="#!/results/all/1"  class="results orange common-button col-lg-4 col-xs-10" bs-check-bidmood> <div class="text"> {{\'home_auctions_results\' | i18n}} </div>  </a> </div>    </div> </div>  </div> </div>   '), 
        $templateCache.put("/portal/templates/auctions/lists/auctionsListsGroup.html?0.565", '<div class="auctions-lists-group">  <div class="title" ng-if="data.nextAuctions.length"> <div class="space hidden-xs" ng-if="data.nextAuctions.length && showRegionSelection"> </div> <h3 class="caption" ng-if="data.nextAuctions.length"> {{\'auctions_list_next\' | i18n}}</h3> <div uib-dropdown class="region-selection btn-group" ng-class="currentLang"  is-open="status.isopen" ng-if="showRegionSelection" > <div type="button" class="default-align selected entry" uib-dropdown-toggle > <div class="float icon {{currentRegion | lowercase}}"></div> <div class="float text">{{("region_"+currentRegion) | i18n }}</div> <div class="opposite float caret {{dir}}" ></div> <div class="clearfix"></div> </div> <ul class="uib-dropdown-menu" role="menu"> <li  ng-repeat="region in regions" ng-if="region!=currentRegion"> <a class="default-align entry" ng-href="{{regionLink(region)}}"> <div class="float icon {{region | lowercase}}"></div> <div class="float text">{{("region_"+region) | i18n}}</div> <div class="clearfix"></div> </a>  </li> </ul>  </div> </div>  <div ng-if="nextAuctionsVisible">  <div class="short-separator"></div> <bs-auctions-list auctions="data.nextAuctions" view="\'next\'" ></bs-auctions-list> </div>   <div ng-if="futureAuctionsButtonVisible"> <button bs-check-bidmood class="future orange common-button col-lg-4 col-xs-10" ng-click="showFutureAuctions()"> <div class="text">{{\'auctions_list_show_future\' | i18n}}</div> </button> </div>   <div ng-if="futureAuctionsVisible" bs-scroll-on watched-value="scrollToFutureAuctions" debug-key="future">  <div class="title"> <h3 class="caption">{{\'auctions_list_future\' | i18n}}</h3> </div>  <div class="short-separator"></div> <bs-auctions-list auctions="data.futureAuctions" house-name-as-link="futureHouseNameAsLink" view="\'future\'" ></bs-auctions-list> </div>   <div ng-if="recentAuctionsVisible" > <div class="title"> <h3 class="caption">{{(showAllPastAuctions ? \'auctions_list_past\' : \'auctions_list_recent\') | i18n}}</h3> </div>  <div class="short-separator"></div> <bs-auctions-list auctions="data.recentAuctions" view="\'recent\'"  ></bs-auctions-list> </div>  </div> '), 
        $templateCache.put("/portal/templates/auctions/lists/auctionsList.html?0.565", '<div class="list" ng-class="[screenView,view]">  <div class="row {{screenView}}" bs-text-direction > <div class="item col-md-3 col-xs-12"  ng-repeat="auction in auctions" ng-click="onAuctionClick(auction)" bs-log-click="auction-{{auction.house.code}}-{{ (auction.date | date :\'dd.MM.yy\') }}", ng-animate ng-class="{clickable:isAuctionClickable(auction)}" bs-scroll-on="auction.id == scrollTo" >  <div  ng-if="screenView==\'wide\'"     ng-include src="\'auctions/lists/auctionListItemWide\' | appTemplate" class="frame"> </div> <div  ng-if="screenView==\'narrow\'"     ng-include src="\'auctions/lists/auctionListItemNarrow\' | appTemplate" class="frame"> </div> </div> </div>  </div> '), 
        $templateCache.put("/portal/templates/auctions/lists/auctionListItemNarrow.html?0.565", '<div class="frame viewport_{{viewPort.viewPortWidth}}" >  <!--  {{auction.hoursTillAuction}} -->  <auction-badge auction="auction" is-today="auction.date==today"></auction-badge>   <div class="float image"  bs-cloudinary-bg="{{(auction.resources[\'topItem\'] || auction.house.resources[\'mainPageLogo\'])}}" ng-class="{contain:auction.resources[\'topItem\']!=null}"  params="{size:imageSize} "> </div>  <div class="opposite float texts" >  <h2> {{auction.house.details.name | langField}}  </h2> <div class="number" ng-if="auction.number"> {{"auction_label_number" | i18n:{number:auction.number} }}&nbsp; <span class="part" ng-if="auction.part"> {{("auction_part_"+auction.part) | i18n}}  </span> </div>  <div class="time" > {{auction | auctionTime}}  </div>  <div class="name"> <div ng-bind-html="auction.name | langField"></div> <div ng-if="auction.shortDetails | langField" style="color:{{auction.textColors.details}}" ng-bind-html="auction.shortDetails | langField"></div> </div>  <button class="float common-button"   ng-class="auctionButtonClass(auction)" ng-if="auction.state!=\'PENDING\'">  <div class="text"> {{auctionButtonText(auction) | i18n}} </div> </button>  <div ng-if="auction.state==\'PENDING\'" class="pending-label"  ng-if="view!=\'future\'" ng-class="{blink:auction.clickedRecently}"> <div class="text"> {{auctionButtonText(auction) | i18n}} </div> </div>   <div class="clearfix"></div>  </div>  <div class="clearfix"></div>  </div> '), 
        $templateCache.put("/portal/templates/auctions/lists/auctionListItemWide.html?0.565", '<div class="frame" >  <!--  {{auction.hoursTillAuction}} -->   <div class="image"  bs-cloudinary-bg="{{(auction.resources[\'topItem\'] || auction.house.resources[\'mainPageLogo\'])}}" ng-class="{contain:auction.resources[\'topItem\']!=null}"  params="{size:imageSize} "> <auction-badge auction="auction" is-today="auction.date==today"></auction-badge> </div>   <div class="texts"> <h2> <a class="btn-link" ng-href="#!/houses/{{auction.house.code}}" ng-if="isAuctionHouseLink(auction)">{{auction.house.details.name | langField}}</a> <span ng-if="!isAuctionHouseLink(auction)">{{auction.house.details.name | langField}}</span> <span ng-if="auction.number">- {{"auction_label_number" | i18n:{number:auction.number} }}</span> </h2> <div class="part" ng-if="auction.part"> {{("auction_part_"+auction.part) | i18n}}  </div>  <div class="time" > {{auction | auctionTime}} </div> <div class="short-separator"></div> <div class="name"> <div ng-bind-html="auction.name | langField"></div> <div ng-if="auction.shortDetails | langField" style="color:{{auction.textColors.details}}" ng-bind-html="auction.shortDetails | langField"></div> </div> <bs-auction-structured-data auction="auction"></bs-auction-structured-data> </div>   <div class="center-block common-button " bs-check-bidmood  ng-class="auctionButtonClass(auction)" ng-if="view!=\'future\'"> <div class="text"> <a ng-if="isLinkbutton(auction)" ng-href="#!/catalog/auction/{{auction.id}}/1">{{auctionButtonText(auction) | i18n}}</a> <span  ng-if="!isLinkbutton(auction)" >{{auctionButtonText(auction) | i18n}}</span> </div> </div>  </div> '), 
        $templateCache.put("/portal/templates/auctions/lists/auctionBadge.html?0.565", ' <div class="badge-frame" ng-show="shouldShow" > <div class="text">{{text}}</div> </div>      '), 
        $templateCache.put("/portal/templates/userDetails/userDetailsMain.html?0.565", '<div ng-controller="UserDetailsController" class="userDetails scene" bs-scroll-to-top> <div class="narrow upper-part">  <div class="dark overlay">  <div class="message center-block container col-lg-7 col-md-7 col-sm-8 col xs-12"> <h1>{{"user_details_title" | i18n}}</h1> <div class="short-separator"></div> </div> </div> </div>  <div class="content container">  <h4>{{"user_details_message" | i18n}}</h4> <br>  <uib-accordion ng-if="currentUser" > <uib-accordion-group ng-repeat="section in sections" is-open="opened[section]"> <uib-accordion-heading> <div> <div class="section-name    col-sm-4  float">{{"user_details_"+section | i18n}}</div> <div class="section-summary col-sm-5 float">{{getSectionSummary(section)}}</div> <div class="edit btn-link   col-sm-3  opposite float opposite-align" ng-show="!opened[section]">{{"dialogs_edit" | i18n}}</div> <div class="clearfix"></div> </div> </uib-accordion-heading> <div class="section-content col-lg-6 col-md-7 col-sm-8 col-xs-12" ng-class="section"> <div  ng-include src="(\'userDetails/sections/\'+section +\'Section\') | appTemplate" ng-if="opened[section]"> </div> </div> </uib-accordion-group> </uib-accordion> </div>   </div> '), 
        $templateCache.put("/portal/templates/userDetails/sections/nameSection.html?0.565", '<div class="name-section" >  <form name=\'nameUpdateForm\'  novalidate bs-form  bs-submit="updateUserInfo(\'name\')">   <bs-form-group field-name="firstName" label="user_details_first_name"> <label class="float"></label> <bs-form-validation-message css-class="float"></bs-form-validation-message> <div class="clearfix"></div> <input  name="firstName" class="form-control" ng-model="data.user.firstName" required ng-minlength="2" ng-pattern="bsValidationPatterns.alpha"/>  </bs-form-group>  <bs-form-group field-name="lastName" label="user_details_last_name"> <label  class="float"></label> <bs-form-validation-message css-class="float"></bs-form-validation-message> <div class="clearfix"></div> <input  name="lastName" class="form-control" ng-model="data.user.lastName" required ng-minlength="2" ng-pattern="bsValidationPatterns.alpha"/> </bs-form-group>   <div class="buttons-row"> <bs-async-button button-class="\'float orange common-button\'"  bs-form-controller="nameUpdateForm" label="\'dialogs_save\'" > </bs-async-button> <div class="float btn-link" ng-click="onUpdateDone(\'name\')">{{"dialogs_cancel" | i18n}}</div> <div class="clearfix"></div> </div>   <div class="clearfix"></div> </form> </div>  '), 
        $templateCache.put("/portal/templates/userDetails/sections/shippingSection.html?0.565", '<div class="shipping-section" >  <div class="form-group checkbox-row"> <input  type="checkbox" class="float" name="residenceIsShipping" ng-model="data.userDetails.shippingAddress.residenceIsShipping"/> <label class="float">{{\'user_details_shipping_is_residence\' | i18n}}</label> <div class="clearfix"></div> </div>   <form name=\'shippingUpdateForm\'  novalidate bs-form  bs-submit="updateShippingAddress()"  > <bs-user-details-address address="data.userDetails.shippingAddress" ng-show="!data.userDetails.shippingAddress.residenceIsShipping"></bs-user-details-address> <div class="buttons-row" > <bs-async-button  button-class="\'float orange common-button\'"  bs-form-controller="shippingUpdateForm" label="\'dialogs_save\'" > </bs-async-button> <div class="float btn-link" ng-click="onUpdateDone(\'shipping\')">{{"dialogs_cancel" | i18n}}</div> <div class="clearfix"></div> </div>  </form>       </div>  '), 
        $templateCache.put("/portal/templates/userDetails/sections/companySection.html?0.565", '<div class="company-section" >  <form name=\'companyUpdateForm\'  novalidate bs-form  bs-submit="updateUserInfo(\'company\')">   <bs-form-group field-name="company" label="user_details_company"> <label class="float"></label> <bs-form-validation-message css-class="float"></bs-form-validation-message> <div class="clearfix"></div> <input  name="company" class="form-control" ng-model="data.user.company"/>  </bs-form-group>   <div class="buttons-row"> <bs-async-button button-class="\'float orange common-button\'"  bs-form-controller="companyUpdateForm" label="\'dialogs_save\'" > </bs-async-button> <div class="float btn-link" ng-click="onUpdateDone(\'company\')">{{"dialogs_cancel" | i18n}}</div> <div class="clearfix"></div> </div>   <div class="clearfix"></div> </form> </div>  '), 
        $templateCache.put("/portal/templates/userDetails/sections/residenceSection.html?0.565", '<div class="residence-section" >  <form name=\'residenceUpdateForm\'  novalidate bs-form  bs-submit="updateResidenceAddress()">  <bs-user-details-address address="data.userDetails.residenceAddress" ></bs-user-details-address>  <div class="buttons-row"> <bs-async-button button-class="\'float orange common-button\'"  bs-form-controller="residenceUpdateForm" label="\'dialogs_save\'" > </bs-async-button> <div class="float btn-link" ng-click="onUpdateDone(\'residence\')">{{"dialogs_cancel" | i18n}}</div> <div class="clearfix"></div> </div> </form>   </div>  '), 
        $templateCache.put("/portal/templates/userDetails/sections/phoneSection.html?0.565", '<div class="phone-section" >  <form name=\'phoneUpdateForm\'  novalidate bs-form  bs-submit="updateUserInfo(\'phone\')">   <bs-form-group field-name="phone" label="user_details_phone"> <label class="float"></label> <bs-form-validation-message css-class="float"></bs-form-validation-message> <div class="clearfix"></div> <input  dir="ltr" name="phone" class="form-control" ng-model="data.user.phone" required ng-minlength="8" ng-pattern="bsValidationPatterns.phone"/>  </bs-form-group>   <div class="buttons-row"> <bs-async-button button-class="\'float orange common-button\'"  bs-form-controller="phoneUpdateForm" label="\'dialogs_save\'" > </bs-async-button> <div class="float btn-link" ng-click="onUpdateDone(\'phone\')">{{"dialogs_cancel" | i18n}}</div> <div class="clearfix"></div> </div>   <div class="clearfix"></div> </form> </div>  '), 
        $templateCache.put("/portal/templates/userDetails/sections/emailSection.html?0.565", "<div> <bs-edit-email></bs-edit-email> </div> "), 
        $templateCache.put("/portal/templates/userDetails/sections/passwordSection.html?0.565", '<div class="password-section" ng-controller="PasswordUpdateController"> <form name=\'passwordUpdateForm\'  novalidate bs-form  bs-submit="updatePassword()" >  <bs-form-group field-name="existingsPassword" label="user_details_existing_password"> <label class="float"></label> <bs-form-validation-message css-class="float" wrong="user_details_wrong_password"  ></bs-form-validation-message> <div class="clearfix"></div> <input dir="ltr"  type="password" name="existingsPassword" class="form-control"  ng-model="data.existingPassword" required bs-validate="{wrong : \'!wrongPassword($value)\' }" bs-validate-watch="\'wrongPasswords\'"/>  </bs-form-group>  <bs-form-group field-name="newPassword" label="user_details_new_password" > <label class="float"></label> <bs-form-validation-message  css-class="float" minlength="error_bad_password" ></bs-form-validation-message> <div class="clearfix"></div> <input dir="ltr"  type="password" name="newPassword" class="form-control" ng-model="data.newPassword" required ng-minlength="6"/>  </bs-form-group>  <bs-form-group field-name="passwordConfirm" label="user_details_confirm_password" > <label class="float"></label> <bs-form-validation-message  css-class="float" match="error_password_mismatch" ></bs-form-validation-message> <div class="clearfix"></div> <input dir="ltr"  type="password"  name="passwordConfirm" class="form-control"  ng-model="data.passwordConfirm"  bs-validate="{match : \'passwordConfirmedMatch()\' }" bs-validate-watch="\'data\'"/>  </bs-form-group>  <div class="buttons-row"> <bs-async-button button-class="\'float orange common-button\'"  bs-form-controller="passwordUpdateForm" label="\'dialogs_save\'" > </bs-async-button> <div class="float btn-link" ng-click="updateDone()">{{"dialogs_cancel" | i18n}}</div> <div class="clearfix"></div> </div>   <div class="clearfix"></div> </form> </div>  '), 
        $templateCache.put("/portal/templates/userDetails/reusableElements/editEmail.html?0.565", '<div class="edit-email">   <div ng-show="stage==\'edit\'" > <label>{{"user_details_change_email" | i18n}}:</label> <form bs-form name="emailChangeForm" bs-submit="updateEmail()" novalidate> <bs-form-group field-name="email" label="user_details_email"> <input  dir="ltr" type="email" name="email" class="form-control" ng-model="data.email"  required  bs-validate="{exists : \'!emailExists($value)\' }" bs-validate-watch="\'existingEmails\'" /> <bs-form-validation-message hidden="true" exists="error_email_exists" ></bs-form-validation-message>  </bs-form-group>  <div class="form-error text-danger"> <div class="error-message" bs-blink-on-form-error>{{bsFormFirstErrorMessage()}}</div> </div>  <div class="buttons-row"> <bs-async-button button-class="\'float orange common-button\'"  bs-form-controller="emailChangeForm" name="\'changeEmail\'" label="\'dialogs_save\'" > </bs-async-button> <div class="float btn-link" ng-click="cancelEdit()">{{"dialogs_cancel" | i18n}}</div> <div class="clearfix"></div> </div>  </form> </div> <div ng-show="stage==\'not_confirmed\'" > <div class="title">{{notConfirmedTitle | i18n}}.</div> <div class="line" ng-bind-html="\'email_not_confirmed_line_1\' | i18n:{email: getEmail()}"></div> <div class="line">{{"email_not_confirmed_line_2" | i18n}}</div>  <div class="links"> <div class="float"> <div class="btn-link" ng-click="sendEmailConfirmationAgain()" ng-class="{waiting:sendingConfirmationAgain}"> {{"email_not_confirmed_send_again" | i18n}} </div> </div>  <div class="opposite float btn-link" ng-click="stage=\'edit\'">{{"email_not_confirmed_change_email" | i18n}}</div>  <div class="clearfix"></div> <div class="float resent-message" ng-show="sentConfirmationAgain"> {{"email_not_confirmed_sent_another" | i18n }} </div> </div>  <div class="sent-message" ng-show="anotherSent"> {{"email_not_confirmed_sent_another" | i18n}}</div>  </div>  </div>  '), 
        $templateCache.put("/portal/templates/userDetails/reusableElements/address.html?0.565", '<div class="address" >  <div class="row">  <bs-form-group field-name="country" label="user_details_country" css-class="col-xs-12  float" > <label class="float"></label> <span class="float star">*</span><div><!-- this empty div is needed for ie8 --></div> <bs-form-validation-message  debug="true" css-class="float" minlength="error_mandatory" pattern="error_bad_pattern_with_name"></bs-form-validation-message> <div class="clearfix"></div> <input  debug="true" name="country" class="form-control" ng-model="address.country" ng-minlength="2" ng-pattern="bsValidationPatterns.alpha" required /><div><!-- this empty div is needed for ie8 --></div>  </bs-form-group>  </div>   <div class="row">  <bs-form-group field-name="city" label="user_details_city" css-class="col-xs-12 float"> <label class="float"></label> <span class="float star">*</span><div><!-- this empty div is needed for ie8 --></div> <bs-form-validation-message  css-class="float" minlength="error_mandatory"  pattern="error_bad_pattern_with_name"></bs-form-validation-message> <div class="clearfix"></div> <input  name="city" class="form-control" ng-model="address.city" ng-minlength="2" ng-pattern="bsValidationPatterns.alpha" required /><div><!-- this empty div is needed for ie8 --></div>  </bs-form-group>  </div>  <div class="row">  <bs-form-group field-name="address" label="user_details_address" css-class="col-xs-12 float"> <label class="float"></label> <span class="float star">*</span><div><!-- this empty div is needed for ie8 --></div> <bs-form-validation-message  css-class="float" minlength="error_mandatory"></bs-form-validation-message> <div class="clearfix"></div> <input  name="address" class="form-control" ng-model="address.address" ng-minlength="2" required /><div><!-- this empty div is needed for ie8 --></div>  </bs-form-group>  </div>    <div class="row">  <bs-form-group field-name="state" label="user_details_state" css-class="col-xs-12 float"> <label class="float"></label> <bs-form-validation-message  css-class="float"></bs-form-validation-message> <div class="clearfix"></div> <input  name="state" class="form-control" ng-model="address.state" ng-pattern="bsValidationPatterns.alpha" /><div><!-- this empty div is needed for ie8 --></div>  </bs-form-group>  </div>  <div class="row">  <bs-form-group field-name="zip" label="user_details_zip" css-class="col-xs-12 float"> <label class="float"></label> <bs-form-validation-message  css-class="float"></bs-form-validation-message> <div class="clearfix"></div> <input  name="zip" class="form-control" ng-model="address.zipCode"  /><div><!-- this empty div is needed for ie8 --></div>  </bs-form-group> </div>  </div>  '), 
        $templateCache.put("/portal/templates/account/myAccount/myAccountMain.html?0.565", '<div ng-controller="MyAccountController" class="myAccount scene" bs-scroll-to-top> <div class="narrow upper-part">  <div class="dark overlay">  <div class="message center-block container col-lg-7 col-md-7 col-sm-8 xs-12"> <h1>{{titleKey | i18n}}</h1> <div class="short-separator"></div> </div> </div> </div>  <div class="content container"> <div class="col-lg-10 col-md-11 col-sm-12 xs-12 no-float"> <h4>{{messageKey | i18n}}</h4> <br> <uib-accordion ng-if="currentUser" > <uib-accordion-group  ng-repeat="house in houses" ng-if="(devMode || (!house.hidden && house.site.code!=\'demo\')) && !house.site.down" is-open="data.opened[house.id]">  <uib-accordion-heading > <div ng-class="{\'dev-only\':house.hidden || house.site.code==\'demo\'}"> <div class="float logo" bs-cloudinary-bg="{{house.resources[\'mainPageLogo\']}}"  params="{size:\'60x22\'}"></div> <div class="house-name  float">{{house.details.name | langField | trim:20}}</div>  <div class="edit btn-link  opposite float opposite-align" ng-show="!opened[house.id]"> {{(data.opened[house.id] ? "dialogs_close" : viewKey) | i18n}} </div> <div class="clearfix"></div> </div> </uib-accordion-heading>  <div class="house-entry-content col-xs-12" ng-class="section" > <div ng-if="data.housesEntries[house.id]"> <bs-my-account-house-entry	items-type="itemsType" house-info="data.housesEntries[house.id]"></bs-my-account-house-entry> </div>  <div class="error" ng-if="error" ng-bind-html="error"></div> <bs-content-loader loaded="data.housesEntries[house.id] || error"></bs-content-loader> </div> </uib-accordion-group> </uib-accordion> </div>  </div>   </div> '), 
        $templateCache.put("/portal/templates/account/myAccount/myAccountAuctionsSection.html?0.565", '<div class="auctions-section"> <div ng-if="auctionsInfo.length>0"> <div class="float title"> <div class="text">{{(\'my_account_\'+label) | i18n}}</div> </div> <div class="clearfix"></div> <div class="title-separator"></div> <bs-my-account-auction-bids  ng-repeat="auctionInfo in auctionsInfo"  auction="auctionInfo.auction" lots="auctionInfo[lotsField]" count-label="label+\'_count\'" > </bs-my-account-auction-bids> </div>  </div> '), 
        $templateCache.put("/portal/templates/account/myAccount/myAccountHouseEntry.html?0.565", '<div>   <div ng-if="houseInfo.approvalState==\'APPROVED\'"> <label ng-if="houseInfo.empty"> {{ "my_account_empty_"+itemsType | i18n}}  </label>  <div ng-if="!houseInfo.empty"> <bs-my-account-auctions-section  auctions-info="houseInfo.auctions.current"  label="\'current\'" ng-if="itemsType==\'absentee\'"  lots-field="\'lotsWithAbsenteeBids\'"> </bs-my-account-auctions-section>  <bs-my-account-auctions-section auctions-info="houseInfo.auctions.sold"  label="\'sold\'" ng-if="itemsType==\'won\'"  lots-field="\'wonLots\'"> </bs-my-account-auctions-section> </div> </div>   <div ng-if="houseInfo.approvalState!=\'APPROVED\'"> <bs-house-approval  house-id="houseInfo.house.id" approval-state="houseInfo.approvalState"></bs-house-approval> </div>     </div> '), 
        $templateCache.put("/portal/templates/account/myAccount/myAccountAuctionBids.html?0.565", '<div class="auction-bids"> <div class="auctionName">{{auctionName}}</div> <div class="bid-row" ng-repeat="lot in lots" ng-click="gotoLot(lot)" bs-scroll-on="lot.id == scrollTo"> <bs-lot-image lot="lot" size="108x108" as-bg="true" image-mode="\'fit\'" class="lot-pic"></bs-lot-image>  <div class="info"> <div class="item-index"> {{"lot_number" | i18n:{number:lot.itemIndex} }}</div>  <div ng-bind-html="lot | lotText:80 "></div>   <div class="price-label" ng-if="lot.selfSoldLotBid"> <span class="label">{{"lot_self_sold_bid" | i18n}}:</span> <span class="price">{{lot.selfSoldLotBid.price | sumInCurrency:currency}} </span>  </div>   <div class="price-label" ng-if="lot.selfAbsenteeBid && !lot.selfSoldLotBid"> <span class="label">{{"lot_self_absentee_bid" | i18n}}:</span> <span class="price">{{lot.selfAbsenteeBid.price | sumInCurrency:currency}} </span>  </div>    <div class="orange common-button" bs-text-direction ng-if="!lot.soldLotBid && [\'READY\',\'RUNNING\'].indexOf(lot.auction.state!=-1)"> <div class="text">{{"dialogs_edit" | i18n }}</div> </div> <div class="clearfix"></div> </div>  <div class="clearfix"></div> </div>  </div> '), 
        $templateCache.put("/portal/templates/account/approval/houseApprovalPopup.html?0.565", '<div class="approval-popup" bs-text-direction >  <div  class="modal-header"> <label  class="float modal-title">{{"dialogs_notice_title" | i18n}}</label>  <div class="close btn-link" ng-click="$close()">&times;</div> <div class="clearfix"></div>  </div>  <div class="modal-body"> <bs-house-approval house-id="houseId" in-popup="true"></bs-house-approval> </div>  </div>  '), 
        $templateCache.put("/portal/templates/account/approval/houseApprovalScene.html?0.565", ' <div class="info-popup scene" bs-scroll-to-top>  <div class="content container col-lg-6 col-md-6 col-sm-8 col xs-12"> <div ng-if="options.title" class="title center-block container col-lg-7 col-md-7 col-sm-8 col xs-12" > <H3>{{"dialogs_notice_title" | i18n}}</H3> <div class="short-separator"></div> </div> <bs-house-approval house-id="$stateParams.houseId"></bs-house-approval>  </div> </div>     '), 
        $templateCache.put("/portal/templates/account/approval/houseApproval.html?0.565", ' <div  class="approval-message">  <p ng-bind-html="firstParagraph"></p> <p ng-bind-html="secondParagraph"></p>  <div ng-if="approvalState==\'NOT_REGISTERED\'">  <div class="user-id-request" ng-if="house.requestUserStateIdForApproval"> <p><div class="caption">	{{"approval_request_user_id_caption" | i18n : {house:(house.details.name | langField) } }}</div></p>  <form name=\'requestUserIdForm\'  novalidate bs-form  > <bs-form-group field-name="userStateId" label="approval_request_user_id_label"> <label></label> <input name="userStateId" class="form-control" ng-model="formData.userStateId" />  <bs-form-validation-message></bs-form-validation-message>  </bs-form-group> </form> </div>  <div class="error-message text-danger" ng-if="formData.error">  <p>{{formData.error}}</p> </div>  <div class="clearfix"></div>  <bs-async-button  class="float" action-fn="requestApproval()"  button-class="\'btn-primary common-button \'+currentLang"  label="\'approval_send_request\'" > </bs-async-button>  <button ng-if="!inPopup" class="opposite float back btn btn-link text-danger" bs-back-button ng-class="currentLang"> {{("dialogs_cancel") | i18n}}</button> <div class="clearfix"></div> </div>   <div  ng-if="inPopup && (approvalState==\'PENDING\' || approvalState==\'INCOMPLETE_PROFILE\'  || formData.error)" > <br><br> <button  class="center-block btn btn-primary"  ng-click="closePopup()">{{"dialogs_close" | i18n}} </button> </div>    </div> '), 
        $templateCache.put("/portal/templates/account/favorites/favoritesItems.html?0.565", ' <div class="list"  ng-class="{\'mobile-list\':viewPort.mobileMedia}">   <div class="row"> <div  ng-repeat="lot in pagesData.pageItems" bs-text-direction bs-scroll-on="lot.id == scrollTo"  ng-class="{\'pc-item\':viewPort.pcMedia,\'mobile-item\':viewPort.mobileMedia,clearfix:lot.loadPastLinkFakeItem,item:!lot.loadPastLinkFakeItem}"> <div ng-if="!lot.loadPastLinkFakeItem" bs-log-click="favorite-lot-{{lot.auction.house.code}}-{{lot.auction.date | date :\'dd.MM.yy\'}}-{{lot.itemIndex}}"  ng-click="gotoLot(lot)">   <div class="link"   > <div ng-if="viewPort.pcMedia"      ng-include src="\'auctions/catalogs/list/catalogItemWide\' | appTemplate" class="frame"></div> <div ng-if="viewPort.mobileMedia" ng-include src="\'auctions/catalogs/list/catalogItemNarrow\' | appTemplate"  ></div> </div> <bs-lot-favorite-flag lot="lot"></bs-lot-favorite-flag>  </div> <div ng-if="lot.loadPastLinkFakeItem"> <div class="float pastItems link" ng-class="data.sceneInfo.pastItemState" ng-click="loadPastItems()" > {{"favorites_page_past" | i18n}} </div> <div class="clearFix"></div> </div> </div>   <div class="clearfix"></div> </div>   <div class="clearfix"></div> </div>  '), 
        $templateCache.put("/portal/templates/account/favorites/favoritesMain.html?0.565", '<div ng-controller="FavoritesController" > <div class="narrow upper-part">  <div class="dark overlay">  <div class="message center-block container col-lg-7 col-md-7 col-sm-8 xs-12"> <h1>{{"link_favorites" | i18n}}</h1> <div class="short-separator"></div> </div> </div> </div>  <div class="catalog favorites scene"> <div class="content col-xs-12" >  <bs-catalog-list-pagination  on-current-page-change="onPageChange()" pages-data="pagesData"   href-pages="false" ></bs-catalog-list-pagination>  <div bs-scroll-on watched-value="scrollToPagination" offset="-200"></div>  <div ng-if="loadState!=\'loading\'" ng-include src="\'account/favorites/favoritesItems\' | appTemplate"  ></div>   <bs-content-loader loaded="loadState!=\'loading\'"></bs-content-loader>   <bs-content-loader ng-if="data.sceneInfo.pastItemState!=\'unloaded\'" loaded="data.sceneInfo.pastItemState==\'loaded\'"></bs-content-loader>   <bs-catalog-list-pagination  on-current-page-change="onPageChange()" pages-data="pagesData"   href-pages="false" ></bs-catalog-list-pagination>  </div>    </div> </div>   '), 
        $templateCache.put("/portal/templates/houses/housesList.html?0.565", '<div ng-controller="HousesListController" class="houses scene" bs-scroll-to-top> <div class="narrow upper-part">  <div class="dark overlay">  <div class="message center-block container col-lg-7 col-md-7 col-sm-8 col xs-12"> <h1>{{"auction_houses_title" | i18nWithRegion  }}</h1> <div class="short-separator"></div> </div> </div> </div> <div class="content container"> <h4 ng-bind-html="\'auction_houses_message\' | i18nWithRegion"></h4> <br> <div class="container-fluid"> <div class="row text-center"> <div  class="col-xs-12 house-item default-align"  bs-text-direction ng-repeat="house in houses" ng-if="(devMode || bidmoodEnv || (!house.hidden && house.site.code!=\'demo\')) && !house.site.down && house.orderInd>0"  > <div class="house-frame"  ui-sref="app.house({houseCode:house.code})">  <div class="frame-top" ng-style="{\'background-color\':(house.details.brandColor || \'#aaa\')}"> <div class="float name"> <h2>{{house.details.name | langField}}</h2> </div>  <div class="opposite float logo" bs-cloudinary-bg="{{house.resources[\'mainPageLogo\']}}"> </div> <div class="clearfix"></div>  </div>  <div class="frame-bottom"> <div ng-if="house.details.summary"> {{house.details.summary | langField}} <br><br> </div> <div ng-if="house.details.expertise"> <b>{{"auction_houses_expertise" | i18n}}:</b><br>  {{house.details.expertise | langField}} </div>  <a class="more btn-link" ng-href="#!/houses/{{house.code}}">{{"auction_houses_more" | i18n}}</a> </div>  </div>  </div> </div>  </div>  </div>   </div> '), 
        $templateCache.put("/portal/templates/houses/housePage.html?0.565", '<div ng-controller="HousePageController" class="house-page scene" > <div ng-if="housePic" class="house-page-image" bs-cloudinary-bg="{{housePic}}"> </div> <div ng-if="!housePic" class="house-page-image-space"> </div> <div class="content container"> <div class="house-info"> <div class="house-info-upper"> <div class="float texts"  style="max-width:{{viewPort.contentWidth-280}}px"> <h2 class="house-name"> {{house.details.name | langField}} </h2> <div ng-bind-html="houseTextParams.link"></div>  <div class="address">{{house.details.address | langField}}</div> </div>   <div class="opposite float logo" bs-cloudinary-bg="{{(house.resources[\'mainPageLogo\'])}}" params="{size:\'188x74\'}"></div>  <div class="clearfix"></div>  </div> <bs-house-regisration-promotion ng-if="devMode || house.site.code!=\'demo\'" house="house" > </bs-house-regisration-promotion> <hr>  <div class="house-info-lower"> <div class="text" ng-bind-html="house.details.info | langField"> </div> <div class="contact-info"> <div class="caption">{{\'auction_house_contact\' | i18n}}</div>  <div class="table"> <div class="labels table-cell"> <div class="contact-label" ng-if="houseTextParams.phone">{{\'auction_house_phone\' | i18n}}</div>  <div class="contact-label" ng-if="houseTextParams.email">{{\'auction_house_email\' | i18n}}</div> <div class="contact-label" ng-if="houseTextParams.link">{{\'auction_house_website\' | i18n}}</div> </div> <div class="separator table-cell"></div> <div class="values table-cell"> <div class="contact-value" ng-if="houseTextParams.phone" dir="ltr" ng-bind-html="houseTextParams.phone"></div>  <div class="contact-value" ng-if="houseTextParams.email" dir="ltr" ng-bind-html="houseTextParams.email"></div> <div class="contact-value" ng-if="houseTextParams.link" dir="ltr" ng-bind-html="houseTextParams.link"></div> </div> </div> </div>  <br>  <div class="btn btn-link terms" ng-click="openTerms()" > {{"house_terms" | i18n:{house:(house.details.name | langField)} }}</div> </div>    <bs-house-alerts-promotion house="house" > </bs-house-alerts-promotion> </div>   <bs-auctions-lists-group auctions-data="{auctions:auctions}" show-all-past-auctions="true" show-all-future-auctions="true"  ></bs-auctions-lists-group>  </div> </div> '), 
        $templateCache.put("/portal/templates/houses/houseAlertsPromotion.html?0.565", '<div class="house-alerts-promotion" ng-if="shouldDisplay">  {{\'alerts_promotion_configure_house\' | i18n:{house:(house.details.name | langField)} }}&nbsp <span class="no-break"> <span><span class="orange common-button" ui-sref="app.alerts.house({houseCode:house.code})"> <span class="text">{{\'alerts_promotion_configure_command\' | i18n}}</span></span> <span class="clearfix"></span> </span> </div>    '), 
        $templateCache.put("/portal/templates/auth/authScene.html?0.565", '<div  class="auth scene" ng-controller="AuthSceneController" ng-class="{\'logged-in\':currentUser!=null}" >  <div class="narrow upper-part">  <div class="dark overlay">  <div class="message center-block container">  <H1 >{{titleKey() | i18n}}</H1> <div class="short-separator"></div> </div> </div> </div> <div class="content container col-lg-5 col-md-7  col-xs-12" >  <div  bs-text-direction class="auth-view" ng-class="authDisplayInfo.authScene"  ng-if="!isIe8" ng-include 	src="\'auth/elements/\'+authDisplayInfo.authSubScene | appTemplate"> </div> </div>   </div> '), 
        $templateCache.put("/portal/templates/auth/authModalPopup.html?0.565", '<div  ng-controller="AuthModalPopupController" bs-text-direction>  <div  class="modal-header">  <label  class="float modal-title">{{ titleKey() | i18n}}</label> <div class="close btn-link" ng-click="$close()">&times;</div> <div class="clearfix"></div>  </div>  <div class="modal-body">  <div  class="auth-view"  ng-if= "!isIe8" ng-include 	src="\'auth/elements/\'+authDisplayInfo.popupSubScene | appTemplate"> </div>  <div ng-if="isIe8" ie8-warning></div> </div>  </div>  '), 
        $templateCache.put("/portal/templates/auth/legalApproval/legalApprovalRequired.html?0.565", '<div class="legal-approval-required"> <bs-linkable-text options="{ textKey:\'legal_reapproval_line_1\', onLinkClick:options.showLegalDoc }" > </bs-linkable-text> <br> <p ng-bind-html="\'legal_reapproval_line_2\' | i18n"></p>  </div>  '), 
        $templateCache.put("/portal/templates/auth/legalApproval/legalTermsRejected.html?0.565", '<div> <p ng-bind-html="\'legal_reapproval_rejected\' | i18n"></p>  <br><br> <div class="text-danger"	ng-bind-html="\'legal_reapproval_support\' | i18n:{email:BidspiritInfo.emailLink}"> </div>   </div>  '), 
        $templateCache.put("/portal/templates/auth/authNavBarPopup.html?0.565", '<div> <div class="close btn-link" ng-click="hidePopup()">x</div>  <div  class="auth-view"   ng-if= "!isIe8"" ng-include 	src="\'auth/elements/\'+authDisplayInfo.popupSubScene | appTemplate"> </div>  <div ng-if="isIe8" ie8-warning></div>   </div> '), 
        $templateCache.put("/portal/templates/auth/authUpperNavigation.html?0.565", '<div class="auth-navigation-section" ng-controller="AuthUpperNavigationController"> <div ng-if="!currentUser"> <div> <div ng-repeat="link in [\'login\',\'register\']"  class="btn-link"   ng-click="togglePopupView(link)"  ng-class="[currentLang,link]"> <div class="text"> {{"link_"+link | i18n }} </div>  <div class="up-arrow" ng-show="authDisplayInfo.popupScene==link"></div>  </div> </div> </div> <div ng-if="currentUser" class="logged-in-links" > <div class="float hazard btn-link"  ng-if="currentUser.registrationStage!=\'COMPLETE\'" ng-click="togglePopupView(\'warning\')"> <div class="icon" ng-class="{on:authDisplayInfo.popupScene==\'warning\'}"></div> <div class="up-arrow" ng-show="authDisplayInfo.popupScene==\'warning\'"></div>  </div>  <div class="float"> <div class="link" ng-click="toggleAuthMenu()"> <div class="float text"> {{\'link_hello\' | i18n:{name:currentUser.firstName} }} </div> <div class="float arrow"> <div class="down"></div> <div class="up" ng-show="authDisplayInfo.menuVisible"></div> <div class="up" ng-show="nudgePopupVisible"></div> </div> <div class="clearfix"></div> </div> <div class="auth-menu" ng-show="authDisplayInfo.menuVisible" ng-click="authDisplayInfo.menuVisible=false" ng-mouseleave="authDisplayInfo.menuVisible=false" bs-text-direction> <div class="up-arrow"></div> <div class="close btn-link" >x</div>  <div ng-include src="\'elements/navigation/pcUserMenu\' | appTemplate" ></div> </div> <bs-nudge-navbar-popup></bs-nudge-navbar-popup> </div>  <div class="clearfix"></div> </div>  <div class="auth-navbar-popup" ng-class="[authDisplayInfo.popupScene, currentLang]"  ng-include src="\'auth/authNavBarPopup\' | appTemplate"  ng-if="authDisplayInfo.popupScene!=null">  </div> </div>  '), 
        $templateCache.put("/portal/templates/auth/elements/recoverPassword.html?0.565", '<div class="recover-password sub-scene" ng-controller="RecoverPasswordController"> <div class="title"> {{\'recover_password_title\' | i18n}}</div> <div class="separator"></div>  <div ng-if="stage==1">  <div class="message"> {{\'recover_password_message\' | i18n}}:</div> <form name=\'recoverForm\'  novalidate bs-form  bs-submit="sendPassword()" >  <bs-form-group field-name="email" label="user_details_email"> <input type="email" name="email" class="form-control" ng-model="info.email" required ng-change="data.emailUnknown=false" bs-validate="{unknown : \'!data.emailUnknown\' }"  bs-validate-watch="\'data.emailUnknown\'" /> <bs-form-validation-message hidden="true" unknown="error_email_not_exists"> </bs-form-validation-message>  </bs-form-group>  <div class="form-error text-danger" > <div class="error-message" bs-blink-on-form-error>{{bsFormFirstErrorMessage()}}</div> </div>  <div class="orange common-button opposite float" ng-click="recoverForm.submit()" > <div class="text">{{"dialogs_send" | i18n }}</div> </div>  <div class="cancel btn-link opposite float" ng-click="setAuthSubScene(\'login\')">{{\'dialogs_cancel\' | i18n}}</div>  <div class="clearfix"></div>  <div class="help" ng-bind-html="\'recover_password_help\' | i18n:{email:BidspiritInfo.emailLink,phone:BidspiritInfo.phoneLink}"></div>    </form>  </div>    <div ng-if="stage==2"> <div class="message"> {{\'recover_password_success\' | i18n :{email:info.email} }}</div>  <div class="orange finish common-button opposite float"  ng-click="setAuthSubScene(\'login\')" > <div class="text">{{"dialogs_end" | i18n }}</div> </div>  <div class="clearfix"></div>  </div>  </div> '), 
        $templateCache.put("/portal/templates/auth/elements/warning.html?0.565", '<div  class="warning sub-scene" >  <bs-edit-email ng-if="currentUser.registrationStage==\'UNCONFIRMED_EMAIL\'"></bs-edit-email>    <div class="incompleteProfile" ng-if="currentUser.registrationStage==\'INCOMPLETE_PROFILE\'"> <div class="message">{{"incomplete_details_message" | i18n}}</div>  <div class="orange common-button" ui-sref="app.auth({authScene:\'postRegistrationDetails\'})"  > <div class="text">{{"incomplete_details_update" | i18n }}</div> </div> </div>  </div> '), 
        $templateCache.put("/portal/templates/auth/elements/postRegistrationDetails.html?0.565", '<div ng-controller="PostRegistrationDetailsController"> <div ng-show="!formSubmitted" class="before-submit" ng-if="userDataLoaded">  <div class="register-success" ng-if="currentUser.justConfirmed">{{"register_success" | i18n}}</div>  <div class="message">{{"post_registration_message" | i18n}}</div> <div class="clearfix"></div> <form name=\'completeRegistrationForm\'  novalidate bs-form  bs-submit="save()" > <div class="form-half-page"> <h4 class="default-align">{{"user_details_personal_details" | i18n}}</h4>  <div class="row">  <bs-form-group field-name="phone" label="user_details_phone" css-class="col-xs-12 float" debug="true"> <label class="float"></label> <span class="float star">*</span> <bs-form-validation-message  css-class="float"></bs-form-validation-message> <div class="clearfix"></div>  <input  name="phone" class="form-control" dir="ltr" ng-model="userDetails.phone"  required  ng-pattern="bsValidationPatterns.phone" ng-minlength="8"/>  </bs-form-group>  </div>  <div class="row">  <bs-form-group field-name="company" label="user_details_company" css-class="col-xs-12 float"> <label class="float"></label> <bs-form-validation-message  css-class="float"></bs-form-validation-message> <div class="clearfix"></div> <input  name="company" class="form-control" ng-model="userDetails.company" />  </bs-form-group>  </div>  <h4>{{"user_details_residence" | i18n}}</h4> <div ng-if="true"> <!--  crazy, but without this line validation stops to work... couldn\'t figure out why --> <ng-form bs-form name="residence"> <bs-user-details-address address="userDetails.residenceAddress" ></bs-user-details-address> </ng-form>  </div>  </div>  <div class="clearfix"></div>  <bs-form-group field-name="residenceIsShipping" css-class="col-xs-12 float checkbox-row"> <input  type="checkbox" class="float" name="residenceIsShipping" ng-model="userDetails.shippingAddress.residenceIsShipping"/> <label class="float">{{\'user_details_shipping_is_residence\' | i18n}}</label> </bs-form-group>  <div class="form-half-page">  <div ng-if="!userDetails.shippingAddress.residenceIsShipping" > <h4>{{"user_details_shipping" | i18n}}</h4> <ng-form bs-form name="shipping"> <bs-user-details-address  address="userDetails.shippingAddress"></bs-user-details-address> </ng-form>  </div> </div>  <div class="clearfix"></div>  <div class="form-error"> <div class="form-input error-message text-danger" bs-blink-on-form-error ng-show="!loginErrorVisible">{{bsFormFirstErrorMessage()}}</div> </div>   <div class="orange common-button float" ng-click="completeRegistrationForm.submit()" > <div class="text">{{"dialogs_send" | i18n }}</div> </div>   </form> </div>  <div class="clearfix"></div>  <div ng-show="formSubmitted" class="post-submit"> <div class="row"> <div class="title">{{"post_registration_details_success" | i18n }}</div> </div> <div class="row"> <div class="message col-xs-9">{{"post_registration_details_success_message" | i18n }}</div> </div>  <div class="row"> <div class="orange common-button  float" ui-sref="app.home" > <div class="text">{{"dialogs_end" | i18n }}</div> </div>  </div>  </div>  <br><br> </div>  '), 
        $templateCache.put("/portal/templates/auth/elements/register.html?0.565", ' <div class="register sub-scene" ng-controller="RegisterController">  <div class="message" bs-scroll-on watched-value="scrollToFisrtLine" debug-key="register"> {{"register_message_line_1"  | i18n }} <br> {{"register_message_line_2"  | i18n }} <br>  </div>  <form name=\'registerForm\'  novalidate bs-form  bs-submit="register()" >  <bs-form-group field-name="firstName" label="user_details_first_name" css-class="float"> <label></label> <input name="firstName" class="form-control" ng-model="registrationInfo.firstName"  required ng-minlength="2" ng-pattern="bsValidationPatterns.alpha" />  <bs-form-validation-message hidden="true" ></bs-form-validation-message>  </bs-form-group>  <div class="float space"></div>  <bs-form-group field-name="lastName" label="user_details_last_name" css-class="float"> <label></label> <input name="lastName" class="form-control" ng-model="registrationInfo.lastName" required  ng-pattern="bsValidationPatterns.alpha" ng-minlength="2"/> <bs-form-validation-message hidden="true" ></bs-form-validation-message>  </bs-form-group> <div class="clearfix"></div>   <bs-form-group field-name="email" label="user_details_email"> <label></label> <input dir="ltr" class="email form-control"  type="email" name="email"  ng-model="registrationInfo.email"  required  bs-validate="{exists : \'!emailExists($value)\' }" bs-validate-watch="\'existingEmails\'" /> <bs-form-validation-message hidden="true" exists="error_email_exists" ></bs-form-validation-message>  </bs-form-group> <div class="clearfix"></div>   <bs-form-group field-name="password" label="user_details_password" css-class="float"> <label></label> <input  dir="ltr" type="password" name="password" class="form-control" ng-model="registrationInfo.password" required ng-minlength="6"/> <bs-form-validation-message  minlength="error_bad_password" hidden="true" ></bs-form-validation-message>  </bs-form-group>  <div class="float space"></div>  <bs-form-group field-name="passwordConfirm" label="user_details_confirm_password" css-class="float"> <label></label> <input  dir="ltr" type="password" name="passwordConfirm" class="form-control"  ng-model="registrationInfo.passwordConfirm" required  bs-validate="{match : \'passwordConfirmedMatch()\' }" bs-validate-watch="\'registrationInfo\'"/> <div class="clearfix"></div>  <bs-form-validation-message hidden="true" match="error_password_mismatch" ></bs-form-validation-message> </bs-form-group>   <bs-form-group field-name="over18" css-class="checkbox-row"> <input  type="checkbox" class="float" name="over18" ng-model="registrationInfo.over18" required/> <bs-checkbox class="float"  bs-model="registrationInfo.over18"></bs-checkbox> <label class="float">{{\'register_over18\' | i18n}}</label> <div class="clearfix"></div> <bs-form-validation-message hidden="true" required="error_over18"></bs-form-validation-message> </bs-form-group>  <div class="clearfix"></div>   <bs-form-group field-name="terms" css-class="checkbox-row"> <input  type="checkbox" name="terms" ng-model="registrationInfo.terms" required/> <bs-checkbox class="float"  bs-model="registrationInfo.terms"></bs-checkbox> <label class="terms float">{{\'register_terms_accept\' | i18n}}<span ng-click="showTerms()" class="currentLang link">{{\'register_terms_label\' | i18n}}</span></label> <bs-form-validation-message hidden="true" required="error_accept_terms"></bs-form-validation-message> <div class="clearfix"></div>  </bs-form-group>    <div class="form-error text-danger" > <div class="error-message" bs-blink-on-form-error >{{bsFormFirstErrorMessage()}}</div>  <div class="login link" ng-show="displayLoginLink()" ng-click="setAuthScene(\'login\')" >{{\'register_login_with_mail\' | i18n}}</div>  <div class="clearfix"></div> </div>    <bs-async-button button-class="\'opposite float orange common-button\'"  bs-form-controller="registerForm"  label="\'dialogs_send\'" ></bs-async-button>   <div class="clearfix"></div>  </form> </div>  '), 
        $templateCache.put("/portal/templates/auth/elements/login.html?0.565", '<div class="login sub-scene" ng-controller="PortalLoginController"> <div class="message" ng-if="authDisplayInfo.args.message">{{ authDisplayInfo.args.message | i18n}}</div> <form name=\'loginForm\'  novalidate bs-form  bs-submit="login()" >  <bs-form-group field-name="email" label="user_details_email"> <label></label> <input dir="ltr" type="email" name="email" class="form-control" debug="true" ng-model="loginInfo.email" required  ng-change="hideLoginError()"/>  <bs-form-validation-message hidden="true"  ></bs-form-validation-message>  </bs-form-group>  <bs-form-group field-name="password" label="user_details_password" class="password"> <label></label> <div dir="ltr"> <input bs-focus-on="focusOnPassword" type="{{passwordVisible ? \'text\' : \'password\'}}" name="password" autocorrect="off" autocapitalize="none" class="form-control" ng-model="loginInfo.password" required ng-change="hideLoginError()"/> </div> <bs-form-validation-message hidden="true" ></bs-form-validation-message> <div class="showPassword" ng-click="togglePasswordVisible()"></div>  </bs-form-group>   <div class="form-error text-danger"> <div class="form-input error-message  bs-blink-on-form-error" ng-if="!loginErrorVisible">{{bsFormFirstErrorMessage()}}</div> <div class="login error-message" ng-if="loginErrorVisible">{{"error_login" | i18n }}. <span class="help link" ng-click="toggleHelpVisible()"> {{"dialogs_help" | i18n }} <span class="help-triangle" ng-show="loginHelpVisible"></span>  </span> </div> </div>  <div class="login-error-help" ng-show="loginHelpVisible"> <div class="close btn-link" ng-click="loginHelpVisible=false">x</div> <div class="text" ng-bind-html="(\'login_error_help_line_1\' | i18n)+ \'<br>\'+ (\'login_error_help_line_2\' | i18n:{email:BidspiritInfo.emailLink,phone:BidspiritInfo.phoneLink})"> </div>  </div>  <bs-form-group field-name="remember" css-class="checkbox-row"> <input type="checkbox" class="float" name="remember" ng-model="loginInfo.remember"/> <bs-checkbox class="float"  bs-model="loginInfo.remember"></bs-checkbox> <label class="float" ng-click="loginInfo.remember=!loginInfo.remember">{{\'login_remember_me\' | i18n}}</label> <div class="clearfix"></div>  </bs-form-group>     <div class="forgot-password btn-link" ng-click="setAuthSubScene(\'recoverPassword\')">{{"login_forgot_password" | i18n }}</div>  <div class="orange common-button opposite" ng-click="loginForm.submit()" > <div class="text">{{"login_enter" | i18n | capitalize}}</div> </div>  <div class="goto-register btn-link" ng-click="setAuthScene(\'register\')">{{"login_goto_register" | i18n }}</div>    </form> </div> '), 
        $templateCache.put("/portal/templates/elements/carousel/housesCarousel.html?0.565", '<div class="houses-carousel-container"> <div  ng-if="!animationOn" class="houses-carousel" ng-style="{backgroundImage:\'url(\'+bgPics[currentPicInd]+\')\'}">  </div>  <div ng-if="animationOn" class="houses-carousel"> <div ng-include dir="{{dir}}" src="\'elements/carousel/slider\' | appTemplate"></div>  </div> </div>  '), 
        $templateCache.put("/portal/templates/elements/carousel/slider.html?0.565", '<wallop-slider data-images="bgPics" data-animation="scale" data-current-item-index="_ind" data-next-item-index="currentPicInd"> </wallop-slider> '), 
        $templateCache.put("/portal/templates/elements/contentLoader.html?0.565", '<div class="content-loader" ng-show="!loaded"> <img  class="center-block" ng-src="{{\'system/pagePreLoader.gif\' | commonImage}}"> </div> '), 
        $templateCache.put("/portal/templates/elements/popups/popupAsScene.html?0.565", '<div class="info-popup scene popup-scene-{{options.code}}" dir="{{dir}}" ng-controller="PopupController">  <div class="content container col-lg-6 col-md-6 col-sm-10 col-xs-11"> <button class="upper btn btn-primary" ng-if="options.backText" bs-back-button >{{options.backText | i18n}}</button>  <div class="clearfix"></div> <div ng-if="options.title" class="title center-block container col-lg-7 col-md-7 col-sm-8 col-xs-11" > <H3>{{options.title}}</H3> <div class="short-separator"></div> </div> <div ng-include src="\'elements/popups/popupBody\' | appTemplate" ></div>   <ul class="list-inline"> <li  ng-repeat="button in options.buttons"> <button ng-if="button.isCloseButton" class="btn btn-{{button.type||\'primary\'}}" bs-back-button  >{{(button.text) | i18n}} </button> <button ng-if="button.action" class="btn btn-{{button.type||\'primary\'}}"  ng-click="button.action()">{{(button.text) | i18n}} </button>  </li>  </ul>  </div> </div> '), 
        $templateCache.put("/portal/templates/elements/popups/popupBody.html?0.565", '<div dir="{{dir}}"> <iframe ng-if="options.contentUrl" width="100%" height="500px" name="about" ng-src="{{options.contentUrl}}" frameborder=0 ALLOWTRANSPARENCY="true"></iframe> <div    ng-if=\'options.contentHtml\'    class="info-popup-content" ng-bind-html="options.contentHtml"></div> <div    ng-if=\'options.contentInclude\' class="info-popup-content"  ng-include src="options.contentInclude | appTemplate"></div>  </div> '), 
        $templateCache.put("/portal/templates/elements/popups/popupModal.html?0.565", '<div dir="{{dir}}" ng-keyup="onKeyup()" class="popup-modal-{{options.code}}">  <div  class="modal-header"> <label  class="float modal-title" ng-if="options.titleKey">{{options.titleKey | i18n}}</label>  <label  class="float modal-title" ng-if="!options.titleKey">{{options.title}}</label> <button type="button" class="opposite float close" ng-if="!options.unclosable" ng-click="$close()">&times;</button> <div class="clearfix"></div>  </div>  <div class="modal-body"> <div ng-include src="\'elements/popups/popupBody\' | appTemplate" ></div> </div>  <div class="modal-footer"> <ul class="list-inline"> <li  ng-repeat="button in options.buttons">  <button ng-if="button.isCloseButton" class="btn btn-{{button.type||\'primary\'}}"  ng-click="$close()">{{(button.text) | i18n}} </button> <button ng-if="button.action" class="btn btn-{{button.type||\'primary\'}}"  ng-click="button.action()">{{(button.text) | i18n}} </button>  </li>  </ul>   </div> </div> '), 
        $templateCache.put("/portal/templates/elements/navigation/upperNavigationSearch.html?0.565", ' <form name=\'searchForm\' novalidate bs-form  bs-submit="gotoSearch()"  ng-click="gotoSearchIfMobile()" class="global-search-form"  bs-text-direction ng-show="state.current.url!=\'search\'"> <bs-form-group field-name="phrase" label="catalog_search_all" > <input bs-place-holder name="phrase" class="form-control" ng-model="data.searchToken" bs-enter-key-action="gotoSearch()"/> </bs-form-group> <div class="button noselect" ng-click="gotoSearch()"> </div> <div class="clearfix"></div> </form>     '), 
        $templateCache.put("/portal/templates/elements/navigation/mobileLangSelection.html?0.565", '<div class="lang-selection"  ng-if="data.langs.length>1"> <div class="selected entry" slide-toggle="#langsMenu{{langMenuAtBottom}}" ng-click="onLanguageClick()" > {{currentLang | langName:"english"}} <span class="caret {{dir}}" ></span> </div> <ul id="langsMenu{{langMenuAtBottom}}" class="slideable" duration="0.25s"> <li class="sub entry" ng-repeat="lang in data.langs" ng-if="lang!=currentLang" ng-click="setLanguage(lang)">{{lang | langName}}</li> </ul> </div> '), 
        $templateCache.put("/portal/templates/elements/navigation/upperNavigation.html?0.565", '<div class="upper-navigation"  ng-class="{ \'has-warning\':ie8WarningVisible, \'logged-in\':currentUser!=null, \'no-fixed\':mobileMenuOn, \'mobile\':isMobileApp || viewPort.clientWidth<1200, \'pc\':!isMobileApp &&  viewPort.clientWidth>=1200 }"  ng-controller="UpperNavigationController"  dir="{{dir}}" > <div ie8-warning></div>  <div class="mobile-only" ng-if="data.showContainer"> <div class="icon-button {{button}}" ng-repeat="button in data.mobileButtons"  ng-click="handleMobileButtonClick(button)"  bs-touched-class="\'touched\'"></div> <div ng-include src="\'elements/navigation/mobileMenu\' | appTemplate"></div> <div class="clearfix"></div> </div>   <div class="pc-only"  > <div class="container" ng-if="data.showContainer">  <div class="float clickable logo" ui-sref="app.home" bs-check-bidmood></div>  <div class="links"> <div class="opposite float lang-selection btn-group" uib-dropdown is-open="status.isopen" ng-if="data.langs.length>1"> <div type="button" uib-dropdown-toggle class="selected entry" > {{currentLang | langName:"english"}} <span class="opposite float caret {{dir}}" ></span> </div> <ul class="uib-dropdown-menu" role="menu" > <li class="entry" ng-repeat="lang in data.langs" ng-if="lang!=currentLang" ng-click="setLanguage(lang)">{{lang | langName}}</li> </ul> </div>  <span class="info-links opposite float" > <a class="btn-link opposite float entry" ng-class="currentLang" ng-href="#!/{{link}}" ng-repeat="link in data.infoLinks">{{(\'link_\'+link) | i18n}}</a> </span>  <div ng-include src="\'elements/navigation/upperNavigationSearch\' | appTemplate" class="opposite float" ></div>    <div class="float auth" ng-include src="\'auth/authUpperNavigation\' | appTemplate" >  </div>  </div>   </div>  </div>  <div class="mobile-only hello-bar" ng-if="currentUser && data.showContainer"> <div class="text">{{\'link_hello\' | i18n:{name:currentUser.firstName} }} </div> </div>  </div> '), 
        $templateCache.put("/portal/templates/elements/navigation/reload.html?0.565", '<div class="refresh scene" ng-controller="ReloadController">  </div> '), 
        $templateCache.put("/portal/templates/elements/navigation/pcUserMenu.html?0.565", ' <a class="btn-link" ng-if="currentUser.registrationStage!=\'UNCONFIRMED_EMAIL\'" ui-sref="app.myAccount({itemsType:\'absentee\'})" >{{\'link_absentee\' | i18n}}</a> <a class="btn-link" ng-if="currentUser.registrationStage!=\'UNCONFIRMED_EMAIL\'" ui-sref="app.myAccount({itemsType:\'won\'})" >{{\'link_won\' | i18n}}</a> <a class="btn-link" ng-if="currentUser.registrationStage!=\'UNCONFIRMED_EMAIL\'" ui-sref="app.favorites">{{\'link_favorites\' | i18n}}</a> <a class="btn-link" ui-sref="app.alerts">{{\'link_alerts\' | i18n}}</a> <a class="btn-link" ui-sref="app.userDetails">{{\'link_update_details\' | i18n}}</a> <a class="btn-link" ng-click="logout()">{{\'link_logout\' | i18n}}</a> '), 
        $templateCache.put("/portal/templates/elements/navigation/mobileMenu.html?0.565", '<div ng-controller="MobileMenuController" > <div> <div  class="menu icon-button needsclick" ng-click="toggleMenu()" ng-class="{touched:menuTouched}"></div> <div class="clearfix"></div> <div class="arrow" ng-show="mobileMenuOn" ></div> <div class="clearfix"></div> </div> <div id="linksMenu" class="mobile-menu" ng-show="mobileMenuOn" > <div class="bg"> <div ng-if="!langMenuAtBottom" ng-include src="\'elements/navigation/mobileLangSelection\' | appTemplate"></div>  <a class="orange entry"  ng-if="currentUser && currentUser.registrationStage!=\'COMPLETE\'" ng-click="nextRegistrationStep()" ng-class="currentLang" >{{(\'link_complete_registration\') | i18n}}</a>  <a class="entry"  ng-if="!currentUser" ng-class="currentLang" ng-href="#!/auth/{{authLink}}/" ng-repeat="authLink in [\'login\',\'register\']">{{(\'link_\'+authLink) | i18n}}</a>   <a class="entry"   ng-if="currentUser "   ui-sref="app.myAccount({itemsType:\'absentee\'})" >{{\'link_absentee\' | i18n}}</a>  <a class="entry"   ng-if="currentUser "   ui-sref="app.myAccount({itemsType:\'won\'})" >{{\'link_won\' | i18n}}</a>  <a class="entry"   ng-if="currentUser " ng-class="currentLang" ui-sref="app.favorites">{{\'link_favorites\' | i18n}}</a>  <a class="entry"   ng-if="currentUser" ng-class="currentLang" ui-sref="app.alerts">{{\'link_alerts\' | i18n}}</a>  <a class="entry"   ng-if="currentUser " ng-class="currentLang" ui-sref="app.userDetails">{{\'link_update_details\' | i18n}}</a>  <a class="entry" ng-if="currentUser " ng-class="currentLang" ng-click="logout()" ng-href="#!/home" >{{(\'link_logout\') | i18n}}</a>  <a class="entry"   ng-class="currentLang" ng-href="#!/{{link}}" ng-repeat="link in data.infoLinks">{{(\'link_\'+link) | i18n}}</a>  <a class="entry"   ng-class="currentLang" ng-href="#!/results/all/1" ">{{\'home_auctions_results\' | i18n}}</a>  <div ng-if="langMenuAtBottom" ng-include src="\'elements/navigation/mobileLangSelection\' | appTemplate"></div> </div>   <div class="bottom-space"></div>  </div> </div>  '), 
        $templateCache.put("/portal/templates/elements/pageFooter.html?0.565", ' <div class="page-footer" ng-if="showFooter" > <div class="container col-md-7 col-xs-12 center-block"> <div class="arrow"></div> <div class="row">  <div class="info-part col-xs-6"> <div class="logo" bs-check-bidmood></div> <div class="text-line" ng-bind-html="\'home_footer_info_email\' | i18n:{email:BidspiritInfo.emailLink}"></div> <div class="text-line" ng-bind-html="\'home_footer_info_phone\' | i18n:{phone:BidspiritInfo.phoneLink}"></div> </div> <div class="float vertical-separator" ng-class="{invisible:shouldHideContactUs()}"></div> <div class="contact-us-part info-part col-xs-5" > <div class="pc-message hidden-xs hidden-sm" ng-class="{invisible:shouldHideContactUs()}"> <div class="message"> {{"home_footer_contact_text" | i18n }} </div> <div class="orange common-button center-block" bs-check-bidmood ui-sref="app.contact"> <div class="text">{{"home_footer_contact_button" | i18n }}</div> </div> </div>  <div class="mobile-links hidden-md hidden-lg"> <a class="btn-link" ng-href="#!/contact">{{"link_contact" | i18n}}</a> <a class="btn-link" ng-click="showInfoPopup(\'terms\')">{{"link_terms" | i18n}}</a>  <a class="btn-link" ng-click="showInfoPopup(\'privacy\')">{{"link_privacy" | i18n}}</a> <a class="btn-link" ng-href="#!/about">{{"link_about" | i18n}}</a> <a class="btn-link" ng-href="#!/product">{{"link_product" | i18n}}</a>  <a class="btn-link" ng-click="showAllFutureAuctions()">{{"all_future_auctions" | i18n}}</a> </div> </div>  <div class="clearfix"></div> </div>   <div class="horizontal-separator"></div>  <div class="second-line"> <div class="sell float col-xs-6" > <div class="float text">{{"home_footer_sell" | i18n }}&nbsp;</div>  <a class="float btn-link" ng-href="#!/houses">{{"home_footer_houses" | i18n}}</a> <div class="clearfix"></div> </div>  <div class="float col-xs-6 social" > <div class="text">{{"home_footer_follow" | i18n }}</div> <div class="icons"> <a class="button twitter" target="{{linkTarget}}" href="https://www.twitter.com/{{twitterPage}}"></a> <a class="button fb" target="{{linkTarget}}" href="https://www.facebook.com/{{fbPage}}"></a> </div> </div> <div class="clearfix"></div> </div>   <div> <div class="horizontal-separator"></div> <div class="hidden-xs hidden-sm">  <div class="bottom-links"> <a class="btn-link" ng-click="showInfoPopup(\'terms\')">{{"link_terms" | i18n}}</a>  <a class="btn-link" ng-click="showInfoPopup(\'privacy\')">{{"link_privacy" | i18n}}</a> <a class="btn-link" ng-href="#!/about">{{"link_about" | i18n}}</a> <a class="btn-link" ng-href="#!/product">{{"link_product" | i18n}}</a>  <a class="btn-link" ng-click="showAllFutureAuctions()">{{"all_future_auctions" | i18n}}</a> </div> <div class="horizontal-separator"></div> </div>  <div class="rights-line">	{{"home_footer_rights" | i18n }}	</div>  </div> <div class="clearfix"></div>  </div> <div class="clearfix"></div> </div> ');
    });
}), define("domReady", [], function() {
    function runCallbacks(callbacks) {
        var i;
        for (i = 0; i < callbacks.length; i += 1) callbacks[i](doc);
    }
    function callReady() {
        var callbacks = readyCalls;
        isPageLoaded && callbacks.length && (readyCalls = [], runCallbacks(callbacks));
    }
    function pageLoaded() {
        isPageLoaded || (isPageLoaded = !0, scrollIntervalId && clearInterval(scrollIntervalId), 
        callReady());
    }
    function domReady(callback) {
        return isPageLoaded ? callback(doc) : readyCalls.push(callback), domReady;
    }
    var isTop, testDiv, scrollIntervalId, isBrowser = "undefined" != typeof window && window.document, isPageLoaded = !isBrowser, doc = isBrowser ? document : null, readyCalls = [];
    if (isBrowser) {
        if (document.addEventListener) document.addEventListener("DOMContentLoaded", pageLoaded, !1), 
        window.addEventListener("load", pageLoaded, !1); else if (window.attachEvent) {
            window.attachEvent("onload", pageLoaded), testDiv = document.createElement("div");
            try {
                isTop = null === window.frameElement;
            } catch (e) {}
            testDiv.doScroll && isTop && window.external && (scrollIntervalId = setInterval(function() {
                try {
                    testDiv.doScroll(), pageLoaded();
                } catch (e) {}
            }, 30));
        }
        "complete" === document.readyState && pageLoaded();
    }
    return domReady.version = "2.0.1", domReady.load = function(name, req, onLoad, config) {
        config.isBuild ? onLoad(null) : domReady(onLoad);
    }, domReady;
}), function() {
    function FastClick(layer, options) {
        function bind(method, context) {
            return function() {
                return method.apply(context, arguments);
            };
        }
        var oldOnClick;
        if (options = options || {}, this.trackingClick = !1, this.trackingClickStart = 0, 
        this.targetElement = null, this.touchStartX = 0, this.touchStartY = 0, this.lastTouchIdentifier = 0, 
        this.touchBoundary = options.touchBoundary || 10, this.layer = layer, this.tapDelay = options.tapDelay || 200, 
        this.tapTimeout = options.tapTimeout || 700, !FastClick.notNeeded(layer)) {
            for (var methods = [ "onMouse", "onClick", "onTouchStart", "onTouchMove", "onTouchEnd", "onTouchCancel" ], context = this, i = 0, l = methods.length; l > i; i++) context[methods[i]] = bind(context[methods[i]], context);
            deviceIsAndroid && (layer.addEventListener("mouseover", this.onMouse, !0), layer.addEventListener("mousedown", this.onMouse, !0), 
            layer.addEventListener("mouseup", this.onMouse, !0)), layer.addEventListener("click", this.onClick, !0), 
            layer.addEventListener("touchstart", this.onTouchStart, !1), layer.addEventListener("touchmove", this.onTouchMove, !1), 
            layer.addEventListener("touchend", this.onTouchEnd, !1), layer.addEventListener("touchcancel", this.onTouchCancel, !1), 
            Event.prototype.stopImmediatePropagation || (layer.removeEventListener = function(type, callback, capture) {
                var rmv = Node.prototype.removeEventListener;
                "click" === type ? rmv.call(layer, type, callback.hijacked || callback, capture) : rmv.call(layer, type, callback, capture);
            }, layer.addEventListener = function(type, callback, capture) {
                var adv = Node.prototype.addEventListener;
                "click" === type ? adv.call(layer, type, callback.hijacked || (callback.hijacked = function(event) {
                    event.propagationStopped || callback(event);
                }), capture) : adv.call(layer, type, callback, capture);
            }), "function" == typeof layer.onclick && (oldOnClick = layer.onclick, layer.addEventListener("click", function(event) {
                oldOnClick(event);
            }, !1), layer.onclick = null);
        }
    }
    var deviceIsWindowsPhone = navigator.userAgent.indexOf("Windows Phone") >= 0, deviceIsAndroid = navigator.userAgent.indexOf("Android") > 0 && !deviceIsWindowsPhone, deviceIsIOS = /iP(ad|hone|od)/.test(navigator.userAgent) && !deviceIsWindowsPhone, deviceIsIOS4 = deviceIsIOS && /OS 4_\d(_\d)?/.test(navigator.userAgent), deviceIsIOSWithBadTarget = deviceIsIOS && /OS [6-7]_\d/.test(navigator.userAgent), deviceIsBlackBerry10 = navigator.userAgent.indexOf("BB10") > 0;
    FastClick.prototype.needsClick = function(target) {
        switch (target.nodeName.toLowerCase()) {
          case "button":
          case "select":
          case "textarea":
            if (target.disabled) return !0;
            break;

          case "input":
            if (deviceIsIOS && "file" === target.type || target.disabled) return !0;
            break;

          case "label":
          case "iframe":
          case "video":
            return !0;
        }
        return /\bneedsclick\b/.test(target.className);
    }, FastClick.prototype.needsFocus = function(target) {
        switch (target.nodeName.toLowerCase()) {
          case "textarea":
            return !0;

          case "select":
            return !deviceIsAndroid;

          case "input":
            switch (target.type) {
              case "button":
              case "checkbox":
              case "file":
              case "image":
              case "radio":
              case "submit":
                return !1;
            }
            return !target.disabled && !target.readOnly;

          default:
            return /\bneedsfocus\b/.test(target.className);
        }
    }, FastClick.prototype.sendClick = function(targetElement, event) {
        var clickEvent, touch;
        document.activeElement && document.activeElement !== targetElement && document.activeElement.blur(), 
        touch = event.changedTouches[0], clickEvent = document.createEvent("MouseEvents"), 
        clickEvent.initMouseEvent(this.determineEventType(targetElement), !0, !0, window, 1, touch.screenX, touch.screenY, touch.clientX, touch.clientY, !1, !1, !1, !1, 0, null), 
        clickEvent.forwardedTouchEvent = !0, targetElement.dispatchEvent(clickEvent);
    }, FastClick.prototype.determineEventType = function(targetElement) {
        return deviceIsAndroid && "select" === targetElement.tagName.toLowerCase() ? "mousedown" : "click";
    }, FastClick.prototype.focus = function(targetElement) {
        var length;
        deviceIsIOS && targetElement.setSelectionRange && 0 !== targetElement.type.indexOf("date") && "time" !== targetElement.type && "month" !== targetElement.type ? (length = targetElement.value.length, 
        targetElement.setSelectionRange(length, length)) : targetElement.focus();
    }, FastClick.prototype.updateScrollParent = function(targetElement) {
        var scrollParent, parentElement;
        if (scrollParent = targetElement.fastClickScrollParent, !scrollParent || !scrollParent.contains(targetElement)) {
            parentElement = targetElement;
            do {
                if (parentElement.scrollHeight > parentElement.offsetHeight) {
                    scrollParent = parentElement, targetElement.fastClickScrollParent = parentElement;
                    break;
                }
                parentElement = parentElement.parentElement;
            } while (parentElement);
        }
        scrollParent && (scrollParent.fastClickLastScrollTop = scrollParent.scrollTop);
    }, FastClick.prototype.getTargetElementFromEventTarget = function(eventTarget) {
        return eventTarget.nodeType === Node.TEXT_NODE ? eventTarget.parentNode : eventTarget;
    }, FastClick.prototype.onTouchStart = function(event) {
        var targetElement, touch, selection;
        if (event.targetTouches.length > 1) return !0;
        if (targetElement = this.getTargetElementFromEventTarget(event.target), touch = event.targetTouches[0], 
        deviceIsIOS) {
            if (selection = window.getSelection(), selection.rangeCount && !selection.isCollapsed) return !0;
            if (!deviceIsIOS4) {
                if (touch.identifier && touch.identifier === this.lastTouchIdentifier) return event.preventDefault(), 
                !1;
                this.lastTouchIdentifier = touch.identifier, this.updateScrollParent(targetElement);
            }
        }
        return this.trackingClick = !0, this.trackingClickStart = event.timeStamp, this.targetElement = targetElement, 
        this.touchStartX = touch.pageX, this.touchStartY = touch.pageY, event.timeStamp - this.lastClickTime < this.tapDelay && event.preventDefault(), 
        !0;
    }, FastClick.prototype.touchHasMoved = function(event) {
        var touch = event.changedTouches[0], boundary = this.touchBoundary;
        return Math.abs(touch.pageX - this.touchStartX) > boundary || Math.abs(touch.pageY - this.touchStartY) > boundary ? !0 : !1;
    }, FastClick.prototype.onTouchMove = function(event) {
        return this.trackingClick ? ((this.targetElement !== this.getTargetElementFromEventTarget(event.target) || this.touchHasMoved(event)) && (this.trackingClick = !1, 
        this.targetElement = null), !0) : !0;
    }, FastClick.prototype.findControl = function(labelElement) {
        return void 0 !== labelElement.control ? labelElement.control : labelElement.htmlFor ? document.getElementById(labelElement.htmlFor) : labelElement.querySelector("button, input:not([type=hidden]), keygen, meter, output, progress, select, textarea");
    }, FastClick.prototype.onTouchEnd = function(event) {
        var forElement, trackingClickStart, targetTagName, scrollParent, touch, targetElement = this.targetElement;
        if (!this.trackingClick) return !0;
        if (event.timeStamp - this.lastClickTime < this.tapDelay) return this.cancelNextClick = !0, 
        !0;
        if (event.timeStamp - this.trackingClickStart > this.tapTimeout) return !0;
        if (this.cancelNextClick = !1, this.lastClickTime = event.timeStamp, trackingClickStart = this.trackingClickStart, 
        this.trackingClick = !1, this.trackingClickStart = 0, deviceIsIOSWithBadTarget && (touch = event.changedTouches[0], 
        targetElement = document.elementFromPoint(touch.pageX - window.pageXOffset, touch.pageY - window.pageYOffset) || targetElement, 
        targetElement.fastClickScrollParent = this.targetElement.fastClickScrollParent), 
        targetTagName = targetElement.tagName.toLowerCase(), "label" === targetTagName) {
            if (forElement = this.findControl(targetElement)) {
                if (this.focus(targetElement), deviceIsAndroid) return !1;
                targetElement = forElement;
            }
        } else if (this.needsFocus(targetElement)) return event.timeStamp - trackingClickStart > 100 || deviceIsIOS && window.top !== window && "input" === targetTagName ? (this.targetElement = null, 
        !1) : (this.focus(targetElement), this.sendClick(targetElement, event), deviceIsIOS && "select" === targetTagName || (this.targetElement = null, 
        event.preventDefault()), !1);
        return deviceIsIOS && !deviceIsIOS4 && (scrollParent = targetElement.fastClickScrollParent, 
        scrollParent && scrollParent.fastClickLastScrollTop !== scrollParent.scrollTop) ? !0 : (this.needsClick(targetElement) || (event.preventDefault(), 
        this.sendClick(targetElement, event)), !1);
    }, FastClick.prototype.onTouchCancel = function() {
        this.trackingClick = !1, this.targetElement = null;
    }, FastClick.prototype.onMouse = function(event) {
        return this.targetElement ? event.forwardedTouchEvent ? !0 : event.cancelable && (!this.needsClick(this.targetElement) || this.cancelNextClick) ? (event.stopImmediatePropagation ? event.stopImmediatePropagation() : event.propagationStopped = !0, 
        event.stopPropagation(), event.preventDefault(), !1) : !0 : !0;
    }, FastClick.prototype.onClick = function(event) {
        var permitted;
        return this.trackingClick ? (this.targetElement = null, this.trackingClick = !1, 
        !0) : "submit" === event.target.type && 0 === event.detail ? !0 : (permitted = this.onMouse(event), 
        permitted || (this.targetElement = null), permitted);
    }, FastClick.prototype.destroy = function() {
        var layer = this.layer;
        deviceIsAndroid && (layer.removeEventListener("mouseover", this.onMouse, !0), layer.removeEventListener("mousedown", this.onMouse, !0), 
        layer.removeEventListener("mouseup", this.onMouse, !0)), layer.removeEventListener("click", this.onClick, !0), 
        layer.removeEventListener("touchstart", this.onTouchStart, !1), layer.removeEventListener("touchmove", this.onTouchMove, !1), 
        layer.removeEventListener("touchend", this.onTouchEnd, !1), layer.removeEventListener("touchcancel", this.onTouchCancel, !1);
    }, FastClick.notNeeded = function(layer) {
        var metaViewport, chromeVersion, blackberryVersion, firefoxVersion;
        if ("undefined" == typeof window.ontouchstart) return !0;
        if (chromeVersion = +(/Chrome\/([0-9]+)/.exec(navigator.userAgent) || [ , 0 ])[1]) {
            if (!deviceIsAndroid) return !0;
            if (metaViewport = document.querySelector("meta[name=viewport]")) {
                if (-1 !== metaViewport.content.indexOf("user-scalable=no")) return !0;
                if (chromeVersion > 31 && document.documentElement.scrollWidth <= window.outerWidth) return !0;
            }
        }
        if (deviceIsBlackBerry10 && (blackberryVersion = navigator.userAgent.match(/Version\/([0-9]*)\.([0-9]*)/), 
        blackberryVersion[1] >= 10 && blackberryVersion[2] >= 3 && (metaViewport = document.querySelector("meta[name=viewport]")))) {
            if (-1 !== metaViewport.content.indexOf("user-scalable=no")) return !0;
            if (document.documentElement.scrollWidth <= window.outerWidth) return !0;
        }
        return "none" === layer.style.msTouchAction || "manipulation" === layer.style.touchAction ? !0 : (firefoxVersion = +(/Firefox\/([0-9]+)/.exec(navigator.userAgent) || [ , 0 ])[1], 
        firefoxVersion >= 27 && (metaViewport = document.querySelector("meta[name=viewport]"), 
        metaViewport && (-1 !== metaViewport.content.indexOf("user-scalable=no") || document.documentElement.scrollWidth <= window.outerWidth)) ? !0 : "none" === layer.style.touchAction || "manipulation" === layer.style.touchAction ? !0 : !1);
    }, FastClick.attach = function(layer, options) {
        return new FastClick(layer, options);
    }, "function" == typeof define && "object" == typeof define.amd && define.amd ? define("fastClick", [], function() {
        return FastClick;
    }) : "undefined" != typeof module && module.exports ? (module.exports = FastClick.attach, 
    module.exports.FastClick = FastClick) : window.FastClick = FastClick;
}(), window.location.hash && -1 != window.location.hash.indexOf("%21") && (window.location.hash = window.location.hash.replace("%21", "!")), 
define('portal/js/all', [ "require", "angular", "app", "commonModules", "domReady", "fastClick" ], function(require, ng) {
    require([ "domReady!", "fastClick" ], function(document, fastClick) {
        window.BIDSPIRIT_SNAPSHOT || (ng.bootstrap(document, [ "app" ]), fastClick.attach(document.body));
    });
});