/**
 * @license AngularJS v1.7.2
 * (c) 2010-2018 Google, Inc. http://angularjs.org
 * License: MIT
 */

/**
 * State-based routing for AngularJS 1.x
 * NOTICE: This monolithic bundle also bundles the @uirouter/core code.
 *         This causes it to be incompatible with plugins that depend on @uirouter/core.
 *         We recommend switching to the ui-router-core.js and ui-router-angularjs.js bundles instead.
 *         For more information, see https://ui-router.github.io/blog/uirouter-for-angularjs-umd-bundles
 * @version v1.0.20
 * @link https://ui-router.github.io
 * @license MIT License, http://www.opensource.org/licenses/MIT
 */

/**
         * Returns true if the provided parameter is the same state.
         *
         * Compares the identity of the state against the passed value, which is either an object
         * reference to the actual `State` instance, the original definition object passed to
         * `$stateProvider.state()`, or the fully-qualified name.
         *
         * @param ref Can be one of (a) a `State` instance, (b) an object that was passed
         *        into `$stateProvider.state()`, (c) the fully-qualified name of a state as a string.
         * @returns Returns `true` if `ref` matches the current `State` instance.
         */

/**
 * @license AngularJS v1.4.7
 * (c) 2010-2015 Google, Inc. http://angularjs.org
 * License: MIT
 */

/*!
  * Morpheus - A Brilliant Animator
  * https://github.com/ded/morpheus - (c) Dustin Diaz 2011
  * License MIT
  */

/**
 * @license Copyright 2013 Logentries.
 * Please view license at https://raw.github.com/logentries/le_js/master/LICENSE
 */

/*!
 * Pusher JavaScript Library v3.2.1
 * http://pusher.com/
 *
 * Copyright 2016, Pusher
 * Released under the MIT licence.
 */

/*! 3.15.2 / web */

/*
	 CryptoJS v3.1.2
	 code.google.com/p/crypto-js
	 (c) 2009-2013 by Jeff Mott. All rights reserved.
	 code.google.com/p/crypto-js/wiki/License
	 */

/**
 * @license RequireJS domReady 2.0.1 Copyright (c) 2010-2012, The Dojo Foundation All Rights Reserved.
 * Available via the MIT or new BSD license.
 * see: http://github.com/requirejs/domReady for details
 */

/**
     * @preserve FastClick: polyfill to remove click delays on browsers with touch UIs.
     *
     * @codingstandard ftlabs-jsv2
     * @copyright The Financial Times Limited [All Rights Reserved]
     * @license MIT License (see LICENSE.txt)
     */

function getServiceForDebug(serviceName) {
    return eval(serviceName + "= angular.element(document.body).injector().get(serviceName)");
}

function getControllerForDebug(contollerName) {
    return eval(contollerName + '=angular.element(document.querySelector("[ng-controller="+contollerName+"]")).scope()');
}

function getCurrentLotForDebug() {
    return eval('lot=angular.element(document.querySelector("[ng-controller=LotPageController]")).scope().data.item');
}

!function(window) {
    function errorHandlingConfig(config) {
        return isObject(config) ? (isDefined(config.objectMaxDepth) && (minErrConfig.objectMaxDepth = isValidObjectMaxDepth(config.objectMaxDepth) ? config.objectMaxDepth : 0/0), 
        void (isDefined(config.urlErrorParamsEnabled) && isBoolean(config.urlErrorParamsEnabled) && (minErrConfig.urlErrorParamsEnabled = config.urlErrorParamsEnabled))) : minErrConfig;
    }
    function isValidObjectMaxDepth(maxDepth) {
        return isNumber(maxDepth) && maxDepth > 0;
    }
    function minErr(module, ErrorConstructor) {
        ErrorConstructor = ErrorConstructor || Error;
        var url = "https://errors.angularjs.org/1.7.2/", regex = url.replace(".", "\\.") + "[\\s\\S]*", errRegExp = new RegExp(regex, "g");
        return function() {
            var paramPrefix, i, code = arguments[0], template = arguments[1], message = "[" + (module ? module + ":" : "") + code + "] ", templateArgs = sliceArgs(arguments, 2).map(function(arg) {
                return toDebugString(arg, minErrConfig.objectMaxDepth);
            });
            if (message += template.replace(/\{\d+\}/g, function(match) {
                var index = +match.slice(1, -1);
                return index < templateArgs.length ? templateArgs[index].replace(errRegExp, "") : match;
            }), message += "\n" + url + (module ? module + "/" : "") + code, minErrConfig.urlErrorParamsEnabled) for (i = 0, 
            paramPrefix = "?"; i < templateArgs.length; i++, paramPrefix = "&") message += paramPrefix + "p" + i + "=" + encodeURIComponent(templateArgs[i]);
            return new ErrorConstructor(message);
        };
    }
    function isArrayLike(obj) {
        if (null == obj || isWindow(obj)) return !1;
        if (isArray(obj) || isString(obj) || jqLite && obj instanceof jqLite) return !0;
        var length = "length" in Object(obj) && obj.length;
        return isNumber(length) && (length >= 0 && length - 1 in obj || "function" == typeof obj.item);
    }
    function forEach(obj, iterator, context) {
        var key, length;
        if (obj) if (isFunction(obj)) for (key in obj) "prototype" !== key && "length" !== key && "name" !== key && obj.hasOwnProperty(key) && iterator.call(context, obj[key], key, obj); else if (isArray(obj) || isArrayLike(obj)) {
            var isPrimitive = "object" != typeof obj;
            for (key = 0, length = obj.length; length > key; key++) (isPrimitive || key in obj) && iterator.call(context, obj[key], key, obj);
        } else if (obj.forEach && obj.forEach !== forEach) obj.forEach(iterator, context, obj); else if (isBlankObject(obj)) for (key in obj) iterator.call(context, obj[key], key, obj); else if ("function" == typeof obj.hasOwnProperty) for (key in obj) obj.hasOwnProperty(key) && iterator.call(context, obj[key], key, obj); else for (key in obj) hasOwnProperty.call(obj, key) && iterator.call(context, obj[key], key, obj);
        return obj;
    }
    function forEachSorted(obj, iterator, context) {
        for (var keys = Object.keys(obj).sort(), i = 0; i < keys.length; i++) iterator.call(context, obj[keys[i]], keys[i]);
        return keys;
    }
    function reverseParams(iteratorFn) {
        return function(value, key) {
            iteratorFn(key, value);
        };
    }
    function nextUid() {
        return ++uid;
    }
    function setHashKey(obj, h) {
        h ? obj.$$hashKey = h : delete obj.$$hashKey;
    }
    function baseExtend(dst, objs, deep) {
        for (var h = dst.$$hashKey, i = 0, ii = objs.length; ii > i; ++i) {
            var obj = objs[i];
            if (isObject(obj) || isFunction(obj)) for (var keys = Object.keys(obj), j = 0, jj = keys.length; jj > j; j++) {
                var key = keys[j], src = obj[key];
                deep && isObject(src) ? isDate(src) ? dst[key] = new Date(src.valueOf()) : isRegExp(src) ? dst[key] = new RegExp(src) : src.nodeName ? dst[key] = src.cloneNode(!0) : isElement(src) ? dst[key] = src.clone() : (isObject(dst[key]) || (dst[key] = isArray(src) ? [] : {}), 
                baseExtend(dst[key], [ src ], !0)) : dst[key] = src;
            }
        }
        return setHashKey(dst, h), dst;
    }
    function extend(dst) {
        return baseExtend(dst, slice.call(arguments, 1), !1);
    }
    function merge(dst) {
        return baseExtend(dst, slice.call(arguments, 1), !0);
    }
    function toInt(str) {
        return parseInt(str, 10);
    }
    function inherit(parent, extra) {
        return extend(Object.create(parent), extra);
    }
    function noop() {}
    function identity($) {
        return $;
    }
    function valueFn(value) {
        return function() {
            return value;
        };
    }
    function hasCustomToString(obj) {
        return isFunction(obj.toString) && obj.toString !== toString;
    }
    function isUndefined(value) {
        return "undefined" == typeof value;
    }
    function isDefined(value) {
        return "undefined" != typeof value;
    }
    function isObject(value) {
        return null !== value && "object" == typeof value;
    }
    function isBlankObject(value) {
        return null !== value && "object" == typeof value && !getPrototypeOf(value);
    }
    function isString(value) {
        return "string" == typeof value;
    }
    function isNumber(value) {
        return "number" == typeof value;
    }
    function isDate(value) {
        return "[object Date]" === toString.call(value);
    }
    function isArray(arr) {
        return Array.isArray(arr) || arr instanceof Array;
    }
    function isError(value) {
        var tag = toString.call(value);
        switch (tag) {
          case "[object Error]":
            return !0;

          case "[object Exception]":
            return !0;

          case "[object DOMException]":
            return !0;

          default:
            return value instanceof Error;
        }
    }
    function isFunction(value) {
        return "function" == typeof value;
    }
    function isRegExp(value) {
        return "[object RegExp]" === toString.call(value);
    }
    function isWindow(obj) {
        return obj && obj.window === obj;
    }
    function isScope(obj) {
        return obj && obj.$evalAsync && obj.$watch;
    }
    function isFile(obj) {
        return "[object File]" === toString.call(obj);
    }
    function isFormData(obj) {
        return "[object FormData]" === toString.call(obj);
    }
    function isBlob(obj) {
        return "[object Blob]" === toString.call(obj);
    }
    function isBoolean(value) {
        return "boolean" == typeof value;
    }
    function isPromiseLike(obj) {
        return obj && isFunction(obj.then);
    }
    function isTypedArray(value) {
        return value && isNumber(value.length) && TYPED_ARRAY_REGEXP.test(toString.call(value));
    }
    function isArrayBuffer(obj) {
        return "[object ArrayBuffer]" === toString.call(obj);
    }
    function isElement(node) {
        return !(!node || !(node.nodeName || node.prop && node.attr && node.find));
    }
    function makeMap(str) {
        var i, obj = {}, items = str.split(",");
        for (i = 0; i < items.length; i++) obj[items[i]] = !0;
        return obj;
    }
    function nodeName_(element) {
        return lowercase(element.nodeName || element[0] && element[0].nodeName);
    }
    function includes(array, obj) {
        return -1 !== Array.prototype.indexOf.call(array, obj);
    }
    function arrayRemove(array, value) {
        var index = array.indexOf(value);
        return index >= 0 && array.splice(index, 1), index;
    }
    function copy(source, destination, maxDepth) {
        function copyRecurse(source, destination, maxDepth) {
            if (maxDepth--, 0 > maxDepth) return "...";
            var key, h = destination.$$hashKey;
            if (isArray(source)) for (var i = 0, ii = source.length; ii > i; i++) destination.push(copyElement(source[i], maxDepth)); else if (isBlankObject(source)) for (key in source) destination[key] = copyElement(source[key], maxDepth); else if (source && "function" == typeof source.hasOwnProperty) for (key in source) source.hasOwnProperty(key) && (destination[key] = copyElement(source[key], maxDepth)); else for (key in source) hasOwnProperty.call(source, key) && (destination[key] = copyElement(source[key], maxDepth));
            return setHashKey(destination, h), destination;
        }
        function copyElement(source, maxDepth) {
            if (!isObject(source)) return source;
            var index = stackSource.indexOf(source);
            if (-1 !== index) return stackDest[index];
            if (isWindow(source) || isScope(source)) throw ngMinErr("cpws", "Can't copy! Making copies of Window or Scope instances is not supported.");
            var needsRecurse = !1, destination = copyType(source);
            return void 0 === destination && (destination = isArray(source) ? [] : Object.create(getPrototypeOf(source)), 
            needsRecurse = !0), stackSource.push(source), stackDest.push(destination), needsRecurse ? copyRecurse(source, destination, maxDepth) : destination;
        }
        function copyType(source) {
            switch (toString.call(source)) {
              case "[object Int8Array]":
              case "[object Int16Array]":
              case "[object Int32Array]":
              case "[object Float32Array]":
              case "[object Float64Array]":
              case "[object Uint8Array]":
              case "[object Uint8ClampedArray]":
              case "[object Uint16Array]":
              case "[object Uint32Array]":
                return new source.constructor(copyElement(source.buffer), source.byteOffset, source.length);

              case "[object ArrayBuffer]":
                if (!source.slice) {
                    var copied = new ArrayBuffer(source.byteLength);
                    return new Uint8Array(copied).set(new Uint8Array(source)), copied;
                }
                return source.slice(0);

              case "[object Boolean]":
              case "[object Number]":
              case "[object String]":
              case "[object Date]":
                return new source.constructor(source.valueOf());

              case "[object RegExp]":
                var re = new RegExp(source.source, source.toString().match(/[^\/]*$/)[0]);
                return re.lastIndex = source.lastIndex, re;

              case "[object Blob]":
                return new source.constructor([ source ], {
                    type: source.type
                });
            }
            return isFunction(source.cloneNode) ? source.cloneNode(!0) : void 0;
        }
        var stackSource = [], stackDest = [];
        if (maxDepth = isValidObjectMaxDepth(maxDepth) ? maxDepth : 0/0, destination) {
            if (isTypedArray(destination) || isArrayBuffer(destination)) throw ngMinErr("cpta", "Can't copy! TypedArray destination cannot be mutated.");
            if (source === destination) throw ngMinErr("cpi", "Can't copy! Source and destination are identical.");
            return isArray(destination) ? destination.length = 0 : forEach(destination, function(value, key) {
                "$$hashKey" !== key && delete destination[key];
            }), stackSource.push(source), stackDest.push(destination), copyRecurse(source, destination, maxDepth);
        }
        return copyElement(source, maxDepth);
    }
    function simpleCompare(a, b) {
        return a === b || a !== a && b !== b;
    }
    function equals(o1, o2) {
        if (o1 === o2) return !0;
        if (null === o1 || null === o2) return !1;
        if (o1 !== o1 && o2 !== o2) return !0;
        var length, key, keySet, t1 = typeof o1, t2 = typeof o2;
        if (t1 === t2 && "object" === t1) {
            if (!isArray(o1)) {
                if (isDate(o1)) return isDate(o2) ? simpleCompare(o1.getTime(), o2.getTime()) : !1;
                if (isRegExp(o1)) return isRegExp(o2) ? o1.toString() === o2.toString() : !1;
                if (isScope(o1) || isScope(o2) || isWindow(o1) || isWindow(o2) || isArray(o2) || isDate(o2) || isRegExp(o2)) return !1;
                keySet = createMap();
                for (key in o1) if ("$" !== key.charAt(0) && !isFunction(o1[key])) {
                    if (!equals(o1[key], o2[key])) return !1;
                    keySet[key] = !0;
                }
                for (key in o2) if (!(key in keySet) && "$" !== key.charAt(0) && isDefined(o2[key]) && !isFunction(o2[key])) return !1;
                return !0;
            }
            if (!isArray(o2)) return !1;
            if ((length = o1.length) === o2.length) {
                for (key = 0; length > key; key++) if (!equals(o1[key], o2[key])) return !1;
                return !0;
            }
        }
        return !1;
    }
    function concat(array1, array2, index) {
        return array1.concat(slice.call(array2, index));
    }
    function sliceArgs(args, startIndex) {
        return slice.call(args, startIndex || 0);
    }
    function bind(self, fn) {
        var curryArgs = arguments.length > 2 ? sliceArgs(arguments, 2) : [];
        return !isFunction(fn) || fn instanceof RegExp ? fn : curryArgs.length ? function() {
            return arguments.length ? fn.apply(self, concat(curryArgs, arguments, 0)) : fn.apply(self, curryArgs);
        } : function() {
            return arguments.length ? fn.apply(self, arguments) : fn.call(self);
        };
    }
    function toJsonReplacer(key, value) {
        var val = value;
        return "string" == typeof key && "$" === key.charAt(0) && "$" === key.charAt(1) ? val = void 0 : isWindow(value) ? val = "$WINDOW" : value && window.document === value ? val = "$DOCUMENT" : isScope(value) && (val = "$SCOPE"), 
        val;
    }
    function toJson(obj, pretty) {
        return isUndefined(obj) ? void 0 : (isNumber(pretty) || (pretty = pretty ? 2 : null), 
        JSON.stringify(obj, toJsonReplacer, pretty));
    }
    function fromJson(json) {
        return isString(json) ? JSON.parse(json) : json;
    }
    function timezoneToOffset(timezone, fallback) {
        timezone = timezone.replace(ALL_COLONS, "");
        var requestedTimezoneOffset = Date.parse("Jan 01, 1970 00:00:00 " + timezone) / 6e4;
        return isNumberNaN(requestedTimezoneOffset) ? fallback : requestedTimezoneOffset;
    }
    function addDateMinutes(date, minutes) {
        return date = new Date(date.getTime()), date.setMinutes(date.getMinutes() + minutes), 
        date;
    }
    function convertTimezoneToLocal(date, timezone, reverse) {
        reverse = reverse ? -1 : 1;
        var dateTimezoneOffset = date.getTimezoneOffset(), timezoneOffset = timezoneToOffset(timezone, dateTimezoneOffset);
        return addDateMinutes(date, reverse * (timezoneOffset - dateTimezoneOffset));
    }
    function startingTag(element) {
        element = jqLite(element).clone().empty();
        var elemHtml = jqLite("<div></div>").append(element).html();
        try {
            return element[0].nodeType === NODE_TYPE_TEXT ? lowercase(elemHtml) : elemHtml.match(/^(<[^>]+>)/)[1].replace(/^<([\w-]+)/, function(match, nodeName) {
                return "<" + lowercase(nodeName);
            });
        } catch (e) {
            return lowercase(elemHtml);
        }
    }
    function tryDecodeURIComponent(value) {
        try {
            return decodeURIComponent(value);
        } catch (e) {}
    }
    function parseKeyValue(keyValue) {
        var obj = {};
        return forEach((keyValue || "").split("&"), function(keyValue) {
            var splitPoint, key, val;
            keyValue && (key = keyValue = keyValue.replace(/\+/g, "%20"), splitPoint = keyValue.indexOf("="), 
            -1 !== splitPoint && (key = keyValue.substring(0, splitPoint), val = keyValue.substring(splitPoint + 1)), 
            key = tryDecodeURIComponent(key), isDefined(key) && (val = isDefined(val) ? tryDecodeURIComponent(val) : !0, 
            hasOwnProperty.call(obj, key) ? isArray(obj[key]) ? obj[key].push(val) : obj[key] = [ obj[key], val ] : obj[key] = val));
        }), obj;
    }
    function toKeyValue(obj) {
        var parts = [];
        return forEach(obj, function(value, key) {
            isArray(value) ? forEach(value, function(arrayValue) {
                parts.push(encodeUriQuery(key, !0) + (arrayValue === !0 ? "" : "=" + encodeUriQuery(arrayValue, !0)));
            }) : parts.push(encodeUriQuery(key, !0) + (value === !0 ? "" : "=" + encodeUriQuery(value, !0)));
        }), parts.length ? parts.join("&") : "";
    }
    function encodeUriSegment(val) {
        return encodeUriQuery(val, !0).replace(/%26/gi, "&").replace(/%3D/gi, "=").replace(/%2B/gi, "+");
    }
    function encodeUriQuery(val, pctEncodeSpaces) {
        return encodeURIComponent(val).replace(/%40/gi, "@").replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%3B/gi, ";").replace(/%20/g, pctEncodeSpaces ? "%20" : "+");
    }
    function getNgAttribute(element, ngAttr) {
        var attr, i, ii = ngAttrPrefixes.length;
        for (i = 0; ii > i; ++i) if (attr = ngAttrPrefixes[i] + ngAttr, isString(attr = element.getAttribute(attr))) return attr;
        return null;
    }
    function allowAutoBootstrap(document) {
        var script = document.currentScript;
        if (!script) return !0;
        if (!(script instanceof window.HTMLScriptElement || script instanceof window.SVGScriptElement)) return !1;
        var attributes = script.attributes, srcs = [ attributes.getNamedItem("src"), attributes.getNamedItem("href"), attributes.getNamedItem("xlink:href") ];
        return srcs.every(function(src) {
            if (!src) return !0;
            if (!src.value) return !1;
            var link = document.createElement("a");
            if (link.href = src.value, document.location.origin === link.origin) return !0;
            switch (link.protocol) {
              case "http:":
              case "https:":
              case "ftp:":
              case "blob:":
              case "file:":
              case "data:":
                return !0;

              default:
                return !1;
            }
        });
    }
    function angularInit(element, bootstrap) {
        var appElement, module, config = {};
        if (forEach(ngAttrPrefixes, function(prefix) {
            var name = prefix + "app";
            !appElement && element.hasAttribute && element.hasAttribute(name) && (appElement = element, 
            module = element.getAttribute(name));
        }), forEach(ngAttrPrefixes, function(prefix) {
            var candidate, name = prefix + "app";
            !appElement && (candidate = element.querySelector("[" + name.replace(":", "\\:") + "]")) && (appElement = candidate, 
            module = candidate.getAttribute(name));
        }), appElement) {
            if (!isAutoBootstrapAllowed) return void window.console.error("AngularJS: disabling automatic bootstrap. <script> protocol indicates an extension, document.location.href does not match.");
            config.strictDi = null !== getNgAttribute(appElement, "strict-di"), bootstrap(appElement, module ? [ module ] : [], config);
        }
    }
    function bootstrap(element, modules, config) {
        isObject(config) || (config = {});
        var defaultConfig = {
            strictDi: !1
        };
        config = extend(defaultConfig, config);
        var doBootstrap = function() {
            if (element = jqLite(element), element.injector()) {
                var tag = element[0] === window.document ? "document" : startingTag(element);
                throw ngMinErr("btstrpd", "App already bootstrapped with this element '{0}'", tag.replace(/</, "&lt;").replace(/>/, "&gt;"));
            }
            modules = modules || [], modules.unshift([ "$provide", function($provide) {
                $provide.value("$rootElement", element);
            } ]), config.debugInfoEnabled && modules.push([ "$compileProvider", function($compileProvider) {
                $compileProvider.debugInfoEnabled(!0);
            } ]), modules.unshift("ng");
            var injector = createInjector(modules, config.strictDi);
            return injector.invoke([ "$rootScope", "$rootElement", "$compile", "$injector", function(scope, element, compile, injector) {
                scope.$apply(function() {
                    element.data("$injector", injector), compile(element)(scope);
                });
            } ]), injector;
        }, NG_ENABLE_DEBUG_INFO = /^NG_ENABLE_DEBUG_INFO!/, NG_DEFER_BOOTSTRAP = /^NG_DEFER_BOOTSTRAP!/;
        return window && NG_ENABLE_DEBUG_INFO.test(window.name) && (config.debugInfoEnabled = !0, 
        window.name = window.name.replace(NG_ENABLE_DEBUG_INFO, "")), window && !NG_DEFER_BOOTSTRAP.test(window.name) ? doBootstrap() : (window.name = window.name.replace(NG_DEFER_BOOTSTRAP, ""), 
        angular.resumeBootstrap = function(extraModules) {
            return forEach(extraModules, function(module) {
                modules.push(module);
            }), doBootstrap();
        }, void (isFunction(angular.resumeDeferredBootstrap) && angular.resumeDeferredBootstrap()));
    }
    function reloadWithDebugInfo() {
        window.name = "NG_ENABLE_DEBUG_INFO!" + window.name, window.location.reload();
    }
    function getTestability(rootElement) {
        var injector = angular.element(rootElement).injector();
        if (!injector) throw ngMinErr("test", "no injector found for element argument to getTestability");
        return injector.get("$$testability");
    }
    function snake_case(name, separator) {
        return separator = separator || "_", name.replace(SNAKE_CASE_REGEXP, function(letter, pos) {
            return (pos ? separator : "") + letter.toLowerCase();
        });
    }
    function bindJQuery() {
        var originalCleanData;
        if (!bindJQueryFired) {
            var jqName = jq();
            jQuery = isUndefined(jqName) ? window.jQuery : jqName ? window[jqName] : void 0, 
            jQuery && jQuery.fn.on ? (jqLite = jQuery, extend(jQuery.fn, {
                scope: JQLitePrototype.scope,
                isolateScope: JQLitePrototype.isolateScope,
                controller: JQLitePrototype.controller,
                injector: JQLitePrototype.injector,
                inheritedData: JQLitePrototype.inheritedData
            })) : jqLite = JQLite, originalCleanData = jqLite.cleanData, jqLite.cleanData = function(elems) {
                for (var events, elem, i = 0; null != (elem = elems[i]); i++) events = jqLite._data(elem).events, 
                events && events.$destroy && jqLite(elem).triggerHandler("$destroy");
                originalCleanData(elems);
            }, angular.element = jqLite, bindJQueryFired = !0;
        }
    }
    function assertArg(arg, name, reason) {
        if (!arg) throw ngMinErr("areq", "Argument '{0}' is {1}", name || "?", reason || "required");
        return arg;
    }
    function assertArgFn(arg, name, acceptArrayAnnotation) {
        return acceptArrayAnnotation && isArray(arg) && (arg = arg[arg.length - 1]), assertArg(isFunction(arg), name, "not a function, got " + (arg && "object" == typeof arg ? arg.constructor.name || "Object" : typeof arg)), 
        arg;
    }
    function assertNotHasOwnProperty(name, context) {
        if ("hasOwnProperty" === name) throw ngMinErr("badname", "hasOwnProperty is not a valid {0} name", context);
    }
    function getter(obj, path, bindFnToScope) {
        if (!path) return obj;
        for (var key, keys = path.split("."), lastInstance = obj, len = keys.length, i = 0; len > i; i++) key = keys[i], 
        obj && (obj = (lastInstance = obj)[key]);
        return !bindFnToScope && isFunction(obj) ? bind(lastInstance, obj) : obj;
    }
    function getBlockNodes(nodes) {
        for (var blockNodes, node = nodes[0], endNode = nodes[nodes.length - 1], i = 1; node !== endNode && (node = node.nextSibling); i++) (blockNodes || nodes[i] !== node) && (blockNodes || (blockNodes = jqLite(slice.call(nodes, 0, i))), 
        blockNodes.push(node));
        return blockNodes || nodes;
    }
    function createMap() {
        return Object.create(null);
    }
    function stringify(value) {
        if (null == value) return "";
        switch (typeof value) {
          case "string":
            break;

          case "number":
            value = "" + value;
            break;

          default:
            value = !hasCustomToString(value) || isArray(value) || isDate(value) ? toJson(value) : value.toString();
        }
        return value;
    }
    function setupModuleLoader(window) {
        function ensure(obj, name, factory) {
            return obj[name] || (obj[name] = factory());
        }
        var $injectorMinErr = minErr("$injector"), ngMinErr = minErr("ng"), angular = ensure(window, "angular", Object);
        return angular.$$minErr = angular.$$minErr || minErr, ensure(angular, "module", function() {
            var modules = {};
            return function(name, requires, configFn) {
                var info = {}, assertNotHasOwnProperty = function(name, context) {
                    if ("hasOwnProperty" === name) throw ngMinErr("badname", "hasOwnProperty is not a valid {0} name", context);
                };
                return assertNotHasOwnProperty(name, "module"), requires && modules.hasOwnProperty(name) && (modules[name] = null), 
                ensure(modules, name, function() {
                    function invokeLater(provider, method, insertMethod, queue) {
                        return queue || (queue = invokeQueue), function() {
                            return queue[insertMethod || "push"]([ provider, method, arguments ]), moduleInstance;
                        };
                    }
                    function invokeLaterAndSetModuleName(provider, method, queue) {
                        return queue || (queue = invokeQueue), function(recipeName, factoryFunction) {
                            return factoryFunction && isFunction(factoryFunction) && (factoryFunction.$$moduleName = name), 
                            queue.push([ provider, method, arguments ]), moduleInstance;
                        };
                    }
                    if (!requires) throw $injectorMinErr("nomod", "Module '{0}' is not available! You either misspelled the module name or forgot to load it. If registering a module ensure that you specify the dependencies as the second argument.", name);
                    var invokeQueue = [], configBlocks = [], runBlocks = [], config = invokeLater("$injector", "invoke", "push", configBlocks), moduleInstance = {
                        _invokeQueue: invokeQueue,
                        _configBlocks: configBlocks,
                        _runBlocks: runBlocks,
                        info: function(value) {
                            if (isDefined(value)) {
                                if (!isObject(value)) throw ngMinErr("aobj", "Argument '{0}' must be an object", "value");
                                return info = value, this;
                            }
                            return info;
                        },
                        requires: requires,
                        name: name,
                        provider: invokeLaterAndSetModuleName("$provide", "provider"),
                        factory: invokeLaterAndSetModuleName("$provide", "factory"),
                        service: invokeLaterAndSetModuleName("$provide", "service"),
                        value: invokeLater("$provide", "value"),
                        constant: invokeLater("$provide", "constant", "unshift"),
                        decorator: invokeLaterAndSetModuleName("$provide", "decorator", configBlocks),
                        animation: invokeLaterAndSetModuleName("$animateProvider", "register"),
                        filter: invokeLaterAndSetModuleName("$filterProvider", "register"),
                        controller: invokeLaterAndSetModuleName("$controllerProvider", "register"),
                        directive: invokeLaterAndSetModuleName("$compileProvider", "directive"),
                        component: invokeLaterAndSetModuleName("$compileProvider", "component"),
                        config: config,
                        run: function(block) {
                            return runBlocks.push(block), this;
                        }
                    };
                    return configFn && config(configFn), moduleInstance;
                });
            };
        });
    }
    function shallowCopy(src, dst) {
        if (isArray(src)) {
            dst = dst || [];
            for (var i = 0, ii = src.length; ii > i; i++) dst[i] = src[i];
        } else if (isObject(src)) {
            dst = dst || {};
            for (var key in src) ("$" !== key.charAt(0) || "$" !== key.charAt(1)) && (dst[key] = src[key]);
        }
        return dst || src;
    }
    function serializeObject(obj, maxDepth) {
        var seen = [];
        return isValidObjectMaxDepth(maxDepth) && (obj = angular.copy(obj, null, maxDepth)), 
        JSON.stringify(obj, function(key, val) {
            if (val = toJsonReplacer(key, val), isObject(val)) {
                if (seen.indexOf(val) >= 0) return "...";
                seen.push(val);
            }
            return val;
        });
    }
    function toDebugString(obj, maxDepth) {
        return "function" == typeof obj ? obj.toString().replace(/ \{[\s\S]*$/, "") : isUndefined(obj) ? "undefined" : "string" != typeof obj ? serializeObject(obj, maxDepth) : obj;
    }
    function publishExternalAPI(angular) {
        extend(angular, {
            errorHandlingConfig: errorHandlingConfig,
            bootstrap: bootstrap,
            copy: copy,
            extend: extend,
            merge: merge,
            equals: equals,
            element: jqLite,
            forEach: forEach,
            injector: createInjector,
            noop: noop,
            bind: bind,
            toJson: toJson,
            fromJson: fromJson,
            identity: identity,
            isUndefined: isUndefined,
            isDefined: isDefined,
            isString: isString,
            isFunction: isFunction,
            isObject: isObject,
            isNumber: isNumber,
            isElement: isElement,
            isArray: isArray,
            version: version,
            isDate: isDate,
            callbacks: {
                $$counter: 0
            },
            getTestability: getTestability,
            reloadWithDebugInfo: reloadWithDebugInfo,
            $$minErr: minErr,
            $$csp: csp,
            $$encodeUriSegment: encodeUriSegment,
            $$encodeUriQuery: encodeUriQuery,
            $$lowercase: lowercase,
            $$stringify: stringify,
            $$uppercase: uppercase
        }), angularModule = setupModuleLoader(window), angularModule("ng", [ "ngLocale" ], [ "$provide", function($provide) {
            $provide.provider({
                $$sanitizeUri: $$SanitizeUriProvider
            }), $provide.provider("$compile", $CompileProvider).directive({
                a: htmlAnchorDirective,
                input: inputDirective,
                textarea: inputDirective,
                form: formDirective,
                script: scriptDirective,
                select: selectDirective,
                option: optionDirective,
                ngBind: ngBindDirective,
                ngBindHtml: ngBindHtmlDirective,
                ngBindTemplate: ngBindTemplateDirective,
                ngClass: ngClassDirective,
                ngClassEven: ngClassEvenDirective,
                ngClassOdd: ngClassOddDirective,
                ngCloak: ngCloakDirective,
                ngController: ngControllerDirective,
                ngForm: ngFormDirective,
                ngHide: ngHideDirective,
                ngIf: ngIfDirective,
                ngInclude: ngIncludeDirective,
                ngInit: ngInitDirective,
                ngNonBindable: ngNonBindableDirective,
                ngPluralize: ngPluralizeDirective,
                ngRef: ngRefDirective,
                ngRepeat: ngRepeatDirective,
                ngShow: ngShowDirective,
                ngStyle: ngStyleDirective,
                ngSwitch: ngSwitchDirective,
                ngSwitchWhen: ngSwitchWhenDirective,
                ngSwitchDefault: ngSwitchDefaultDirective,
                ngOptions: ngOptionsDirective,
                ngTransclude: ngTranscludeDirective,
                ngModel: ngModelDirective,
                ngList: ngListDirective,
                ngChange: ngChangeDirective,
                pattern: patternDirective,
                ngPattern: patternDirective,
                required: requiredDirective,
                ngRequired: requiredDirective,
                minlength: minlengthDirective,
                ngMinlength: minlengthDirective,
                maxlength: maxlengthDirective,
                ngMaxlength: maxlengthDirective,
                ngValue: ngValueDirective,
                ngModelOptions: ngModelOptionsDirective
            }).directive({
                ngInclude: ngIncludeFillContentDirective
            }).directive(ngAttributeAliasDirectives).directive(ngEventDirectives), $provide.provider({
                $anchorScroll: $AnchorScrollProvider,
                $animate: $AnimateProvider,
                $animateCss: $CoreAnimateCssProvider,
                $$animateJs: $$CoreAnimateJsProvider,
                $$animateQueue: $$CoreAnimateQueueProvider,
                $$AnimateRunner: $$AnimateRunnerFactoryProvider,
                $$animateAsyncRun: $$AnimateAsyncRunFactoryProvider,
                $browser: $BrowserProvider,
                $cacheFactory: $CacheFactoryProvider,
                $controller: $ControllerProvider,
                $document: $DocumentProvider,
                $$isDocumentHidden: $$IsDocumentHiddenProvider,
                $exceptionHandler: $ExceptionHandlerProvider,
                $filter: $FilterProvider,
                $$forceReflow: $$ForceReflowProvider,
                $interpolate: $InterpolateProvider,
                $interval: $IntervalProvider,
                $http: $HttpProvider,
                $httpParamSerializer: $HttpParamSerializerProvider,
                $httpParamSerializerJQLike: $HttpParamSerializerJQLikeProvider,
                $httpBackend: $HttpBackendProvider,
                $xhrFactory: $xhrFactoryProvider,
                $jsonpCallbacks: $jsonpCallbacksProvider,
                $location: $LocationProvider,
                $log: $LogProvider,
                $parse: $ParseProvider,
                $rootScope: $RootScopeProvider,
                $q: $QProvider,
                $$q: $$QProvider,
                $sce: $SceProvider,
                $sceDelegate: $SceDelegateProvider,
                $sniffer: $SnifferProvider,
                $templateCache: $TemplateCacheProvider,
                $templateRequest: $TemplateRequestProvider,
                $$testability: $$TestabilityProvider,
                $timeout: $TimeoutProvider,
                $window: $WindowProvider,
                $$rAF: $$RAFProvider,
                $$jqLite: $$jqLiteProvider,
                $$Map: $$MapProvider,
                $$cookieReader: $$CookieReaderProvider
            });
        } ]).info({
            angularVersion: "1.7.2"
        });
    }
    function jqNextId() {
        return ++jqId;
    }
    function cssKebabToCamel(name) {
        return kebabToCamel(name.replace(MS_HACK_REGEXP, "ms-"));
    }
    function fnCamelCaseReplace(all, letter) {
        return letter.toUpperCase();
    }
    function kebabToCamel(name) {
        return name.replace(DASH_LOWERCASE_REGEXP, fnCamelCaseReplace);
    }
    function jqLiteIsTextNode(html) {
        return !HTML_REGEXP.test(html);
    }
    function jqLiteAcceptsData(node) {
        var nodeType = node.nodeType;
        return nodeType === NODE_TYPE_ELEMENT || !nodeType || nodeType === NODE_TYPE_DOCUMENT;
    }
    function jqLiteHasData(node) {
        for (var key in jqCache[node.ng339]) return !0;
        return !1;
    }
    function jqLiteBuildFragment(html, context) {
        var tmp, tag, wrap, i, fragment = context.createDocumentFragment(), nodes = [];
        if (jqLiteIsTextNode(html)) nodes.push(context.createTextNode(html)); else {
            for (tmp = fragment.appendChild(context.createElement("div")), tag = (TAG_NAME_REGEXP.exec(html) || [ "", "" ])[1].toLowerCase(), 
            wrap = wrapMap[tag] || wrapMap._default, tmp.innerHTML = wrap[1] + html.replace(XHTML_TAG_REGEXP, "<$1></$2>") + wrap[2], 
            i = wrap[0]; i--; ) tmp = tmp.lastChild;
            nodes = concat(nodes, tmp.childNodes), tmp = fragment.firstChild, tmp.textContent = "";
        }
        return fragment.textContent = "", fragment.innerHTML = "", forEach(nodes, function(node) {
            fragment.appendChild(node);
        }), fragment;
    }
    function jqLiteParseHTML(html, context) {
        context = context || window.document;
        var parsed;
        return (parsed = SINGLE_TAG_REGEXP.exec(html)) ? [ context.createElement(parsed[1]) ] : (parsed = jqLiteBuildFragment(html, context)) ? parsed.childNodes : [];
    }
    function jqLiteWrapNode(node, wrapper) {
        var parent = node.parentNode;
        parent && parent.replaceChild(wrapper, node), wrapper.appendChild(node);
    }
    function JQLite(element) {
        if (element instanceof JQLite) return element;
        var argIsString;
        if (isString(element) && (element = trim(element), argIsString = !0), !(this instanceof JQLite)) {
            if (argIsString && "<" !== element.charAt(0)) throw jqLiteMinErr("nosel", "Looking up elements via selectors is not supported by jqLite! See: http://docs.angularjs.org/api/angular.element");
            return new JQLite(element);
        }
        argIsString ? jqLiteAddNodes(this, jqLiteParseHTML(element)) : isFunction(element) ? jqLiteReady(element) : jqLiteAddNodes(this, element);
    }
    function jqLiteClone(element) {
        return element.cloneNode(!0);
    }
    function jqLiteDealoc(element, onlyDescendants) {
        !onlyDescendants && jqLiteAcceptsData(element) && jqLite.cleanData([ element ]), 
        element.querySelectorAll && jqLite.cleanData(element.querySelectorAll("*"));
    }
    function isEmptyObject(obj) {
        var name;
        for (name in obj) return !1;
        return !0;
    }
    function removeIfEmptyData(element) {
        var expandoId = element.ng339, expandoStore = expandoId && jqCache[expandoId], events = expandoStore && expandoStore.events, data = expandoStore && expandoStore.data;
        data && !isEmptyObject(data) || events && !isEmptyObject(events) || (delete jqCache[expandoId], 
        element.ng339 = void 0);
    }
    function jqLiteOff(element, type, fn, unsupported) {
        if (isDefined(unsupported)) throw jqLiteMinErr("offargs", "jqLite#off() does not support the `selector` argument");
        var expandoStore = jqLiteExpandoStore(element), events = expandoStore && expandoStore.events, handle = expandoStore && expandoStore.handle;
        if (handle) {
            if (type) {
                var removeHandler = function(type) {
                    var listenerFns = events[type];
                    isDefined(fn) && arrayRemove(listenerFns || [], fn), isDefined(fn) && listenerFns && listenerFns.length > 0 || (element.removeEventListener(type, handle), 
                    delete events[type]);
                };
                forEach(type.split(" "), function(type) {
                    removeHandler(type), MOUSE_EVENT_MAP[type] && removeHandler(MOUSE_EVENT_MAP[type]);
                });
            } else for (type in events) "$destroy" !== type && element.removeEventListener(type, handle), 
            delete events[type];
            removeIfEmptyData(element);
        }
    }
    function jqLiteRemoveData(element, name) {
        var expandoId = element.ng339, expandoStore = expandoId && jqCache[expandoId];
        expandoStore && (name ? delete expandoStore.data[name] : expandoStore.data = {}, 
        removeIfEmptyData(element));
    }
    function jqLiteExpandoStore(element, createIfNecessary) {
        var expandoId = element.ng339, expandoStore = expandoId && jqCache[expandoId];
        return createIfNecessary && !expandoStore && (element.ng339 = expandoId = jqNextId(), 
        expandoStore = jqCache[expandoId] = {
            events: {},
            data: {},
            handle: void 0
        }), expandoStore;
    }
    function jqLiteData(element, key, value) {
        if (jqLiteAcceptsData(element)) {
            var prop, isSimpleSetter = isDefined(value), isSimpleGetter = !isSimpleSetter && key && !isObject(key), massGetter = !key, expandoStore = jqLiteExpandoStore(element, !isSimpleGetter), data = expandoStore && expandoStore.data;
            if (isSimpleSetter) data[kebabToCamel(key)] = value; else {
                if (massGetter) return data;
                if (isSimpleGetter) return data && data[kebabToCamel(key)];
                for (prop in key) data[kebabToCamel(prop)] = key[prop];
            }
        }
    }
    function jqLiteHasClass(element, selector) {
        return element.getAttribute ? (" " + (element.getAttribute("class") || "") + " ").replace(/[\n\t]/g, " ").indexOf(" " + selector + " ") > -1 : !1;
    }
    function jqLiteRemoveClass(element, cssClasses) {
        if (cssClasses && element.setAttribute) {
            var existingClasses = (" " + (element.getAttribute("class") || "") + " ").replace(/[\n\t]/g, " "), newClasses = existingClasses;
            forEach(cssClasses.split(" "), function(cssClass) {
                cssClass = trim(cssClass), newClasses = newClasses.replace(" " + cssClass + " ", " ");
            }), newClasses !== existingClasses && element.setAttribute("class", trim(newClasses));
        }
    }
    function jqLiteAddClass(element, cssClasses) {
        if (cssClasses && element.setAttribute) {
            var existingClasses = (" " + (element.getAttribute("class") || "") + " ").replace(/[\n\t]/g, " "), newClasses = existingClasses;
            forEach(cssClasses.split(" "), function(cssClass) {
                cssClass = trim(cssClass), -1 === newClasses.indexOf(" " + cssClass + " ") && (newClasses += cssClass + " ");
            }), newClasses !== existingClasses && element.setAttribute("class", trim(newClasses));
        }
    }
    function jqLiteAddNodes(root, elements) {
        if (elements) if (elements.nodeType) root[root.length++] = elements; else {
            var length = elements.length;
            if ("number" == typeof length && elements.window !== elements) {
                if (length) for (var i = 0; length > i; i++) root[root.length++] = elements[i];
            } else root[root.length++] = elements;
        }
    }
    function jqLiteController(element, name) {
        return jqLiteInheritedData(element, "$" + (name || "ngController") + "Controller");
    }
    function jqLiteInheritedData(element, name, value) {
        element.nodeType === NODE_TYPE_DOCUMENT && (element = element.documentElement);
        for (var names = isArray(name) ? name : [ name ]; element; ) {
            for (var i = 0, ii = names.length; ii > i; i++) if (isDefined(value = jqLite.data(element, names[i]))) return value;
            element = element.parentNode || element.nodeType === NODE_TYPE_DOCUMENT_FRAGMENT && element.host;
        }
    }
    function jqLiteEmpty(element) {
        for (jqLiteDealoc(element, !0); element.firstChild; ) element.removeChild(element.firstChild);
    }
    function jqLiteRemove(element, keepData) {
        keepData || jqLiteDealoc(element);
        var parent = element.parentNode;
        parent && parent.removeChild(element);
    }
    function jqLiteDocumentLoaded(action, win) {
        win = win || window, "complete" === win.document.readyState ? win.setTimeout(action) : jqLite(win).on("load", action);
    }
    function jqLiteReady(fn) {
        function trigger() {
            window.document.removeEventListener("DOMContentLoaded", trigger), window.removeEventListener("load", trigger), 
            fn();
        }
        "complete" === window.document.readyState ? window.setTimeout(fn) : (window.document.addEventListener("DOMContentLoaded", trigger), 
        window.addEventListener("load", trigger));
    }
    function getBooleanAttrName(element, name) {
        var booleanAttr = BOOLEAN_ATTR[name.toLowerCase()];
        return booleanAttr && BOOLEAN_ELEMENTS[nodeName_(element)] && booleanAttr;
    }
    function getAliasedAttrName(name) {
        return ALIASED_ATTR[name];
    }
    function createEventHandler(element, events) {
        var eventHandler = function(event, type) {
            event.isDefaultPrevented = function() {
                return event.defaultPrevented;
            };
            var eventFns = events[type || event.type], eventFnsLength = eventFns ? eventFns.length : 0;
            if (eventFnsLength) {
                if (isUndefined(event.immediatePropagationStopped)) {
                    var originalStopImmediatePropagation = event.stopImmediatePropagation;
                    event.stopImmediatePropagation = function() {
                        event.immediatePropagationStopped = !0, event.stopPropagation && event.stopPropagation(), 
                        originalStopImmediatePropagation && originalStopImmediatePropagation.call(event);
                    };
                }
                event.isImmediatePropagationStopped = function() {
                    return event.immediatePropagationStopped === !0;
                };
                var handlerWrapper = eventFns.specialHandlerWrapper || defaultHandlerWrapper;
                eventFnsLength > 1 && (eventFns = shallowCopy(eventFns));
                for (var i = 0; eventFnsLength > i; i++) event.isImmediatePropagationStopped() || handlerWrapper(element, event, eventFns[i]);
            }
        };
        return eventHandler.elem = element, eventHandler;
    }
    function defaultHandlerWrapper(element, event, handler) {
        handler.call(element, event);
    }
    function specialMouseHandlerWrapper(target, event, handler) {
        var related = event.relatedTarget;
        (!related || related !== target && !jqLiteContains.call(target, related)) && handler.call(target, event);
    }
    function $$jqLiteProvider() {
        this.$get = function() {
            return extend(JQLite, {
                hasClass: function(node, classes) {
                    return node.attr && (node = node[0]), jqLiteHasClass(node, classes);
                },
                addClass: function(node, classes) {
                    return node.attr && (node = node[0]), jqLiteAddClass(node, classes);
                },
                removeClass: function(node, classes) {
                    return node.attr && (node = node[0]), jqLiteRemoveClass(node, classes);
                }
            });
        };
    }
    function hashKey(obj, nextUidFn) {
        var key = obj && obj.$$hashKey;
        if (key) return "function" == typeof key && (key = obj.$$hashKey()), key;
        var objType = typeof obj;
        return key = "function" === objType || "object" === objType && null !== obj ? obj.$$hashKey = objType + ":" + (nextUidFn || nextUid)() : objType + ":" + obj;
    }
    function NgMapShim() {
        this._keys = [], this._values = [], this._lastKey = 0/0, this._lastIndex = -1;
    }
    function stringifyFn(fn) {
        return Function.prototype.toString.call(fn);
    }
    function extractArgs(fn) {
        var fnText = stringifyFn(fn).replace(STRIP_COMMENTS, ""), args = fnText.match(ARROW_ARG) || fnText.match(FN_ARGS);
        return args;
    }
    function anonFn(fn) {
        var args = extractArgs(fn);
        return args ? "function(" + (args[1] || "").replace(/[\s\r\n]+/, " ") + ")" : "fn";
    }
    function annotate(fn, strictDi, name) {
        var $inject, argDecl, last;
        if ("function" == typeof fn) {
            if (!($inject = fn.$inject)) {
                if ($inject = [], fn.length) {
                    if (strictDi) throw isString(name) && name || (name = fn.name || anonFn(fn)), $injectorMinErr("strictdi", "{0} is not using explicit annotation and cannot be invoked in strict mode", name);
                    argDecl = extractArgs(fn), forEach(argDecl[1].split(FN_ARG_SPLIT), function(arg) {
                        arg.replace(FN_ARG, function(all, underscore, name) {
                            $inject.push(name);
                        });
                    });
                }
                fn.$inject = $inject;
            }
        } else isArray(fn) ? (last = fn.length - 1, assertArgFn(fn[last], "fn"), $inject = fn.slice(0, last)) : assertArgFn(fn, "fn", !0);
        return $inject;
    }
    function createInjector(modulesToLoad, strictDi) {
        function supportObject(delegate) {
            return function(key, value) {
                return isObject(key) ? void forEach(key, reverseParams(delegate)) : delegate(key, value);
            };
        }
        function provider(name, provider_) {
            if (assertNotHasOwnProperty(name, "service"), (isFunction(provider_) || isArray(provider_)) && (provider_ = providerInjector.instantiate(provider_)), 
            !provider_.$get) throw $injectorMinErr("pget", "Provider '{0}' must define $get factory method.", name);
            return providerCache[name + providerSuffix] = provider_;
        }
        function enforceReturnValue(name, factory) {
            return function() {
                var result = instanceInjector.invoke(factory, this);
                if (isUndefined(result)) throw $injectorMinErr("undef", "Provider '{0}' must return a value from $get factory method.", name);
                return result;
            };
        }
        function factory(name, factoryFn, enforce) {
            return provider(name, {
                $get: enforce !== !1 ? enforceReturnValue(name, factoryFn) : factoryFn
            });
        }
        function service(name, constructor) {
            return factory(name, [ "$injector", function($injector) {
                return $injector.instantiate(constructor);
            } ]);
        }
        function value(name, val) {
            return factory(name, valueFn(val), !1);
        }
        function constant(name, value) {
            assertNotHasOwnProperty(name, "constant"), providerCache[name] = value, instanceCache[name] = value;
        }
        function decorator(serviceName, decorFn) {
            var origProvider = providerInjector.get(serviceName + providerSuffix), orig$get = origProvider.$get;
            origProvider.$get = function() {
                var origInstance = instanceInjector.invoke(orig$get, origProvider);
                return instanceInjector.invoke(decorFn, null, {
                    $delegate: origInstance
                });
            };
        }
        function loadModules(modulesToLoad) {
            assertArg(isUndefined(modulesToLoad) || isArray(modulesToLoad), "modulesToLoad", "not an array");
            var moduleFn, runBlocks = [];
            return forEach(modulesToLoad, function(module) {
                function runInvokeQueue(queue) {
                    var i, ii;
                    for (i = 0, ii = queue.length; ii > i; i++) {
                        var invokeArgs = queue[i], provider = providerInjector.get(invokeArgs[0]);
                        provider[invokeArgs[1]].apply(provider, invokeArgs[2]);
                    }
                }
                if (!loadedModules.get(module)) {
                    loadedModules.set(module, !0);
                    try {
                        isString(module) ? (moduleFn = angularModule(module), instanceInjector.modules[module] = moduleFn, 
                        runBlocks = runBlocks.concat(loadModules(moduleFn.requires)).concat(moduleFn._runBlocks), 
                        runInvokeQueue(moduleFn._invokeQueue), runInvokeQueue(moduleFn._configBlocks)) : isFunction(module) ? runBlocks.push(providerInjector.invoke(module)) : isArray(module) ? runBlocks.push(providerInjector.invoke(module)) : assertArgFn(module, "module");
                    } catch (e) {
                        throw isArray(module) && (module = module[module.length - 1]), e.message && e.stack && -1 === e.stack.indexOf(e.message) && (e = e.message + "\n" + e.stack), 
                        $injectorMinErr("modulerr", "Failed to instantiate module {0} due to:\n{1}", module, e.stack || e.message || e);
                    }
                }
            }), runBlocks;
        }
        function createInternalInjector(cache, factory) {
            function getService(serviceName, caller) {
                if (cache.hasOwnProperty(serviceName)) {
                    if (cache[serviceName] === INSTANTIATING) throw $injectorMinErr("cdep", "Circular dependency found: {0}", serviceName + " <- " + path.join(" <- "));
                    return cache[serviceName];
                }
                try {
                    return path.unshift(serviceName), cache[serviceName] = INSTANTIATING, cache[serviceName] = factory(serviceName, caller), 
                    cache[serviceName];
                } catch (err) {
                    throw cache[serviceName] === INSTANTIATING && delete cache[serviceName], err;
                } finally {
                    path.shift();
                }
            }
            function injectionArgs(fn, locals, serviceName) {
                for (var args = [], $inject = createInjector.$$annotate(fn, strictDi, serviceName), i = 0, length = $inject.length; length > i; i++) {
                    var key = $inject[i];
                    if ("string" != typeof key) throw $injectorMinErr("itkn", "Incorrect injection token! Expected service name as string, got {0}", key);
                    args.push(locals && locals.hasOwnProperty(key) ? locals[key] : getService(key, serviceName));
                }
                return args;
            }
            function isClass(func) {
                if (msie || "function" != typeof func) return !1;
                var result = func.$$ngIsClass;
                return isBoolean(result) || (result = func.$$ngIsClass = /^class\b/.test(stringifyFn(func))), 
                result;
            }
            function invoke(fn, self, locals, serviceName) {
                "string" == typeof locals && (serviceName = locals, locals = null);
                var args = injectionArgs(fn, locals, serviceName);
                return isArray(fn) && (fn = fn[fn.length - 1]), isClass(fn) ? (args.unshift(null), 
                new (Function.prototype.bind.apply(fn, args))()) : fn.apply(self, args);
            }
            function instantiate(Type, locals, serviceName) {
                var ctor = isArray(Type) ? Type[Type.length - 1] : Type, args = injectionArgs(Type, locals, serviceName);
                return args.unshift(null), new (Function.prototype.bind.apply(ctor, args))();
            }
            return {
                invoke: invoke,
                instantiate: instantiate,
                get: getService,
                annotate: createInjector.$$annotate,
                has: function(name) {
                    return providerCache.hasOwnProperty(name + providerSuffix) || cache.hasOwnProperty(name);
                }
            };
        }
        strictDi = strictDi === !0;
        var INSTANTIATING = {}, providerSuffix = "Provider", path = [], loadedModules = new NgMap(), providerCache = {
            $provide: {
                provider: supportObject(provider),
                factory: supportObject(factory),
                service: supportObject(service),
                value: supportObject(value),
                constant: supportObject(constant),
                decorator: decorator
            }
        }, providerInjector = providerCache.$injector = createInternalInjector(providerCache, function(serviceName, caller) {
            throw angular.isString(caller) && path.push(caller), $injectorMinErr("unpr", "Unknown provider: {0}", path.join(" <- "));
        }), instanceCache = {}, protoInstanceInjector = createInternalInjector(instanceCache, function(serviceName, caller) {
            var provider = providerInjector.get(serviceName + providerSuffix, caller);
            return instanceInjector.invoke(provider.$get, provider, void 0, serviceName);
        }), instanceInjector = protoInstanceInjector;
        providerCache["$injector" + providerSuffix] = {
            $get: valueFn(protoInstanceInjector)
        }, instanceInjector.modules = providerInjector.modules = createMap();
        var runBlocks = loadModules(modulesToLoad);
        return instanceInjector = protoInstanceInjector.get("$injector"), instanceInjector.strictDi = strictDi, 
        forEach(runBlocks, function(fn) {
            fn && instanceInjector.invoke(fn);
        }), instanceInjector.loadNewModules = function(mods) {
            forEach(loadModules(mods), function(fn) {
                fn && instanceInjector.invoke(fn);
            });
        }, instanceInjector;
    }
    function $AnchorScrollProvider() {
        var autoScrollingEnabled = !0;
        this.disableAutoScrolling = function() {
            autoScrollingEnabled = !1;
        }, this.$get = [ "$window", "$location", "$rootScope", function($window, $location, $rootScope) {
            function getFirstAnchor(list) {
                var result = null;
                return Array.prototype.some.call(list, function(element) {
                    return "a" === nodeName_(element) ? (result = element, !0) : void 0;
                }), result;
            }
            function getYOffset() {
                var offset = scroll.yOffset;
                if (isFunction(offset)) offset = offset(); else if (isElement(offset)) {
                    var elem = offset[0], style = $window.getComputedStyle(elem);
                    offset = "fixed" !== style.position ? 0 : elem.getBoundingClientRect().bottom;
                } else isNumber(offset) || (offset = 0);
                return offset;
            }
            function scrollTo(elem) {
                if (elem) {
                    elem.scrollIntoView();
                    var offset = getYOffset();
                    if (offset) {
                        var elemTop = elem.getBoundingClientRect().top;
                        $window.scrollBy(0, elemTop - offset);
                    }
                } else $window.scrollTo(0, 0);
            }
            function scroll(hash) {
                hash = isString(hash) ? hash : isNumber(hash) ? hash.toString() : $location.hash();
                var elm;
                hash ? (elm = document.getElementById(hash)) ? scrollTo(elm) : (elm = getFirstAnchor(document.getElementsByName(hash))) ? scrollTo(elm) : "top" === hash && scrollTo(null) : scrollTo(null);
            }
            var document = $window.document;
            return autoScrollingEnabled && $rootScope.$watch(function() {
                return $location.hash();
            }, function(newVal, oldVal) {
                (newVal !== oldVal || "" !== newVal) && jqLiteDocumentLoaded(function() {
                    $rootScope.$evalAsync(scroll);
                });
            }), scroll;
        } ];
    }
    function mergeClasses(a, b) {
        return a || b ? a ? b ? (isArray(a) && (a = a.join(" ")), isArray(b) && (b = b.join(" ")), 
        a + " " + b) : a : b : "";
    }
    function extractElementNode(element) {
        for (var i = 0; i < element.length; i++) {
            var elm = element[i];
            if (elm.nodeType === ELEMENT_NODE) return elm;
        }
    }
    function splitClasses(classes) {
        isString(classes) && (classes = classes.split(" "));
        var obj = createMap();
        return forEach(classes, function(klass) {
            klass.length && (obj[klass] = !0);
        }), obj;
    }
    function prepareAnimateOptions(options) {
        return isObject(options) ? options : {};
    }
    function Browser(window, document, $log, $sniffer) {
        function completeOutstandingRequest(fn) {
            try {
                fn.apply(null, sliceArgs(arguments, 1));
            } finally {
                if (outstandingRequestCount--, 0 === outstandingRequestCount) for (;outstandingRequestCallbacks.length; ) try {
                    outstandingRequestCallbacks.pop()();
                } catch (e) {
                    $log.error(e);
                }
            }
        }
        function getHash(url) {
            var index = url.indexOf("#");
            return -1 === index ? "" : url.substr(index);
        }
        function cacheStateAndFireUrlChange() {
            pendingLocation = null, fireStateOrUrlChange();
        }
        function cacheState() {
            cachedState = getCurrentState(), cachedState = isUndefined(cachedState) ? null : cachedState, 
            equals(cachedState, lastCachedState) && (cachedState = lastCachedState), lastCachedState = cachedState, 
            lastHistoryState = cachedState;
        }
        function fireStateOrUrlChange() {
            var prevLastHistoryState = lastHistoryState;
            cacheState(), (lastBrowserUrl !== self.url() || prevLastHistoryState !== cachedState) && (lastBrowserUrl = self.url(), 
            lastHistoryState = cachedState, forEach(urlChangeListeners, function(listener) {
                listener(self.url(), cachedState);
            }));
        }
        var self = this, location = window.location, history = window.history, setTimeout = window.setTimeout, clearTimeout = window.clearTimeout, pendingDeferIds = {};
        self.isMock = !1;
        var outstandingRequestCount = 0, outstandingRequestCallbacks = [];
        self.$$completeOutstandingRequest = completeOutstandingRequest, self.$$incOutstandingRequestCount = function() {
            outstandingRequestCount++;
        }, self.notifyWhenNoOutstandingRequests = function(callback) {
            0 === outstandingRequestCount ? callback() : outstandingRequestCallbacks.push(callback);
        };
        var cachedState, lastHistoryState, lastBrowserUrl = location.href, baseElement = document.find("base"), pendingLocation = null, getCurrentState = $sniffer.history ? function() {
            try {
                return history.state;
            } catch (e) {}
        } : noop;
        cacheState(), self.url = function(url, replace, state) {
            if (isUndefined(state) && (state = null), location !== window.location && (location = window.location), 
            history !== window.history && (history = window.history), url) {
                var sameState = lastHistoryState === state;
                if (lastBrowserUrl === url && (!$sniffer.history || sameState)) return self;
                var sameBase = lastBrowserUrl && stripHash(lastBrowserUrl) === stripHash(url);
                return lastBrowserUrl = url, lastHistoryState = state, !$sniffer.history || sameBase && sameState ? (sameBase || (pendingLocation = url), 
                replace ? location.replace(url) : sameBase ? location.hash = getHash(url) : location.href = url, 
                location.href !== url && (pendingLocation = url)) : (history[replace ? "replaceState" : "pushState"](state, "", url), 
                cacheState()), pendingLocation && (pendingLocation = url), self;
            }
            return pendingLocation || location.href;
        }, self.state = function() {
            return cachedState;
        };
        var urlChangeListeners = [], urlChangeInit = !1, lastCachedState = null;
        self.onUrlChange = function(callback) {
            return urlChangeInit || ($sniffer.history && jqLite(window).on("popstate", cacheStateAndFireUrlChange), 
            jqLite(window).on("hashchange", cacheStateAndFireUrlChange), urlChangeInit = !0), 
            urlChangeListeners.push(callback), callback;
        }, self.$$applicationDestroyed = function() {
            jqLite(window).off("hashchange popstate", cacheStateAndFireUrlChange);
        }, self.$$checkUrlChange = fireStateOrUrlChange, self.baseHref = function() {
            var href = baseElement.attr("href");
            return href ? href.replace(/^(https?:)?\/\/[^\/]*/, "") : "";
        }, self.defer = function(fn, delay) {
            var timeoutId;
            return outstandingRequestCount++, timeoutId = setTimeout(function() {
                delete pendingDeferIds[timeoutId], completeOutstandingRequest(fn);
            }, delay || 0), pendingDeferIds[timeoutId] = !0, timeoutId;
        }, self.defer.cancel = function(deferId) {
            return pendingDeferIds[deferId] ? (delete pendingDeferIds[deferId], clearTimeout(deferId), 
            completeOutstandingRequest(noop), !0) : !1;
        };
    }
    function $BrowserProvider() {
        this.$get = [ "$window", "$log", "$sniffer", "$document", function($window, $log, $sniffer, $document) {
            return new Browser($window, $document, $log, $sniffer);
        } ];
    }
    function $CacheFactoryProvider() {
        this.$get = function() {
            function cacheFactory(cacheId, options) {
                function refresh(entry) {
                    entry !== freshEnd && (staleEnd ? staleEnd === entry && (staleEnd = entry.n) : staleEnd = entry, 
                    link(entry.n, entry.p), link(entry, freshEnd), freshEnd = entry, freshEnd.n = null);
                }
                function link(nextEntry, prevEntry) {
                    nextEntry !== prevEntry && (nextEntry && (nextEntry.p = prevEntry), prevEntry && (prevEntry.n = nextEntry));
                }
                if (cacheId in caches) throw minErr("$cacheFactory")("iid", "CacheId '{0}' is already taken!", cacheId);
                var size = 0, stats = extend({}, options, {
                    id: cacheId
                }), data = createMap(), capacity = options && options.capacity || Number.MAX_VALUE, lruHash = createMap(), freshEnd = null, staleEnd = null;
                return caches[cacheId] = {
                    put: function(key, value) {
                        if (!isUndefined(value)) {
                            if (capacity < Number.MAX_VALUE) {
                                var lruEntry = lruHash[key] || (lruHash[key] = {
                                    key: key
                                });
                                refresh(lruEntry);
                            }
                            return key in data || size++, data[key] = value, size > capacity && this.remove(staleEnd.key), 
                            value;
                        }
                    },
                    get: function(key) {
                        if (capacity < Number.MAX_VALUE) {
                            var lruEntry = lruHash[key];
                            if (!lruEntry) return;
                            refresh(lruEntry);
                        }
                        return data[key];
                    },
                    remove: function(key) {
                        if (capacity < Number.MAX_VALUE) {
                            var lruEntry = lruHash[key];
                            if (!lruEntry) return;
                            lruEntry === freshEnd && (freshEnd = lruEntry.p), lruEntry === staleEnd && (staleEnd = lruEntry.n), 
                            link(lruEntry.n, lruEntry.p), delete lruHash[key];
                        }
                        key in data && (delete data[key], size--);
                    },
                    removeAll: function() {
                        data = createMap(), size = 0, lruHash = createMap(), freshEnd = staleEnd = null;
                    },
                    destroy: function() {
                        data = null, stats = null, lruHash = null, delete caches[cacheId];
                    },
                    info: function() {
                        return extend({}, stats, {
                            size: size
                        });
                    }
                };
            }
            var caches = {};
            return cacheFactory.info = function() {
                var info = {};
                return forEach(caches, function(cache, cacheId) {
                    info[cacheId] = cache.info();
                }), info;
            }, cacheFactory.get = function(cacheId) {
                return caches[cacheId];
            }, cacheFactory;
        };
    }
    function $TemplateCacheProvider() {
        this.$get = [ "$cacheFactory", function($cacheFactory) {
            return $cacheFactory("templates");
        } ];
    }
    function UNINITIALIZED_VALUE() {}
    function $CompileProvider($provide, $$sanitizeUriProvider) {
        function parseIsolateBindings(scope, directiveName, isController) {
            var LOCAL_REGEXP = /^([@&]|[=<](\*?))(\??)\s*([\w$]*)$/, bindings = createMap();
            return forEach(scope, function(definition, scopeName) {
                if (definition = definition.trim(), definition in bindingCache) return void (bindings[scopeName] = bindingCache[definition]);
                var match = definition.match(LOCAL_REGEXP);
                if (!match) throw $compileMinErr("iscp", "Invalid {3} for directive '{0}'. Definition: {... {1}: '{2}' ...}", directiveName, scopeName, definition, isController ? "controller bindings definition" : "isolate scope definition");
                bindings[scopeName] = {
                    mode: match[1][0],
                    collection: "*" === match[2],
                    optional: "?" === match[3],
                    attrName: match[4] || scopeName
                }, match[4] && (bindingCache[definition] = bindings[scopeName]);
            }), bindings;
        }
        function parseDirectiveBindings(directive, directiveName) {
            var bindings = {
                isolateScope: null,
                bindToController: null
            };
            if (isObject(directive.scope) && (directive.bindToController === !0 ? (bindings.bindToController = parseIsolateBindings(directive.scope, directiveName, !0), 
            bindings.isolateScope = {}) : bindings.isolateScope = parseIsolateBindings(directive.scope, directiveName, !1)), 
            isObject(directive.bindToController) && (bindings.bindToController = parseIsolateBindings(directive.bindToController, directiveName, !0)), 
            bindings.bindToController && !directive.controller) throw $compileMinErr("noctrl", "Cannot bind to controller without directive '{0}'s controller.", directiveName);
            return bindings;
        }
        function assertValidDirectiveName(name) {
            var letter = name.charAt(0);
            if (!letter || letter !== lowercase(letter)) throw $compileMinErr("baddir", "Directive/Component name '{0}' is invalid. The first character must be a lowercase letter", name);
            if (name !== name.trim()) throw $compileMinErr("baddir", "Directive/Component name '{0}' is invalid. The name should not contain leading or trailing whitespaces", name);
        }
        function getDirectiveRequire(directive) {
            var require = directive.require || directive.controller && directive.name;
            return !isArray(require) && isObject(require) && forEach(require, function(value, key) {
                var match = value.match(REQUIRE_PREFIX_REGEXP), name = value.substring(match[0].length);
                name || (require[key] = match[0] + key);
            }), require;
        }
        function getDirectiveRestrict(restrict, name) {
            if (restrict && (!isString(restrict) || !/[EACM]/.test(restrict))) throw $compileMinErr("badrestrict", "Restrict property '{0}' of directive '{1}' is invalid", restrict, name);
            return restrict || "EA";
        }
        var hasDirectives = {}, Suffix = "Directive", COMMENT_DIRECTIVE_REGEXP = /^\s*directive:\s*([\w-]+)\s+(.*)$/, CLASS_DIRECTIVE_REGEXP = /(([\w-]+)(?::([^;]+))?;?)/, ALL_OR_NOTHING_ATTRS = makeMap("ngSrc,ngSrcset,src,srcset"), REQUIRE_PREFIX_REGEXP = /^(?:(\^\^?)?(\?)?(\^\^?)?)?/, EVENT_HANDLER_ATTR_REGEXP = /^(on[a-z]+|formaction)$/, bindingCache = createMap();
        this.directive = function registerDirective(name, directiveFactory) {
            return assertArg(name, "name"), assertNotHasOwnProperty(name, "directive"), isString(name) ? (assertValidDirectiveName(name), 
            assertArg(directiveFactory, "directiveFactory"), hasDirectives.hasOwnProperty(name) || (hasDirectives[name] = [], 
            $provide.factory(name + Suffix, [ "$injector", "$exceptionHandler", function($injector, $exceptionHandler) {
                var directives = [];
                return forEach(hasDirectives[name], function(directiveFactory, index) {
                    try {
                        var directive = $injector.invoke(directiveFactory);
                        isFunction(directive) ? directive = {
                            compile: valueFn(directive)
                        } : !directive.compile && directive.link && (directive.compile = valueFn(directive.link)), 
                        directive.priority = directive.priority || 0, directive.index = index, directive.name = directive.name || name, 
                        directive.require = getDirectiveRequire(directive), directive.restrict = getDirectiveRestrict(directive.restrict, name), 
                        directive.$$moduleName = directiveFactory.$$moduleName, directives.push(directive);
                    } catch (e) {
                        $exceptionHandler(e);
                    }
                }), directives;
            } ])), hasDirectives[name].push(directiveFactory)) : forEach(name, reverseParams(registerDirective)), 
            this;
        }, this.component = function registerComponent(name, options) {
            function factory($injector) {
                function makeInjectable(fn) {
                    return isFunction(fn) || isArray(fn) ? function(tElement, tAttrs) {
                        return $injector.invoke(fn, this, {
                            $element: tElement,
                            $attrs: tAttrs
                        });
                    } : fn;
                }
                var template = options.template || options.templateUrl ? options.template : "", ddo = {
                    controller: controller,
                    controllerAs: identifierForController(options.controller) || options.controllerAs || "$ctrl",
                    template: makeInjectable(template),
                    templateUrl: makeInjectable(options.templateUrl),
                    transclude: options.transclude,
                    scope: {},
                    bindToController: options.bindings || {},
                    restrict: "E",
                    require: options.require
                };
                return forEach(options, function(val, key) {
                    "$" === key.charAt(0) && (ddo[key] = val);
                }), ddo;
            }
            if (!isString(name)) return forEach(name, reverseParams(bind(this, registerComponent))), 
            this;
            var controller = options.controller || function() {};
            return forEach(options, function(val, key) {
                "$" === key.charAt(0) && (factory[key] = val, isFunction(controller) && (controller[key] = val));
            }), factory.$inject = [ "$injector" ], this.directive(name, factory);
        }, this.aHrefSanitizationWhitelist = function(regexp) {
            return isDefined(regexp) ? ($$sanitizeUriProvider.aHrefSanitizationWhitelist(regexp), 
            this) : $$sanitizeUriProvider.aHrefSanitizationWhitelist();
        }, this.imgSrcSanitizationWhitelist = function(regexp) {
            return isDefined(regexp) ? ($$sanitizeUriProvider.imgSrcSanitizationWhitelist(regexp), 
            this) : $$sanitizeUriProvider.imgSrcSanitizationWhitelist();
        };
        var debugInfoEnabled = !0;
        this.debugInfoEnabled = function(enabled) {
            return isDefined(enabled) ? (debugInfoEnabled = enabled, this) : debugInfoEnabled;
        };
        var strictComponentBindingsEnabled = !1;
        this.strictComponentBindingsEnabled = function(enabled) {
            return isDefined(enabled) ? (strictComponentBindingsEnabled = enabled, this) : strictComponentBindingsEnabled;
        };
        var TTL = 10;
        this.onChangesTtl = function(value) {
            return arguments.length ? (TTL = value, this) : TTL;
        };
        var commentDirectivesEnabledConfig = !0;
        this.commentDirectivesEnabled = function(value) {
            return arguments.length ? (commentDirectivesEnabledConfig = value, this) : commentDirectivesEnabledConfig;
        };
        var cssClassDirectivesEnabledConfig = !0;
        this.cssClassDirectivesEnabled = function(value) {
            return arguments.length ? (cssClassDirectivesEnabledConfig = value, this) : cssClassDirectivesEnabledConfig;
        }, this.$get = [ "$injector", "$interpolate", "$exceptionHandler", "$templateRequest", "$parse", "$controller", "$rootScope", "$sce", "$animate", function($injector, $interpolate, $exceptionHandler, $templateRequest, $parse, $controller, $rootScope, $sce, $animate) {
            function flushOnChangesQueue() {
                try {
                    if (!--onChangesTtl) throw onChangesQueue = void 0, $compileMinErr("infchng", "{0} $onChanges() iterations reached. Aborting!\n", TTL);
                    $rootScope.$apply(function() {
                        for (var i = 0, ii = onChangesQueue.length; ii > i; ++i) try {
                            onChangesQueue[i]();
                        } catch (e) {
                            $exceptionHandler(e);
                        }
                        onChangesQueue = void 0;
                    });
                } finally {
                    onChangesTtl++;
                }
            }
            function Attributes(element, attributesToCopy) {
                if (attributesToCopy) {
                    var i, l, key, keys = Object.keys(attributesToCopy);
                    for (i = 0, l = keys.length; l > i; i++) key = keys[i], this[key] = attributesToCopy[key];
                } else this.$attr = {};
                this.$$element = element;
            }
            function setSpecialAttr(element, attrName, value) {
                specialAttrHolder.innerHTML = "<span " + attrName + ">";
                var attributes = specialAttrHolder.firstChild.attributes, attribute = attributes[0];
                attributes.removeNamedItem(attribute.name), attribute.value = value, element.attributes.setNamedItem(attribute);
            }
            function safeAddClass($element, className) {
                try {
                    $element.addClass(className);
                } catch (e) {}
            }
            function compile($compileNodes, transcludeFn, maxPriority, ignoreDirective, previousCompileContext) {
                $compileNodes instanceof jqLite || ($compileNodes = jqLite($compileNodes));
                var compositeLinkFn = compileNodes($compileNodes, transcludeFn, $compileNodes, maxPriority, ignoreDirective, previousCompileContext);
                compile.$$addScopeClass($compileNodes);
                var namespace = null;
                return function(scope, cloneConnectFn, options) {
                    if (!$compileNodes) throw $compileMinErr("multilink", "This element has already been linked.");
                    assertArg(scope, "scope"), previousCompileContext && previousCompileContext.needsNewScope && (scope = scope.$parent.$new()), 
                    options = options || {};
                    var parentBoundTranscludeFn = options.parentBoundTranscludeFn, transcludeControllers = options.transcludeControllers, futureParentElement = options.futureParentElement;
                    parentBoundTranscludeFn && parentBoundTranscludeFn.$$boundTransclude && (parentBoundTranscludeFn = parentBoundTranscludeFn.$$boundTransclude), 
                    namespace || (namespace = detectNamespaceForChildElements(futureParentElement));
                    var $linkNode;
                    if ($linkNode = "html" !== namespace ? jqLite(wrapTemplate(namespace, jqLite("<div></div>").append($compileNodes).html())) : cloneConnectFn ? JQLitePrototype.clone.call($compileNodes) : $compileNodes, 
                    transcludeControllers) for (var controllerName in transcludeControllers) $linkNode.data("$" + controllerName + "Controller", transcludeControllers[controllerName].instance);
                    return compile.$$addScopeInfo($linkNode, scope), cloneConnectFn && cloneConnectFn($linkNode, scope), 
                    compositeLinkFn && compositeLinkFn(scope, $linkNode, $linkNode, parentBoundTranscludeFn), 
                    cloneConnectFn || ($compileNodes = compositeLinkFn = null), $linkNode;
                };
            }
            function detectNamespaceForChildElements(parentElement) {
                var node = parentElement && parentElement[0];
                return node && "foreignobject" !== nodeName_(node) && toString.call(node).match(/SVG/) ? "svg" : "html";
            }
            function compileNodes(nodeList, transcludeFn, $rootElement, maxPriority, ignoreDirective, previousCompileContext) {
                function compositeLinkFn(scope, nodeList, $rootElement, parentBoundTranscludeFn) {
                    var nodeLinkFn, childLinkFn, node, childScope, i, ii, idx, childBoundTranscludeFn, stableNodeList;
                    if (nodeLinkFnFound) {
                        var nodeListLength = nodeList.length;
                        for (stableNodeList = new Array(nodeListLength), i = 0; i < linkFns.length; i += 3) idx = linkFns[i], 
                        stableNodeList[idx] = nodeList[idx];
                    } else stableNodeList = nodeList;
                    for (i = 0, ii = linkFns.length; ii > i; ) node = stableNodeList[linkFns[i++]], 
                    nodeLinkFn = linkFns[i++], childLinkFn = linkFns[i++], nodeLinkFn ? (nodeLinkFn.scope ? (childScope = scope.$new(), 
                    compile.$$addScopeInfo(jqLite(node), childScope)) : childScope = scope, childBoundTranscludeFn = nodeLinkFn.transcludeOnThisElement ? createBoundTranscludeFn(scope, nodeLinkFn.transclude, parentBoundTranscludeFn) : !nodeLinkFn.templateOnThisElement && parentBoundTranscludeFn ? parentBoundTranscludeFn : !parentBoundTranscludeFn && transcludeFn ? createBoundTranscludeFn(scope, transcludeFn) : null, 
                    nodeLinkFn(childLinkFn, childScope, node, $rootElement, childBoundTranscludeFn)) : childLinkFn && childLinkFn(scope, node.childNodes, void 0, parentBoundTranscludeFn);
                }
                for (var attrs, directives, nodeLinkFn, childNodes, childLinkFn, linkFnFound, nodeLinkFnFound, linkFns = [], notLiveList = isArray(nodeList) || nodeList instanceof jqLite, i = 0; i < nodeList.length; i++) attrs = new Attributes(), 
                11 === msie && mergeConsecutiveTextNodes(nodeList, i, notLiveList), directives = collectDirectives(nodeList[i], [], attrs, 0 === i ? maxPriority : void 0, ignoreDirective), 
                nodeLinkFn = directives.length ? applyDirectivesToNode(directives, nodeList[i], attrs, transcludeFn, $rootElement, null, [], [], previousCompileContext) : null, 
                nodeLinkFn && nodeLinkFn.scope && compile.$$addScopeClass(attrs.$$element), childLinkFn = nodeLinkFn && nodeLinkFn.terminal || !(childNodes = nodeList[i].childNodes) || !childNodes.length ? null : compileNodes(childNodes, nodeLinkFn ? (nodeLinkFn.transcludeOnThisElement || !nodeLinkFn.templateOnThisElement) && nodeLinkFn.transclude : transcludeFn), 
                (nodeLinkFn || childLinkFn) && (linkFns.push(i, nodeLinkFn, childLinkFn), linkFnFound = !0, 
                nodeLinkFnFound = nodeLinkFnFound || nodeLinkFn), previousCompileContext = null;
                return linkFnFound ? compositeLinkFn : null;
            }
            function mergeConsecutiveTextNodes(nodeList, idx, notLiveList) {
                var sibling, node = nodeList[idx], parent = node.parentNode;
                if (node.nodeType === NODE_TYPE_TEXT) for (;;) {
                    if (sibling = parent ? node.nextSibling : nodeList[idx + 1], !sibling || sibling.nodeType !== NODE_TYPE_TEXT) break;
                    node.nodeValue = node.nodeValue + sibling.nodeValue, sibling.parentNode && sibling.parentNode.removeChild(sibling), 
                    notLiveList && sibling === nodeList[idx + 1] && nodeList.splice(idx + 1, 1);
                }
            }
            function createBoundTranscludeFn(scope, transcludeFn, previousBoundTranscludeFn) {
                function boundTranscludeFn(transcludedScope, cloneFn, controllers, futureParentElement, containingScope) {
                    return transcludedScope || (transcludedScope = scope.$new(!1, containingScope), 
                    transcludedScope.$$transcluded = !0), transcludeFn(transcludedScope, cloneFn, {
                        parentBoundTranscludeFn: previousBoundTranscludeFn,
                        transcludeControllers: controllers,
                        futureParentElement: futureParentElement
                    });
                }
                var boundSlots = boundTranscludeFn.$$slots = createMap();
                for (var slotName in transcludeFn.$$slots) boundSlots[slotName] = transcludeFn.$$slots[slotName] ? createBoundTranscludeFn(scope, transcludeFn.$$slots[slotName], previousBoundTranscludeFn) : null;
                return boundTranscludeFn;
            }
            function collectDirectives(node, directives, attrs, maxPriority, ignoreDirective) {
                var match, nodeName, className, nodeType = node.nodeType, attrsMap = attrs.$attr;
                switch (nodeType) {
                  case NODE_TYPE_ELEMENT:
                    nodeName = nodeName_(node), addDirective(directives, directiveNormalize(nodeName), "E", maxPriority, ignoreDirective);
                    for (var attr, name, nName, ngAttrName, value, isNgAttr, nAttrs = node.attributes, j = 0, jj = nAttrs && nAttrs.length; jj > j; j++) {
                        var attrStartName = !1, attrEndName = !1;
                        attr = nAttrs[j], name = attr.name, value = attr.value, ngAttrName = directiveNormalize(name), 
                        isNgAttr = NG_ATTR_BINDING.test(ngAttrName), isNgAttr && (name = name.replace(PREFIX_REGEXP, "").substr(8).replace(/_(.)/g, function(match, letter) {
                            return letter.toUpperCase();
                        }));
                        var multiElementMatch = ngAttrName.match(MULTI_ELEMENT_DIR_RE);
                        multiElementMatch && directiveIsMultiElement(multiElementMatch[1]) && (attrStartName = name, 
                        attrEndName = name.substr(0, name.length - 5) + "end", name = name.substr(0, name.length - 6)), 
                        nName = directiveNormalize(name.toLowerCase()), attrsMap[nName] = name, (isNgAttr || !attrs.hasOwnProperty(nName)) && (attrs[nName] = value, 
                        getBooleanAttrName(node, nName) && (attrs[nName] = !0)), addAttrInterpolateDirective(node, directives, value, nName, isNgAttr), 
                        addDirective(directives, nName, "A", maxPriority, ignoreDirective, attrStartName, attrEndName);
                    }
                    if ("input" === nodeName && "hidden" === node.getAttribute("type") && node.setAttribute("autocomplete", "off"), 
                    !cssClassDirectivesEnabled) break;
                    if (className = node.className, isObject(className) && (className = className.animVal), 
                    isString(className) && "" !== className) for (;match = CLASS_DIRECTIVE_REGEXP.exec(className); ) nName = directiveNormalize(match[2]), 
                    addDirective(directives, nName, "C", maxPriority, ignoreDirective) && (attrs[nName] = trim(match[3])), 
                    className = className.substr(match.index + match[0].length);
                    break;

                  case NODE_TYPE_TEXT:
                    addTextInterpolateDirective(directives, node.nodeValue);
                    break;

                  case NODE_TYPE_COMMENT:
                    if (!commentDirectivesEnabled) break;
                    collectCommentDirectives(node, directives, attrs, maxPriority, ignoreDirective);
                }
                return directives.sort(byPriority), directives;
            }
            function collectCommentDirectives(node, directives, attrs, maxPriority, ignoreDirective) {
                try {
                    var match = COMMENT_DIRECTIVE_REGEXP.exec(node.nodeValue);
                    if (match) {
                        var nName = directiveNormalize(match[1]);
                        addDirective(directives, nName, "M", maxPriority, ignoreDirective) && (attrs[nName] = trim(match[2]));
                    }
                } catch (e) {}
            }
            function groupScan(node, attrStart, attrEnd) {
                var nodes = [], depth = 0;
                if (attrStart && node.hasAttribute && node.hasAttribute(attrStart)) {
                    do {
                        if (!node) throw $compileMinErr("uterdir", "Unterminated attribute, found '{0}' but no matching '{1}' found.", attrStart, attrEnd);
                        node.nodeType === NODE_TYPE_ELEMENT && (node.hasAttribute(attrStart) && depth++, 
                        node.hasAttribute(attrEnd) && depth--), nodes.push(node), node = node.nextSibling;
                    } while (depth > 0);
                } else nodes.push(node);
                return jqLite(nodes);
            }
            function groupElementsLinkFnWrapper(linkFn, attrStart, attrEnd) {
                return function(scope, element, attrs, controllers, transcludeFn) {
                    return element = groupScan(element[0], attrStart, attrEnd), linkFn(scope, element, attrs, controllers, transcludeFn);
                };
            }
            function compilationGenerator(eager, $compileNodes, transcludeFn, maxPriority, ignoreDirective, previousCompileContext) {
                var compiled;
                return eager ? compile($compileNodes, transcludeFn, maxPriority, ignoreDirective, previousCompileContext) : function() {
                    return compiled || (compiled = compile($compileNodes, transcludeFn, maxPriority, ignoreDirective, previousCompileContext), 
                    $compileNodes = transcludeFn = previousCompileContext = null), compiled.apply(this, arguments);
                };
            }
            function applyDirectivesToNode(directives, compileNode, templateAttrs, transcludeFn, jqCollection, originalReplaceDirective, preLinkFns, postLinkFns, previousCompileContext) {
                function addLinkFns(pre, post, attrStart, attrEnd) {
                    pre && (attrStart && (pre = groupElementsLinkFnWrapper(pre, attrStart, attrEnd)), 
                    pre.require = directive.require, pre.directiveName = directiveName, (newIsolateScopeDirective === directive || directive.$$isolateScope) && (pre = cloneAndAnnotateFn(pre, {
                        isolateScope: !0
                    })), preLinkFns.push(pre)), post && (attrStart && (post = groupElementsLinkFnWrapper(post, attrStart, attrEnd)), 
                    post.require = directive.require, post.directiveName = directiveName, (newIsolateScopeDirective === directive || directive.$$isolateScope) && (post = cloneAndAnnotateFn(post, {
                        isolateScope: !0
                    })), postLinkFns.push(post));
                }
                function nodeLinkFn(childLinkFn, scope, linkNode, $rootElement, boundTranscludeFn) {
                    function controllersBoundTransclude(scope, cloneAttachFn, futureParentElement, slotName) {
                        var transcludeControllers;
                        if (isScope(scope) || (slotName = futureParentElement, futureParentElement = cloneAttachFn, 
                        cloneAttachFn = scope, scope = void 0), hasElementTranscludeDirective && (transcludeControllers = elementControllers), 
                        futureParentElement || (futureParentElement = hasElementTranscludeDirective ? $element.parent() : $element), 
                        !slotName) return boundTranscludeFn(scope, cloneAttachFn, transcludeControllers, futureParentElement, scopeToChild);
                        var slotTranscludeFn = boundTranscludeFn.$$slots[slotName];
                        if (slotTranscludeFn) return slotTranscludeFn(scope, cloneAttachFn, transcludeControllers, futureParentElement, scopeToChild);
                        if (isUndefined(slotTranscludeFn)) throw $compileMinErr("noslot", 'No parent directive that requires a transclusion with slot name "{0}". Element: {1}', slotName, startingTag($element));
                    }
                    var i, ii, linkFn, isolateScope, controllerScope, elementControllers, transcludeFn, $element, attrs, scopeBindingInfo;
                    compileNode === linkNode ? (attrs = templateAttrs, $element = templateAttrs.$$element) : ($element = jqLite(linkNode), 
                    attrs = new Attributes($element, templateAttrs)), controllerScope = scope, newIsolateScopeDirective ? isolateScope = scope.$new(!0) : newScopeDirective && (controllerScope = scope.$parent), 
                    boundTranscludeFn && (transcludeFn = controllersBoundTransclude, transcludeFn.$$boundTransclude = boundTranscludeFn, 
                    transcludeFn.isSlotFilled = function(slotName) {
                        return !!boundTranscludeFn.$$slots[slotName];
                    }), controllerDirectives && (elementControllers = setupControllers($element, attrs, transcludeFn, controllerDirectives, isolateScope, scope, newIsolateScopeDirective)), 
                    newIsolateScopeDirective && (compile.$$addScopeInfo($element, isolateScope, !0, !(templateDirective && (templateDirective === newIsolateScopeDirective || templateDirective === newIsolateScopeDirective.$$originalDirective))), 
                    compile.$$addScopeClass($element, !0), isolateScope.$$isolateBindings = newIsolateScopeDirective.$$isolateBindings, 
                    scopeBindingInfo = initializeDirectiveBindings(scope, attrs, isolateScope, isolateScope.$$isolateBindings, newIsolateScopeDirective), 
                    scopeBindingInfo.removeWatches && isolateScope.$on("$destroy", scopeBindingInfo.removeWatches));
                    for (var name in elementControllers) {
                        var controllerDirective = controllerDirectives[name], controller = elementControllers[name], bindings = controllerDirective.$$bindings.bindToController;
                        controller.instance = controller(), $element.data("$" + controllerDirective.name + "Controller", controller.instance), 
                        controller.bindingInfo = initializeDirectiveBindings(controllerScope, attrs, controller.instance, bindings, controllerDirective);
                    }
                    for (forEach(controllerDirectives, function(controllerDirective, name) {
                        var require = controllerDirective.require;
                        controllerDirective.bindToController && !isArray(require) && isObject(require) && extend(elementControllers[name].instance, getControllers(name, require, $element, elementControllers));
                    }), forEach(elementControllers, function(controller) {
                        var controllerInstance = controller.instance;
                        if (isFunction(controllerInstance.$onChanges)) try {
                            controllerInstance.$onChanges(controller.bindingInfo.initialChanges);
                        } catch (e) {
                            $exceptionHandler(e);
                        }
                        if (isFunction(controllerInstance.$onInit)) try {
                            controllerInstance.$onInit();
                        } catch (e) {
                            $exceptionHandler(e);
                        }
                        isFunction(controllerInstance.$doCheck) && (controllerScope.$watch(function() {
                            controllerInstance.$doCheck();
                        }), controllerInstance.$doCheck()), isFunction(controllerInstance.$onDestroy) && controllerScope.$on("$destroy", function() {
                            controllerInstance.$onDestroy();
                        });
                    }), i = 0, ii = preLinkFns.length; ii > i; i++) linkFn = preLinkFns[i], invokeLinkFn(linkFn, linkFn.isolateScope ? isolateScope : scope, $element, attrs, linkFn.require && getControllers(linkFn.directiveName, linkFn.require, $element, elementControllers), transcludeFn);
                    var scopeToChild = scope;
                    for (newIsolateScopeDirective && (newIsolateScopeDirective.template || null === newIsolateScopeDirective.templateUrl) && (scopeToChild = isolateScope), 
                    childLinkFn && childLinkFn(scopeToChild, linkNode.childNodes, void 0, boundTranscludeFn), 
                    i = postLinkFns.length - 1; i >= 0; i--) linkFn = postLinkFns[i], invokeLinkFn(linkFn, linkFn.isolateScope ? isolateScope : scope, $element, attrs, linkFn.require && getControllers(linkFn.directiveName, linkFn.require, $element, elementControllers), transcludeFn);
                    forEach(elementControllers, function(controller) {
                        var controllerInstance = controller.instance;
                        isFunction(controllerInstance.$postLink) && controllerInstance.$postLink();
                    });
                }
                previousCompileContext = previousCompileContext || {};
                for (var directive, directiveName, $template, linkFn, directiveValue, terminalPriority = -Number.MAX_VALUE, newScopeDirective = previousCompileContext.newScopeDirective, controllerDirectives = previousCompileContext.controllerDirectives, newIsolateScopeDirective = previousCompileContext.newIsolateScopeDirective, templateDirective = previousCompileContext.templateDirective, nonTlbTranscludeDirective = previousCompileContext.nonTlbTranscludeDirective, hasTranscludeDirective = !1, hasTemplate = !1, hasElementTranscludeDirective = previousCompileContext.hasElementTranscludeDirective, $compileNode = templateAttrs.$$element = jqLite(compileNode), replaceDirective = originalReplaceDirective, childTranscludeFn = transcludeFn, didScanForMultipleTransclusion = !1, mightHaveMultipleTransclusionError = !1, i = 0, ii = directives.length; ii > i; i++) {
                    directive = directives[i];
                    var attrStart = directive.$$start, attrEnd = directive.$$end;
                    if (attrStart && ($compileNode = groupScan(compileNode, attrStart, attrEnd)), $template = void 0, 
                    terminalPriority > directive.priority) break;
                    if (directiveValue = directive.scope, directiveValue && (directive.templateUrl || (isObject(directiveValue) ? (assertNoDuplicate("new/isolated scope", newIsolateScopeDirective || newScopeDirective, directive, $compileNode), 
                    newIsolateScopeDirective = directive) : assertNoDuplicate("new/isolated scope", newIsolateScopeDirective, directive, $compileNode)), 
                    newScopeDirective = newScopeDirective || directive), directiveName = directive.name, 
                    !didScanForMultipleTransclusion && (directive.replace && (directive.templateUrl || directive.template) || directive.transclude && !directive.$$tlb)) {
                        for (var candidateDirective, scanningIndex = i + 1; candidateDirective = directives[scanningIndex++]; ) if (candidateDirective.transclude && !candidateDirective.$$tlb || candidateDirective.replace && (candidateDirective.templateUrl || candidateDirective.template)) {
                            mightHaveMultipleTransclusionError = !0;
                            break;
                        }
                        didScanForMultipleTransclusion = !0;
                    }
                    if (!directive.templateUrl && directive.controller && (controllerDirectives = controllerDirectives || createMap(), 
                    assertNoDuplicate("'" + directiveName + "' controller", controllerDirectives[directiveName], directive, $compileNode), 
                    controllerDirectives[directiveName] = directive), directiveValue = directive.transclude) if (hasTranscludeDirective = !0, 
                    directive.$$tlb || (assertNoDuplicate("transclusion", nonTlbTranscludeDirective, directive, $compileNode), 
                    nonTlbTranscludeDirective = directive), "element" === directiveValue) hasElementTranscludeDirective = !0, 
                    terminalPriority = directive.priority, $template = $compileNode, $compileNode = templateAttrs.$$element = jqLite(compile.$$createComment(directiveName, templateAttrs[directiveName])), 
                    compileNode = $compileNode[0], replaceWith(jqCollection, sliceArgs($template), compileNode), 
                    childTranscludeFn = compilationGenerator(mightHaveMultipleTransclusionError, $template, transcludeFn, terminalPriority, replaceDirective && replaceDirective.name, {
                        nonTlbTranscludeDirective: nonTlbTranscludeDirective
                    }); else {
                        var slots = createMap();
                        if (isObject(directiveValue)) {
                            $template = window.document.createDocumentFragment();
                            var slotMap = createMap(), filledSlots = createMap();
                            forEach(directiveValue, function(elementSelector, slotName) {
                                var optional = "?" === elementSelector.charAt(0);
                                elementSelector = optional ? elementSelector.substring(1) : elementSelector, slotMap[elementSelector] = slotName, 
                                slots[slotName] = null, filledSlots[slotName] = optional;
                            }), forEach($compileNode.contents(), function(node) {
                                var slotName = slotMap[directiveNormalize(nodeName_(node))];
                                slotName ? (filledSlots[slotName] = !0, slots[slotName] = slots[slotName] || window.document.createDocumentFragment(), 
                                slots[slotName].appendChild(node)) : $template.appendChild(node);
                            }), forEach(filledSlots, function(filled, slotName) {
                                if (!filled) throw $compileMinErr("reqslot", "Required transclusion slot `{0}` was not filled.", slotName);
                            });
                            for (var slotName in slots) slots[slotName] && (slots[slotName] = compilationGenerator(mightHaveMultipleTransclusionError, slots[slotName].childNodes, transcludeFn));
                            $template = $template.childNodes;
                        } else $template = jqLite(jqLiteClone(compileNode)).contents();
                        $compileNode.empty(), childTranscludeFn = compilationGenerator(mightHaveMultipleTransclusionError, $template, transcludeFn, void 0, void 0, {
                            needsNewScope: directive.$$isolateScope || directive.$$newScope
                        }), childTranscludeFn.$$slots = slots;
                    }
                    if (directive.template) if (hasTemplate = !0, assertNoDuplicate("template", templateDirective, directive, $compileNode), 
                    templateDirective = directive, directiveValue = isFunction(directive.template) ? directive.template($compileNode, templateAttrs) : directive.template, 
                    directiveValue = denormalizeTemplate(directiveValue), directive.replace) {
                        if (replaceDirective = directive, $template = jqLiteIsTextNode(directiveValue) ? [] : removeComments(wrapTemplate(directive.templateNamespace, trim(directiveValue))), 
                        compileNode = $template[0], 1 !== $template.length || compileNode.nodeType !== NODE_TYPE_ELEMENT) throw $compileMinErr("tplrt", "Template for directive '{0}' must have exactly one root element. {1}", directiveName, "");
                        replaceWith(jqCollection, $compileNode, compileNode);
                        var newTemplateAttrs = {
                            $attr: {}
                        }, templateDirectives = collectDirectives(compileNode, [], newTemplateAttrs), unprocessedDirectives = directives.splice(i + 1, directives.length - (i + 1));
                        (newIsolateScopeDirective || newScopeDirective) && markDirectiveScope(templateDirectives, newIsolateScopeDirective, newScopeDirective), 
                        directives = directives.concat(templateDirectives).concat(unprocessedDirectives), 
                        mergeTemplateAttributes(templateAttrs, newTemplateAttrs), ii = directives.length;
                    } else $compileNode.html(directiveValue);
                    if (directive.templateUrl) hasTemplate = !0, assertNoDuplicate("template", templateDirective, directive, $compileNode), 
                    templateDirective = directive, directive.replace && (replaceDirective = directive), 
                    nodeLinkFn = compileTemplateUrl(directives.splice(i, directives.length - i), $compileNode, templateAttrs, jqCollection, hasTranscludeDirective && childTranscludeFn, preLinkFns, postLinkFns, {
                        controllerDirectives: controllerDirectives,
                        newScopeDirective: newScopeDirective !== directive && newScopeDirective,
                        newIsolateScopeDirective: newIsolateScopeDirective,
                        templateDirective: templateDirective,
                        nonTlbTranscludeDirective: nonTlbTranscludeDirective
                    }), ii = directives.length; else if (directive.compile) try {
                        linkFn = directive.compile($compileNode, templateAttrs, childTranscludeFn);
                        var context = directive.$$originalDirective || directive;
                        isFunction(linkFn) ? addLinkFns(null, bind(context, linkFn), attrStart, attrEnd) : linkFn && addLinkFns(bind(context, linkFn.pre), bind(context, linkFn.post), attrStart, attrEnd);
                    } catch (e) {
                        $exceptionHandler(e, startingTag($compileNode));
                    }
                    directive.terminal && (nodeLinkFn.terminal = !0, terminalPriority = Math.max(terminalPriority, directive.priority));
                }
                return nodeLinkFn.scope = newScopeDirective && newScopeDirective.scope === !0, nodeLinkFn.transcludeOnThisElement = hasTranscludeDirective, 
                nodeLinkFn.templateOnThisElement = hasTemplate, nodeLinkFn.transclude = childTranscludeFn, 
                previousCompileContext.hasElementTranscludeDirective = hasElementTranscludeDirective, 
                nodeLinkFn;
            }
            function getControllers(directiveName, require, $element, elementControllers) {
                var value;
                if (isString(require)) {
                    var match = require.match(REQUIRE_PREFIX_REGEXP), name = require.substring(match[0].length), inheritType = match[1] || match[3], optional = "?" === match[2];
                    if ("^^" === inheritType ? $element = $element.parent() : (value = elementControllers && elementControllers[name], 
                    value = value && value.instance), !value) {
                        var dataName = "$" + name + "Controller";
                        value = inheritType ? $element.inheritedData(dataName) : $element.data(dataName);
                    }
                    if (!value && !optional) throw $compileMinErr("ctreq", "Controller '{0}', required by directive '{1}', can't be found!", name, directiveName);
                } else if (isArray(require)) {
                    value = [];
                    for (var i = 0, ii = require.length; ii > i; i++) value[i] = getControllers(directiveName, require[i], $element, elementControllers);
                } else isObject(require) && (value = {}, forEach(require, function(controller, property) {
                    value[property] = getControllers(directiveName, controller, $element, elementControllers);
                }));
                return value || null;
            }
            function setupControllers($element, attrs, transcludeFn, controllerDirectives, isolateScope, scope, newIsolateScopeDirective) {
                var elementControllers = createMap();
                for (var controllerKey in controllerDirectives) {
                    var directive = controllerDirectives[controllerKey], locals = {
                        $scope: directive === newIsolateScopeDirective || directive.$$isolateScope ? isolateScope : scope,
                        $element: $element,
                        $attrs: attrs,
                        $transclude: transcludeFn
                    }, controller = directive.controller;
                    "@" === controller && (controller = attrs[directive.name]);
                    var controllerInstance = $controller(controller, locals, !0, directive.controllerAs);
                    elementControllers[directive.name] = controllerInstance, $element.data("$" + directive.name + "Controller", controllerInstance.instance);
                }
                return elementControllers;
            }
            function markDirectiveScope(directives, isolateScope, newScope) {
                for (var j = 0, jj = directives.length; jj > j; j++) directives[j] = inherit(directives[j], {
                    $$isolateScope: isolateScope,
                    $$newScope: newScope
                });
            }
            function addDirective(tDirectives, name, location, maxPriority, ignoreDirective, startAttrName, endAttrName) {
                if (name === ignoreDirective) return null;
                var match = null;
                if (hasDirectives.hasOwnProperty(name)) for (var directive, directives = $injector.get(name + Suffix), i = 0, ii = directives.length; ii > i; i++) if (directive = directives[i], 
                (isUndefined(maxPriority) || maxPriority > directive.priority) && -1 !== directive.restrict.indexOf(location)) {
                    if (startAttrName && (directive = inherit(directive, {
                        $$start: startAttrName,
                        $$end: endAttrName
                    })), !directive.$$bindings) {
                        var bindings = directive.$$bindings = parseDirectiveBindings(directive, directive.name);
                        isObject(bindings.isolateScope) && (directive.$$isolateBindings = bindings.isolateScope);
                    }
                    tDirectives.push(directive), match = directive;
                }
                return match;
            }
            function directiveIsMultiElement(name) {
                if (hasDirectives.hasOwnProperty(name)) for (var directive, directives = $injector.get(name + Suffix), i = 0, ii = directives.length; ii > i; i++) if (directive = directives[i], 
                directive.multiElement) return !0;
                return !1;
            }
            function mergeTemplateAttributes(dst, src) {
                var srcAttr = src.$attr, dstAttr = dst.$attr;
                forEach(dst, function(value, key) {
                    "$" !== key.charAt(0) && (src[key] && src[key] !== value && (value.length ? value += ("style" === key ? ";" : " ") + src[key] : value = src[key]), 
                    dst.$set(key, value, !0, srcAttr[key]));
                }), forEach(src, function(value, key) {
                    dst.hasOwnProperty(key) || "$" === key.charAt(0) || (dst[key] = value, "class" !== key && "style" !== key && (dstAttr[key] = srcAttr[key]));
                });
            }
            function compileTemplateUrl(directives, $compileNode, tAttrs, $rootElement, childTranscludeFn, preLinkFns, postLinkFns, previousCompileContext) {
                var afterTemplateNodeLinkFn, afterTemplateChildLinkFn, linkQueue = [], beforeTemplateCompileNode = $compileNode[0], origAsyncDirective = directives.shift(), derivedSyncDirective = inherit(origAsyncDirective, {
                    templateUrl: null,
                    transclude: null,
                    replace: null,
                    $$originalDirective: origAsyncDirective
                }), templateUrl = isFunction(origAsyncDirective.templateUrl) ? origAsyncDirective.templateUrl($compileNode, tAttrs) : origAsyncDirective.templateUrl, templateNamespace = origAsyncDirective.templateNamespace;
                return $compileNode.empty(), $templateRequest(templateUrl).then(function(content) {
                    var compileNode, tempTemplateAttrs, $template, childBoundTranscludeFn;
                    if (content = denormalizeTemplate(content), origAsyncDirective.replace) {
                        if ($template = jqLiteIsTextNode(content) ? [] : removeComments(wrapTemplate(templateNamespace, trim(content))), 
                        compileNode = $template[0], 1 !== $template.length || compileNode.nodeType !== NODE_TYPE_ELEMENT) throw $compileMinErr("tplrt", "Template for directive '{0}' must have exactly one root element. {1}", origAsyncDirective.name, templateUrl);
                        tempTemplateAttrs = {
                            $attr: {}
                        }, replaceWith($rootElement, $compileNode, compileNode);
                        var templateDirectives = collectDirectives(compileNode, [], tempTemplateAttrs);
                        isObject(origAsyncDirective.scope) && markDirectiveScope(templateDirectives, !0), 
                        directives = templateDirectives.concat(directives), mergeTemplateAttributes(tAttrs, tempTemplateAttrs);
                    } else compileNode = beforeTemplateCompileNode, $compileNode.html(content);
                    for (directives.unshift(derivedSyncDirective), afterTemplateNodeLinkFn = applyDirectivesToNode(directives, compileNode, tAttrs, childTranscludeFn, $compileNode, origAsyncDirective, preLinkFns, postLinkFns, previousCompileContext), 
                    forEach($rootElement, function(node, i) {
                        node === compileNode && ($rootElement[i] = $compileNode[0]);
                    }), afterTemplateChildLinkFn = compileNodes($compileNode[0].childNodes, childTranscludeFn); linkQueue.length; ) {
                        var scope = linkQueue.shift(), beforeTemplateLinkNode = linkQueue.shift(), linkRootElement = linkQueue.shift(), boundTranscludeFn = linkQueue.shift(), linkNode = $compileNode[0];
                        if (!scope.$$destroyed) {
                            if (beforeTemplateLinkNode !== beforeTemplateCompileNode) {
                                var oldClasses = beforeTemplateLinkNode.className;
                                previousCompileContext.hasElementTranscludeDirective && origAsyncDirective.replace || (linkNode = jqLiteClone(compileNode)), 
                                replaceWith(linkRootElement, jqLite(beforeTemplateLinkNode), linkNode), safeAddClass(jqLite(linkNode), oldClasses);
                            }
                            childBoundTranscludeFn = afterTemplateNodeLinkFn.transcludeOnThisElement ? createBoundTranscludeFn(scope, afterTemplateNodeLinkFn.transclude, boundTranscludeFn) : boundTranscludeFn, 
                            afterTemplateNodeLinkFn(afterTemplateChildLinkFn, scope, linkNode, $rootElement, childBoundTranscludeFn);
                        }
                    }
                    linkQueue = null;
                }).catch(function(error) {
                    isError(error) && $exceptionHandler(error);
                }), function(ignoreChildLinkFn, scope, node, rootElement, boundTranscludeFn) {
                    var childBoundTranscludeFn = boundTranscludeFn;
                    scope.$$destroyed || (linkQueue ? linkQueue.push(scope, node, rootElement, childBoundTranscludeFn) : (afterTemplateNodeLinkFn.transcludeOnThisElement && (childBoundTranscludeFn = createBoundTranscludeFn(scope, afterTemplateNodeLinkFn.transclude, boundTranscludeFn)), 
                    afterTemplateNodeLinkFn(afterTemplateChildLinkFn, scope, node, rootElement, childBoundTranscludeFn)));
                };
            }
            function byPriority(a, b) {
                var diff = b.priority - a.priority;
                return 0 !== diff ? diff : a.name !== b.name ? a.name < b.name ? -1 : 1 : a.index - b.index;
            }
            function assertNoDuplicate(what, previousDirective, directive, element) {
                function wrapModuleNameIfDefined(moduleName) {
                    return moduleName ? " (module: " + moduleName + ")" : "";
                }
                if (previousDirective) throw $compileMinErr("multidir", "Multiple directives [{0}{1}, {2}{3}] asking for {4} on: {5}", previousDirective.name, wrapModuleNameIfDefined(previousDirective.$$moduleName), directive.name, wrapModuleNameIfDefined(directive.$$moduleName), what, startingTag(element));
            }
            function addTextInterpolateDirective(directives, text) {
                var interpolateFn = $interpolate(text, !0);
                interpolateFn && directives.push({
                    priority: 0,
                    compile: function(templateNode) {
                        var templateNodeParent = templateNode.parent(), hasCompileParent = !!templateNodeParent.length;
                        return hasCompileParent && compile.$$addBindingClass(templateNodeParent), function(scope, node) {
                            var parent = node.parent();
                            hasCompileParent || compile.$$addBindingClass(parent), compile.$$addBindingInfo(parent, interpolateFn.expressions), 
                            scope.$watch(interpolateFn, function(value) {
                                node[0].nodeValue = value;
                            });
                        };
                    }
                });
            }
            function wrapTemplate(type, template) {
                switch (type = lowercase(type || "html")) {
                  case "svg":
                  case "math":
                    var wrapper = window.document.createElement("div");
                    return wrapper.innerHTML = "<" + type + ">" + template + "</" + type + ">", wrapper.childNodes[0].childNodes;

                  default:
                    return template;
                }
            }
            function getTrustedContext(node, attrNormalizedName) {
                if ("srcdoc" === attrNormalizedName) return $sce.HTML;
                var tag = nodeName_(node);
                return "src" === attrNormalizedName || "ngSrc" === attrNormalizedName ? -1 === [ "img", "video", "audio", "source", "track" ].indexOf(tag) ? $sce.RESOURCE_URL : $sce.MEDIA_URL : "xlinkHref" === attrNormalizedName ? "image" === tag ? $sce.MEDIA_URL : "a" === tag ? $sce.URL : $sce.RESOURCE_URL : "form" === tag && "action" === attrNormalizedName || "base" === tag && "href" === attrNormalizedName || "link" === tag && "href" === attrNormalizedName ? $sce.RESOURCE_URL : "a" !== tag || "href" !== attrNormalizedName && "ngHref" !== attrNormalizedName ? void 0 : $sce.URL;
            }
            function addAttrInterpolateDirective(node, directives, value, name, isNgAttr) {
                var trustedContext = getTrustedContext(node, name), mustHaveExpression = !isNgAttr, allOrNothing = ALL_OR_NOTHING_ATTRS[name] || isNgAttr, interpolateFn = $interpolate(value, mustHaveExpression, trustedContext, allOrNothing);
                if (interpolateFn) {
                    if ("multiple" === name && "select" === nodeName_(node)) throw $compileMinErr("selmulti", "Binding to the 'multiple' attribute is not supported. Element: {0}", startingTag(node));
                    if (EVENT_HANDLER_ATTR_REGEXP.test(name)) throw $compileMinErr("nodomevents", "Interpolations for HTML DOM event attributes are disallowed.  Please use the ng- versions (such as ng-click instead of onclick) instead.");
                    directives.push({
                        priority: 100,
                        compile: function() {
                            return {
                                pre: function(scope, element, attr) {
                                    var $$observers = attr.$$observers || (attr.$$observers = createMap()), newValue = attr[name];
                                    newValue !== value && (interpolateFn = newValue && $interpolate(newValue, !0, trustedContext, allOrNothing), 
                                    value = newValue), interpolateFn && (attr[name] = interpolateFn(scope), ($$observers[name] || ($$observers[name] = [])).$$inter = !0, 
                                    (attr.$$observers && attr.$$observers[name].$$scope || scope).$watch(interpolateFn, function(newValue, oldValue) {
                                        "class" === name && newValue !== oldValue ? attr.$updateClass(newValue, oldValue) : attr.$set(name, newValue);
                                    }));
                                }
                            };
                        }
                    });
                }
            }
            function replaceWith($rootElement, elementsToRemove, newNode) {
                var i, ii, firstElementToRemove = elementsToRemove[0], removeCount = elementsToRemove.length, parent = firstElementToRemove.parentNode;
                if ($rootElement) for (i = 0, ii = $rootElement.length; ii > i; i++) if ($rootElement[i] === firstElementToRemove) {
                    $rootElement[i++] = newNode;
                    for (var j = i, j2 = j + removeCount - 1, jj = $rootElement.length; jj > j; j++, 
                    j2++) jj > j2 ? $rootElement[j] = $rootElement[j2] : delete $rootElement[j];
                    $rootElement.length -= removeCount - 1, $rootElement.context === firstElementToRemove && ($rootElement.context = newNode);
                    break;
                }
                parent && parent.replaceChild(newNode, firstElementToRemove);
                var fragment = window.document.createDocumentFragment();
                for (i = 0; removeCount > i; i++) fragment.appendChild(elementsToRemove[i]);
                for (jqLite.hasData(firstElementToRemove) && (jqLite.data(newNode, jqLite.data(firstElementToRemove)), 
                jqLite(firstElementToRemove).off("$destroy")), jqLite.cleanData(fragment.querySelectorAll("*")), 
                i = 1; removeCount > i; i++) delete elementsToRemove[i];
                elementsToRemove[0] = newNode, elementsToRemove.length = 1;
            }
            function cloneAndAnnotateFn(fn, annotation) {
                return extend(function() {
                    return fn.apply(null, arguments);
                }, fn, annotation);
            }
            function invokeLinkFn(linkFn, scope, $element, attrs, controllers, transcludeFn) {
                try {
                    linkFn(scope, $element, attrs, controllers, transcludeFn);
                } catch (e) {
                    $exceptionHandler(e, startingTag($element));
                }
            }
            function strictBindingsCheck(attrName, directiveName) {
                if (strictComponentBindingsEnabled) throw $compileMinErr("missingattr", "Attribute '{0}' of '{1}' is non-optional and must be set!", attrName, directiveName);
            }
            function initializeDirectiveBindings(scope, attrs, destination, bindings, directive) {
                function recordChanges(key, currentValue, previousValue) {
                    isFunction(destination.$onChanges) && !simpleCompare(currentValue, previousValue) && (onChangesQueue || (scope.$$postDigest(flushOnChangesQueue), 
                    onChangesQueue = []), changes || (changes = {}, onChangesQueue.push(triggerOnChangesHook)), 
                    changes[key] && (previousValue = changes[key].previousValue), changes[key] = new SimpleChange(previousValue, currentValue));
                }
                function triggerOnChangesHook() {
                    destination.$onChanges(changes), changes = void 0;
                }
                var changes, removeWatchCollection = [], initialChanges = {};
                return forEach(bindings, function(definition, scopeName) {
                    var lastValue, parentGet, parentSet, compare, removeWatch, attrName = definition.attrName, optional = definition.optional, mode = definition.mode;
                    switch (mode) {
                      case "@":
                        optional || hasOwnProperty.call(attrs, attrName) || (strictBindingsCheck(attrName, directive.name), 
                        destination[scopeName] = attrs[attrName] = void 0), removeWatch = attrs.$observe(attrName, function(value) {
                            if (isString(value) || isBoolean(value)) {
                                var oldValue = destination[scopeName];
                                recordChanges(scopeName, value, oldValue), destination[scopeName] = value;
                            }
                        }), attrs.$$observers[attrName].$$scope = scope, lastValue = attrs[attrName], isString(lastValue) ? destination[scopeName] = $interpolate(lastValue)(scope) : isBoolean(lastValue) && (destination[scopeName] = lastValue), 
                        initialChanges[scopeName] = new SimpleChange(_UNINITIALIZED_VALUE, destination[scopeName]), 
                        removeWatchCollection.push(removeWatch);
                        break;

                      case "=":
                        if (!hasOwnProperty.call(attrs, attrName)) {
                            if (optional) break;
                            strictBindingsCheck(attrName, directive.name), attrs[attrName] = void 0;
                        }
                        if (optional && !attrs[attrName]) break;
                        parentGet = $parse(attrs[attrName]), compare = parentGet.literal ? equals : simpleCompare, 
                        parentSet = parentGet.assign || function() {
                            throw lastValue = destination[scopeName] = parentGet(scope), $compileMinErr("nonassign", "Expression '{0}' in attribute '{1}' used with directive '{2}' is non-assignable!", attrs[attrName], attrName, directive.name);
                        }, lastValue = destination[scopeName] = parentGet(scope);
                        var parentValueWatch = function(parentValue) {
                            return compare(parentValue, destination[scopeName]) || (compare(parentValue, lastValue) ? parentSet(scope, parentValue = destination[scopeName]) : destination[scopeName] = parentValue), 
                            lastValue = parentValue;
                        };
                        parentValueWatch.$stateful = !0, removeWatch = definition.collection ? scope.$watchCollection(attrs[attrName], parentValueWatch) : scope.$watch($parse(attrs[attrName], parentValueWatch), null, parentGet.literal), 
                        removeWatchCollection.push(removeWatch);
                        break;

                      case "<":
                        if (!hasOwnProperty.call(attrs, attrName)) {
                            if (optional) break;
                            strictBindingsCheck(attrName, directive.name), attrs[attrName] = void 0;
                        }
                        if (optional && !attrs[attrName]) break;
                        parentGet = $parse(attrs[attrName]);
                        var isLiteral = parentGet.literal, initialValue = destination[scopeName] = parentGet(scope);
                        initialChanges[scopeName] = new SimpleChange(_UNINITIALIZED_VALUE, destination[scopeName]), 
                        removeWatch = scope[definition.collection ? "$watchCollection" : "$watch"](parentGet, function(newValue, oldValue) {
                            if (oldValue === newValue) {
                                if (oldValue === initialValue || isLiteral && equals(oldValue, initialValue)) return;
                                oldValue = initialValue;
                            }
                            recordChanges(scopeName, newValue, oldValue), destination[scopeName] = newValue;
                        }), removeWatchCollection.push(removeWatch);
                        break;

                      case "&":
                        if (optional || hasOwnProperty.call(attrs, attrName) || strictBindingsCheck(attrName, directive.name), 
                        parentGet = attrs.hasOwnProperty(attrName) ? $parse(attrs[attrName]) : noop, parentGet === noop && optional) break;
                        destination[scopeName] = function(locals) {
                            return parentGet(scope, locals);
                        };
                    }
                }), {
                    initialChanges: initialChanges,
                    removeWatches: removeWatchCollection.length && function() {
                        for (var i = 0, ii = removeWatchCollection.length; ii > i; ++i) removeWatchCollection[i]();
                    }
                };
            }
            var onChangesQueue, SIMPLE_ATTR_NAME = /^\w/, specialAttrHolder = window.document.createElement("div"), commentDirectivesEnabled = commentDirectivesEnabledConfig, cssClassDirectivesEnabled = cssClassDirectivesEnabledConfig, onChangesTtl = TTL;
            Attributes.prototype = {
                $normalize: directiveNormalize,
                $addClass: function(classVal) {
                    classVal && classVal.length > 0 && $animate.addClass(this.$$element, classVal);
                },
                $removeClass: function(classVal) {
                    classVal && classVal.length > 0 && $animate.removeClass(this.$$element, classVal);
                },
                $updateClass: function(newClasses, oldClasses) {
                    var toAdd = tokenDifference(newClasses, oldClasses);
                    toAdd && toAdd.length && $animate.addClass(this.$$element, toAdd);
                    var toRemove = tokenDifference(oldClasses, newClasses);
                    toRemove && toRemove.length && $animate.removeClass(this.$$element, toRemove);
                },
                $set: function(key, value, writeAttr, attrName) {
                    var nodeName, node = this.$$element[0], booleanKey = getBooleanAttrName(node, key), aliasedKey = getAliasedAttrName(key), observer = key;
                    if (booleanKey ? (this.$$element.prop(key, value), attrName = booleanKey) : aliasedKey && (this[aliasedKey] = value, 
                    observer = aliasedKey), this[key] = value, attrName ? this.$attr[key] = attrName : (attrName = this.$attr[key], 
                    attrName || (this.$attr[key] = attrName = snake_case(key, "-"))), nodeName = nodeName_(this.$$element), 
                    "img" === nodeName && "srcset" === key && value) {
                        if (!isString(value)) throw $compileMinErr("srcset", "Can't pass trusted values to `$set('srcset', value)`: \"{0}\"", value.toString());
                        for (var result = "", trimmedSrcset = trim(value), srcPattern = /(\s+\d+x\s*,|\s+\d+w\s*,|\s+,|,\s+)/, pattern = /\s/.test(trimmedSrcset) ? srcPattern : /(,)/, rawUris = trimmedSrcset.split(pattern), nbrUrisWith2parts = Math.floor(rawUris.length / 2), i = 0; nbrUrisWith2parts > i; i++) {
                            var innerIdx = 2 * i;
                            result += $sce.getTrustedMediaUrl(trim(rawUris[innerIdx])), result += " " + trim(rawUris[innerIdx + 1]);
                        }
                        var lastTuple = trim(rawUris[2 * i]).split(/\s/);
                        result += $sce.getTrustedMediaUrl(trim(lastTuple[0])), 2 === lastTuple.length && (result += " " + trim(lastTuple[1])), 
                        this[key] = value = result;
                    }
                    writeAttr !== !1 && (null === value || isUndefined(value) ? this.$$element.removeAttr(attrName) : SIMPLE_ATTR_NAME.test(attrName) ? this.$$element.attr(attrName, value) : setSpecialAttr(this.$$element[0], attrName, value));
                    var $$observers = this.$$observers;
                    $$observers && forEach($$observers[observer], function(fn) {
                        try {
                            fn(value);
                        } catch (e) {
                            $exceptionHandler(e);
                        }
                    });
                },
                $observe: function(key, fn) {
                    var attrs = this, $$observers = attrs.$$observers || (attrs.$$observers = createMap()), listeners = $$observers[key] || ($$observers[key] = []);
                    return listeners.push(fn), $rootScope.$evalAsync(function() {
                        listeners.$$inter || !attrs.hasOwnProperty(key) || isUndefined(attrs[key]) || fn(attrs[key]);
                    }), function() {
                        arrayRemove(listeners, fn);
                    };
                }
            };
            var startSymbol = $interpolate.startSymbol(), endSymbol = $interpolate.endSymbol(), denormalizeTemplate = "{{" === startSymbol && "}}" === endSymbol ? identity : function(template) {
                return template.replace(/\{\{/g, startSymbol).replace(/}}/g, endSymbol);
            }, NG_ATTR_BINDING = /^ngAttr[A-Z]/, MULTI_ELEMENT_DIR_RE = /^(.+)Start$/;
            return compile.$$addBindingInfo = debugInfoEnabled ? function($element, binding) {
                var bindings = $element.data("$binding") || [];
                isArray(binding) ? bindings = bindings.concat(binding) : bindings.push(binding), 
                $element.data("$binding", bindings);
            } : noop, compile.$$addBindingClass = debugInfoEnabled ? function($element) {
                safeAddClass($element, "ng-binding");
            } : noop, compile.$$addScopeInfo = debugInfoEnabled ? function($element, scope, isolated, noTemplate) {
                var dataName = isolated ? noTemplate ? "$isolateScopeNoTemplate" : "$isolateScope" : "$scope";
                $element.data(dataName, scope);
            } : noop, compile.$$addScopeClass = debugInfoEnabled ? function($element, isolated) {
                safeAddClass($element, isolated ? "ng-isolate-scope" : "ng-scope");
            } : noop, compile.$$createComment = function(directiveName, comment) {
                var content = "";
                return debugInfoEnabled && (content = " " + (directiveName || "") + ": ", comment && (content += comment + " ")), 
                window.document.createComment(content);
            }, compile;
        } ];
    }
    function SimpleChange(previous, current) {
        this.previousValue = previous, this.currentValue = current;
    }
    function directiveNormalize(name) {
        return name.replace(PREFIX_REGEXP, "").replace(SPECIAL_CHARS_REGEXP, function(_, letter, offset) {
            return offset ? letter.toUpperCase() : letter;
        });
    }
    function tokenDifference(str1, str2) {
        var values = "", tokens1 = str1.split(/\s+/), tokens2 = str2.split(/\s+/);
        outer: for (var i = 0; i < tokens1.length; i++) {
            for (var token = tokens1[i], j = 0; j < tokens2.length; j++) if (token === tokens2[j]) continue outer;
            values += (values.length > 0 ? " " : "") + token;
        }
        return values;
    }
    function removeComments(jqNodes) {
        jqNodes = jqLite(jqNodes);
        var i = jqNodes.length;
        if (1 >= i) return jqNodes;
        for (;i--; ) {
            var node = jqNodes[i];
            (node.nodeType === NODE_TYPE_COMMENT || node.nodeType === NODE_TYPE_TEXT && "" === node.nodeValue.trim()) && splice.call(jqNodes, i, 1);
        }
        return jqNodes;
    }
    function identifierForController(controller, ident) {
        if (ident && isString(ident)) return ident;
        if (isString(controller)) {
            var match = CNTRL_REG.exec(controller);
            if (match) return match[3];
        }
    }
    function $ControllerProvider() {
        var controllers = {};
        this.has = function(name) {
            return controllers.hasOwnProperty(name);
        }, this.register = function(name, constructor) {
            assertNotHasOwnProperty(name, "controller"), isObject(name) ? extend(controllers, name) : controllers[name] = constructor;
        }, this.$get = [ "$injector", function($injector) {
            function addIdentifier(locals, identifier, instance, name) {
                if (!locals || !isObject(locals.$scope)) throw minErr("$controller")("noscp", "Cannot export controller '{0}' as '{1}'! No $scope object provided via `locals`.", name, identifier);
                locals.$scope[identifier] = instance;
            }
            return function(expression, locals, later, ident) {
                var instance, match, constructor, identifier;
                if (later = later === !0, ident && isString(ident) && (identifier = ident), isString(expression)) {
                    if (match = expression.match(CNTRL_REG), !match) throw $controllerMinErr("ctrlfmt", "Badly formed controller string '{0}'. Must match `__name__ as __id__` or `__name__`.", expression);
                    if (constructor = match[1], identifier = identifier || match[3], expression = controllers.hasOwnProperty(constructor) ? controllers[constructor] : getter(locals.$scope, constructor, !0), 
                    !expression) throw $controllerMinErr("ctrlreg", "The controller with the name '{0}' is not registered.", constructor);
                    assertArgFn(expression, constructor, !0);
                }
                if (later) {
                    var controllerPrototype = (isArray(expression) ? expression[expression.length - 1] : expression).prototype;
                    return instance = Object.create(controllerPrototype || null), identifier && addIdentifier(locals, identifier, instance, constructor || expression.name), 
                    extend(function() {
                        var result = $injector.invoke(expression, instance, locals, constructor);
                        return result !== instance && (isObject(result) || isFunction(result)) && (instance = result, 
                        identifier && addIdentifier(locals, identifier, instance, constructor || expression.name)), 
                        instance;
                    }, {
                        instance: instance,
                        identifier: identifier
                    });
                }
                return instance = $injector.instantiate(expression, locals, constructor), identifier && addIdentifier(locals, identifier, instance, constructor || expression.name), 
                instance;
            };
        } ];
    }
    function $DocumentProvider() {
        this.$get = [ "$window", function(window) {
            return jqLite(window.document);
        } ];
    }
    function $$IsDocumentHiddenProvider() {
        this.$get = [ "$document", "$rootScope", function($document, $rootScope) {
            function changeListener() {
                hidden = doc.hidden;
            }
            var doc = $document[0], hidden = doc && doc.hidden;
            return $document.on("visibilitychange", changeListener), $rootScope.$on("$destroy", function() {
                $document.off("visibilitychange", changeListener);
            }), function() {
                return hidden;
            };
        } ];
    }
    function $ExceptionHandlerProvider() {
        this.$get = [ "$log", function($log) {
            return function() {
                $log.error.apply($log, arguments);
            };
        } ];
    }
    function serializeValue(v) {
        return isObject(v) ? isDate(v) ? v.toISOString() : toJson(v) : v;
    }
    function $HttpParamSerializerProvider() {
        this.$get = function() {
            return function(params) {
                if (!params) return "";
                var parts = [];
                return forEachSorted(params, function(value, key) {
                    null === value || isUndefined(value) || isFunction(value) || (isArray(value) ? forEach(value, function(v) {
                        parts.push(encodeUriQuery(key) + "=" + encodeUriQuery(serializeValue(v)));
                    }) : parts.push(encodeUriQuery(key) + "=" + encodeUriQuery(serializeValue(value))));
                }), parts.join("&");
            };
        };
    }
    function $HttpParamSerializerJQLikeProvider() {
        this.$get = function() {
            return function(params) {
                function serialize(toSerialize, prefix, topLevel) {
                    isArray(toSerialize) ? forEach(toSerialize, function(value, index) {
                        serialize(value, prefix + "[" + (isObject(value) ? index : "") + "]");
                    }) : isObject(toSerialize) && !isDate(toSerialize) ? forEachSorted(toSerialize, function(value, key) {
                        serialize(value, prefix + (topLevel ? "" : "[") + key + (topLevel ? "" : "]"));
                    }) : (isFunction(toSerialize) && (toSerialize = toSerialize()), parts.push(encodeUriQuery(prefix) + "=" + (null == toSerialize ? "" : encodeUriQuery(serializeValue(toSerialize)))));
                }
                if (!params) return "";
                var parts = [];
                return serialize(params, "", !0), parts.join("&");
            };
        };
    }
    function defaultHttpResponseTransform(data, headers) {
        if (isString(data)) {
            var tempData = data.replace(JSON_PROTECTION_PREFIX, "").trim();
            if (tempData) {
                var contentType = headers("Content-Type"), hasJsonContentType = contentType && 0 === contentType.indexOf(APPLICATION_JSON);
                if (hasJsonContentType || isJsonLike(tempData)) try {
                    data = fromJson(tempData);
                } catch (e) {
                    if (!hasJsonContentType) return data;
                    throw $httpMinErr("baddata", 'Data must be a valid JSON object. Received: "{0}". Parse error: "{1}"', data, e);
                }
            }
        }
        return data;
    }
    function isJsonLike(str) {
        var jsonStart = str.match(JSON_START);
        return jsonStart && JSON_ENDS[jsonStart[0]].test(str);
    }
    function parseHeaders(headers) {
        function fillInParsed(key, val) {
            key && (parsed[key] = parsed[key] ? parsed[key] + ", " + val : val);
        }
        var i, parsed = createMap();
        return isString(headers) ? forEach(headers.split("\n"), function(line) {
            i = line.indexOf(":"), fillInParsed(lowercase(trim(line.substr(0, i))), trim(line.substr(i + 1)));
        }) : isObject(headers) && forEach(headers, function(headerVal, headerKey) {
            fillInParsed(lowercase(headerKey), trim(headerVal));
        }), parsed;
    }
    function headersGetter(headers) {
        var headersObj;
        return function(name) {
            if (headersObj || (headersObj = parseHeaders(headers)), name) {
                var value = headersObj[lowercase(name)];
                return void 0 === value && (value = null), value;
            }
            return headersObj;
        };
    }
    function transformData(data, headers, status, fns) {
        return isFunction(fns) ? fns(data, headers, status) : (forEach(fns, function(fn) {
            data = fn(data, headers, status);
        }), data);
    }
    function isSuccess(status) {
        return status >= 200 && 300 > status;
    }
    function $HttpProvider() {
        var defaults = this.defaults = {
            transformResponse: [ defaultHttpResponseTransform ],
            transformRequest: [ function(d) {
                return !isObject(d) || isFile(d) || isBlob(d) || isFormData(d) ? d : toJson(d);
            } ],
            headers: {
                common: {
                    Accept: "application/json, text/plain, */*"
                },
                post: shallowCopy(CONTENT_TYPE_APPLICATION_JSON),
                put: shallowCopy(CONTENT_TYPE_APPLICATION_JSON),
                patch: shallowCopy(CONTENT_TYPE_APPLICATION_JSON)
            },
            xsrfCookieName: "XSRF-TOKEN",
            xsrfHeaderName: "X-XSRF-TOKEN",
            paramSerializer: "$httpParamSerializer",
            jsonpCallbackParam: "callback"
        }, useApplyAsync = !1;
        this.useApplyAsync = function(value) {
            return isDefined(value) ? (useApplyAsync = !!value, this) : useApplyAsync;
        };
        var interceptorFactories = this.interceptors = [], xsrfWhitelistedOrigins = this.xsrfWhitelistedOrigins = [];
        this.$get = [ "$browser", "$httpBackend", "$$cookieReader", "$cacheFactory", "$rootScope", "$q", "$injector", "$sce", function($browser, $httpBackend, $$cookieReader, $cacheFactory, $rootScope, $q, $injector, $sce) {
            function $http(requestConfig) {
                function chainInterceptors(promise, interceptors) {
                    for (var i = 0, ii = interceptors.length; ii > i; ) {
                        var thenFn = interceptors[i++], rejectFn = interceptors[i++];
                        promise = promise.then(thenFn, rejectFn);
                    }
                    return interceptors.length = 0, promise;
                }
                function completeOutstandingRequest() {
                    $browser.$$completeOutstandingRequest(noop);
                }
                function executeHeaderFns(headers, config) {
                    var headerContent, processedHeaders = {};
                    return forEach(headers, function(headerFn, header) {
                        isFunction(headerFn) ? (headerContent = headerFn(config), null != headerContent && (processedHeaders[header] = headerContent)) : processedHeaders[header] = headerFn;
                    }), processedHeaders;
                }
                function mergeHeaders(config) {
                    var defHeaderName, lowercaseDefHeaderName, reqHeaderName, defHeaders = defaults.headers, reqHeaders = extend({}, config.headers);
                    defHeaders = extend({}, defHeaders.common, defHeaders[lowercase(config.method)]);
                    defaultHeadersIteration: for (defHeaderName in defHeaders) {
                        lowercaseDefHeaderName = lowercase(defHeaderName);
                        for (reqHeaderName in reqHeaders) if (lowercase(reqHeaderName) === lowercaseDefHeaderName) continue defaultHeadersIteration;
                        reqHeaders[defHeaderName] = defHeaders[defHeaderName];
                    }
                    return executeHeaderFns(reqHeaders, shallowCopy(config));
                }
                function serverRequest(config) {
                    var headers = config.headers, reqData = transformData(config.data, headersGetter(headers), void 0, config.transformRequest);
                    return isUndefined(reqData) && forEach(headers, function(value, header) {
                        "content-type" === lowercase(header) && delete headers[header];
                    }), isUndefined(config.withCredentials) && !isUndefined(defaults.withCredentials) && (config.withCredentials = defaults.withCredentials), 
                    sendReq(config, reqData).then(transformResponse, transformResponse);
                }
                function transformResponse(response) {
                    var resp = extend({}, response);
                    return resp.data = transformData(response.data, response.headers, response.status, config.transformResponse), 
                    isSuccess(response.status) ? resp : $q.reject(resp);
                }
                if (!isObject(requestConfig)) throw minErr("$http")("badreq", "Http request configuration must be an object.  Received: {0}", requestConfig);
                if (!isString($sce.valueOf(requestConfig.url))) throw minErr("$http")("badreq", "Http request configuration url must be a string or a $sce trusted object.  Received: {0}", requestConfig.url);
                var config = extend({
                    method: "get",
                    transformRequest: defaults.transformRequest,
                    transformResponse: defaults.transformResponse,
                    paramSerializer: defaults.paramSerializer,
                    jsonpCallbackParam: defaults.jsonpCallbackParam
                }, requestConfig);
                config.headers = mergeHeaders(requestConfig), config.method = uppercase(config.method), 
                config.paramSerializer = isString(config.paramSerializer) ? $injector.get(config.paramSerializer) : config.paramSerializer, 
                $browser.$$incOutstandingRequestCount();
                var requestInterceptors = [], responseInterceptors = [], promise = $q.resolve(config);
                return forEach(reversedInterceptors, function(interceptor) {
                    (interceptor.request || interceptor.requestError) && requestInterceptors.unshift(interceptor.request, interceptor.requestError), 
                    (interceptor.response || interceptor.responseError) && responseInterceptors.push(interceptor.response, interceptor.responseError);
                }), promise = chainInterceptors(promise, requestInterceptors), promise = promise.then(serverRequest), 
                promise = chainInterceptors(promise, responseInterceptors), promise = promise.finally(completeOutstandingRequest);
            }
            function createShortMethods() {
                forEach(arguments, function(name) {
                    $http[name] = function(url, config) {
                        return $http(extend({}, config || {}, {
                            method: name,
                            url: url
                        }));
                    };
                });
            }
            function createShortMethodsWithData() {
                forEach(arguments, function(name) {
                    $http[name] = function(url, data, config) {
                        return $http(extend({}, config || {}, {
                            method: name,
                            url: url,
                            data: data
                        }));
                    };
                });
            }
            function sendReq(config, reqData) {
                function createApplyHandlers(eventHandlers) {
                    if (eventHandlers) {
                        var applyHandlers = {};
                        return forEach(eventHandlers, function(eventHandler, key) {
                            applyHandlers[key] = function(event) {
                                function callEventHandler() {
                                    eventHandler(event);
                                }
                                useApplyAsync ? $rootScope.$applyAsync(callEventHandler) : $rootScope.$$phase ? callEventHandler() : $rootScope.$apply(callEventHandler);
                            };
                        }), applyHandlers;
                    }
                }
                function done(status, response, headersString, statusText, xhrStatus) {
                    function resolveHttpPromise() {
                        resolvePromise(response, status, headersString, statusText, xhrStatus);
                    }
                    cache && (isSuccess(status) ? cache.put(url, [ status, response, parseHeaders(headersString), statusText, xhrStatus ]) : cache.remove(url)), 
                    useApplyAsync ? $rootScope.$applyAsync(resolveHttpPromise) : (resolveHttpPromise(), 
                    $rootScope.$$phase || $rootScope.$apply());
                }
                function resolvePromise(response, status, headers, statusText, xhrStatus) {
                    status = status >= -1 ? status : 0, (isSuccess(status) ? deferred.resolve : deferred.reject)({
                        data: response,
                        status: status,
                        headers: headersGetter(headers),
                        config: config,
                        statusText: statusText,
                        xhrStatus: xhrStatus
                    });
                }
                function resolvePromiseWithResult(result) {
                    resolvePromise(result.data, result.status, shallowCopy(result.headers()), result.statusText, result.xhrStatus);
                }
                function removePendingReq() {
                    var idx = $http.pendingRequests.indexOf(config);
                    -1 !== idx && $http.pendingRequests.splice(idx, 1);
                }
                var cache, cachedResp, deferred = $q.defer(), promise = deferred.promise, reqHeaders = config.headers, isJsonp = "jsonp" === lowercase(config.method), url = config.url;
                if (isJsonp ? url = $sce.getTrustedResourceUrl(url) : isString(url) || (url = $sce.valueOf(url)), 
                url = buildUrl(url, config.paramSerializer(config.params)), isJsonp && (url = sanitizeJsonpCallbackParam(url, config.jsonpCallbackParam)), 
                $http.pendingRequests.push(config), promise.then(removePendingReq, removePendingReq), 
                !config.cache && !defaults.cache || config.cache === !1 || "GET" !== config.method && "JSONP" !== config.method || (cache = isObject(config.cache) ? config.cache : isObject(defaults.cache) ? defaults.cache : defaultCache), 
                cache && (cachedResp = cache.get(url), isDefined(cachedResp) ? isPromiseLike(cachedResp) ? cachedResp.then(resolvePromiseWithResult, resolvePromiseWithResult) : isArray(cachedResp) ? resolvePromise(cachedResp[1], cachedResp[0], shallowCopy(cachedResp[2]), cachedResp[3], cachedResp[4]) : resolvePromise(cachedResp, 200, {}, "OK", "complete") : cache.put(url, promise)), 
                isUndefined(cachedResp)) {
                    var xsrfValue = urlIsAllowedOrigin(config.url) ? $$cookieReader()[config.xsrfCookieName || defaults.xsrfCookieName] : void 0;
                    xsrfValue && (reqHeaders[config.xsrfHeaderName || defaults.xsrfHeaderName] = xsrfValue), 
                    $httpBackend(config.method, url, reqData, done, reqHeaders, config.timeout, config.withCredentials, config.responseType, createApplyHandlers(config.eventHandlers), createApplyHandlers(config.uploadEventHandlers));
                }
                return promise;
            }
            function buildUrl(url, serializedParams) {
                return serializedParams.length > 0 && (url += (-1 === url.indexOf("?") ? "?" : "&") + serializedParams), 
                url;
            }
            function sanitizeJsonpCallbackParam(url, cbKey) {
                var parts = url.split("?");
                if (parts.length > 2) throw $httpMinErr("badjsonp", 'Illegal use more than one "?", in url, "{1}"', url);
                var params = parseKeyValue(parts[1]);
                return forEach(params, function(value, key) {
                    if ("JSON_CALLBACK" === value) throw $httpMinErr("badjsonp", 'Illegal use of JSON_CALLBACK in url, "{0}"', url);
                    if (key === cbKey) throw $httpMinErr("badjsonp", 'Illegal use of callback param, "{0}", in url, "{1}"', cbKey, url);
                }), url += (-1 === url.indexOf("?") ? "?" : "&") + cbKey + "=JSON_CALLBACK";
            }
            var defaultCache = $cacheFactory("$http");
            defaults.paramSerializer = isString(defaults.paramSerializer) ? $injector.get(defaults.paramSerializer) : defaults.paramSerializer;
            var reversedInterceptors = [];
            forEach(interceptorFactories, function(interceptorFactory) {
                reversedInterceptors.unshift(isString(interceptorFactory) ? $injector.get(interceptorFactory) : $injector.invoke(interceptorFactory));
            });
            var urlIsAllowedOrigin = urlIsAllowedOriginFactory(xsrfWhitelistedOrigins);
            return $http.pendingRequests = [], createShortMethods("get", "delete", "head", "jsonp"), 
            createShortMethodsWithData("post", "put", "patch"), $http.defaults = defaults, $http;
        } ];
    }
    function $xhrFactoryProvider() {
        this.$get = function() {
            return function() {
                return new window.XMLHttpRequest();
            };
        };
    }
    function $HttpBackendProvider() {
        this.$get = [ "$browser", "$jsonpCallbacks", "$document", "$xhrFactory", function($browser, $jsonpCallbacks, $document, $xhrFactory) {
            return createHttpBackend($browser, $xhrFactory, $browser.defer, $jsonpCallbacks, $document[0]);
        } ];
    }
    function createHttpBackend($browser, createXhr, $browserDefer, callbacks, rawDocument) {
        function jsonpReq(url, callbackPath, done) {
            url = url.replace("JSON_CALLBACK", callbackPath);
            var script = rawDocument.createElement("script"), callback = null;
            return script.type = "text/javascript", script.src = url, script.async = !0, callback = function(event) {
                script.removeEventListener("load", callback), script.removeEventListener("error", callback), 
                rawDocument.body.removeChild(script), script = null;
                var status = -1, text = "unknown";
                event && ("load" !== event.type || callbacks.wasCalled(callbackPath) || (event = {
                    type: "error"
                }), text = event.type, status = "error" === event.type ? 404 : 200), done && done(status, text);
            }, script.addEventListener("load", callback), script.addEventListener("error", callback), 
            rawDocument.body.appendChild(script), callback;
        }
        return function(method, url, post, callback, headers, timeout, withCredentials, responseType, eventHandlers, uploadEventHandlers) {
            function timeoutRequest(reason) {
                abortedByTimeout = "timeout" === reason, jsonpDone && jsonpDone(), xhr && xhr.abort();
            }
            function completeRequest(callback, status, response, headersString, statusText, xhrStatus) {
                isDefined(timeoutId) && $browserDefer.cancel(timeoutId), jsonpDone = xhr = null, 
                callback(status, response, headersString, statusText, xhrStatus);
            }
            if (url = url || $browser.url(), "jsonp" === lowercase(method)) var callbackPath = callbacks.createCallback(url), jsonpDone = jsonpReq(url, callbackPath, function(status, text) {
                var response = 200 === status && callbacks.getResponse(callbackPath);
                completeRequest(callback, status, response, "", text, "complete"), callbacks.removeCallback(callbackPath);
            }); else {
                var xhr = createXhr(method, url), abortedByTimeout = !1;
                xhr.open(method, url, !0), forEach(headers, function(value, key) {
                    isDefined(value) && xhr.setRequestHeader(key, value);
                }), xhr.onload = function() {
                    var statusText = xhr.statusText || "", response = "response" in xhr ? xhr.response : xhr.responseText, status = 1223 === xhr.status ? 204 : xhr.status;
                    0 === status && (status = response ? 200 : "file" === urlResolve(url).protocol ? 404 : 0), 
                    completeRequest(callback, status, response, xhr.getAllResponseHeaders(), statusText, "complete");
                };
                var requestError = function() {
                    completeRequest(callback, -1, null, null, "", "error");
                }, requestAborted = function() {
                    completeRequest(callback, -1, null, null, "", abortedByTimeout ? "timeout" : "abort");
                }, requestTimeout = function() {
                    completeRequest(callback, -1, null, null, "", "timeout");
                };
                if (xhr.onerror = requestError, xhr.ontimeout = requestTimeout, xhr.onabort = requestAborted, 
                forEach(eventHandlers, function(value, key) {
                    xhr.addEventListener(key, value);
                }), forEach(uploadEventHandlers, function(value, key) {
                    xhr.upload.addEventListener(key, value);
                }), withCredentials && (xhr.withCredentials = !0), responseType) try {
                    xhr.responseType = responseType;
                } catch (e) {
                    if ("json" !== responseType) throw e;
                }
                xhr.send(isUndefined(post) ? null : post);
            }
            if (timeout > 0) var timeoutId = $browserDefer(function() {
                timeoutRequest("timeout");
            }, timeout); else isPromiseLike(timeout) && timeout.then(function() {
                timeoutRequest(isDefined(timeout.$$timeoutId) ? "timeout" : "abort");
            });
        };
    }
    function $InterpolateProvider() {
        var startSymbol = "{{", endSymbol = "}}";
        this.startSymbol = function(value) {
            return value ? (startSymbol = value, this) : startSymbol;
        }, this.endSymbol = function(value) {
            return value ? (endSymbol = value, this) : endSymbol;
        }, this.$get = [ "$parse", "$exceptionHandler", "$sce", function($parse, $exceptionHandler, $sce) {
            function escape(ch) {
                return "\\\\\\" + ch;
            }
            function unescapeText(text) {
                return text.replace(escapedStartRegexp, startSymbol).replace(escapedEndRegexp, endSymbol);
            }
            function constantWatchDelegate(scope, listener, objectEquality, constantInterp) {
                var unwatch = scope.$watch(function(scope) {
                    return unwatch(), constantInterp(scope);
                }, listener, objectEquality);
                return unwatch;
            }
            function $interpolate(text, mustHaveExpression, trustedContext, allOrNothing) {
                function parseStringifyInterceptor(value) {
                    try {
                        return value = trustedContext && !contextAllowsConcatenation ? $sce.getTrusted(trustedContext, value) : $sce.valueOf(value), 
                        allOrNothing && !isDefined(value) ? value : stringify(value);
                    } catch (err) {
                        $exceptionHandler($interpolateMinErr.interr(text, err));
                    }
                }
                var contextAllowsConcatenation = trustedContext === $sce.URL || trustedContext === $sce.MEDIA_URL;
                if (!text.length || -1 === text.indexOf(startSymbol)) {
                    if (mustHaveExpression && !contextAllowsConcatenation) return;
                    var unescapedText = unescapeText(text);
                    contextAllowsConcatenation && (unescapedText = $sce.getTrusted(trustedContext, unescapedText));
                    var constantInterp = valueFn(unescapedText);
                    return constantInterp.exp = text, constantInterp.expressions = [], constantInterp.$$watchDelegate = constantWatchDelegate, 
                    constantInterp;
                }
                allOrNothing = !!allOrNothing;
                for (var startIndex, endIndex, parseFns, exp, singleExpression, index = 0, expressions = [], textLength = text.length, concat = [], expressionPositions = []; textLength > index; ) {
                    if (-1 === (startIndex = text.indexOf(startSymbol, index)) || -1 === (endIndex = text.indexOf(endSymbol, startIndex + startSymbolLength))) {
                        index !== textLength && concat.push(unescapeText(text.substring(index)));
                        break;
                    }
                    index !== startIndex && concat.push(unescapeText(text.substring(index, startIndex))), 
                    exp = text.substring(startIndex + startSymbolLength, endIndex), expressions.push(exp), 
                    index = endIndex + endSymbolLength, expressionPositions.push(concat.length), concat.push("");
                }
                singleExpression = 1 === concat.length && 1 === expressionPositions.length;
                var interceptor = contextAllowsConcatenation && singleExpression ? void 0 : parseStringifyInterceptor;
                if (parseFns = expressions.map(function(exp) {
                    return $parse(exp, interceptor);
                }), !mustHaveExpression || expressions.length) {
                    var compute = function(values) {
                        for (var i = 0, ii = expressions.length; ii > i; i++) {
                            if (allOrNothing && isUndefined(values[i])) return;
                            concat[expressionPositions[i]] = values[i];
                        }
                        return contextAllowsConcatenation ? $sce.getTrusted(trustedContext, singleExpression ? concat[0] : concat.join("")) : (trustedContext && concat.length > 1 && $interpolateMinErr.throwNoconcat(text), 
                        concat.join(""));
                    };
                    return extend(function(context) {
                        var i = 0, ii = expressions.length, values = new Array(ii);
                        try {
                            for (;ii > i; i++) values[i] = parseFns[i](context);
                            return compute(values);
                        } catch (err) {
                            $exceptionHandler($interpolateMinErr.interr(text, err));
                        }
                    }, {
                        exp: text,
                        expressions: expressions,
                        $$watchDelegate: function(scope, listener) {
                            var lastValue;
                            return scope.$watchGroup(parseFns, function(values, oldValues) {
                                var currValue = compute(values);
                                listener.call(this, currValue, values !== oldValues ? lastValue : currValue, scope), 
                                lastValue = currValue;
                            });
                        }
                    });
                }
            }
            var startSymbolLength = startSymbol.length, endSymbolLength = endSymbol.length, escapedStartRegexp = new RegExp(startSymbol.replace(/./g, escape), "g"), escapedEndRegexp = new RegExp(endSymbol.replace(/./g, escape), "g");
            return $interpolate.startSymbol = function() {
                return startSymbol;
            }, $interpolate.endSymbol = function() {
                return endSymbol;
            }, $interpolate;
        } ];
    }
    function $IntervalProvider() {
        this.$get = [ "$rootScope", "$window", "$q", "$$q", "$browser", function($rootScope, $window, $q, $$q, $browser) {
            function interval(fn, delay, count, invokeApply) {
                function callback() {
                    hasParams ? fn.apply(null, args) : fn(iteration);
                }
                var hasParams = arguments.length > 4, args = hasParams ? sliceArgs(arguments, 4) : [], setInterval = $window.setInterval, clearInterval = $window.clearInterval, iteration = 0, skipApply = isDefined(invokeApply) && !invokeApply, deferred = (skipApply ? $$q : $q).defer(), promise = deferred.promise;
                return count = isDefined(count) ? count : 0, promise.$$intervalId = setInterval(function() {
                    skipApply ? $browser.defer(callback) : $rootScope.$evalAsync(callback), deferred.notify(iteration++), 
                    count > 0 && iteration >= count && (deferred.resolve(iteration), clearInterval(promise.$$intervalId), 
                    delete intervals[promise.$$intervalId]), skipApply || $rootScope.$apply();
                }, delay), intervals[promise.$$intervalId] = deferred, promise;
            }
            var intervals = {};
            return interval.cancel = function(promise) {
                if (!promise) return !1;
                if (!promise.hasOwnProperty("$$intervalId")) throw $intervalMinErr("badprom", "`$interval.cancel()` called with a promise that was not generated by `$interval()`.");
                if (!intervals.hasOwnProperty(promise.$$intervalId)) return !1;
                var id = promise.$$intervalId, deferred = intervals[id];
                return markQExceptionHandled(deferred.promise), deferred.reject("canceled"), $window.clearInterval(id), 
                delete intervals[id], !0;
            }, interval;
        } ];
    }
    function encodePath(path) {
        for (var segments = path.split("/"), i = segments.length; i--; ) segments[i] = encodeUriSegment(segments[i].replace(/%2F/g, "/"));
        return segments.join("/");
    }
    function decodePath(path, html5Mode) {
        for (var segments = path.split("/"), i = segments.length; i--; ) segments[i] = decodeURIComponent(segments[i]), 
        html5Mode && (segments[i] = segments[i].replace(/\//g, "%2F"));
        return segments.join("/");
    }
    function parseAbsoluteUrl(absoluteUrl, locationObj) {
        var parsedUrl = urlResolve(absoluteUrl);
        locationObj.$$protocol = parsedUrl.protocol, locationObj.$$host = parsedUrl.hostname, 
        locationObj.$$port = toInt(parsedUrl.port) || DEFAULT_PORTS[parsedUrl.protocol] || null;
    }
    function parseAppUrl(url, locationObj, html5Mode) {
        if (DOUBLE_SLASH_REGEX.test(url)) throw $locationMinErr("badpath", 'Invalid url "{0}".', url);
        var prefixed = "/" !== url.charAt(0);
        prefixed && (url = "/" + url);
        var match = urlResolve(url), path = prefixed && "/" === match.pathname.charAt(0) ? match.pathname.substring(1) : match.pathname;
        locationObj.$$path = decodePath(path, html5Mode), locationObj.$$search = parseKeyValue(match.search), 
        locationObj.$$hash = decodeURIComponent(match.hash), locationObj.$$path && "/" !== locationObj.$$path.charAt(0) && (locationObj.$$path = "/" + locationObj.$$path);
    }
    function startsWith(str, search) {
        return str.slice(0, search.length) === search;
    }
    function stripBaseUrl(base, url) {
        return startsWith(url, base) ? url.substr(base.length) : void 0;
    }
    function stripHash(url) {
        var index = url.indexOf("#");
        return -1 === index ? url : url.substr(0, index);
    }
    function trimEmptyHash(url) {
        return url.replace(/(#.+)|#$/, "$1");
    }
    function stripFile(url) {
        return url.substr(0, stripHash(url).lastIndexOf("/") + 1);
    }
    function serverBase(url) {
        return url.substring(0, url.indexOf("/", url.indexOf("//") + 2));
    }
    function LocationHtml5Url(appBase, appBaseNoFile, basePrefix) {
        this.$$html5 = !0, basePrefix = basePrefix || "", parseAbsoluteUrl(appBase, this), 
        this.$$parse = function(url) {
            var pathUrl = stripBaseUrl(appBaseNoFile, url);
            if (!isString(pathUrl)) throw $locationMinErr("ipthprfx", 'Invalid url "{0}", missing path prefix "{1}".', url, appBaseNoFile);
            parseAppUrl(pathUrl, this, !0), this.$$path || (this.$$path = "/"), this.$$compose();
        }, this.$$compose = function() {
            var search = toKeyValue(this.$$search), hash = this.$$hash ? "#" + encodeUriSegment(this.$$hash) : "";
            this.$$url = encodePath(this.$$path) + (search ? "?" + search : "") + hash, this.$$absUrl = appBaseNoFile + this.$$url.substr(1), 
            this.$$urlUpdatedByLocation = !0;
        }, this.$$parseLinkUrl = function(url, relHref) {
            if (relHref && "#" === relHref[0]) return this.hash(relHref.slice(1)), !0;
            var appUrl, prevAppUrl, rewrittenUrl;
            return isDefined(appUrl = stripBaseUrl(appBase, url)) ? (prevAppUrl = appUrl, rewrittenUrl = basePrefix && isDefined(appUrl = stripBaseUrl(basePrefix, appUrl)) ? appBaseNoFile + (stripBaseUrl("/", appUrl) || appUrl) : appBase + prevAppUrl) : isDefined(appUrl = stripBaseUrl(appBaseNoFile, url)) ? rewrittenUrl = appBaseNoFile + appUrl : appBaseNoFile === url + "/" && (rewrittenUrl = appBaseNoFile), 
            rewrittenUrl && this.$$parse(rewrittenUrl), !!rewrittenUrl;
        };
    }
    function LocationHashbangUrl(appBase, appBaseNoFile, hashPrefix) {
        parseAbsoluteUrl(appBase, this), this.$$parse = function(url) {
            function removeWindowsDriveName(path, url, base) {
                var firstPathSegmentMatch, windowsFilePathExp = /^\/[A-Z]:(\/.*)/;
                return startsWith(url, base) && (url = url.replace(base, "")), windowsFilePathExp.exec(url) ? path : (firstPathSegmentMatch = windowsFilePathExp.exec(path), 
                firstPathSegmentMatch ? firstPathSegmentMatch[1] : path);
            }
            var withoutHashUrl, withoutBaseUrl = stripBaseUrl(appBase, url) || stripBaseUrl(appBaseNoFile, url);
            isUndefined(withoutBaseUrl) || "#" !== withoutBaseUrl.charAt(0) ? this.$$html5 ? withoutHashUrl = withoutBaseUrl : (withoutHashUrl = "", 
            isUndefined(withoutBaseUrl) && (appBase = url, this.replace())) : (withoutHashUrl = stripBaseUrl(hashPrefix, withoutBaseUrl), 
            isUndefined(withoutHashUrl) && (withoutHashUrl = withoutBaseUrl)), parseAppUrl(withoutHashUrl, this, !1), 
            this.$$path = removeWindowsDriveName(this.$$path, withoutHashUrl, appBase), this.$$compose();
        }, this.$$compose = function() {
            var search = toKeyValue(this.$$search), hash = this.$$hash ? "#" + encodeUriSegment(this.$$hash) : "";
            this.$$url = encodePath(this.$$path) + (search ? "?" + search : "") + hash, this.$$absUrl = appBase + (this.$$url ? hashPrefix + this.$$url : ""), 
            this.$$urlUpdatedByLocation = !0;
        }, this.$$parseLinkUrl = function(url) {
            return stripHash(appBase) === stripHash(url) ? (this.$$parse(url), !0) : !1;
        };
    }
    function LocationHashbangInHtml5Url(appBase, appBaseNoFile, hashPrefix) {
        this.$$html5 = !0, LocationHashbangUrl.apply(this, arguments), this.$$parseLinkUrl = function(url, relHref) {
            if (relHref && "#" === relHref[0]) return this.hash(relHref.slice(1)), !0;
            var rewrittenUrl, appUrl;
            return appBase === stripHash(url) ? rewrittenUrl = url : (appUrl = stripBaseUrl(appBaseNoFile, url)) ? rewrittenUrl = appBase + hashPrefix + appUrl : appBaseNoFile === url + "/" && (rewrittenUrl = appBaseNoFile), 
            rewrittenUrl && this.$$parse(rewrittenUrl), !!rewrittenUrl;
        }, this.$$compose = function() {
            var search = toKeyValue(this.$$search), hash = this.$$hash ? "#" + encodeUriSegment(this.$$hash) : "";
            this.$$url = encodePath(this.$$path) + (search ? "?" + search : "") + hash, this.$$absUrl = appBase + hashPrefix + this.$$url, 
            this.$$urlUpdatedByLocation = !0;
        };
    }
    function locationGetter(property) {
        return function() {
            return this[property];
        };
    }
    function locationGetterSetter(property, preprocess) {
        return function(value) {
            return isUndefined(value) ? this[property] : (this[property] = preprocess(value), 
            this.$$compose(), this);
        };
    }
    function $LocationProvider() {
        var hashPrefix = "!", html5Mode = {
            enabled: !1,
            requireBase: !0,
            rewriteLinks: !0
        };
        this.hashPrefix = function(prefix) {
            return isDefined(prefix) ? (hashPrefix = prefix, this) : hashPrefix;
        }, this.html5Mode = function(mode) {
            return isBoolean(mode) ? (html5Mode.enabled = mode, this) : isObject(mode) ? (isBoolean(mode.enabled) && (html5Mode.enabled = mode.enabled), 
            isBoolean(mode.requireBase) && (html5Mode.requireBase = mode.requireBase), (isBoolean(mode.rewriteLinks) || isString(mode.rewriteLinks)) && (html5Mode.rewriteLinks = mode.rewriteLinks), 
            this) : html5Mode;
        }, this.$get = [ "$rootScope", "$browser", "$sniffer", "$rootElement", "$window", function($rootScope, $browser, $sniffer, $rootElement, $window) {
            function setBrowserUrlWithFallback(url, replace, state) {
                var oldUrl = $location.url(), oldState = $location.$$state;
                try {
                    $browser.url(url, replace, state), $location.$$state = $browser.state();
                } catch (e) {
                    throw $location.url(oldUrl), $location.$$state = oldState, e;
                }
            }
            function afterLocationChange(oldUrl, oldState) {
                $rootScope.$broadcast("$locationChangeSuccess", $location.absUrl(), oldUrl, $location.$$state, oldState);
            }
            var $location, LocationMode, appBase, baseHref = $browser.baseHref(), initialUrl = $browser.url();
            if (html5Mode.enabled) {
                if (!baseHref && html5Mode.requireBase) throw $locationMinErr("nobase", "$location in HTML5 mode requires a <base> tag to be present!");
                appBase = serverBase(initialUrl) + (baseHref || "/"), LocationMode = $sniffer.history ? LocationHtml5Url : LocationHashbangInHtml5Url;
            } else appBase = stripHash(initialUrl), LocationMode = LocationHashbangUrl;
            var appBaseNoFile = stripFile(appBase);
            $location = new LocationMode(appBase, appBaseNoFile, "#" + hashPrefix), $location.$$parseLinkUrl(initialUrl, initialUrl), 
            $location.$$state = $browser.state();
            var IGNORE_URI_REGEXP = /^\s*(javascript|mailto):/i;
            $rootElement.on("click", function(event) {
                var rewriteLinks = html5Mode.rewriteLinks;
                if (rewriteLinks && !event.ctrlKey && !event.metaKey && !event.shiftKey && 2 !== event.which && 2 !== event.button) {
                    for (var elm = jqLite(event.target); "a" !== nodeName_(elm[0]); ) if (elm[0] === $rootElement[0] || !(elm = elm.parent())[0]) return;
                    if (!isString(rewriteLinks) || !isUndefined(elm.attr(rewriteLinks))) {
                        var absHref = elm.prop("href"), relHref = elm.attr("href") || elm.attr("xlink:href");
                        isObject(absHref) && "[object SVGAnimatedString]" === absHref.toString() && (absHref = urlResolve(absHref.animVal).href), 
                        IGNORE_URI_REGEXP.test(absHref) || !absHref || elm.attr("target") || event.isDefaultPrevented() || $location.$$parseLinkUrl(absHref, relHref) && (event.preventDefault(), 
                        $location.absUrl() !== $browser.url() && $rootScope.$apply());
                    }
                }
            }), trimEmptyHash($location.absUrl()) !== trimEmptyHash(initialUrl) && $browser.url($location.absUrl(), !0);
            var initializing = !0;
            return $browser.onUrlChange(function(newUrl, newState) {
                return startsWith(newUrl, appBaseNoFile) ? ($rootScope.$evalAsync(function() {
                    var defaultPrevented, oldUrl = $location.absUrl(), oldState = $location.$$state;
                    newUrl = trimEmptyHash(newUrl), $location.$$parse(newUrl), $location.$$state = newState, 
                    defaultPrevented = $rootScope.$broadcast("$locationChangeStart", newUrl, oldUrl, newState, oldState).defaultPrevented, 
                    $location.absUrl() === newUrl && (defaultPrevented ? ($location.$$parse(oldUrl), 
                    $location.$$state = oldState, setBrowserUrlWithFallback(oldUrl, !1, oldState)) : (initializing = !1, 
                    afterLocationChange(oldUrl, oldState)));
                }), void ($rootScope.$$phase || $rootScope.$digest())) : void ($window.location.href = newUrl);
            }), $rootScope.$watch(function() {
                if (initializing || $location.$$urlUpdatedByLocation) {
                    $location.$$urlUpdatedByLocation = !1;
                    var oldUrl = trimEmptyHash($browser.url()), newUrl = trimEmptyHash($location.absUrl()), oldState = $browser.state(), currentReplace = $location.$$replace, urlOrStateChanged = oldUrl !== newUrl || $location.$$html5 && $sniffer.history && oldState !== $location.$$state;
                    (initializing || urlOrStateChanged) && (initializing = !1, $rootScope.$evalAsync(function() {
                        var newUrl = $location.absUrl(), defaultPrevented = $rootScope.$broadcast("$locationChangeStart", newUrl, oldUrl, $location.$$state, oldState).defaultPrevented;
                        $location.absUrl() === newUrl && (defaultPrevented ? ($location.$$parse(oldUrl), 
                        $location.$$state = oldState) : (urlOrStateChanged && setBrowserUrlWithFallback(newUrl, currentReplace, oldState === $location.$$state ? null : $location.$$state), 
                        afterLocationChange(oldUrl, oldState)));
                    }));
                }
                $location.$$replace = !1;
            }), $location;
        } ];
    }
    function $LogProvider() {
        var debug = !0, self = this;
        this.debugEnabled = function(flag) {
            return isDefined(flag) ? (debug = flag, this) : debug;
        }, this.$get = [ "$window", function($window) {
            function formatError(arg) {
                return isError(arg) && (arg.stack && formatStackTrace ? arg = arg.message && -1 === arg.stack.indexOf(arg.message) ? "Error: " + arg.message + "\n" + arg.stack : arg.stack : arg.sourceURL && (arg = arg.message + "\n" + arg.sourceURL + ":" + arg.line)), 
                arg;
            }
            function consoleLog(type) {
                var console = $window.console || {}, logFn = console[type] || console.log || noop;
                return function() {
                    var args = [];
                    return forEach(arguments, function(arg) {
                        args.push(formatError(arg));
                    }), Function.prototype.apply.call(logFn, console, args);
                };
            }
            var formatStackTrace = msie || /\bEdge\//.test($window.navigator && $window.navigator.userAgent);
            return {
                log: consoleLog("log"),
                info: consoleLog("info"),
                warn: consoleLog("warn"),
                error: consoleLog("error"),
                debug: function() {
                    var fn = consoleLog("debug");
                    return function() {
                        debug && fn.apply(self, arguments);
                    };
                }()
            };
        } ];
    }
    function getStringValue(name) {
        return name + "";
    }
    function ifDefined(v, d) {
        return "undefined" != typeof v ? v : d;
    }
    function plusFn(l, r) {
        return "undefined" == typeof l ? r : "undefined" == typeof r ? l : l + r;
    }
    function isStateless($filter, filterName) {
        var fn = $filter(filterName);
        return !fn.$stateful;
    }
    function isPure(node, parentIsPure) {
        switch (node.type) {
          case AST.MemberExpression:
            if (node.computed) return !1;
            break;

          case AST.UnaryExpression:
            return PURITY_ABSOLUTE;

          case AST.BinaryExpression:
            return "+" !== node.operator ? PURITY_ABSOLUTE : !1;

          case AST.CallExpression:
            return !1;
        }
        return void 0 === parentIsPure ? PURITY_RELATIVE : parentIsPure;
    }
    function findConstantAndWatchExpressions(ast, $filter, parentIsPure) {
        var allConstants, argsToWatch, isStatelessFilter, astIsPure = ast.isPure = isPure(ast, parentIsPure);
        switch (ast.type) {
          case AST.Program:
            allConstants = !0, forEach(ast.body, function(expr) {
                findConstantAndWatchExpressions(expr.expression, $filter, astIsPure), allConstants = allConstants && expr.expression.constant;
            }), ast.constant = allConstants;
            break;

          case AST.Literal:
            ast.constant = !0, ast.toWatch = [];
            break;

          case AST.UnaryExpression:
            findConstantAndWatchExpressions(ast.argument, $filter, astIsPure), ast.constant = ast.argument.constant, 
            ast.toWatch = ast.argument.toWatch;
            break;

          case AST.BinaryExpression:
            findConstantAndWatchExpressions(ast.left, $filter, astIsPure), findConstantAndWatchExpressions(ast.right, $filter, astIsPure), 
            ast.constant = ast.left.constant && ast.right.constant, ast.toWatch = ast.left.toWatch.concat(ast.right.toWatch);
            break;

          case AST.LogicalExpression:
            findConstantAndWatchExpressions(ast.left, $filter, astIsPure), findConstantAndWatchExpressions(ast.right, $filter, astIsPure), 
            ast.constant = ast.left.constant && ast.right.constant, ast.toWatch = ast.constant ? [] : [ ast ];
            break;

          case AST.ConditionalExpression:
            findConstantAndWatchExpressions(ast.test, $filter, astIsPure), findConstantAndWatchExpressions(ast.alternate, $filter, astIsPure), 
            findConstantAndWatchExpressions(ast.consequent, $filter, astIsPure), ast.constant = ast.test.constant && ast.alternate.constant && ast.consequent.constant, 
            ast.toWatch = ast.constant ? [] : [ ast ];
            break;

          case AST.Identifier:
            ast.constant = !1, ast.toWatch = [ ast ];
            break;

          case AST.MemberExpression:
            findConstantAndWatchExpressions(ast.object, $filter, astIsPure), ast.computed && findConstantAndWatchExpressions(ast.property, $filter, astIsPure), 
            ast.constant = ast.object.constant && (!ast.computed || ast.property.constant), 
            ast.toWatch = ast.constant ? [] : [ ast ];
            break;

          case AST.CallExpression:
            isStatelessFilter = ast.filter ? isStateless($filter, ast.callee.name) : !1, allConstants = isStatelessFilter, 
            argsToWatch = [], forEach(ast.arguments, function(expr) {
                findConstantAndWatchExpressions(expr, $filter, astIsPure), allConstants = allConstants && expr.constant, 
                argsToWatch.push.apply(argsToWatch, expr.toWatch);
            }), ast.constant = allConstants, ast.toWatch = isStatelessFilter ? argsToWatch : [ ast ];
            break;

          case AST.AssignmentExpression:
            findConstantAndWatchExpressions(ast.left, $filter, astIsPure), findConstantAndWatchExpressions(ast.right, $filter, astIsPure), 
            ast.constant = ast.left.constant && ast.right.constant, ast.toWatch = [ ast ];
            break;

          case AST.ArrayExpression:
            allConstants = !0, argsToWatch = [], forEach(ast.elements, function(expr) {
                findConstantAndWatchExpressions(expr, $filter, astIsPure), allConstants = allConstants && expr.constant, 
                argsToWatch.push.apply(argsToWatch, expr.toWatch);
            }), ast.constant = allConstants, ast.toWatch = argsToWatch;
            break;

          case AST.ObjectExpression:
            allConstants = !0, argsToWatch = [], forEach(ast.properties, function(property) {
                findConstantAndWatchExpressions(property.value, $filter, astIsPure), allConstants = allConstants && property.value.constant, 
                argsToWatch.push.apply(argsToWatch, property.value.toWatch), property.computed && (findConstantAndWatchExpressions(property.key, $filter, !1), 
                allConstants = allConstants && property.key.constant, argsToWatch.push.apply(argsToWatch, property.key.toWatch));
            }), ast.constant = allConstants, ast.toWatch = argsToWatch;
            break;

          case AST.ThisExpression:
            ast.constant = !1, ast.toWatch = [];
            break;

          case AST.LocalsExpression:
            ast.constant = !1, ast.toWatch = [];
        }
    }
    function getInputs(body) {
        if (1 === body.length) {
            var lastExpression = body[0].expression, candidate = lastExpression.toWatch;
            return 1 !== candidate.length ? candidate : candidate[0] !== lastExpression ? candidate : void 0;
        }
    }
    function isAssignable(ast) {
        return ast.type === AST.Identifier || ast.type === AST.MemberExpression;
    }
    function assignableAST(ast) {
        return 1 === ast.body.length && isAssignable(ast.body[0].expression) ? {
            type: AST.AssignmentExpression,
            left: ast.body[0].expression,
            right: {
                type: AST.NGValueParameter
            },
            operator: "="
        } : void 0;
    }
    function isLiteral(ast) {
        return 0 === ast.body.length || 1 === ast.body.length && (ast.body[0].expression.type === AST.Literal || ast.body[0].expression.type === AST.ArrayExpression || ast.body[0].expression.type === AST.ObjectExpression);
    }
    function isConstant(ast) {
        return ast.constant;
    }
    function ASTCompiler($filter) {
        this.$filter = $filter;
    }
    function ASTInterpreter($filter) {
        this.$filter = $filter;
    }
    function Parser(lexer, $filter, options) {
        this.ast = new AST(lexer, options), this.astCompiler = options.csp ? new ASTInterpreter($filter) : new ASTCompiler($filter);
    }
    function getValueOf(value) {
        return isFunction(value.valueOf) ? value.valueOf() : objectValueOf.call(value);
    }
    function $ParseProvider() {
        var identStart, identContinue, cache = createMap(), literals = {
            "true": !0,
            "false": !1,
            "null": null,
            undefined: void 0
        };
        this.addLiteral = function(literalName, literalValue) {
            literals[literalName] = literalValue;
        }, this.setIdentifierFns = function(identifierStart, identifierContinue) {
            return identStart = identifierStart, identContinue = identifierContinue, this;
        }, this.$get = [ "$filter", function($filter) {
            function $parse(exp, interceptorFn) {
                var parsedExpression, cacheKey;
                switch (typeof exp) {
                  case "string":
                    if (exp = exp.trim(), cacheKey = exp, parsedExpression = cache[cacheKey], !parsedExpression) {
                        var lexer = new Lexer($parseOptions), parser = new Parser(lexer, $filter, $parseOptions);
                        parsedExpression = parser.parse(exp), cache[cacheKey] = addWatchDelegate(parsedExpression);
                    }
                    return addInterceptor(parsedExpression, interceptorFn);

                  case "function":
                    return addInterceptor(exp, interceptorFn);

                  default:
                    return addInterceptor(noop, interceptorFn);
                }
            }
            function $$getAst(exp) {
                var lexer = new Lexer($parseOptions), parser = new Parser(lexer, $filter, $parseOptions);
                return parser.getAst(exp).ast;
            }
            function expressionInputDirtyCheck(newValue, oldValueOfValue, compareObjectIdentity) {
                return null == newValue || null == oldValueOfValue ? newValue === oldValueOfValue : "object" != typeof newValue || (newValue = getValueOf(newValue), 
                "object" != typeof newValue || compareObjectIdentity) ? newValue === oldValueOfValue || newValue !== newValue && oldValueOfValue !== oldValueOfValue : !1;
            }
            function inputsWatchDelegate(scope, listener, objectEquality, parsedExpression, prettyPrintExpression) {
                var lastResult, inputExpressions = parsedExpression.inputs;
                if (1 === inputExpressions.length) {
                    var oldInputValueOf = expressionInputDirtyCheck;
                    return inputExpressions = inputExpressions[0], scope.$watch(function(scope) {
                        var newInputValue = inputExpressions(scope);
                        return expressionInputDirtyCheck(newInputValue, oldInputValueOf, inputExpressions.isPure) || (lastResult = parsedExpression(scope, void 0, void 0, [ newInputValue ]), 
                        oldInputValueOf = newInputValue && getValueOf(newInputValue)), lastResult;
                    }, listener, objectEquality, prettyPrintExpression);
                }
                for (var oldInputValueOfValues = [], oldInputValues = [], i = 0, ii = inputExpressions.length; ii > i; i++) oldInputValueOfValues[i] = expressionInputDirtyCheck, 
                oldInputValues[i] = null;
                return scope.$watch(function(scope) {
                    for (var changed = !1, i = 0, ii = inputExpressions.length; ii > i; i++) {
                        var newInputValue = inputExpressions[i](scope);
                        (changed || (changed = !expressionInputDirtyCheck(newInputValue, oldInputValueOfValues[i], inputExpressions[i].isPure))) && (oldInputValues[i] = newInputValue, 
                        oldInputValueOfValues[i] = newInputValue && getValueOf(newInputValue));
                    }
                    return changed && (lastResult = parsedExpression(scope, void 0, void 0, oldInputValues)), 
                    lastResult;
                }, listener, objectEquality, prettyPrintExpression);
            }
            function oneTimeWatchDelegate(scope, listener, objectEquality, parsedExpression, prettyPrintExpression) {
                function unwatchIfDone() {
                    isDone(lastValue) && unwatch();
                }
                function oneTimeWatch(scope, locals, assign, inputs) {
                    return lastValue = useInputs && inputs ? inputs[0] : exp(scope, locals, assign, inputs), 
                    isDone(lastValue) && scope.$$postDigest(unwatchIfDone), post(lastValue);
                }
                var unwatch, lastValue, isDone = parsedExpression.literal ? isAllDefined : isDefined, exp = parsedExpression.$$intercepted || parsedExpression, post = parsedExpression.$$interceptor || identity, useInputs = parsedExpression.inputs && !exp.inputs;
                return oneTimeWatch.literal = parsedExpression.literal, oneTimeWatch.constant = parsedExpression.constant, 
                oneTimeWatch.inputs = parsedExpression.inputs, addWatchDelegate(oneTimeWatch), unwatch = scope.$watch(oneTimeWatch, listener, objectEquality, prettyPrintExpression);
            }
            function isAllDefined(value) {
                var allDefined = !0;
                return forEach(value, function(val) {
                    isDefined(val) || (allDefined = !1);
                }), allDefined;
            }
            function constantWatchDelegate(scope, listener, objectEquality, parsedExpression) {
                var unwatch = scope.$watch(function(scope) {
                    return unwatch(), parsedExpression(scope);
                }, listener, objectEquality);
                return unwatch;
            }
            function addWatchDelegate(parsedExpression) {
                return parsedExpression.constant ? parsedExpression.$$watchDelegate = constantWatchDelegate : parsedExpression.oneTime ? parsedExpression.$$watchDelegate = oneTimeWatchDelegate : parsedExpression.inputs && (parsedExpression.$$watchDelegate = inputsWatchDelegate), 
                parsedExpression;
            }
            function chainInterceptors(first, second) {
                function chainedInterceptor(value) {
                    return second(first(value));
                }
                return chainedInterceptor.$stateful = first.$stateful || second.$stateful, chainedInterceptor.$$pure = first.$$pure && second.$$pure, 
                chainedInterceptor;
            }
            function addInterceptor(parsedExpression, interceptorFn) {
                if (!interceptorFn) return parsedExpression;
                parsedExpression.$$interceptor && (interceptorFn = chainInterceptors(parsedExpression.$$interceptor, interceptorFn), 
                parsedExpression = parsedExpression.$$intercepted);
                var useInputs = !1, fn = function(scope, locals, assign, inputs) {
                    var value = useInputs && inputs ? inputs[0] : parsedExpression(scope, locals, assign, inputs);
                    return interceptorFn(value);
                };
                return fn.$$intercepted = parsedExpression, fn.$$interceptor = interceptorFn, fn.literal = parsedExpression.literal, 
                fn.oneTime = parsedExpression.oneTime, fn.constant = parsedExpression.constant, 
                interceptorFn.$stateful || (useInputs = !parsedExpression.inputs, fn.inputs = parsedExpression.inputs ? parsedExpression.inputs : [ parsedExpression ], 
                interceptorFn.$$pure || (fn.inputs = fn.inputs.map(function(e) {
                    return e.isPure === PURITY_RELATIVE ? function(s) {
                        return e(s);
                    } : e;
                }))), addWatchDelegate(fn);
            }
            var noUnsafeEval = csp().noUnsafeEval, $parseOptions = {
                csp: noUnsafeEval,
                literals: copy(literals),
                isIdentifierStart: isFunction(identStart) && identStart,
                isIdentifierContinue: isFunction(identContinue) && identContinue
            };
            return $parse.$$getAst = $$getAst, $parse;
        } ];
    }
    function $QProvider() {
        var errorOnUnhandledRejections = !0;
        this.$get = [ "$rootScope", "$exceptionHandler", function($rootScope, $exceptionHandler) {
            return qFactory(function(callback) {
                $rootScope.$evalAsync(callback);
            }, $exceptionHandler, errorOnUnhandledRejections);
        } ], this.errorOnUnhandledRejections = function(value) {
            return isDefined(value) ? (errorOnUnhandledRejections = value, this) : errorOnUnhandledRejections;
        };
    }
    function $$QProvider() {
        var errorOnUnhandledRejections = !0;
        this.$get = [ "$browser", "$exceptionHandler", function($browser, $exceptionHandler) {
            return qFactory(function(callback) {
                $browser.defer(callback);
            }, $exceptionHandler, errorOnUnhandledRejections);
        } ], this.errorOnUnhandledRejections = function(value) {
            return isDefined(value) ? (errorOnUnhandledRejections = value, this) : errorOnUnhandledRejections;
        };
    }
    function qFactory(nextTick, exceptionHandler, errorOnUnhandledRejections) {
        function defer() {
            return new Deferred();
        }
        function Deferred() {
            var promise = this.promise = new Promise();
            this.resolve = function(val) {
                resolvePromise(promise, val);
            }, this.reject = function(reason) {
                rejectPromise(promise, reason);
            }, this.notify = function(progress) {
                notifyPromise(promise, progress);
            };
        }
        function Promise() {
            this.$$state = {
                status: 0
            };
        }
        function processQueue(state) {
            var fn, promise, pending;
            pending = state.pending, state.processScheduled = !1, state.pending = void 0;
            try {
                for (var i = 0, ii = pending.length; ii > i; ++i) {
                    markQStateExceptionHandled(state), promise = pending[i][0], fn = pending[i][state.status];
                    try {
                        isFunction(fn) ? resolvePromise(promise, fn(state.value)) : 1 === state.status ? resolvePromise(promise, state.value) : rejectPromise(promise, state.value);
                    } catch (e) {
                        rejectPromise(promise, e), e && e.$$passToExceptionHandler === !0 && exceptionHandler(e);
                    }
                }
            } finally {
                --queueSize, errorOnUnhandledRejections && 0 === queueSize && nextTick(processChecks);
            }
        }
        function processChecks() {
            for (;!queueSize && checkQueue.length; ) {
                var toCheck = checkQueue.shift();
                if (!isStateExceptionHandled(toCheck)) {
                    markQStateExceptionHandled(toCheck);
                    var errorMessage = "Possibly unhandled rejection: " + toDebugString(toCheck.value);
                    isError(toCheck.value) ? exceptionHandler(toCheck.value, errorMessage) : exceptionHandler(errorMessage);
                }
            }
        }
        function scheduleProcessQueue(state) {
            !errorOnUnhandledRejections || state.pending || 2 !== state.status || isStateExceptionHandled(state) || (0 === queueSize && 0 === checkQueue.length && nextTick(processChecks), 
            checkQueue.push(state)), !state.processScheduled && state.pending && (state.processScheduled = !0, 
            ++queueSize, nextTick(function() {
                processQueue(state);
            }));
        }
        function resolvePromise(promise, val) {
            promise.$$state.status || (val === promise ? $$reject(promise, $qMinErr("qcycle", "Expected promise to be resolved with value other than itself '{0}'", val)) : $$resolve(promise, val));
        }
        function $$resolve(promise, val) {
            function doResolve(val) {
                done || (done = !0, $$resolve(promise, val));
            }
            function doReject(val) {
                done || (done = !0, $$reject(promise, val));
            }
            function doNotify(progress) {
                notifyPromise(promise, progress);
            }
            var then, done = !1;
            try {
                (isObject(val) || isFunction(val)) && (then = val.then), isFunction(then) ? (promise.$$state.status = -1, 
                then.call(val, doResolve, doReject, doNotify)) : (promise.$$state.value = val, promise.$$state.status = 1, 
                scheduleProcessQueue(promise.$$state));
            } catch (e) {
                doReject(e);
            }
        }
        function rejectPromise(promise, reason) {
            promise.$$state.status || $$reject(promise, reason);
        }
        function $$reject(promise, reason) {
            promise.$$state.value = reason, promise.$$state.status = 2, scheduleProcessQueue(promise.$$state);
        }
        function notifyPromise(promise, progress) {
            var callbacks = promise.$$state.pending;
            promise.$$state.status <= 0 && callbacks && callbacks.length && nextTick(function() {
                for (var callback, result, i = 0, ii = callbacks.length; ii > i; i++) {
                    result = callbacks[i][0], callback = callbacks[i][3];
                    try {
                        notifyPromise(result, isFunction(callback) ? callback(progress) : progress);
                    } catch (e) {
                        exceptionHandler(e);
                    }
                }
            });
        }
        function reject(reason) {
            var result = new Promise();
            return rejectPromise(result, reason), result;
        }
        function handleCallback(value, resolver, callback) {
            var callbackOutput = null;
            try {
                isFunction(callback) && (callbackOutput = callback());
            } catch (e) {
                return reject(e);
            }
            return isPromiseLike(callbackOutput) ? callbackOutput.then(function() {
                return resolver(value);
            }, reject) : resolver(value);
        }
        function when(value, callback, errback, progressBack) {
            var result = new Promise();
            return resolvePromise(result, value), result.then(callback, errback, progressBack);
        }
        function all(promises) {
            var result = new Promise(), counter = 0, results = isArray(promises) ? [] : {};
            return forEach(promises, function(promise, key) {
                counter++, when(promise).then(function(value) {
                    results[key] = value, --counter || resolvePromise(result, results);
                }, function(reason) {
                    rejectPromise(result, reason);
                });
            }), 0 === counter && resolvePromise(result, results), result;
        }
        function race(promises) {
            var deferred = defer();
            return forEach(promises, function(promise) {
                when(promise).then(deferred.resolve, deferred.reject);
            }), deferred.promise;
        }
        function $Q(resolver) {
            function resolveFn(value) {
                resolvePromise(promise, value);
            }
            function rejectFn(reason) {
                rejectPromise(promise, reason);
            }
            if (!isFunction(resolver)) throw $qMinErr("norslvr", "Expected resolverFn, got '{0}'", resolver);
            var promise = new Promise();
            return resolver(resolveFn, rejectFn), promise;
        }
        var $qMinErr = minErr("$q", TypeError), queueSize = 0, checkQueue = [];
        extend(Promise.prototype, {
            then: function(onFulfilled, onRejected, progressBack) {
                if (isUndefined(onFulfilled) && isUndefined(onRejected) && isUndefined(progressBack)) return this;
                var result = new Promise();
                return this.$$state.pending = this.$$state.pending || [], this.$$state.pending.push([ result, onFulfilled, onRejected, progressBack ]), 
                this.$$state.status > 0 && scheduleProcessQueue(this.$$state), result;
            },
            "catch": function(callback) {
                return this.then(null, callback);
            },
            "finally": function(callback, progressBack) {
                return this.then(function(value) {
                    return handleCallback(value, resolve, callback);
                }, function(error) {
                    return handleCallback(error, reject, callback);
                }, progressBack);
            }
        });
        var resolve = when;
        return $Q.prototype = Promise.prototype, $Q.defer = defer, $Q.reject = reject, $Q.when = when, 
        $Q.resolve = resolve, $Q.all = all, $Q.race = race, $Q;
    }
    function isStateExceptionHandled(state) {
        return !!state.pur;
    }
    function markQStateExceptionHandled(state) {
        state.pur = !0;
    }
    function markQExceptionHandled(q) {
        markQStateExceptionHandled(q.$$state);
    }
    function $$RAFProvider() {
        this.$get = [ "$window", "$timeout", function($window, $timeout) {
            var requestAnimationFrame = $window.requestAnimationFrame || $window.webkitRequestAnimationFrame, cancelAnimationFrame = $window.cancelAnimationFrame || $window.webkitCancelAnimationFrame || $window.webkitCancelRequestAnimationFrame, rafSupported = !!requestAnimationFrame, raf = rafSupported ? function(fn) {
                var id = requestAnimationFrame(fn);
                return function() {
                    cancelAnimationFrame(id);
                };
            } : function(fn) {
                var timer = $timeout(fn, 16.66, !1);
                return function() {
                    $timeout.cancel(timer);
                };
            };
            return raf.supported = rafSupported, raf;
        } ];
    }
    function $RootScopeProvider() {
        function createChildScopeClass(parent) {
            function ChildScope() {
                this.$$watchers = this.$$nextSibling = this.$$childHead = this.$$childTail = null, 
                this.$$listeners = {}, this.$$listenerCount = {}, this.$$watchersCount = 0, this.$id = nextUid(), 
                this.$$ChildScope = null, this.$$suspended = !1;
            }
            return ChildScope.prototype = parent, ChildScope;
        }
        var TTL = 10, $rootScopeMinErr = minErr("$rootScope"), lastDirtyWatch = null, applyAsyncId = null;
        this.digestTtl = function(value) {
            return arguments.length && (TTL = value), TTL;
        }, this.$get = [ "$exceptionHandler", "$parse", "$browser", function($exceptionHandler, $parse, $browser) {
            function destroyChildScope($event) {
                $event.currentScope.$$destroyed = !0;
            }
            function cleanUpScope($scope) {
                9 === msie && ($scope.$$childHead && cleanUpScope($scope.$$childHead), $scope.$$nextSibling && cleanUpScope($scope.$$nextSibling)), 
                $scope.$parent = $scope.$$nextSibling = $scope.$$prevSibling = $scope.$$childHead = $scope.$$childTail = $scope.$root = $scope.$$watchers = null;
            }
            function Scope() {
                this.$id = nextUid(), this.$$phase = this.$parent = this.$$watchers = this.$$nextSibling = this.$$prevSibling = this.$$childHead = this.$$childTail = null, 
                this.$root = this, this.$$destroyed = !1, this.$$suspended = !1, this.$$listeners = {}, 
                this.$$listenerCount = {}, this.$$watchersCount = 0, this.$$isolateBindings = null;
            }
            function beginPhase(phase) {
                if ($rootScope.$$phase) throw $rootScopeMinErr("inprog", "{0} already in progress", $rootScope.$$phase);
                $rootScope.$$phase = phase;
            }
            function clearPhase() {
                $rootScope.$$phase = null;
            }
            function incrementWatchersCount(current, count) {
                do current.$$watchersCount += count; while (current = current.$parent);
            }
            function decrementListenerCount(current, count, name) {
                do current.$$listenerCount[name] -= count, 0 === current.$$listenerCount[name] && delete current.$$listenerCount[name]; while (current = current.$parent);
            }
            function initWatchVal() {}
            function flushApplyAsync() {
                for (;applyAsyncQueue.length; ) try {
                    applyAsyncQueue.shift()();
                } catch (e) {
                    $exceptionHandler(e);
                }
                applyAsyncId = null;
            }
            function scheduleApplyAsync() {
                null === applyAsyncId && (applyAsyncId = $browser.defer(function() {
                    $rootScope.$apply(flushApplyAsync);
                }));
            }
            Scope.prototype = {
                constructor: Scope,
                $new: function(isolate, parent) {
                    var child;
                    return parent = parent || this, isolate ? (child = new Scope(), child.$root = this.$root) : (this.$$ChildScope || (this.$$ChildScope = createChildScopeClass(this)), 
                    child = new this.$$ChildScope()), child.$parent = parent, child.$$prevSibling = parent.$$childTail, 
                    parent.$$childHead ? (parent.$$childTail.$$nextSibling = child, parent.$$childTail = child) : parent.$$childHead = parent.$$childTail = child, 
                    (isolate || parent !== this) && child.$on("$destroy", destroyChildScope), child;
                },
                $watch: function(watchExp, listener, objectEquality, prettyPrintExpression) {
                    var get = $parse(watchExp), fn = isFunction(listener) ? listener : noop;
                    if (get.$$watchDelegate) return get.$$watchDelegate(this, fn, objectEquality, get, watchExp);
                    var scope = this, array = scope.$$watchers, watcher = {
                        fn: fn,
                        last: initWatchVal,
                        get: get,
                        exp: prettyPrintExpression || watchExp,
                        eq: !!objectEquality
                    };
                    return lastDirtyWatch = null, array || (array = scope.$$watchers = [], array.$$digestWatchIndex = -1), 
                    array.unshift(watcher), array.$$digestWatchIndex++, incrementWatchersCount(this, 1), 
                    function() {
                        var index = arrayRemove(array, watcher);
                        index >= 0 && (incrementWatchersCount(scope, -1), index < array.$$digestWatchIndex && array.$$digestWatchIndex--), 
                        lastDirtyWatch = null;
                    };
                },
                $watchGroup: function(watchExpressions, listener) {
                    function watchGroupAction() {
                        changeReactionScheduled = !1;
                        try {
                            firstRun ? (firstRun = !1, listener(newValues, newValues, self)) : listener(newValues, oldValues, self);
                        } finally {
                            for (var i = 0; i < watchExpressions.length; i++) oldValues[i] = newValues[i];
                        }
                    }
                    var oldValues = new Array(watchExpressions.length), newValues = new Array(watchExpressions.length), deregisterFns = [], self = this, changeReactionScheduled = !1, firstRun = !0;
                    if (!watchExpressions.length) {
                        var shouldCall = !0;
                        return self.$evalAsync(function() {
                            shouldCall && listener(newValues, newValues, self);
                        }), function() {
                            shouldCall = !1;
                        };
                    }
                    return 1 === watchExpressions.length ? this.$watch(watchExpressions[0], function(value, oldValue, scope) {
                        newValues[0] = value, oldValues[0] = oldValue, listener(newValues, value === oldValue ? newValues : oldValues, scope);
                    }) : (forEach(watchExpressions, function(expr, i) {
                        var unwatchFn = self.$watch(expr, function(value) {
                            newValues[i] = value, changeReactionScheduled || (changeReactionScheduled = !0, 
                            self.$evalAsync(watchGroupAction));
                        });
                        deregisterFns.push(unwatchFn);
                    }), function() {
                        for (;deregisterFns.length; ) deregisterFns.shift()();
                    });
                },
                $watchCollection: function(obj, listener) {
                    function $watchCollectionInterceptor(_value) {
                        newValue = _value;
                        var newLength, key, bothNaN, newItem, oldItem;
                        if (!isUndefined(newValue)) {
                            if (isObject(newValue)) if (isArrayLike(newValue)) {
                                oldValue !== internalArray && (oldValue = internalArray, oldLength = oldValue.length = 0, 
                                changeDetected++), newLength = newValue.length, oldLength !== newLength && (changeDetected++, 
                                oldValue.length = oldLength = newLength);
                                for (var i = 0; newLength > i; i++) oldItem = oldValue[i], newItem = newValue[i], 
                                bothNaN = oldItem !== oldItem && newItem !== newItem, bothNaN || oldItem === newItem || (changeDetected++, 
                                oldValue[i] = newItem);
                            } else {
                                oldValue !== internalObject && (oldValue = internalObject = {}, oldLength = 0, changeDetected++), 
                                newLength = 0;
                                for (key in newValue) hasOwnProperty.call(newValue, key) && (newLength++, newItem = newValue[key], 
                                oldItem = oldValue[key], key in oldValue ? (bothNaN = oldItem !== oldItem && newItem !== newItem, 
                                bothNaN || oldItem === newItem || (changeDetected++, oldValue[key] = newItem)) : (oldLength++, 
                                oldValue[key] = newItem, changeDetected++));
                                if (oldLength > newLength) {
                                    changeDetected++;
                                    for (key in oldValue) hasOwnProperty.call(newValue, key) || (oldLength--, delete oldValue[key]);
                                }
                            } else oldValue !== newValue && (oldValue = newValue, changeDetected++);
                            return changeDetected;
                        }
                    }
                    function $watchCollectionAction() {
                        if (initRun ? (initRun = !1, listener(newValue, newValue, self)) : listener(newValue, veryOldValue, self), 
                        trackVeryOldValue) if (isObject(newValue)) if (isArrayLike(newValue)) {
                            veryOldValue = new Array(newValue.length);
                            for (var i = 0; i < newValue.length; i++) veryOldValue[i] = newValue[i];
                        } else {
                            veryOldValue = {};
                            for (var key in newValue) hasOwnProperty.call(newValue, key) && (veryOldValue[key] = newValue[key]);
                        } else veryOldValue = newValue;
                    }
                    $watchCollectionInterceptor.$$pure = $parse(obj).literal, $watchCollectionInterceptor.$stateful = !$watchCollectionInterceptor.$$pure;
                    var newValue, oldValue, veryOldValue, self = this, trackVeryOldValue = listener.length > 1, changeDetected = 0, changeDetector = $parse(obj, $watchCollectionInterceptor), internalArray = [], internalObject = {}, initRun = !0, oldLength = 0;
                    return this.$watch(changeDetector, $watchCollectionAction);
                },
                $digest: function() {
                    var watch, value, last, fn, get, watchers, dirty, next, current, logIdx, asyncTask, ttl = TTL, target = asyncQueue.length ? $rootScope : this, watchLog = [];
                    beginPhase("$digest"), $browser.$$checkUrlChange(), this === $rootScope && null !== applyAsyncId && ($browser.defer.cancel(applyAsyncId), 
                    flushApplyAsync()), lastDirtyWatch = null;
                    do {
                        dirty = !1, current = target;
                        for (var asyncQueuePosition = 0; asyncQueuePosition < asyncQueue.length; asyncQueuePosition++) {
                            try {
                                asyncTask = asyncQueue[asyncQueuePosition], fn = asyncTask.fn, fn(asyncTask.scope, asyncTask.locals);
                            } catch (e) {
                                $exceptionHandler(e);
                            }
                            lastDirtyWatch = null;
                        }
                        asyncQueue.length = 0;
                        traverseScopesLoop: do {
                            if (watchers = !current.$$suspended && current.$$watchers) for (watchers.$$digestWatchIndex = watchers.length; watchers.$$digestWatchIndex--; ) try {
                                if (watch = watchers[watchers.$$digestWatchIndex]) if (get = watch.get, (value = get(current)) === (last = watch.last) || (watch.eq ? equals(value, last) : isNumberNaN(value) && isNumberNaN(last))) {
                                    if (watch === lastDirtyWatch) {
                                        dirty = !1;
                                        break traverseScopesLoop;
                                    }
                                } else dirty = !0, lastDirtyWatch = watch, watch.last = watch.eq ? copy(value, null) : value, 
                                fn = watch.fn, fn(value, last === initWatchVal ? value : last, current), 5 > ttl && (logIdx = 4 - ttl, 
                                watchLog[logIdx] || (watchLog[logIdx] = []), watchLog[logIdx].push({
                                    msg: isFunction(watch.exp) ? "fn: " + (watch.exp.name || watch.exp.toString()) : watch.exp,
                                    newVal: value,
                                    oldVal: last
                                }));
                            } catch (e) {
                                $exceptionHandler(e);
                            }
                            if (!(next = !current.$$suspended && current.$$watchersCount && current.$$childHead || current !== target && current.$$nextSibling)) for (;current !== target && !(next = current.$$nextSibling); ) current = current.$parent;
                        } while (current = next);
                        if ((dirty || asyncQueue.length) && !ttl--) throw clearPhase(), $rootScopeMinErr("infdig", "{0} $digest() iterations reached. Aborting!\nWatchers fired in the last 5 iterations: {1}", TTL, watchLog);
                    } while (dirty || asyncQueue.length);
                    for (clearPhase(); postDigestQueuePosition < postDigestQueue.length; ) try {
                        postDigestQueue[postDigestQueuePosition++]();
                    } catch (e) {
                        $exceptionHandler(e);
                    }
                    postDigestQueue.length = postDigestQueuePosition = 0, $browser.$$checkUrlChange();
                },
                $suspend: function() {
                    this.$$suspended = !0;
                },
                $isSuspended: function() {
                    return this.$$suspended;
                },
                $resume: function() {
                    this.$$suspended = !1;
                },
                $destroy: function() {
                    if (!this.$$destroyed) {
                        var parent = this.$parent;
                        this.$broadcast("$destroy"), this.$$destroyed = !0, this === $rootScope && $browser.$$applicationDestroyed(), 
                        incrementWatchersCount(this, -this.$$watchersCount);
                        for (var eventName in this.$$listenerCount) decrementListenerCount(this, this.$$listenerCount[eventName], eventName);
                        parent && parent.$$childHead === this && (parent.$$childHead = this.$$nextSibling), 
                        parent && parent.$$childTail === this && (parent.$$childTail = this.$$prevSibling), 
                        this.$$prevSibling && (this.$$prevSibling.$$nextSibling = this.$$nextSibling), this.$$nextSibling && (this.$$nextSibling.$$prevSibling = this.$$prevSibling), 
                        this.$destroy = this.$digest = this.$apply = this.$evalAsync = this.$applyAsync = noop, 
                        this.$on = this.$watch = this.$watchGroup = function() {
                            return noop;
                        }, this.$$listeners = {}, this.$$nextSibling = null, cleanUpScope(this);
                    }
                },
                $eval: function(expr, locals) {
                    return $parse(expr)(this, locals);
                },
                $evalAsync: function(expr, locals) {
                    $rootScope.$$phase || asyncQueue.length || $browser.defer(function() {
                        asyncQueue.length && $rootScope.$digest();
                    }), asyncQueue.push({
                        scope: this,
                        fn: $parse(expr),
                        locals: locals
                    });
                },
                $$postDigest: function(fn) {
                    postDigestQueue.push(fn);
                },
                $apply: function(expr) {
                    try {
                        beginPhase("$apply");
                        try {
                            return this.$eval(expr);
                        } finally {
                            clearPhase();
                        }
                    } catch (e) {
                        $exceptionHandler(e);
                    } finally {
                        try {
                            $rootScope.$digest();
                        } catch (e) {
                            throw $exceptionHandler(e), e;
                        }
                    }
                },
                $applyAsync: function(expr) {
                    function $applyAsyncExpression() {
                        scope.$eval(expr);
                    }
                    var scope = this;
                    expr && applyAsyncQueue.push($applyAsyncExpression), expr = $parse(expr), scheduleApplyAsync();
                },
                $on: function(name, listener) {
                    var namedListeners = this.$$listeners[name];
                    namedListeners || (this.$$listeners[name] = namedListeners = []), namedListeners.push(listener);
                    var current = this;
                    do current.$$listenerCount[name] || (current.$$listenerCount[name] = 0), current.$$listenerCount[name]++; while (current = current.$parent);
                    var self = this;
                    return function() {
                        var indexOfListener = namedListeners.indexOf(listener);
                        -1 !== indexOfListener && (delete namedListeners[indexOfListener], decrementListenerCount(self, 1, name));
                    };
                },
                $emit: function(name) {
                    var namedListeners, i, length, empty = [], scope = this, stopPropagation = !1, event = {
                        name: name,
                        targetScope: scope,
                        stopPropagation: function() {
                            stopPropagation = !0;
                        },
                        preventDefault: function() {
                            event.defaultPrevented = !0;
                        },
                        defaultPrevented: !1
                    }, listenerArgs = concat([ event ], arguments, 1);
                    do {
                        for (namedListeners = scope.$$listeners[name] || empty, event.currentScope = scope, 
                        i = 0, length = namedListeners.length; length > i; i++) if (namedListeners[i]) try {
                            namedListeners[i].apply(null, listenerArgs);
                        } catch (e) {
                            $exceptionHandler(e);
                        } else namedListeners.splice(i, 1), i--, length--;
                        if (stopPropagation) break;
                        scope = scope.$parent;
                    } while (scope);
                    return event.currentScope = null, event;
                },
                $broadcast: function(name) {
                    var target = this, current = target, next = target, event = {
                        name: name,
                        targetScope: target,
                        preventDefault: function() {
                            event.defaultPrevented = !0;
                        },
                        defaultPrevented: !1
                    };
                    if (!target.$$listenerCount[name]) return event;
                    for (var listeners, i, length, listenerArgs = concat([ event ], arguments, 1); current = next; ) {
                        for (event.currentScope = current, listeners = current.$$listeners[name] || [], 
                        i = 0, length = listeners.length; length > i; i++) if (listeners[i]) try {
                            listeners[i].apply(null, listenerArgs);
                        } catch (e) {
                            $exceptionHandler(e);
                        } else listeners.splice(i, 1), i--, length--;
                        if (!(next = current.$$listenerCount[name] && current.$$childHead || current !== target && current.$$nextSibling)) for (;current !== target && !(next = current.$$nextSibling); ) current = current.$parent;
                    }
                    return event.currentScope = null, event;
                }
            };
            var $rootScope = new Scope(), asyncQueue = $rootScope.$$asyncQueue = [], postDigestQueue = $rootScope.$$postDigestQueue = [], applyAsyncQueue = $rootScope.$$applyAsyncQueue = [], postDigestQueuePosition = 0;
            return $rootScope;
        } ];
    }
    function $$SanitizeUriProvider() {
        var aHrefSanitizationWhitelist = /^\s*(https?|s?ftp|mailto|tel|file):/, imgSrcSanitizationWhitelist = /^\s*((https?|ftp|file|blob):|data:image\/)/;
        this.aHrefSanitizationWhitelist = function(regexp) {
            return isDefined(regexp) ? (aHrefSanitizationWhitelist = regexp, this) : aHrefSanitizationWhitelist;
        }, this.imgSrcSanitizationWhitelist = function(regexp) {
            return isDefined(regexp) ? (imgSrcSanitizationWhitelist = regexp, this) : imgSrcSanitizationWhitelist;
        }, this.$get = function() {
            return function(uri, isMediaUrl) {
                var regex = isMediaUrl ? imgSrcSanitizationWhitelist : aHrefSanitizationWhitelist, normalizedVal = urlResolve(uri && uri.trim()).href;
                return "" === normalizedVal || normalizedVal.match(regex) ? uri : "unsafe:" + normalizedVal;
            };
        };
    }
    function snakeToCamel(name) {
        return name.replace(UNDERSCORE_LOWERCASE_REGEXP, fnCamelCaseReplace);
    }
    function adjustMatcher(matcher) {
        if ("self" === matcher) return matcher;
        if (isString(matcher)) {
            if (matcher.indexOf("***") > -1) throw $sceMinErr("iwcard", "Illegal sequence *** in string matcher.  String: {0}", matcher);
            return matcher = escapeForRegexp(matcher).replace(/\\\*\\\*/g, ".*").replace(/\\\*/g, "[^:/.?&;]*"), 
            new RegExp("^" + matcher + "$");
        }
        if (isRegExp(matcher)) return new RegExp("^" + matcher.source + "$");
        throw $sceMinErr("imatcher", 'Matchers may only be "self", string patterns or RegExp objects');
    }
    function adjustMatchers(matchers) {
        var adjustedMatchers = [];
        return isDefined(matchers) && forEach(matchers, function(matcher) {
            adjustedMatchers.push(adjustMatcher(matcher));
        }), adjustedMatchers;
    }
    function $SceDelegateProvider() {
        this.SCE_CONTEXTS = SCE_CONTEXTS;
        var resourceUrlWhitelist = [ "self" ], resourceUrlBlacklist = [];
        this.resourceUrlWhitelist = function(value) {
            return arguments.length && (resourceUrlWhitelist = adjustMatchers(value)), resourceUrlWhitelist;
        }, this.resourceUrlBlacklist = function(value) {
            return arguments.length && (resourceUrlBlacklist = adjustMatchers(value)), resourceUrlBlacklist;
        }, this.$get = [ "$injector", "$$sanitizeUri", function($injector, $$sanitizeUri) {
            function matchUrl(matcher, parsedUrl) {
                return "self" === matcher ? urlIsSameOrigin(parsedUrl) || urlIsSameOriginAsBaseUrl(parsedUrl) : !!matcher.exec(parsedUrl.href);
            }
            function isResourceUrlAllowedByPolicy(url) {
                var i, n, parsedUrl = urlResolve(url.toString()), allowed = !1;
                for (i = 0, n = resourceUrlWhitelist.length; n > i; i++) if (matchUrl(resourceUrlWhitelist[i], parsedUrl)) {
                    allowed = !0;
                    break;
                }
                if (allowed) for (i = 0, n = resourceUrlBlacklist.length; n > i; i++) if (matchUrl(resourceUrlBlacklist[i], parsedUrl)) {
                    allowed = !1;
                    break;
                }
                return allowed;
            }
            function generateHolderType(Base) {
                var holderType = function(trustedValue) {
                    this.$$unwrapTrustedValue = function() {
                        return trustedValue;
                    };
                };
                return Base && (holderType.prototype = new Base()), holderType.prototype.valueOf = function() {
                    return this.$$unwrapTrustedValue();
                }, holderType.prototype.toString = function() {
                    return this.$$unwrapTrustedValue().toString();
                }, holderType;
            }
            function trustAs(type, trustedValue) {
                var Constructor = byType.hasOwnProperty(type) ? byType[type] : null;
                if (!Constructor) throw $sceMinErr("icontext", "Attempted to trust a value in invalid context. Context: {0}; Value: {1}", type, trustedValue);
                if (null === trustedValue || isUndefined(trustedValue) || "" === trustedValue) return trustedValue;
                if ("string" != typeof trustedValue) throw $sceMinErr("itype", "Attempted to trust a non-string value in a content requiring a string: Context: {0}", type);
                return new Constructor(trustedValue);
            }
            function valueOf(maybeTrusted) {
                return maybeTrusted instanceof trustedValueHolderBase ? maybeTrusted.$$unwrapTrustedValue() : maybeTrusted;
            }
            function getTrusted(type, maybeTrusted) {
                if (null === maybeTrusted || isUndefined(maybeTrusted) || "" === maybeTrusted) return maybeTrusted;
                var constructor = byType.hasOwnProperty(type) ? byType[type] : null;
                if (constructor && maybeTrusted instanceof constructor) return maybeTrusted.$$unwrapTrustedValue();
                if (isFunction(maybeTrusted.$$unwrapTrustedValue) && (maybeTrusted = maybeTrusted.$$unwrapTrustedValue()), 
                type === SCE_CONTEXTS.MEDIA_URL || type === SCE_CONTEXTS.URL) return $$sanitizeUri(maybeTrusted, type === SCE_CONTEXTS.MEDIA_URL);
                if (type === SCE_CONTEXTS.RESOURCE_URL) {
                    if (isResourceUrlAllowedByPolicy(maybeTrusted)) return maybeTrusted;
                    throw $sceMinErr("insecurl", "Blocked loading resource from url not allowed by $sceDelegate policy.  URL: {0}", maybeTrusted.toString());
                }
                if (type === SCE_CONTEXTS.HTML) return htmlSanitizer(maybeTrusted);
                throw $sceMinErr("unsafe", "Attempting to use an unsafe value in a safe context.");
            }
            var htmlSanitizer = function() {
                throw $sceMinErr("unsafe", "Attempting to use an unsafe value in a safe context.");
            };
            $injector.has("$sanitize") && (htmlSanitizer = $injector.get("$sanitize"));
            var trustedValueHolderBase = generateHolderType(), byType = {};
            return byType[SCE_CONTEXTS.HTML] = generateHolderType(trustedValueHolderBase), byType[SCE_CONTEXTS.CSS] = generateHolderType(trustedValueHolderBase), 
            byType[SCE_CONTEXTS.MEDIA_URL] = generateHolderType(trustedValueHolderBase), byType[SCE_CONTEXTS.URL] = generateHolderType(byType[SCE_CONTEXTS.MEDIA_URL]), 
            byType[SCE_CONTEXTS.JS] = generateHolderType(trustedValueHolderBase), byType[SCE_CONTEXTS.RESOURCE_URL] = generateHolderType(byType[SCE_CONTEXTS.URL]), 
            {
                trustAs: trustAs,
                getTrusted: getTrusted,
                valueOf: valueOf
            };
        } ];
    }
    function $SceProvider() {
        var enabled = !0;
        this.enabled = function(value) {
            return arguments.length && (enabled = !!value), enabled;
        }, this.$get = [ "$parse", "$sceDelegate", function($parse, $sceDelegate) {
            if (enabled && 8 > msie) throw $sceMinErr("iequirks", "Strict Contextual Escaping does not support Internet Explorer version < 11 in quirks mode.  You can fix this by adding the text <!doctype html> to the top of your HTML document.  See http://docs.angularjs.org/api/ng.$sce for more information.");
            var sce = shallowCopy(SCE_CONTEXTS);
            sce.isEnabled = function() {
                return enabled;
            }, sce.trustAs = $sceDelegate.trustAs, sce.getTrusted = $sceDelegate.getTrusted, 
            sce.valueOf = $sceDelegate.valueOf, enabled || (sce.trustAs = sce.getTrusted = function(type, value) {
                return value;
            }, sce.valueOf = identity), sce.parseAs = function(type, expr) {
                var parsed = $parse(expr);
                return parsed.literal && parsed.constant ? parsed : $parse(expr, function(value) {
                    return sce.getTrusted(type, value);
                });
            };
            var parse = sce.parseAs, getTrusted = sce.getTrusted, trustAs = sce.trustAs;
            return forEach(SCE_CONTEXTS, function(enumValue, name) {
                var lName = lowercase(name);
                sce[snakeToCamel("parse_as_" + lName)] = function(expr) {
                    return parse(enumValue, expr);
                }, sce[snakeToCamel("get_trusted_" + lName)] = function(value) {
                    return getTrusted(enumValue, value);
                }, sce[snakeToCamel("trust_as_" + lName)] = function(value) {
                    return trustAs(enumValue, value);
                };
            }), sce;
        } ];
    }
    function $SnifferProvider() {
        this.$get = [ "$window", "$document", function($window, $document) {
            var eventSupport = {}, isNw = $window.nw && $window.nw.process, isChromePackagedApp = !isNw && $window.chrome && ($window.chrome.app && $window.chrome.app.runtime || !$window.chrome.app && $window.chrome.runtime && $window.chrome.runtime.id), hasHistoryPushState = !isChromePackagedApp && $window.history && $window.history.pushState, android = toInt((/android (\d+)/.exec(lowercase(($window.navigator || {}).userAgent)) || [])[1]), boxee = /Boxee/i.test(($window.navigator || {}).userAgent), document = $document[0] || {}, bodyStyle = document.body && document.body.style, transitions = !1, animations = !1;
            return bodyStyle && (transitions = !!("transition" in bodyStyle || "webkitTransition" in bodyStyle), 
            animations = !!("animation" in bodyStyle || "webkitAnimation" in bodyStyle)), {
                history: !(!hasHistoryPushState || 4 > android || boxee),
                hasEvent: function(event) {
                    if ("input" === event && msie) return !1;
                    if (isUndefined(eventSupport[event])) {
                        var divElm = document.createElement("div");
                        eventSupport[event] = "on" + event in divElm;
                    }
                    return eventSupport[event];
                },
                csp: csp(),
                transitions: transitions,
                animations: animations,
                android: android
            };
        } ];
    }
    function $TemplateRequestProvider() {
        var httpOptions;
        this.httpOptions = function(val) {
            return val ? (httpOptions = val, this) : httpOptions;
        }, this.$get = [ "$exceptionHandler", "$templateCache", "$http", "$q", "$sce", function($exceptionHandler, $templateCache, $http, $q, $sce) {
            function handleRequestFn(tpl, ignoreRequestError) {
                function handleError(resp) {
                    return ignoreRequestError || (resp = $templateRequestMinErr("tpload", "Failed to load template: {0} (HTTP status: {1} {2})", tpl, resp.status, resp.statusText), 
                    $exceptionHandler(resp)), $q.reject(resp);
                }
                handleRequestFn.totalPendingRequests++, (!isString(tpl) || isUndefined($templateCache.get(tpl))) && (tpl = $sce.getTrustedResourceUrl(tpl));
                var transformResponse = $http.defaults && $http.defaults.transformResponse;
                return isArray(transformResponse) ? transformResponse = transformResponse.filter(function(transformer) {
                    return transformer !== defaultHttpResponseTransform;
                }) : transformResponse === defaultHttpResponseTransform && (transformResponse = null), 
                $http.get(tpl, extend({
                    cache: $templateCache,
                    transformResponse: transformResponse
                }, httpOptions)).finally(function() {
                    handleRequestFn.totalPendingRequests--;
                }).then(function(response) {
                    return $templateCache.put(tpl, response.data);
                }, handleError);
            }
            return handleRequestFn.totalPendingRequests = 0, handleRequestFn;
        } ];
    }
    function $$TestabilityProvider() {
        this.$get = [ "$rootScope", "$browser", "$location", function($rootScope, $browser, $location) {
            var testability = {};
            return testability.findBindings = function(element, expression, opt_exactMatch) {
                var bindings = element.getElementsByClassName("ng-binding"), matches = [];
                return forEach(bindings, function(binding) {
                    var dataBinding = angular.element(binding).data("$binding");
                    dataBinding && forEach(dataBinding, function(bindingName) {
                        if (opt_exactMatch) {
                            var matcher = new RegExp("(^|\\s)" + escapeForRegexp(expression) + "(\\s|\\||$)");
                            matcher.test(bindingName) && matches.push(binding);
                        } else -1 !== bindingName.indexOf(expression) && matches.push(binding);
                    });
                }), matches;
            }, testability.findModels = function(element, expression, opt_exactMatch) {
                for (var prefixes = [ "ng-", "data-ng-", "ng\\:" ], p = 0; p < prefixes.length; ++p) {
                    var attributeEquals = opt_exactMatch ? "=" : "*=", selector = "[" + prefixes[p] + "model" + attributeEquals + '"' + expression + '"]', elements = element.querySelectorAll(selector);
                    if (elements.length) return elements;
                }
            }, testability.getLocation = function() {
                return $location.url();
            }, testability.setLocation = function(url) {
                url !== $location.url() && ($location.url(url), $rootScope.$digest());
            }, testability.whenStable = function(callback) {
                $browser.notifyWhenNoOutstandingRequests(callback);
            }, testability;
        } ];
    }
    function $TimeoutProvider() {
        this.$get = [ "$rootScope", "$browser", "$q", "$$q", "$exceptionHandler", function($rootScope, $browser, $q, $$q, $exceptionHandler) {
            function timeout(fn, delay, invokeApply) {
                isFunction(fn) || (invokeApply = delay, delay = fn, fn = noop);
                var timeoutId, args = sliceArgs(arguments, 3), skipApply = isDefined(invokeApply) && !invokeApply, deferred = (skipApply ? $$q : $q).defer(), promise = deferred.promise;
                return timeoutId = $browser.defer(function() {
                    try {
                        deferred.resolve(fn.apply(null, args));
                    } catch (e) {
                        deferred.reject(e), $exceptionHandler(e);
                    } finally {
                        delete deferreds[promise.$$timeoutId];
                    }
                    skipApply || $rootScope.$apply();
                }, delay), promise.$$timeoutId = timeoutId, deferreds[timeoutId] = deferred, promise;
            }
            var deferreds = {};
            return timeout.cancel = function(promise) {
                if (!promise) return !1;
                if (!promise.hasOwnProperty("$$timeoutId")) throw $timeoutMinErr("badprom", "`$timeout.cancel()` called with a promise that was not generated by `$timeout()`.");
                if (!deferreds.hasOwnProperty(promise.$$timeoutId)) return !1;
                var id = promise.$$timeoutId, deferred = deferreds[id];
                return markQExceptionHandled(deferred.promise), deferred.reject("canceled"), delete deferreds[id], 
                $browser.defer.cancel(id);
            }, timeout;
        } ];
    }
    function urlResolve(url) {
        if (!isString(url)) return url;
        var href = url;
        return msie && (urlParsingNode.setAttribute("href", href), href = urlParsingNode.href), 
        urlParsingNode.setAttribute("href", href), {
            href: urlParsingNode.href,
            protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
            host: urlParsingNode.host,
            search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
            hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
            hostname: urlParsingNode.hostname,
            port: urlParsingNode.port,
            pathname: "/" === urlParsingNode.pathname.charAt(0) ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
        };
    }
    function urlIsSameOrigin(requestUrl) {
        return urlsAreSameOrigin(requestUrl, originUrl);
    }
    function urlIsSameOriginAsBaseUrl(requestUrl) {
        return urlsAreSameOrigin(requestUrl, getBaseUrl());
    }
    function urlIsAllowedOriginFactory(whitelistedOriginUrls) {
        var parsedAllowedOriginUrls = [ originUrl ].concat(whitelistedOriginUrls.map(urlResolve));
        return function(requestUrl) {
            var parsedUrl = urlResolve(requestUrl);
            return parsedAllowedOriginUrls.some(urlsAreSameOrigin.bind(null, parsedUrl));
        };
    }
    function urlsAreSameOrigin(url1, url2) {
        return url1 = urlResolve(url1), url2 = urlResolve(url2), url1.protocol === url2.protocol && url1.host === url2.host;
    }
    function getBaseUrl() {
        return window.document.baseURI ? window.document.baseURI : (baseUrlParsingNode || (baseUrlParsingNode = window.document.createElement("a"), 
        baseUrlParsingNode.href = ".", baseUrlParsingNode = baseUrlParsingNode.cloneNode(!1)), 
        baseUrlParsingNode.href);
    }
    function $WindowProvider() {
        this.$get = valueFn(window);
    }
    function $$CookieReader($document) {
        function safeGetCookie(rawDocument) {
            try {
                return rawDocument.cookie || "";
            } catch (e) {
                return "";
            }
        }
        function safeDecodeURIComponent(str) {
            try {
                return decodeURIComponent(str);
            } catch (e) {
                return str;
            }
        }
        var rawDocument = $document[0] || {}, lastCookies = {}, lastCookieString = "";
        return function() {
            var cookieArray, cookie, i, index, name, currentCookieString = safeGetCookie(rawDocument);
            if (currentCookieString !== lastCookieString) for (lastCookieString = currentCookieString, 
            cookieArray = lastCookieString.split("; "), lastCookies = {}, i = 0; i < cookieArray.length; i++) cookie = cookieArray[i], 
            index = cookie.indexOf("="), index > 0 && (name = safeDecodeURIComponent(cookie.substring(0, index)), 
            isUndefined(lastCookies[name]) && (lastCookies[name] = safeDecodeURIComponent(cookie.substring(index + 1))));
            return lastCookies;
        };
    }
    function $$CookieReaderProvider() {
        this.$get = $$CookieReader;
    }
    function $FilterProvider($provide) {
        function register(name, factory) {
            if (isObject(name)) {
                var filters = {};
                return forEach(name, function(filter, key) {
                    filters[key] = register(key, filter);
                }), filters;
            }
            return $provide.factory(name + suffix, factory);
        }
        var suffix = "Filter";
        this.register = register, this.$get = [ "$injector", function($injector) {
            return function(name) {
                return $injector.get(name + suffix);
            };
        } ], register("currency", currencyFilter), register("date", dateFilter), register("filter", filterFilter), 
        register("json", jsonFilter), register("limitTo", limitToFilter), register("lowercase", lowercaseFilter), 
        register("number", numberFilter), register("orderBy", orderByFilter), register("uppercase", uppercaseFilter);
    }
    function filterFilter() {
        return function(array, expression, comparator, anyPropertyKey) {
            if (!isArrayLike(array)) {
                if (null == array) return array;
                throw minErr("filter")("notarray", "Expected array but received: {0}", array);
            }
            anyPropertyKey = anyPropertyKey || "$";
            var predicateFn, matchAgainstAnyProp, expressionType = getTypeForFilter(expression);
            switch (expressionType) {
              case "function":
                predicateFn = expression;
                break;

              case "boolean":
              case "null":
              case "number":
              case "string":
                matchAgainstAnyProp = !0;

              case "object":
                predicateFn = createPredicateFn(expression, comparator, anyPropertyKey, matchAgainstAnyProp);
                break;

              default:
                return array;
            }
            return Array.prototype.filter.call(array, predicateFn);
        };
    }
    function createPredicateFn(expression, comparator, anyPropertyKey, matchAgainstAnyProp) {
        var predicateFn, shouldMatchPrimitives = isObject(expression) && anyPropertyKey in expression;
        return comparator === !0 ? comparator = equals : isFunction(comparator) || (comparator = function(actual, expected) {
            return isUndefined(actual) ? !1 : null === actual || null === expected ? actual === expected : isObject(expected) || isObject(actual) && !hasCustomToString(actual) ? !1 : (actual = lowercase("" + actual), 
            expected = lowercase("" + expected), -1 !== actual.indexOf(expected));
        }), predicateFn = function(item) {
            return shouldMatchPrimitives && !isObject(item) ? deepCompare(item, expression[anyPropertyKey], comparator, anyPropertyKey, !1) : deepCompare(item, expression, comparator, anyPropertyKey, matchAgainstAnyProp);
        };
    }
    function deepCompare(actual, expected, comparator, anyPropertyKey, matchAgainstAnyProp, dontMatchWholeObject) {
        var actualType = getTypeForFilter(actual), expectedType = getTypeForFilter(expected);
        if ("string" === expectedType && "!" === expected.charAt(0)) return !deepCompare(actual, expected.substring(1), comparator, anyPropertyKey, matchAgainstAnyProp);
        if (isArray(actual)) return actual.some(function(item) {
            return deepCompare(item, expected, comparator, anyPropertyKey, matchAgainstAnyProp);
        });
        switch (actualType) {
          case "object":
            var key;
            if (matchAgainstAnyProp) {
                for (key in actual) if (key.charAt && "$" !== key.charAt(0) && deepCompare(actual[key], expected, comparator, anyPropertyKey, !0)) return !0;
                return dontMatchWholeObject ? !1 : deepCompare(actual, expected, comparator, anyPropertyKey, !1);
            }
            if ("object" === expectedType) {
                for (key in expected) {
                    var expectedVal = expected[key];
                    if (!isFunction(expectedVal) && !isUndefined(expectedVal)) {
                        var matchAnyProperty = key === anyPropertyKey, actualVal = matchAnyProperty ? actual : actual[key];
                        if (!deepCompare(actualVal, expectedVal, comparator, anyPropertyKey, matchAnyProperty, matchAnyProperty)) return !1;
                    }
                }
                return !0;
            }
            return comparator(actual, expected);

          case "function":
            return !1;

          default:
            return comparator(actual, expected);
        }
    }
    function getTypeForFilter(val) {
        return null === val ? "null" : typeof val;
    }
    function currencyFilter($locale) {
        var formats = $locale.NUMBER_FORMATS;
        return function(amount, currencySymbol, fractionSize) {
            isUndefined(currencySymbol) && (currencySymbol = formats.CURRENCY_SYM), isUndefined(fractionSize) && (fractionSize = formats.PATTERNS[1].maxFrac);
            var currencySymbolRe = currencySymbol ? /\u00A4/g : /\s*\u00A4\s*/g;
            return null == amount ? amount : formatNumber(amount, formats.PATTERNS[1], formats.GROUP_SEP, formats.DECIMAL_SEP, fractionSize).replace(currencySymbolRe, currencySymbol);
        };
    }
    function numberFilter($locale) {
        var formats = $locale.NUMBER_FORMATS;
        return function(number, fractionSize) {
            return null == number ? number : formatNumber(number, formats.PATTERNS[0], formats.GROUP_SEP, formats.DECIMAL_SEP, fractionSize);
        };
    }
    function parse(numStr) {
        var digits, numberOfIntegerDigits, i, j, zeros, exponent = 0;
        for ((numberOfIntegerDigits = numStr.indexOf(DECIMAL_SEP)) > -1 && (numStr = numStr.replace(DECIMAL_SEP, "")), 
        (i = numStr.search(/e/i)) > 0 ? (0 > numberOfIntegerDigits && (numberOfIntegerDigits = i), 
        numberOfIntegerDigits += +numStr.slice(i + 1), numStr = numStr.substring(0, i)) : 0 > numberOfIntegerDigits && (numberOfIntegerDigits = numStr.length), 
        i = 0; numStr.charAt(i) === ZERO_CHAR; i++) ;
        if (i === (zeros = numStr.length)) digits = [ 0 ], numberOfIntegerDigits = 1; else {
            for (zeros--; numStr.charAt(zeros) === ZERO_CHAR; ) zeros--;
            for (numberOfIntegerDigits -= i, digits = [], j = 0; zeros >= i; i++, j++) digits[j] = +numStr.charAt(i);
        }
        return numberOfIntegerDigits > MAX_DIGITS && (digits = digits.splice(0, MAX_DIGITS - 1), 
        exponent = numberOfIntegerDigits - 1, numberOfIntegerDigits = 1), {
            d: digits,
            e: exponent,
            i: numberOfIntegerDigits
        };
    }
    function roundNumber(parsedNumber, fractionSize, minFrac, maxFrac) {
        var digits = parsedNumber.d, fractionLen = digits.length - parsedNumber.i;
        fractionSize = isUndefined(fractionSize) ? Math.min(Math.max(minFrac, fractionLen), maxFrac) : +fractionSize;
        var roundAt = fractionSize + parsedNumber.i, digit = digits[roundAt];
        if (roundAt > 0) {
            digits.splice(Math.max(parsedNumber.i, roundAt));
            for (var j = roundAt; j < digits.length; j++) digits[j] = 0;
        } else {
            fractionLen = Math.max(0, fractionLen), parsedNumber.i = 1, digits.length = Math.max(1, roundAt = fractionSize + 1), 
            digits[0] = 0;
            for (var i = 1; roundAt > i; i++) digits[i] = 0;
        }
        if (digit >= 5) if (0 > roundAt - 1) {
            for (var k = 0; k > roundAt; k--) digits.unshift(0), parsedNumber.i++;
            digits.unshift(1), parsedNumber.i++;
        } else digits[roundAt - 1]++;
        for (;fractionLen < Math.max(0, fractionSize); fractionLen++) digits.push(0);
        var carry = digits.reduceRight(function(carry, d, i, digits) {
            return d += carry, digits[i] = d % 10, Math.floor(d / 10);
        }, 0);
        carry && (digits.unshift(carry), parsedNumber.i++);
    }
    function formatNumber(number, pattern, groupSep, decimalSep, fractionSize) {
        if (!isString(number) && !isNumber(number) || isNaN(number)) return "";
        var parsedNumber, isInfinity = !isFinite(number), isZero = !1, numStr = Math.abs(number) + "", formattedText = "";
        if (isInfinity) formattedText = ""; else {
            parsedNumber = parse(numStr), roundNumber(parsedNumber, fractionSize, pattern.minFrac, pattern.maxFrac);
            var digits = parsedNumber.d, integerLen = parsedNumber.i, exponent = parsedNumber.e, decimals = [];
            for (isZero = digits.reduce(function(isZero, d) {
                return isZero && !d;
            }, !0); 0 > integerLen; ) digits.unshift(0), integerLen++;
            integerLen > 0 ? decimals = digits.splice(integerLen, digits.length) : (decimals = digits, 
            digits = [ 0 ]);
            var groups = [];
            for (digits.length >= pattern.lgSize && groups.unshift(digits.splice(-pattern.lgSize, digits.length).join("")); digits.length > pattern.gSize; ) groups.unshift(digits.splice(-pattern.gSize, digits.length).join(""));
            digits.length && groups.unshift(digits.join("")), formattedText = groups.join(groupSep), 
            decimals.length && (formattedText += decimalSep + decimals.join("")), exponent && (formattedText += "e+" + exponent);
        }
        return 0 > number && !isZero ? pattern.negPre + formattedText + pattern.negSuf : pattern.posPre + formattedText + pattern.posSuf;
    }
    function padNumber(num, digits, trim, negWrap) {
        var neg = "";
        for ((0 > num || negWrap && 0 >= num) && (negWrap ? num = -num + 1 : (num = -num, 
        neg = "-")), num = "" + num; num.length < digits; ) num = ZERO_CHAR + num;
        return trim && (num = num.substr(num.length - digits)), neg + num;
    }
    function dateGetter(name, size, offset, trim, negWrap) {
        return offset = offset || 0, function(date) {
            var value = date["get" + name]();
            return (offset > 0 || value > -offset) && (value += offset), 0 === value && -12 === offset && (value = 12), 
            padNumber(value, size, trim, negWrap);
        };
    }
    function dateStrGetter(name, shortForm, standAlone) {
        return function(date, formats) {
            var value = date["get" + name](), propPrefix = (standAlone ? "STANDALONE" : "") + (shortForm ? "SHORT" : ""), get = uppercase(propPrefix + name);
            return formats[get][value];
        };
    }
    function timeZoneGetter(date, formats, offset) {
        var zone = -1 * offset, paddedZone = zone >= 0 ? "+" : "";
        return paddedZone += padNumber(Math[zone > 0 ? "floor" : "ceil"](zone / 60), 2) + padNumber(Math.abs(zone % 60), 2);
    }
    function getFirstThursdayOfYear(year) {
        var dayOfWeekOnFirst = new Date(year, 0, 1).getDay();
        return new Date(year, 0, (4 >= dayOfWeekOnFirst ? 5 : 12) - dayOfWeekOnFirst);
    }
    function getThursdayThisWeek(datetime) {
        return new Date(datetime.getFullYear(), datetime.getMonth(), datetime.getDate() + (4 - datetime.getDay()));
    }
    function weekGetter(size) {
        return function(date) {
            var firstThurs = getFirstThursdayOfYear(date.getFullYear()), thisThurs = getThursdayThisWeek(date), diff = +thisThurs - +firstThurs, result = 1 + Math.round(diff / 6048e5);
            return padNumber(result, size);
        };
    }
    function ampmGetter(date, formats) {
        return date.getHours() < 12 ? formats.AMPMS[0] : formats.AMPMS[1];
    }
    function eraGetter(date, formats) {
        return date.getFullYear() <= 0 ? formats.ERAS[0] : formats.ERAS[1];
    }
    function longEraGetter(date, formats) {
        return date.getFullYear() <= 0 ? formats.ERANAMES[0] : formats.ERANAMES[1];
    }
    function dateFilter($locale) {
        function jsonStringToDate(string) {
            var match;
            if (match = string.match(R_ISO8601_STR)) {
                var date = new Date(0), tzHour = 0, tzMin = 0, dateSetter = match[8] ? date.setUTCFullYear : date.setFullYear, timeSetter = match[8] ? date.setUTCHours : date.setHours;
                match[9] && (tzHour = toInt(match[9] + match[10]), tzMin = toInt(match[9] + match[11])), 
                dateSetter.call(date, toInt(match[1]), toInt(match[2]) - 1, toInt(match[3]));
                var h = toInt(match[4] || 0) - tzHour, m = toInt(match[5] || 0) - tzMin, s = toInt(match[6] || 0), ms = Math.round(1e3 * parseFloat("0." + (match[7] || 0)));
                return timeSetter.call(date, h, m, s, ms), date;
            }
            return string;
        }
        var R_ISO8601_STR = /^(\d{4})-?(\d\d)-?(\d\d)(?:T(\d\d)(?::?(\d\d)(?::?(\d\d)(?:\.(\d+))?)?)?(Z|([+-])(\d\d):?(\d\d))?)?$/;
        return function(date, format, timezone) {
            var fn, match, text = "", parts = [];
            if (format = format || "mediumDate", format = $locale.DATETIME_FORMATS[format] || format, 
            isString(date) && (date = NUMBER_STRING.test(date) ? toInt(date) : jsonStringToDate(date)), 
            isNumber(date) && (date = new Date(date)), !isDate(date) || !isFinite(date.getTime())) return date;
            for (;format; ) match = DATE_FORMATS_SPLIT.exec(format), match ? (parts = concat(parts, match, 1), 
            format = parts.pop()) : (parts.push(format), format = null);
            var dateTimezoneOffset = date.getTimezoneOffset();
            return timezone && (dateTimezoneOffset = timezoneToOffset(timezone, dateTimezoneOffset), 
            date = convertTimezoneToLocal(date, timezone, !0)), forEach(parts, function(value) {
                fn = DATE_FORMATS[value], text += fn ? fn(date, $locale.DATETIME_FORMATS, dateTimezoneOffset) : "''" === value ? "'" : value.replace(/(^'|'$)/g, "").replace(/''/g, "'");
            }), text;
        };
    }
    function jsonFilter() {
        return function(object, spacing) {
            return isUndefined(spacing) && (spacing = 2), toJson(object, spacing);
        };
    }
    function limitToFilter() {
        return function(input, limit, begin) {
            return limit = 1/0 === Math.abs(Number(limit)) ? Number(limit) : toInt(limit), isNumberNaN(limit) ? input : (isNumber(input) && (input = input.toString()), 
            isArrayLike(input) ? (begin = !begin || isNaN(begin) ? 0 : toInt(begin), begin = 0 > begin ? Math.max(0, input.length + begin) : begin, 
            limit >= 0 ? sliceFn(input, begin, begin + limit) : 0 === begin ? sliceFn(input, limit, input.length) : sliceFn(input, Math.max(0, begin + limit), begin)) : input);
        };
    }
    function sliceFn(input, begin, end) {
        return isString(input) ? input.slice(begin, end) : slice.call(input, begin, end);
    }
    function orderByFilter($parse) {
        function processPredicates(sortPredicates) {
            return sortPredicates.map(function(predicate) {
                var descending = 1, get = identity;
                if (isFunction(predicate)) get = predicate; else if (isString(predicate) && (("+" === predicate.charAt(0) || "-" === predicate.charAt(0)) && (descending = "-" === predicate.charAt(0) ? -1 : 1, 
                predicate = predicate.substring(1)), "" !== predicate && (get = $parse(predicate), 
                get.constant))) {
                    var key = get();
                    get = function(value) {
                        return value[key];
                    };
                }
                return {
                    get: get,
                    descending: descending
                };
            });
        }
        function isPrimitive(value) {
            switch (typeof value) {
              case "number":
              case "boolean":
              case "string":
                return !0;

              default:
                return !1;
            }
        }
        function objectValue(value) {
            return isFunction(value.valueOf) && (value = value.valueOf(), isPrimitive(value)) ? value : hasCustomToString(value) && (value = value.toString(), 
            isPrimitive(value)) ? value : value;
        }
        function getPredicateValue(value, index) {
            var type = typeof value;
            return null === value ? type = "null" : "object" === type && (value = objectValue(value)), 
            {
                value: value,
                type: type,
                index: index
            };
        }
        function defaultCompare(v1, v2) {
            var result = 0, type1 = v1.type, type2 = v2.type;
            if (type1 === type2) {
                var value1 = v1.value, value2 = v2.value;
                "string" === type1 ? (value1 = value1.toLowerCase(), value2 = value2.toLowerCase()) : "object" === type1 && (isObject(value1) && (value1 = v1.index), 
                isObject(value2) && (value2 = v2.index)), value1 !== value2 && (result = value2 > value1 ? -1 : 1);
            } else result = "undefined" === type1 ? 1 : "undefined" === type2 ? -1 : "null" === type1 ? 1 : "null" === type2 ? -1 : type2 > type1 ? -1 : 1;
            return result;
        }
        return function(array, sortPredicate, reverseOrder, compareFn) {
            function getComparisonObject(value, index) {
                return {
                    value: value,
                    tieBreaker: {
                        value: index,
                        type: "number",
                        index: index
                    },
                    predicateValues: predicates.map(function(predicate) {
                        return getPredicateValue(predicate.get(value), index);
                    })
                };
            }
            function doComparison(v1, v2) {
                for (var i = 0, ii = predicates.length; ii > i; i++) {
                    var result = compare(v1.predicateValues[i], v2.predicateValues[i]);
                    if (result) return result * predicates[i].descending * descending;
                }
                return (compare(v1.tieBreaker, v2.tieBreaker) || defaultCompare(v1.tieBreaker, v2.tieBreaker)) * descending;
            }
            if (null == array) return array;
            if (!isArrayLike(array)) throw minErr("orderBy")("notarray", "Expected array but received: {0}", array);
            isArray(sortPredicate) || (sortPredicate = [ sortPredicate ]), 0 === sortPredicate.length && (sortPredicate = [ "+" ]);
            var predicates = processPredicates(sortPredicate), descending = reverseOrder ? -1 : 1, compare = isFunction(compareFn) ? compareFn : defaultCompare, compareValues = Array.prototype.map.call(array, getComparisonObject);
            return compareValues.sort(doComparison), array = compareValues.map(function(item) {
                return item.value;
            });
        };
    }
    function ngDirective(directive) {
        return isFunction(directive) && (directive = {
            link: directive
        }), directive.restrict = directive.restrict || "AC", valueFn(directive);
    }
    function nullFormRenameControl(control, name) {
        control.$name = name;
    }
    function FormController($element, $attrs, $scope, $animate, $interpolate) {
        this.$$controls = [], this.$error = {}, this.$$success = {}, this.$pending = void 0, 
        this.$name = $interpolate($attrs.name || $attrs.ngForm || "")($scope), this.$dirty = !1, 
        this.$pristine = !0, this.$valid = !0, this.$invalid = !1, this.$submitted = !1, 
        this.$$parentForm = nullFormCtrl, this.$$element = $element, this.$$animate = $animate, 
        setupValidity(this);
    }
    function setupValidity(instance) {
        instance.$$classCache = {}, instance.$$classCache[INVALID_CLASS] = !(instance.$$classCache[VALID_CLASS] = instance.$$element.hasClass(VALID_CLASS));
    }
    function addSetValidityMethod(context) {
        function createAndSet(ctrl, name, value, controller) {
            ctrl[name] || (ctrl[name] = {}), set(ctrl[name], value, controller);
        }
        function unsetAndCleanup(ctrl, name, value, controller) {
            ctrl[name] && unset(ctrl[name], value, controller), isObjectEmpty(ctrl[name]) && (ctrl[name] = void 0);
        }
        function cachedToggleClass(ctrl, className, switchValue) {
            switchValue && !ctrl.$$classCache[className] ? (ctrl.$$animate.addClass(ctrl.$$element, className), 
            ctrl.$$classCache[className] = !0) : !switchValue && ctrl.$$classCache[className] && (ctrl.$$animate.removeClass(ctrl.$$element, className), 
            ctrl.$$classCache[className] = !1);
        }
        function toggleValidationCss(ctrl, validationErrorKey, isValid) {
            validationErrorKey = validationErrorKey ? "-" + snake_case(validationErrorKey, "-") : "", 
            cachedToggleClass(ctrl, VALID_CLASS + validationErrorKey, isValid === !0), cachedToggleClass(ctrl, INVALID_CLASS + validationErrorKey, isValid === !1);
        }
        var clazz = context.clazz, set = context.set, unset = context.unset;
        clazz.prototype.$setValidity = function(validationErrorKey, state, controller) {
            isUndefined(state) ? createAndSet(this, "$pending", validationErrorKey, controller) : unsetAndCleanup(this, "$pending", validationErrorKey, controller), 
            isBoolean(state) ? state ? (unset(this.$error, validationErrorKey, controller), 
            set(this.$$success, validationErrorKey, controller)) : (set(this.$error, validationErrorKey, controller), 
            unset(this.$$success, validationErrorKey, controller)) : (unset(this.$error, validationErrorKey, controller), 
            unset(this.$$success, validationErrorKey, controller)), this.$pending ? (cachedToggleClass(this, PENDING_CLASS, !0), 
            this.$valid = this.$invalid = void 0, toggleValidationCss(this, "", null)) : (cachedToggleClass(this, PENDING_CLASS, !1), 
            this.$valid = isObjectEmpty(this.$error), this.$invalid = !this.$valid, toggleValidationCss(this, "", this.$valid));
            var combinedState;
            combinedState = this.$pending && this.$pending[validationErrorKey] ? void 0 : this.$error[validationErrorKey] ? !1 : this.$$success[validationErrorKey] ? !0 : null, 
            toggleValidationCss(this, validationErrorKey, combinedState), this.$$parentForm.$setValidity(validationErrorKey, combinedState, this);
        };
    }
    function isObjectEmpty(obj) {
        if (obj) for (var prop in obj) if (obj.hasOwnProperty(prop)) return !1;
        return !0;
    }
    function stringBasedInputType(ctrl) {
        ctrl.$formatters.push(function(value) {
            return ctrl.$isEmpty(value) ? value : value.toString();
        });
    }
    function textInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        baseInputType(scope, element, attr, ctrl, $sniffer, $browser), stringBasedInputType(ctrl);
    }
    function baseInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        var type = lowercase(element[0].type);
        if (!$sniffer.android) {
            var composing = !1;
            element.on("compositionstart", function() {
                composing = !0;
            }), element.on("compositionupdate", function(ev) {
                (isUndefined(ev.data) || "" === ev.data) && (composing = !1);
            }), element.on("compositionend", function() {
                composing = !1, listener();
            });
        }
        var timeout, listener = function(ev) {
            if (timeout && ($browser.defer.cancel(timeout), timeout = null), !composing) {
                var value = element.val(), event = ev && ev.type;
                "password" === type || attr.ngTrim && "false" === attr.ngTrim || (value = trim(value)), 
                (ctrl.$viewValue !== value || "" === value && ctrl.$$hasNativeValidators) && ctrl.$setViewValue(value, event);
            }
        };
        if ($sniffer.hasEvent("input")) element.on("input", listener); else {
            var deferListener = function(ev, input, origValue) {
                timeout || (timeout = $browser.defer(function() {
                    timeout = null, input && input.value === origValue || listener(ev);
                }));
            };
            element.on("keydown", function(event) {
                var key = event.keyCode;
                91 === key || key > 15 && 19 > key || key >= 37 && 40 >= key || deferListener(event, this, this.value);
            }), $sniffer.hasEvent("paste") && element.on("paste cut drop", deferListener);
        }
        element.on("change", listener), PARTIAL_VALIDATION_TYPES[type] && ctrl.$$hasNativeValidators && type === attr.type && element.on(PARTIAL_VALIDATION_EVENTS, function(ev) {
            if (!timeout) {
                var validity = this[VALIDITY_STATE_PROPERTY], origBadInput = validity.badInput, origTypeMismatch = validity.typeMismatch;
                timeout = $browser.defer(function() {
                    timeout = null, (validity.badInput !== origBadInput || validity.typeMismatch !== origTypeMismatch) && listener(ev);
                });
            }
        }), ctrl.$render = function() {
            var value = ctrl.$isEmpty(ctrl.$viewValue) ? "" : ctrl.$viewValue;
            element.val() !== value && element.val(value);
        };
    }
    function weekParser(isoWeek, existingDate) {
        if (isDate(isoWeek)) return isoWeek;
        if (isString(isoWeek)) {
            WEEK_REGEXP.lastIndex = 0;
            var parts = WEEK_REGEXP.exec(isoWeek);
            if (parts) {
                var year = +parts[1], week = +parts[2], hours = 0, minutes = 0, seconds = 0, milliseconds = 0, firstThurs = getFirstThursdayOfYear(year), addDays = 7 * (week - 1);
                return existingDate && (hours = existingDate.getHours(), minutes = existingDate.getMinutes(), 
                seconds = existingDate.getSeconds(), milliseconds = existingDate.getMilliseconds()), 
                new Date(year, 0, firstThurs.getDate() + addDays, hours, minutes, seconds, milliseconds);
            }
        }
        return 0/0;
    }
    function createDateParser(regexp, mapping) {
        return function(iso, previousDate) {
            var parts, map;
            if (isDate(iso)) return iso;
            if (isString(iso)) {
                if ('"' === iso.charAt(0) && '"' === iso.charAt(iso.length - 1) && (iso = iso.substring(1, iso.length - 1)), 
                ISO_DATE_REGEXP.test(iso)) return new Date(iso);
                if (regexp.lastIndex = 0, parts = regexp.exec(iso)) {
                    parts.shift(), map = previousDate ? {
                        yyyy: previousDate.getFullYear(),
                        MM: previousDate.getMonth() + 1,
                        dd: previousDate.getDate(),
                        HH: previousDate.getHours(),
                        mm: previousDate.getMinutes(),
                        ss: previousDate.getSeconds(),
                        sss: previousDate.getMilliseconds() / 1e3
                    } : {
                        yyyy: 1970,
                        MM: 1,
                        dd: 1,
                        HH: 0,
                        mm: 0,
                        ss: 0,
                        sss: 0
                    }, forEach(parts, function(part, index) {
                        index < mapping.length && (map[mapping[index]] = +part);
                    });
                    var date = new Date(map.yyyy, map.MM - 1, map.dd, map.HH, map.mm, map.ss || 0, 1e3 * map.sss || 0);
                    return map.yyyy < 100 && date.setFullYear(map.yyyy), date;
                }
            }
            return 0/0;
        };
    }
    function createDateInputType(type, regexp, parseDate, format) {
        return function(scope, element, attr, ctrl, $sniffer, $browser, $filter) {
            function isValidDate(value) {
                return value && !(value.getTime && value.getTime() !== value.getTime());
            }
            function parseObservedDateValue(val) {
                return isDefined(val) && !isDate(val) ? parseDateAndConvertTimeZoneToLocal(val) || void 0 : val;
            }
            function parseDateAndConvertTimeZoneToLocal(value, previousDate) {
                var timezone = ctrl.$options.getOption("timezone");
                previousTimezone && previousTimezone !== timezone && (previousDate = addDateMinutes(previousDate, timezoneToOffset(previousTimezone)));
                var parsedDate = parseDate(value, previousDate);
                return !isNaN(parsedDate) && timezone && (parsedDate = convertTimezoneToLocal(parsedDate, timezone)), 
                parsedDate;
            }
            badInputChecker(scope, element, attr, ctrl, type), baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
            var previousDate, previousTimezone;
            if (ctrl.$parsers.push(function(value) {
                return ctrl.$isEmpty(value) ? null : regexp.test(value) ? parseDateAndConvertTimeZoneToLocal(value, previousDate) : void (ctrl.$$parserName = type);
            }), ctrl.$formatters.push(function(value) {
                if (value && !isDate(value)) throw ngModelMinErr("datefmt", "Expected `{0}` to be a date", value);
                if (isValidDate(value)) {
                    previousDate = value;
                    var timezone = ctrl.$options.getOption("timezone");
                    return timezone && (previousTimezone = timezone, previousDate = convertTimezoneToLocal(previousDate, timezone, !0)), 
                    $filter("date")(value, format, timezone);
                }
                return previousDate = null, previousTimezone = null, "";
            }), isDefined(attr.min) || attr.ngMin) {
                var minVal;
                ctrl.$validators.min = function(value) {
                    return !isValidDate(value) || isUndefined(minVal) || parseDate(value) >= minVal;
                }, attr.$observe("min", function(val) {
                    minVal = parseObservedDateValue(val), ctrl.$validate();
                });
            }
            if (isDefined(attr.max) || attr.ngMax) {
                var maxVal;
                ctrl.$validators.max = function(value) {
                    return !isValidDate(value) || isUndefined(maxVal) || parseDate(value) <= maxVal;
                }, attr.$observe("max", function(val) {
                    maxVal = parseObservedDateValue(val), ctrl.$validate();
                });
            }
        };
    }
    function badInputChecker(scope, element, attr, ctrl, parserName) {
        var node = element[0], nativeValidation = ctrl.$$hasNativeValidators = isObject(node.validity);
        nativeValidation && ctrl.$parsers.push(function(value) {
            var validity = element.prop(VALIDITY_STATE_PROPERTY) || {};
            return validity.badInput || validity.typeMismatch ? void (ctrl.$$parserName = parserName) : value;
        });
    }
    function numberFormatterParser(ctrl) {
        ctrl.$parsers.push(function(value) {
            return ctrl.$isEmpty(value) ? null : NUMBER_REGEXP.test(value) ? parseFloat(value) : void (ctrl.$$parserName = "number");
        }), ctrl.$formatters.push(function(value) {
            if (!ctrl.$isEmpty(value)) {
                if (!isNumber(value)) throw ngModelMinErr("numfmt", "Expected `{0}` to be a number", value);
                value = value.toString();
            }
            return value;
        });
    }
    function parseNumberAttrVal(val) {
        return isDefined(val) && !isNumber(val) && (val = parseFloat(val)), isNumberNaN(val) ? void 0 : val;
    }
    function isNumberInteger(num) {
        return (0 | num) === num;
    }
    function countDecimals(num) {
        var numString = num.toString(), decimalSymbolIndex = numString.indexOf(".");
        if (-1 === decimalSymbolIndex) {
            if (num > -1 && 1 > num) {
                var match = /e-(\d+)$/.exec(numString);
                if (match) return Number(match[1]);
            }
            return 0;
        }
        return numString.length - decimalSymbolIndex - 1;
    }
    function isValidForStep(viewValue, stepBase, step) {
        var value = Number(viewValue), isNonIntegerValue = !isNumberInteger(value), isNonIntegerStepBase = !isNumberInteger(stepBase), isNonIntegerStep = !isNumberInteger(step);
        if (isNonIntegerValue || isNonIntegerStepBase || isNonIntegerStep) {
            var valueDecimals = isNonIntegerValue ? countDecimals(value) : 0, stepBaseDecimals = isNonIntegerStepBase ? countDecimals(stepBase) : 0, stepDecimals = isNonIntegerStep ? countDecimals(step) : 0, decimalCount = Math.max(valueDecimals, stepBaseDecimals, stepDecimals), multiplier = Math.pow(10, decimalCount);
            value *= multiplier, stepBase *= multiplier, step *= multiplier, isNonIntegerValue && (value = Math.round(value)), 
            isNonIntegerStepBase && (stepBase = Math.round(stepBase)), isNonIntegerStep && (step = Math.round(step));
        }
        return (value - stepBase) % step === 0;
    }
    function numberInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        badInputChecker(scope, element, attr, ctrl, "number"), numberFormatterParser(ctrl), 
        baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
        var minVal, maxVal;
        if ((isDefined(attr.min) || attr.ngMin) && (ctrl.$validators.min = function(modelValue, viewValue) {
            return ctrl.$isEmpty(viewValue) || isUndefined(minVal) || viewValue >= minVal;
        }, attr.$observe("min", function(val) {
            minVal = parseNumberAttrVal(val), ctrl.$validate();
        })), (isDefined(attr.max) || attr.ngMax) && (ctrl.$validators.max = function(modelValue, viewValue) {
            return ctrl.$isEmpty(viewValue) || isUndefined(maxVal) || maxVal >= viewValue;
        }, attr.$observe("max", function(val) {
            maxVal = parseNumberAttrVal(val), ctrl.$validate();
        })), isDefined(attr.step) || attr.ngStep) {
            var stepVal;
            ctrl.$validators.step = function(modelValue, viewValue) {
                return ctrl.$isEmpty(viewValue) || isUndefined(stepVal) || isValidForStep(viewValue, minVal || 0, stepVal);
            }, attr.$observe("step", function(val) {
                stepVal = parseNumberAttrVal(val), ctrl.$validate();
            });
        }
    }
    function rangeInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        function setInitialValueAndObserver(htmlAttrName, changeFn) {
            element.attr(htmlAttrName, attr[htmlAttrName]), attr.$observe(htmlAttrName, changeFn);
        }
        function minChange(val) {
            if (minVal = parseNumberAttrVal(val), !isNumberNaN(ctrl.$modelValue)) if (supportsRange) {
                var elVal = element.val();
                minVal > elVal && (elVal = minVal, element.val(elVal)), ctrl.$setViewValue(elVal);
            } else ctrl.$validate();
        }
        function maxChange(val) {
            if (maxVal = parseNumberAttrVal(val), !isNumberNaN(ctrl.$modelValue)) if (supportsRange) {
                var elVal = element.val();
                elVal > maxVal && (element.val(maxVal), elVal = minVal > maxVal ? minVal : maxVal), 
                ctrl.$setViewValue(elVal);
            } else ctrl.$validate();
        }
        function stepChange(val) {
            stepVal = parseNumberAttrVal(val), isNumberNaN(ctrl.$modelValue) || (supportsRange && ctrl.$viewValue !== element.val() ? ctrl.$setViewValue(element.val()) : ctrl.$validate());
        }
        badInputChecker(scope, element, attr, ctrl, "range"), numberFormatterParser(ctrl), 
        baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
        var supportsRange = ctrl.$$hasNativeValidators && "range" === element[0].type, minVal = supportsRange ? 0 : void 0, maxVal = supportsRange ? 100 : void 0, stepVal = supportsRange ? 1 : void 0, validity = element[0].validity, hasMinAttr = isDefined(attr.min), hasMaxAttr = isDefined(attr.max), hasStepAttr = isDefined(attr.step), originalRender = ctrl.$render;
        ctrl.$render = supportsRange && isDefined(validity.rangeUnderflow) && isDefined(validity.rangeOverflow) ? function() {
            originalRender(), ctrl.$setViewValue(element.val());
        } : originalRender, hasMinAttr && (ctrl.$validators.min = supportsRange ? function() {
            return !0;
        } : function(modelValue, viewValue) {
            return ctrl.$isEmpty(viewValue) || isUndefined(minVal) || viewValue >= minVal;
        }, setInitialValueAndObserver("min", minChange)), hasMaxAttr && (ctrl.$validators.max = supportsRange ? function() {
            return !0;
        } : function(modelValue, viewValue) {
            return ctrl.$isEmpty(viewValue) || isUndefined(maxVal) || maxVal >= viewValue;
        }, setInitialValueAndObserver("max", maxChange)), hasStepAttr && (ctrl.$validators.step = supportsRange ? function() {
            return !validity.stepMismatch;
        } : function(modelValue, viewValue) {
            return ctrl.$isEmpty(viewValue) || isUndefined(stepVal) || isValidForStep(viewValue, minVal || 0, stepVal);
        }, setInitialValueAndObserver("step", stepChange));
    }
    function urlInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        baseInputType(scope, element, attr, ctrl, $sniffer, $browser), stringBasedInputType(ctrl), 
        ctrl.$validators.url = function(modelValue, viewValue) {
            var value = modelValue || viewValue;
            return ctrl.$isEmpty(value) || URL_REGEXP.test(value);
        };
    }
    function emailInputType(scope, element, attr, ctrl, $sniffer, $browser) {
        baseInputType(scope, element, attr, ctrl, $sniffer, $browser), stringBasedInputType(ctrl), 
        ctrl.$validators.email = function(modelValue, viewValue) {
            var value = modelValue || viewValue;
            return ctrl.$isEmpty(value) || EMAIL_REGEXP.test(value);
        };
    }
    function radioInputType(scope, element, attr, ctrl) {
        var doTrim = !attr.ngTrim || "false" !== trim(attr.ngTrim);
        isUndefined(attr.name) && element.attr("name", nextUid());
        var listener = function(ev) {
            var value;
            element[0].checked && (value = attr.value, doTrim && (value = trim(value)), ctrl.$setViewValue(value, ev && ev.type));
        };
        element.on("change", listener), ctrl.$render = function() {
            var value = attr.value;
            doTrim && (value = trim(value)), element[0].checked = value === ctrl.$viewValue;
        }, attr.$observe("value", ctrl.$render);
    }
    function parseConstantExpr($parse, context, name, expression, fallback) {
        var parseFn;
        if (isDefined(expression)) {
            if (parseFn = $parse(expression), !parseFn.constant) throw ngModelMinErr("constexpr", "Expected constant expression for `{0}`, but saw `{1}`.", name, expression);
            return parseFn(context);
        }
        return fallback;
    }
    function checkboxInputType(scope, element, attr, ctrl, $sniffer, $browser, $filter, $parse) {
        var trueValue = parseConstantExpr($parse, scope, "ngTrueValue", attr.ngTrueValue, !0), falseValue = parseConstantExpr($parse, scope, "ngFalseValue", attr.ngFalseValue, !1), listener = function(ev) {
            ctrl.$setViewValue(element[0].checked, ev && ev.type);
        };
        element.on("change", listener), ctrl.$render = function() {
            element[0].checked = ctrl.$viewValue;
        }, ctrl.$isEmpty = function(value) {
            return value === !1;
        }, ctrl.$formatters.push(function(value) {
            return equals(value, trueValue);
        }), ctrl.$parsers.push(function(value) {
            return value ? trueValue : falseValue;
        });
    }
    function classDirective(name, selector) {
        function arrayDifference(tokens1, tokens2) {
            if (!tokens1 || !tokens1.length) return [];
            if (!tokens2 || !tokens2.length) return tokens1;
            var values = [];
            outer: for (var i = 0; i < tokens1.length; i++) {
                for (var token = tokens1[i], j = 0; j < tokens2.length; j++) if (token === tokens2[j]) continue outer;
                values.push(token);
            }
            return values;
        }
        function split(classString) {
            return classString && classString.split(" ");
        }
        function toClassString(classValue) {
            var classString = classValue;
            return isArray(classValue) ? classString = classValue.map(toClassString).join(" ") : isObject(classValue) && (classString = Object.keys(classValue).filter(function(key) {
                return classValue[key];
            }).join(" ")), classString;
        }
        name = "ngClass" + name;
        var indexWatchExpression;
        return [ "$parse", function($parse) {
            return {
                restrict: "AC",
                link: function(scope, element, attr) {
                    function addClasses(classString) {
                        classString = digestClassCounts(split(classString), 1), attr.$addClass(classString);
                    }
                    function removeClasses(classString) {
                        classString = digestClassCounts(split(classString), -1), attr.$removeClass(classString);
                    }
                    function updateClasses(oldClassString, newClassString) {
                        var oldClassArray = split(oldClassString), newClassArray = split(newClassString), toRemoveArray = arrayDifference(oldClassArray, newClassArray), toAddArray = arrayDifference(newClassArray, oldClassArray), toRemoveString = digestClassCounts(toRemoveArray, -1), toAddString = digestClassCounts(toAddArray, 1);
                        attr.$addClass(toAddString), attr.$removeClass(toRemoveString);
                    }
                    function digestClassCounts(classArray, count) {
                        var classesToUpdate = [];
                        return forEach(classArray, function(className) {
                            (count > 0 || classCounts[className]) && (classCounts[className] = (classCounts[className] || 0) + count, 
                            classCounts[className] === +(count > 0) && classesToUpdate.push(className));
                        }), classesToUpdate.join(" ");
                    }
                    function ngClassIndexWatchAction(newModulo) {
                        newModulo === selector ? addClasses(oldClassString) : removeClasses(oldClassString), 
                        oldModulo = newModulo;
                    }
                    function ngClassWatchAction(newClassString) {
                        oldModulo === selector && updateClasses(oldClassString, newClassString), oldClassString = newClassString;
                    }
                    var oldClassString, classCounts = element.data("$classCounts"), oldModulo = !0;
                    classCounts || (classCounts = createMap(), element.data("$classCounts", classCounts)), 
                    "ngClass" !== name && (indexWatchExpression || (indexWatchExpression = $parse("$index", function($index) {
                        return 1 & $index;
                    })), scope.$watch(indexWatchExpression, ngClassIndexWatchAction)), scope.$watch($parse(attr[name], toClassString), ngClassWatchAction);
                }
            };
        } ];
    }
    function NgModelController($scope, $exceptionHandler, $attr, $element, $parse, $animate, $timeout, $q, $interpolate) {
        this.$viewValue = Number.NaN, this.$modelValue = Number.NaN, this.$$rawModelValue = void 0, 
        this.$validators = {}, this.$asyncValidators = {}, this.$parsers = [], this.$formatters = [], 
        this.$viewChangeListeners = [], this.$untouched = !0, this.$touched = !1, this.$pristine = !0, 
        this.$dirty = !1, this.$valid = !0, this.$invalid = !1, this.$error = {}, this.$$success = {}, 
        this.$pending = void 0, this.$name = $interpolate($attr.name || "", !1)($scope), 
        this.$$parentForm = nullFormCtrl, this.$options = defaultModelOptions, this.$$updateEvents = "", 
        this.$$updateEventHandler = this.$$updateEventHandler.bind(this), this.$$parsedNgModel = $parse($attr.ngModel), 
        this.$$parsedNgModelAssign = this.$$parsedNgModel.assign, this.$$ngModelGet = this.$$parsedNgModel, 
        this.$$ngModelSet = this.$$parsedNgModelAssign, this.$$pendingDebounce = null, this.$$parserValid = void 0, 
        this.$$parserName = "parse", this.$$currentValidationRunId = 0, this.$$scope = $scope, 
        this.$$rootScope = $scope.$root, this.$$attr = $attr, this.$$element = $element, 
        this.$$animate = $animate, this.$$timeout = $timeout, this.$$parse = $parse, this.$$q = $q, 
        this.$$exceptionHandler = $exceptionHandler, setupValidity(this), setupModelWatcher(this);
    }
    function setupModelWatcher(ctrl) {
        ctrl.$$scope.$watch(function(scope) {
            var modelValue = ctrl.$$ngModelGet(scope);
            return modelValue === ctrl.$modelValue || ctrl.$modelValue !== ctrl.$modelValue && modelValue !== modelValue || ctrl.$$setModelValue(modelValue), 
            modelValue;
        });
    }
    function ModelOptions(options) {
        this.$$options = options;
    }
    function defaults(dst, src) {
        forEach(src, function(value, key) {
            isDefined(dst[key]) || (dst[key] = value);
        });
    }
    function setOptionSelectedStatus(optionEl, value) {
        optionEl.prop("selected", value), optionEl.attr("selected", value);
    }
    var msie, jqLite, jQuery, angularModule, minErrConfig = {
        objectMaxDepth: 5,
        urlErrorParamsEnabled: !0
    }, REGEX_STRING_REGEXP = /^\/(.+)\/([a-z]*)$/, VALIDITY_STATE_PROPERTY = "validity", hasOwnProperty = Object.prototype.hasOwnProperty, lowercase = function(string) {
        return isString(string) ? string.toLowerCase() : string;
    }, uppercase = function(string) {
        return isString(string) ? string.toUpperCase() : string;
    }, slice = [].slice, splice = [].splice, push = [].push, toString = Object.prototype.toString, getPrototypeOf = Object.getPrototypeOf, ngMinErr = minErr("ng"), angular = window.angular || (window.angular = {}), uid = 0;
    msie = window.document.documentMode;
    var isNumberNaN = Number.isNaN || function(num) {
        return num !== num;
    };
    noop.$inject = [], identity.$inject = [];
    var TYPED_ARRAY_REGEXP = /^\[object (?:Uint8|Uint8Clamped|Uint16|Uint32|Int8|Int16|Int32|Float32|Float64)Array]$/, trim = function(value) {
        return isString(value) ? value.trim() : value;
    }, escapeForRegexp = function(s) {
        return s.replace(/([-()[\]{}+?*.$^|,:#<!\\])/g, "\\$1").replace(/\x08/g, "\\x08");
    }, csp = function() {
        function noUnsafeEval() {
            try {
                return new Function(""), !1;
            } catch (e) {
                return !0;
            }
        }
        if (!isDefined(csp.rules)) {
            var ngCspElement = window.document.querySelector("[ng-csp]") || window.document.querySelector("[data-ng-csp]");
            if (ngCspElement) {
                var ngCspAttribute = ngCspElement.getAttribute("ng-csp") || ngCspElement.getAttribute("data-ng-csp");
                csp.rules = {
                    noUnsafeEval: !ngCspAttribute || -1 !== ngCspAttribute.indexOf("no-unsafe-eval"),
                    noInlineStyle: !ngCspAttribute || -1 !== ngCspAttribute.indexOf("no-inline-style")
                };
            } else csp.rules = {
                noUnsafeEval: noUnsafeEval(),
                noInlineStyle: !1
            };
        }
        return csp.rules;
    }, jq = function() {
        if (isDefined(jq.name_)) return jq.name_;
        var el, i, prefix, name, ii = ngAttrPrefixes.length;
        for (i = 0; ii > i; ++i) if (prefix = ngAttrPrefixes[i], el = window.document.querySelector("[" + prefix.replace(":", "\\:") + "jq]")) {
            name = el.getAttribute(prefix + "jq");
            break;
        }
        return jq.name_ = name;
    }, ALL_COLONS = /:/g, ngAttrPrefixes = [ "ng-", "data-ng-", "ng:", "x-ng-" ], isAutoBootstrapAllowed = allowAutoBootstrap(window.document), SNAKE_CASE_REGEXP = /[A-Z]/g, bindJQueryFired = !1, NODE_TYPE_ELEMENT = 1, NODE_TYPE_ATTRIBUTE = 2, NODE_TYPE_TEXT = 3, NODE_TYPE_COMMENT = 8, NODE_TYPE_DOCUMENT = 9, NODE_TYPE_DOCUMENT_FRAGMENT = 11, version = {
        full: "1.7.2",
        major: 1,
        minor: 7,
        dot: 2,
        codeName: "extreme-compatiplication"
    };
    JQLite.expando = "ng339";
    var jqCache = JQLite.cache = {}, jqId = 1;
    JQLite._data = function(node) {
        return this.cache[node[this.expando]] || {};
    };
    var DASH_LOWERCASE_REGEXP = /-([a-z])/g, MS_HACK_REGEXP = /^-ms-/, MOUSE_EVENT_MAP = {
        mouseleave: "mouseout",
        mouseenter: "mouseover"
    }, jqLiteMinErr = minErr("jqLite"), SINGLE_TAG_REGEXP = /^<([\w-]+)\s*\/?>(?:<\/\1>|)$/, HTML_REGEXP = /<|&#?\w+;/, TAG_NAME_REGEXP = /<([\w:-]+)/, XHTML_TAG_REGEXP = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:-]+)[^>]*)\/>/gi, wrapMap = {
        option: [ 1, '<select multiple="multiple">', "</select>" ],
        thead: [ 1, "<table>", "</table>" ],
        col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
        tr: [ 2, "<table><tbody>", "</tbody></table>" ],
        td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],
        _default: [ 0, "", "" ]
    };
    wrapMap.optgroup = wrapMap.option, wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead, 
    wrapMap.th = wrapMap.td;
    var jqLiteContains = window.Node.prototype.contains || function(arg) {
        return !!(16 & this.compareDocumentPosition(arg));
    }, JQLitePrototype = JQLite.prototype = {
        ready: jqLiteReady,
        toString: function() {
            var value = [];
            return forEach(this, function(e) {
                value.push("" + e);
            }), "[" + value.join(", ") + "]";
        },
        eq: function(index) {
            return jqLite(index >= 0 ? this[index] : this[this.length + index]);
        },
        length: 0,
        push: push,
        sort: [].sort,
        splice: [].splice
    }, BOOLEAN_ATTR = {};
    forEach("multiple,selected,checked,disabled,readOnly,required,open".split(","), function(value) {
        BOOLEAN_ATTR[lowercase(value)] = value;
    });
    var BOOLEAN_ELEMENTS = {};
    forEach("input,select,option,textarea,button,form,details".split(","), function(value) {
        BOOLEAN_ELEMENTS[value] = !0;
    });
    var ALIASED_ATTR = {
        ngMinlength: "minlength",
        ngMaxlength: "maxlength",
        ngMin: "min",
        ngMax: "max",
        ngPattern: "pattern",
        ngStep: "step"
    };
    forEach({
        data: jqLiteData,
        removeData: jqLiteRemoveData,
        hasData: jqLiteHasData,
        cleanData: function(nodes) {
            for (var i = 0, ii = nodes.length; ii > i; i++) jqLiteRemoveData(nodes[i]), jqLiteOff(nodes[i]);
        }
    }, function(fn, name) {
        JQLite[name] = fn;
    }), forEach({
        data: jqLiteData,
        inheritedData: jqLiteInheritedData,
        scope: function(element) {
            return jqLite.data(element, "$scope") || jqLiteInheritedData(element.parentNode || element, [ "$isolateScope", "$scope" ]);
        },
        isolateScope: function(element) {
            return jqLite.data(element, "$isolateScope") || jqLite.data(element, "$isolateScopeNoTemplate");
        },
        controller: jqLiteController,
        injector: function(element) {
            return jqLiteInheritedData(element, "$injector");
        },
        removeAttr: function(element, name) {
            element.removeAttribute(name);
        },
        hasClass: jqLiteHasClass,
        css: function(element, name, value) {
            return name = cssKebabToCamel(name), isDefined(value) ? void (element.style[name] = value) : element.style[name];
        },
        attr: function(element, name, value) {
            var ret, nodeType = element.nodeType;
            if (nodeType !== NODE_TYPE_TEXT && nodeType !== NODE_TYPE_ATTRIBUTE && nodeType !== NODE_TYPE_COMMENT && element.getAttribute) {
                var lowercasedName = lowercase(name), isBooleanAttr = BOOLEAN_ATTR[lowercasedName];
                return isDefined(value) ? void (null === value || value === !1 && isBooleanAttr ? element.removeAttribute(name) : element.setAttribute(name, isBooleanAttr ? lowercasedName : value)) : (ret = element.getAttribute(name), 
                isBooleanAttr && null !== ret && (ret = lowercasedName), null === ret ? void 0 : ret);
            }
        },
        prop: function(element, name, value) {
            return isDefined(value) ? void (element[name] = value) : element[name];
        },
        text: function() {
            function getText(element, value) {
                if (isUndefined(value)) {
                    var nodeType = element.nodeType;
                    return nodeType === NODE_TYPE_ELEMENT || nodeType === NODE_TYPE_TEXT ? element.textContent : "";
                }
                element.textContent = value;
            }
            return getText.$dv = "", getText;
        }(),
        val: function(element, value) {
            if (isUndefined(value)) {
                if (element.multiple && "select" === nodeName_(element)) {
                    var result = [];
                    return forEach(element.options, function(option) {
                        option.selected && result.push(option.value || option.text);
                    }), result;
                }
                return element.value;
            }
            element.value = value;
        },
        html: function(element, value) {
            return isUndefined(value) ? element.innerHTML : (jqLiteDealoc(element, !0), void (element.innerHTML = value));
        },
        empty: jqLiteEmpty
    }, function(fn, name) {
        JQLite.prototype[name] = function(arg1, arg2) {
            var i, key, nodeCount = this.length;
            if (fn !== jqLiteEmpty && isUndefined(2 === fn.length && fn !== jqLiteHasClass && fn !== jqLiteController ? arg1 : arg2)) {
                if (isObject(arg1)) {
                    for (i = 0; nodeCount > i; i++) if (fn === jqLiteData) fn(this[i], arg1); else for (key in arg1) fn(this[i], key, arg1[key]);
                    return this;
                }
                for (var value = fn.$dv, jj = isUndefined(value) ? Math.min(nodeCount, 1) : nodeCount, j = 0; jj > j; j++) {
                    var nodeValue = fn(this[j], arg1, arg2);
                    value = value ? value + nodeValue : nodeValue;
                }
                return value;
            }
            for (i = 0; nodeCount > i; i++) fn(this[i], arg1, arg2);
            return this;
        };
    }), forEach({
        removeData: jqLiteRemoveData,
        on: function(element, type, fn, unsupported) {
            if (isDefined(unsupported)) throw jqLiteMinErr("onargs", "jqLite#on() does not support the `selector` or `eventData` parameters");
            if (jqLiteAcceptsData(element)) {
                var expandoStore = jqLiteExpandoStore(element, !0), events = expandoStore.events, handle = expandoStore.handle;
                handle || (handle = expandoStore.handle = createEventHandler(element, events));
                for (var types = type.indexOf(" ") >= 0 ? type.split(" ") : [ type ], i = types.length, addHandler = function(type, specialHandlerWrapper, noEventListener) {
                    var eventFns = events[type];
                    eventFns || (eventFns = events[type] = [], eventFns.specialHandlerWrapper = specialHandlerWrapper, 
                    "$destroy" === type || noEventListener || element.addEventListener(type, handle)), 
                    eventFns.push(fn);
                }; i--; ) type = types[i], MOUSE_EVENT_MAP[type] ? (addHandler(MOUSE_EVENT_MAP[type], specialMouseHandlerWrapper), 
                addHandler(type, void 0, !0)) : addHandler(type);
            }
        },
        off: jqLiteOff,
        one: function(element, type, fn) {
            element = jqLite(element), element.on(type, function onFn() {
                element.off(type, fn), element.off(type, onFn);
            }), element.on(type, fn);
        },
        replaceWith: function(element, replaceNode) {
            var index, parent = element.parentNode;
            jqLiteDealoc(element), forEach(new JQLite(replaceNode), function(node) {
                index ? parent.insertBefore(node, index.nextSibling) : parent.replaceChild(node, element), 
                index = node;
            });
        },
        children: function(element) {
            var children = [];
            return forEach(element.childNodes, function(element) {
                element.nodeType === NODE_TYPE_ELEMENT && children.push(element);
            }), children;
        },
        contents: function(element) {
            return element.contentDocument || element.childNodes || [];
        },
        append: function(element, node) {
            var nodeType = element.nodeType;
            if (nodeType === NODE_TYPE_ELEMENT || nodeType === NODE_TYPE_DOCUMENT_FRAGMENT) {
                node = new JQLite(node);
                for (var i = 0, ii = node.length; ii > i; i++) {
                    var child = node[i];
                    element.appendChild(child);
                }
            }
        },
        prepend: function(element, node) {
            if (element.nodeType === NODE_TYPE_ELEMENT) {
                var index = element.firstChild;
                forEach(new JQLite(node), function(child) {
                    element.insertBefore(child, index);
                });
            }
        },
        wrap: function(element, wrapNode) {
            jqLiteWrapNode(element, jqLite(wrapNode).eq(0).clone()[0]);
        },
        remove: jqLiteRemove,
        detach: function(element) {
            jqLiteRemove(element, !0);
        },
        after: function(element, newElement) {
            var index = element, parent = element.parentNode;
            if (parent) {
                newElement = new JQLite(newElement);
                for (var i = 0, ii = newElement.length; ii > i; i++) {
                    var node = newElement[i];
                    parent.insertBefore(node, index.nextSibling), index = node;
                }
            }
        },
        addClass: jqLiteAddClass,
        removeClass: jqLiteRemoveClass,
        toggleClass: function(element, selector, condition) {
            selector && forEach(selector.split(" "), function(className) {
                var classCondition = condition;
                isUndefined(classCondition) && (classCondition = !jqLiteHasClass(element, className)), 
                (classCondition ? jqLiteAddClass : jqLiteRemoveClass)(element, className);
            });
        },
        parent: function(element) {
            var parent = element.parentNode;
            return parent && parent.nodeType !== NODE_TYPE_DOCUMENT_FRAGMENT ? parent : null;
        },
        next: function(element) {
            return element.nextElementSibling;
        },
        find: function(element, selector) {
            return element.getElementsByTagName ? element.getElementsByTagName(selector) : [];
        },
        clone: jqLiteClone,
        triggerHandler: function(element, event, extraParameters) {
            var dummyEvent, eventFnsCopy, handlerArgs, eventName = event.type || event, expandoStore = jqLiteExpandoStore(element), events = expandoStore && expandoStore.events, eventFns = events && events[eventName];
            eventFns && (dummyEvent = {
                preventDefault: function() {
                    this.defaultPrevented = !0;
                },
                isDefaultPrevented: function() {
                    return this.defaultPrevented === !0;
                },
                stopImmediatePropagation: function() {
                    this.immediatePropagationStopped = !0;
                },
                isImmediatePropagationStopped: function() {
                    return this.immediatePropagationStopped === !0;
                },
                stopPropagation: noop,
                type: eventName,
                target: element
            }, event.type && (dummyEvent = extend(dummyEvent, event)), eventFnsCopy = shallowCopy(eventFns), 
            handlerArgs = extraParameters ? [ dummyEvent ].concat(extraParameters) : [ dummyEvent ], 
            forEach(eventFnsCopy, function(fn) {
                dummyEvent.isImmediatePropagationStopped() || fn.apply(element, handlerArgs);
            }));
        }
    }, function(fn, name) {
        JQLite.prototype[name] = function(arg1, arg2, arg3) {
            for (var value, i = 0, ii = this.length; ii > i; i++) isUndefined(value) ? (value = fn(this[i], arg1, arg2, arg3), 
            isDefined(value) && (value = jqLite(value))) : jqLiteAddNodes(value, fn(this[i], arg1, arg2, arg3));
            return isDefined(value) ? value : this;
        };
    }), JQLite.prototype.bind = JQLite.prototype.on, JQLite.prototype.unbind = JQLite.prototype.off;
    var nanKey = Object.create(null);
    NgMapShim.prototype = {
        _idx: function(key) {
            return key === this._lastKey ? this._lastIndex : (this._lastKey = key, this._lastIndex = this._keys.indexOf(key), 
            this._lastIndex);
        },
        _transformKey: function(key) {
            return isNumberNaN(key) ? nanKey : key;
        },
        get: function(key) {
            key = this._transformKey(key);
            var idx = this._idx(key);
            return -1 !== idx ? this._values[idx] : void 0;
        },
        set: function(key, value) {
            key = this._transformKey(key);
            var idx = this._idx(key);
            -1 === idx && (idx = this._lastIndex = this._keys.length), this._keys[idx] = key, 
            this._values[idx] = value;
        },
        "delete": function(key) {
            key = this._transformKey(key);
            var idx = this._idx(key);
            return -1 === idx ? !1 : (this._keys.splice(idx, 1), this._values.splice(idx, 1), 
            this._lastKey = 0/0, this._lastIndex = -1, !0);
        }
    };
    var NgMap = NgMapShim, $$MapProvider = [ function() {
        this.$get = [ function() {
            return NgMap;
        } ];
    } ], ARROW_ARG = /^([^(]+?)=>/, FN_ARGS = /^[^(]*\(\s*([^)]*)\)/m, FN_ARG_SPLIT = /,/, FN_ARG = /^\s*(_?)(\S+?)\1\s*$/, STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/gm, $injectorMinErr = minErr("$injector");
    createInjector.$$annotate = annotate;
    var $animateMinErr = minErr("$animate"), ELEMENT_NODE = 1, NG_ANIMATE_CLASSNAME = "ng-animate", $$CoreAnimateJsProvider = function() {
        this.$get = noop;
    }, $$CoreAnimateQueueProvider = function() {
        var postDigestQueue = new NgMap(), postDigestElements = [];
        this.$get = [ "$$AnimateRunner", "$rootScope", function($$AnimateRunner, $rootScope) {
            function updateData(data, classes, value) {
                var changed = !1;
                return classes && (classes = isString(classes) ? classes.split(" ") : isArray(classes) ? classes : [], 
                forEach(classes, function(className) {
                    className && (changed = !0, data[className] = value);
                })), changed;
            }
            function handleCSSClassChanges() {
                forEach(postDigestElements, function(element) {
                    var data = postDigestQueue.get(element);
                    if (data) {
                        var existing = splitClasses(element.attr("class")), toAdd = "", toRemove = "";
                        forEach(data, function(status, className) {
                            var hasClass = !!existing[className];
                            status !== hasClass && (status ? toAdd += (toAdd.length ? " " : "") + className : toRemove += (toRemove.length ? " " : "") + className);
                        }), forEach(element, function(elm) {
                            toAdd && jqLiteAddClass(elm, toAdd), toRemove && jqLiteRemoveClass(elm, toRemove);
                        }), postDigestQueue.delete(element);
                    }
                }), postDigestElements.length = 0;
            }
            function addRemoveClassesPostDigest(element, add, remove) {
                var data = postDigestQueue.get(element) || {}, classesAdded = updateData(data, add, !0), classesRemoved = updateData(data, remove, !1);
                (classesAdded || classesRemoved) && (postDigestQueue.set(element, data), postDigestElements.push(element), 
                1 === postDigestElements.length && $rootScope.$$postDigest(handleCSSClassChanges));
            }
            return {
                enabled: noop,
                on: noop,
                off: noop,
                pin: noop,
                push: function(element, event, options, domOperation) {
                    domOperation && domOperation(), options = options || {}, options.from && element.css(options.from), 
                    options.to && element.css(options.to), (options.addClass || options.removeClass) && addRemoveClassesPostDigest(element, options.addClass, options.removeClass);
                    var runner = new $$AnimateRunner();
                    return runner.complete(), runner;
                }
            };
        } ];
    }, $AnimateProvider = [ "$provide", function($provide) {
        var provider = this, classNameFilter = null, customFilter = null;
        this.$$registeredAnimations = Object.create(null), this.register = function(name, factory) {
            if (name && "." !== name.charAt(0)) throw $animateMinErr("notcsel", "Expecting class selector starting with '.' got '{0}'.", name);
            var key = name + "-animation";
            provider.$$registeredAnimations[name.substr(1)] = key, $provide.factory(key, factory);
        }, this.customFilter = function(filterFn) {
            return 1 === arguments.length && (customFilter = isFunction(filterFn) ? filterFn : null), 
            customFilter;
        }, this.classNameFilter = function(expression) {
            if (1 === arguments.length && (classNameFilter = expression instanceof RegExp ? expression : null)) {
                var reservedRegex = new RegExp("[(\\s|\\/)]" + NG_ANIMATE_CLASSNAME + "[(\\s|\\/)]");
                if (reservedRegex.test(classNameFilter.toString())) throw classNameFilter = null, 
                $animateMinErr("nongcls", '$animateProvider.classNameFilter(regex) prohibits accepting a regex value which matches/contains the "{0}" CSS class.', NG_ANIMATE_CLASSNAME);
            }
            return classNameFilter;
        }, this.$get = [ "$$animateQueue", function($$animateQueue) {
            function domInsert(element, parentElement, afterElement) {
                if (afterElement) {
                    var afterNode = extractElementNode(afterElement);
                    !afterNode || afterNode.parentNode || afterNode.previousElementSibling || (afterElement = null);
                }
                afterElement ? afterElement.after(element) : parentElement.prepend(element);
            }
            return {
                on: $$animateQueue.on,
                off: $$animateQueue.off,
                pin: $$animateQueue.pin,
                enabled: $$animateQueue.enabled,
                cancel: function(runner) {
                    runner.cancel && runner.cancel();
                },
                enter: function(element, parent, after, options) {
                    return parent = parent && jqLite(parent), after = after && jqLite(after), parent = parent || after.parent(), 
                    domInsert(element, parent, after), $$animateQueue.push(element, "enter", prepareAnimateOptions(options));
                },
                move: function(element, parent, after, options) {
                    return parent = parent && jqLite(parent), after = after && jqLite(after), parent = parent || after.parent(), 
                    domInsert(element, parent, after), $$animateQueue.push(element, "move", prepareAnimateOptions(options));
                },
                leave: function(element, options) {
                    return $$animateQueue.push(element, "leave", prepareAnimateOptions(options), function() {
                        element.remove();
                    });
                },
                addClass: function(element, className, options) {
                    return options = prepareAnimateOptions(options), options.addClass = mergeClasses(options.addclass, className), 
                    $$animateQueue.push(element, "addClass", options);
                },
                removeClass: function(element, className, options) {
                    return options = prepareAnimateOptions(options), options.removeClass = mergeClasses(options.removeClass, className), 
                    $$animateQueue.push(element, "removeClass", options);
                },
                setClass: function(element, add, remove, options) {
                    return options = prepareAnimateOptions(options), options.addClass = mergeClasses(options.addClass, add), 
                    options.removeClass = mergeClasses(options.removeClass, remove), $$animateQueue.push(element, "setClass", options);
                },
                animate: function(element, from, to, className, options) {
                    return options = prepareAnimateOptions(options), options.from = options.from ? extend(options.from, from) : from, 
                    options.to = options.to ? extend(options.to, to) : to, className = className || "ng-inline-animate", 
                    options.tempClasses = mergeClasses(options.tempClasses, className), $$animateQueue.push(element, "animate", options);
                }
            };
        } ];
    } ], $$AnimateAsyncRunFactoryProvider = function() {
        this.$get = [ "$$rAF", function($$rAF) {
            function waitForTick(fn) {
                waitQueue.push(fn), waitQueue.length > 1 || $$rAF(function() {
                    for (var i = 0; i < waitQueue.length; i++) waitQueue[i]();
                    waitQueue = [];
                });
            }
            var waitQueue = [];
            return function() {
                var passed = !1;
                return waitForTick(function() {
                    passed = !0;
                }), function(callback) {
                    passed ? callback() : waitForTick(callback);
                };
            };
        } ];
    }, $$AnimateRunnerFactoryProvider = function() {
        this.$get = [ "$q", "$sniffer", "$$animateAsyncRun", "$$isDocumentHidden", "$timeout", function($q, $sniffer, $$animateAsyncRun, $$isDocumentHidden, $timeout) {
            function AnimateRunner(host) {
                this.setHost(host);
                var rafTick = $$animateAsyncRun(), timeoutTick = function(fn) {
                    $timeout(fn, 0, !1);
                };
                this._doneCallbacks = [], this._tick = function(fn) {
                    $$isDocumentHidden() ? timeoutTick(fn) : rafTick(fn);
                }, this._state = 0;
            }
            var INITIAL_STATE = 0, DONE_PENDING_STATE = 1, DONE_COMPLETE_STATE = 2;
            return AnimateRunner.chain = function(chain, callback) {
                function next() {
                    return index === chain.length ? void callback(!0) : void chain[index](function(response) {
                        return response === !1 ? void callback(!1) : (index++, void next());
                    });
                }
                var index = 0;
                next();
            }, AnimateRunner.all = function(runners, callback) {
                function onProgress(response) {
                    status = status && response, ++count === runners.length && callback(status);
                }
                var count = 0, status = !0;
                forEach(runners, function(runner) {
                    runner.done(onProgress);
                });
            }, AnimateRunner.prototype = {
                setHost: function(host) {
                    this.host = host || {};
                },
                done: function(fn) {
                    this._state === DONE_COMPLETE_STATE ? fn() : this._doneCallbacks.push(fn);
                },
                progress: noop,
                getPromise: function() {
                    if (!this.promise) {
                        var self = this;
                        this.promise = $q(function(resolve, reject) {
                            self.done(function(status) {
                                status === !1 ? reject() : resolve();
                            });
                        });
                    }
                    return this.promise;
                },
                then: function(resolveHandler, rejectHandler) {
                    return this.getPromise().then(resolveHandler, rejectHandler);
                },
                "catch": function(handler) {
                    return this.getPromise()["catch"](handler);
                },
                "finally": function(handler) {
                    return this.getPromise()["finally"](handler);
                },
                pause: function() {
                    this.host.pause && this.host.pause();
                },
                resume: function() {
                    this.host.resume && this.host.resume();
                },
                end: function() {
                    this.host.end && this.host.end(), this._resolve(!0);
                },
                cancel: function() {
                    this.host.cancel && this.host.cancel(), this._resolve(!1);
                },
                complete: function(response) {
                    var self = this;
                    self._state === INITIAL_STATE && (self._state = DONE_PENDING_STATE, self._tick(function() {
                        self._resolve(response);
                    }));
                },
                _resolve: function(response) {
                    this._state !== DONE_COMPLETE_STATE && (forEach(this._doneCallbacks, function(fn) {
                        fn(response);
                    }), this._doneCallbacks.length = 0, this._state = DONE_COMPLETE_STATE);
                }
            }, AnimateRunner;
        } ];
    }, $CoreAnimateCssProvider = function() {
        this.$get = [ "$$rAF", "$q", "$$AnimateRunner", function($$rAF, $q, $$AnimateRunner) {
            return function(element, initialOptions) {
                function run() {
                    return $$rAF(function() {
                        applyAnimationContents(), closed || runner.complete(), closed = !0;
                    }), runner;
                }
                function applyAnimationContents() {
                    options.addClass && (element.addClass(options.addClass), options.addClass = null), 
                    options.removeClass && (element.removeClass(options.removeClass), options.removeClass = null), 
                    options.to && (element.css(options.to), options.to = null);
                }
                var options = initialOptions || {};
                options.$$prepared || (options = copy(options)), options.cleanupStyles && (options.from = options.to = null), 
                options.from && (element.css(options.from), options.from = null);
                var closed, runner = new $$AnimateRunner();
                return {
                    start: run,
                    end: run
                };
            };
        } ];
    }, $compileMinErr = minErr("$compile"), _UNINITIALIZED_VALUE = new UNINITIALIZED_VALUE();
    $CompileProvider.$inject = [ "$provide", "$$sanitizeUriProvider" ], SimpleChange.prototype.isFirstChange = function() {
        return this.previousValue === _UNINITIALIZED_VALUE;
    };
    var PREFIX_REGEXP = /^((?:x|data)[:\-_])/i, SPECIAL_CHARS_REGEXP = /[:\-_]+(.)/g, $controllerMinErr = minErr("$controller"), CNTRL_REG = /^(\S+)(\s+as\s+([\w$]+))?$/, $$ForceReflowProvider = function() {
        this.$get = [ "$document", function($document) {
            return function(domNode) {
                return domNode ? !domNode.nodeType && domNode instanceof jqLite && (domNode = domNode[0]) : domNode = $document[0].body, 
                domNode.offsetWidth + 1;
            };
        } ];
    }, APPLICATION_JSON = "application/json", CONTENT_TYPE_APPLICATION_JSON = {
        "Content-Type": APPLICATION_JSON + ";charset=utf-8"
    }, JSON_START = /^\[|^\{(?!\{)/, JSON_ENDS = {
        "[": /]$/,
        "{": /}$/
    }, JSON_PROTECTION_PREFIX = /^\)]\}',?\n/, $httpMinErr = minErr("$http"), $interpolateMinErr = angular.$interpolateMinErr = minErr("$interpolate");
    $interpolateMinErr.throwNoconcat = function(text) {
        throw $interpolateMinErr("noconcat", "Error while interpolating: {0}\nStrict Contextual Escaping disallows interpolations that concatenate multiple expressions when a trusted value is required.  See http://docs.angularjs.org/api/ng.$sce", text);
    }, $interpolateMinErr.interr = function(text, err) {
        return $interpolateMinErr("interr", "Can't interpolate: {0}\n{1}", text, err.toString());
    };
    var $intervalMinErr = minErr("$interval"), $jsonpCallbacksProvider = function() {
        this.$get = function() {
            function createCallback(callbackId) {
                var callback = function(data) {
                    callback.data = data, callback.called = !0;
                };
                return callback.id = callbackId, callback;
            }
            var callbacks = angular.callbacks, callbackMap = {};
            return {
                createCallback: function() {
                    var callbackId = "_" + (callbacks.$$counter++).toString(36), callbackPath = "angular.callbacks." + callbackId, callback = createCallback(callbackId);
                    return callbackMap[callbackPath] = callbacks[callbackId] = callback, callbackPath;
                },
                wasCalled: function(callbackPath) {
                    return callbackMap[callbackPath].called;
                },
                getResponse: function(callbackPath) {
                    return callbackMap[callbackPath].data;
                },
                removeCallback: function(callbackPath) {
                    var callback = callbackMap[callbackPath];
                    delete callbacks[callback.id], delete callbackMap[callbackPath];
                }
            };
        };
    }, PATH_MATCH = /^([^?#]*)(\?([^#]*))?(#(.*))?$/, DEFAULT_PORTS = {
        http: 80,
        https: 443,
        ftp: 21
    }, $locationMinErr = minErr("$location"), DOUBLE_SLASH_REGEX = /^\s*[\\/]{2,}/, locationPrototype = {
        $$absUrl: "",
        $$html5: !1,
        $$replace: !1,
        absUrl: locationGetter("$$absUrl"),
        url: function(url) {
            if (isUndefined(url)) return this.$$url;
            var match = PATH_MATCH.exec(url);
            return (match[1] || "" === url) && this.path(decodeURIComponent(match[1])), (match[2] || match[1] || "" === url) && this.search(match[3] || ""), 
            this.hash(match[5] || ""), this;
        },
        protocol: locationGetter("$$protocol"),
        host: locationGetter("$$host"),
        port: locationGetter("$$port"),
        path: locationGetterSetter("$$path", function(path) {
            return path = null !== path ? path.toString() : "", "/" === path.charAt(0) ? path : "/" + path;
        }),
        search: function(search, paramValue) {
            switch (arguments.length) {
              case 0:
                return this.$$search;

              case 1:
                if (isString(search) || isNumber(search)) search = search.toString(), this.$$search = parseKeyValue(search); else {
                    if (!isObject(search)) throw $locationMinErr("isrcharg", "The first argument of the `$location#search()` call must be a string or an object.");
                    search = copy(search, {}), forEach(search, function(value, key) {
                        null == value && delete search[key];
                    }), this.$$search = search;
                }
                break;

              default:
                isUndefined(paramValue) || null === paramValue ? delete this.$$search[search] : this.$$search[search] = paramValue;
            }
            return this.$$compose(), this;
        },
        hash: locationGetterSetter("$$hash", function(hash) {
            return null !== hash ? hash.toString() : "";
        }),
        replace: function() {
            return this.$$replace = !0, this;
        }
    };
    forEach([ LocationHashbangInHtml5Url, LocationHashbangUrl, LocationHtml5Url ], function(Location) {
        Location.prototype = Object.create(locationPrototype), Location.prototype.state = function(state) {
            if (!arguments.length) return this.$$state;
            if (Location !== LocationHtml5Url || !this.$$html5) throw $locationMinErr("nostate", "History API state support is available only in HTML5 mode and only in browsers supporting HTML5 History API");
            return this.$$state = isUndefined(state) ? null : state, this.$$urlUpdatedByLocation = !0, 
            this;
        };
    });
    var $parseMinErr = minErr("$parse"), objectValueOf = {}.constructor.prototype.valueOf, OPERATORS = createMap();
    forEach("+ - * / % === !== == != < > <= >= && || ! = |".split(" "), function(operator) {
        OPERATORS[operator] = !0;
    });
    var ESCAPE = {
        n: "\n",
        f: "\f",
        r: "\r",
        t: "	",
        v: "",
        "'": "'",
        '"': '"'
    }, Lexer = function(options) {
        this.options = options;
    };
    Lexer.prototype = {
        constructor: Lexer,
        lex: function(text) {
            for (this.text = text, this.index = 0, this.tokens = []; this.index < this.text.length; ) {
                var ch = this.text.charAt(this.index);
                if ('"' === ch || "'" === ch) this.readString(ch); else if (this.isNumber(ch) || "." === ch && this.isNumber(this.peek())) this.readNumber(); else if (this.isIdentifierStart(this.peekMultichar())) this.readIdent(); else if (this.is(ch, "(){}[].,;:?")) this.tokens.push({
                    index: this.index,
                    text: ch
                }), this.index++; else if (this.isWhitespace(ch)) this.index++; else {
                    var ch2 = ch + this.peek(), ch3 = ch2 + this.peek(2), op1 = OPERATORS[ch], op2 = OPERATORS[ch2], op3 = OPERATORS[ch3];
                    if (op1 || op2 || op3) {
                        var token = op3 ? ch3 : op2 ? ch2 : ch;
                        this.tokens.push({
                            index: this.index,
                            text: token,
                            operator: !0
                        }), this.index += token.length;
                    } else this.throwError("Unexpected next character ", this.index, this.index + 1);
                }
            }
            return this.tokens;
        },
        is: function(ch, chars) {
            return -1 !== chars.indexOf(ch);
        },
        peek: function(i) {
            var num = i || 1;
            return this.index + num < this.text.length ? this.text.charAt(this.index + num) : !1;
        },
        isNumber: function(ch) {
            return ch >= "0" && "9" >= ch && "string" == typeof ch;
        },
        isWhitespace: function(ch) {
            return " " === ch || "\r" === ch || "	" === ch || "\n" === ch || "" === ch || "" === ch;
        },
        isIdentifierStart: function(ch) {
            return this.options.isIdentifierStart ? this.options.isIdentifierStart(ch, this.codePointAt(ch)) : this.isValidIdentifierStart(ch);
        },
        isValidIdentifierStart: function(ch) {
            return ch >= "a" && "z" >= ch || ch >= "A" && "Z" >= ch || "_" === ch || "$" === ch;
        },
        isIdentifierContinue: function(ch) {
            return this.options.isIdentifierContinue ? this.options.isIdentifierContinue(ch, this.codePointAt(ch)) : this.isValidIdentifierContinue(ch);
        },
        isValidIdentifierContinue: function(ch, cp) {
            return this.isValidIdentifierStart(ch, cp) || this.isNumber(ch);
        },
        codePointAt: function(ch) {
            return 1 === ch.length ? ch.charCodeAt(0) : (ch.charCodeAt(0) << 10) + ch.charCodeAt(1) - 56613888;
        },
        peekMultichar: function() {
            var ch = this.text.charAt(this.index), peek = this.peek();
            if (!peek) return ch;
            var cp1 = ch.charCodeAt(0), cp2 = peek.charCodeAt(0);
            return cp1 >= 55296 && 56319 >= cp1 && cp2 >= 56320 && 57343 >= cp2 ? ch + peek : ch;
        },
        isExpOperator: function(ch) {
            return "-" === ch || "+" === ch || this.isNumber(ch);
        },
        throwError: function(error, start, end) {
            end = end || this.index;
            var colStr = isDefined(start) ? "s " + start + "-" + this.index + " [" + this.text.substring(start, end) + "]" : " " + end;
            throw $parseMinErr("lexerr", "Lexer Error: {0} at column{1} in expression [{2}].", error, colStr, this.text);
        },
        readNumber: function() {
            for (var number = "", start = this.index; this.index < this.text.length; ) {
                var ch = lowercase(this.text.charAt(this.index));
                if ("." === ch || this.isNumber(ch)) number += ch; else {
                    var peekCh = this.peek();
                    if ("e" === ch && this.isExpOperator(peekCh)) number += ch; else if (this.isExpOperator(ch) && peekCh && this.isNumber(peekCh) && "e" === number.charAt(number.length - 1)) number += ch; else {
                        if (!this.isExpOperator(ch) || peekCh && this.isNumber(peekCh) || "e" !== number.charAt(number.length - 1)) break;
                        this.throwError("Invalid exponent");
                    }
                }
                this.index++;
            }
            this.tokens.push({
                index: start,
                text: number,
                constant: !0,
                value: Number(number)
            });
        },
        readIdent: function() {
            var start = this.index;
            for (this.index += this.peekMultichar().length; this.index < this.text.length; ) {
                var ch = this.peekMultichar();
                if (!this.isIdentifierContinue(ch)) break;
                this.index += ch.length;
            }
            this.tokens.push({
                index: start,
                text: this.text.slice(start, this.index),
                identifier: !0
            });
        },
        readString: function(quote) {
            var start = this.index;
            this.index++;
            for (var string = "", rawString = quote, escape = !1; this.index < this.text.length; ) {
                var ch = this.text.charAt(this.index);
                if (rawString += ch, escape) {
                    if ("u" === ch) {
                        var hex = this.text.substring(this.index + 1, this.index + 5);
                        hex.match(/[\da-f]{4}/i) || this.throwError("Invalid unicode escape [\\u" + hex + "]"), 
                        this.index += 4, string += String.fromCharCode(parseInt(hex, 16));
                    } else {
                        var rep = ESCAPE[ch];
                        string += rep || ch;
                    }
                    escape = !1;
                } else if ("\\" === ch) escape = !0; else {
                    if (ch === quote) return this.index++, void this.tokens.push({
                        index: start,
                        text: rawString,
                        constant: !0,
                        value: string
                    });
                    string += ch;
                }
                this.index++;
            }
            this.throwError("Unterminated quote", start);
        }
    };
    var AST = function(lexer, options) {
        this.lexer = lexer, this.options = options;
    };
    AST.Program = "Program", AST.ExpressionStatement = "ExpressionStatement", AST.AssignmentExpression = "AssignmentExpression", 
    AST.ConditionalExpression = "ConditionalExpression", AST.LogicalExpression = "LogicalExpression", 
    AST.BinaryExpression = "BinaryExpression", AST.UnaryExpression = "UnaryExpression", 
    AST.CallExpression = "CallExpression", AST.MemberExpression = "MemberExpression", 
    AST.Identifier = "Identifier", AST.Literal = "Literal", AST.ArrayExpression = "ArrayExpression", 
    AST.Property = "Property", AST.ObjectExpression = "ObjectExpression", AST.ThisExpression = "ThisExpression", 
    AST.LocalsExpression = "LocalsExpression", AST.NGValueParameter = "NGValueParameter", 
    AST.prototype = {
        ast: function(text) {
            this.text = text, this.tokens = this.lexer.lex(text);
            var value = this.program();
            return 0 !== this.tokens.length && this.throwError("is an unexpected token", this.tokens[0]), 
            value;
        },
        program: function() {
            for (var body = []; ;) if (this.tokens.length > 0 && !this.peek("}", ")", ";", "]") && body.push(this.expressionStatement()), 
            !this.expect(";")) return {
                type: AST.Program,
                body: body
            };
        },
        expressionStatement: function() {
            return {
                type: AST.ExpressionStatement,
                expression: this.filterChain()
            };
        },
        filterChain: function() {
            for (var left = this.expression(); this.expect("|"); ) left = this.filter(left);
            return left;
        },
        expression: function() {
            return this.assignment();
        },
        assignment: function() {
            var result = this.ternary();
            if (this.expect("=")) {
                if (!isAssignable(result)) throw $parseMinErr("lval", "Trying to assign a value to a non l-value");
                result = {
                    type: AST.AssignmentExpression,
                    left: result,
                    right: this.assignment(),
                    operator: "="
                };
            }
            return result;
        },
        ternary: function() {
            var alternate, consequent, test = this.logicalOR();
            return this.expect("?") && (alternate = this.expression(), this.consume(":")) ? (consequent = this.expression(), 
            {
                type: AST.ConditionalExpression,
                test: test,
                alternate: alternate,
                consequent: consequent
            }) : test;
        },
        logicalOR: function() {
            for (var left = this.logicalAND(); this.expect("||"); ) left = {
                type: AST.LogicalExpression,
                operator: "||",
                left: left,
                right: this.logicalAND()
            };
            return left;
        },
        logicalAND: function() {
            for (var left = this.equality(); this.expect("&&"); ) left = {
                type: AST.LogicalExpression,
                operator: "&&",
                left: left,
                right: this.equality()
            };
            return left;
        },
        equality: function() {
            for (var token, left = this.relational(); token = this.expect("==", "!=", "===", "!=="); ) left = {
                type: AST.BinaryExpression,
                operator: token.text,
                left: left,
                right: this.relational()
            };
            return left;
        },
        relational: function() {
            for (var token, left = this.additive(); token = this.expect("<", ">", "<=", ">="); ) left = {
                type: AST.BinaryExpression,
                operator: token.text,
                left: left,
                right: this.additive()
            };
            return left;
        },
        additive: function() {
            for (var token, left = this.multiplicative(); token = this.expect("+", "-"); ) left = {
                type: AST.BinaryExpression,
                operator: token.text,
                left: left,
                right: this.multiplicative()
            };
            return left;
        },
        multiplicative: function() {
            for (var token, left = this.unary(); token = this.expect("*", "/", "%"); ) left = {
                type: AST.BinaryExpression,
                operator: token.text,
                left: left,
                right: this.unary()
            };
            return left;
        },
        unary: function() {
            var token;
            return (token = this.expect("+", "-", "!")) ? {
                type: AST.UnaryExpression,
                operator: token.text,
                prefix: !0,
                argument: this.unary()
            } : this.primary();
        },
        primary: function() {
            var primary;
            this.expect("(") ? (primary = this.filterChain(), this.consume(")")) : this.expect("[") ? primary = this.arrayDeclaration() : this.expect("{") ? primary = this.object() : this.selfReferential.hasOwnProperty(this.peek().text) ? primary = copy(this.selfReferential[this.consume().text]) : this.options.literals.hasOwnProperty(this.peek().text) ? primary = {
                type: AST.Literal,
                value: this.options.literals[this.consume().text]
            } : this.peek().identifier ? primary = this.identifier() : this.peek().constant ? primary = this.constant() : this.throwError("not a primary expression", this.peek());
            for (var next; next = this.expect("(", "[", "."); ) "(" === next.text ? (primary = {
                type: AST.CallExpression,
                callee: primary,
                arguments: this.parseArguments()
            }, this.consume(")")) : "[" === next.text ? (primary = {
                type: AST.MemberExpression,
                object: primary,
                property: this.expression(),
                computed: !0
            }, this.consume("]")) : "." === next.text ? primary = {
                type: AST.MemberExpression,
                object: primary,
                property: this.identifier(),
                computed: !1
            } : this.throwError("IMPOSSIBLE");
            return primary;
        },
        filter: function(baseExpression) {
            for (var args = [ baseExpression ], result = {
                type: AST.CallExpression,
                callee: this.identifier(),
                arguments: args,
                filter: !0
            }; this.expect(":"); ) args.push(this.expression());
            return result;
        },
        parseArguments: function() {
            var args = [];
            if (")" !== this.peekToken().text) do args.push(this.filterChain()); while (this.expect(","));
            return args;
        },
        identifier: function() {
            var token = this.consume();
            return token.identifier || this.throwError("is not a valid identifier", token), 
            {
                type: AST.Identifier,
                name: token.text
            };
        },
        constant: function() {
            return {
                type: AST.Literal,
                value: this.consume().value
            };
        },
        arrayDeclaration: function() {
            var elements = [];
            if ("]" !== this.peekToken().text) do {
                if (this.peek("]")) break;
                elements.push(this.expression());
            } while (this.expect(","));
            return this.consume("]"), {
                type: AST.ArrayExpression,
                elements: elements
            };
        },
        object: function() {
            var property, properties = [];
            if ("}" !== this.peekToken().text) do {
                if (this.peek("}")) break;
                property = {
                    type: AST.Property,
                    kind: "init"
                }, this.peek().constant ? (property.key = this.constant(), property.computed = !1, 
                this.consume(":"), property.value = this.expression()) : this.peek().identifier ? (property.key = this.identifier(), 
                property.computed = !1, this.peek(":") ? (this.consume(":"), property.value = this.expression()) : property.value = property.key) : this.peek("[") ? (this.consume("["), 
                property.key = this.expression(), this.consume("]"), property.computed = !0, this.consume(":"), 
                property.value = this.expression()) : this.throwError("invalid key", this.peek()), 
                properties.push(property);
            } while (this.expect(","));
            return this.consume("}"), {
                type: AST.ObjectExpression,
                properties: properties
            };
        },
        throwError: function(msg, token) {
            throw $parseMinErr("syntax", "Syntax Error: Token '{0}' {1} at column {2} of the expression [{3}] starting at [{4}].", token.text, msg, token.index + 1, this.text, this.text.substring(token.index));
        },
        consume: function(e1) {
            if (0 === this.tokens.length) throw $parseMinErr("ueoe", "Unexpected end of expression: {0}", this.text);
            var token = this.expect(e1);
            return token || this.throwError("is unexpected, expecting [" + e1 + "]", this.peek()), 
            token;
        },
        peekToken: function() {
            if (0 === this.tokens.length) throw $parseMinErr("ueoe", "Unexpected end of expression: {0}", this.text);
            return this.tokens[0];
        },
        peek: function(e1, e2, e3, e4) {
            return this.peekAhead(0, e1, e2, e3, e4);
        },
        peekAhead: function(i, e1, e2, e3, e4) {
            if (this.tokens.length > i) {
                var token = this.tokens[i], t = token.text;
                if (t === e1 || t === e2 || t === e3 || t === e4 || !e1 && !e2 && !e3 && !e4) return token;
            }
            return !1;
        },
        expect: function(e1, e2, e3, e4) {
            var token = this.peek(e1, e2, e3, e4);
            return token ? (this.tokens.shift(), token) : !1;
        },
        selfReferential: {
            "this": {
                type: AST.ThisExpression
            },
            $locals: {
                type: AST.LocalsExpression
            }
        }
    };
    var PURITY_ABSOLUTE = 1, PURITY_RELATIVE = 2;
    ASTCompiler.prototype = {
        compile: function(ast) {
            var self = this;
            this.state = {
                nextId: 0,
                filters: {},
                fn: {
                    vars: [],
                    body: [],
                    own: {}
                },
                assign: {
                    vars: [],
                    body: [],
                    own: {}
                },
                inputs: []
            }, findConstantAndWatchExpressions(ast, self.$filter);
            var assignable, extra = "";
            if (this.stage = "assign", assignable = assignableAST(ast)) {
                this.state.computing = "assign";
                var result = this.nextId();
                this.recurse(assignable, result), this.return_(result), extra = "fn.assign=" + this.generateFunction("assign", "s,v,l");
            }
            var toWatch = getInputs(ast.body);
            self.stage = "inputs", forEach(toWatch, function(watch, key) {
                var fnKey = "fn" + key;
                self.state[fnKey] = {
                    vars: [],
                    body: [],
                    own: {}
                }, self.state.computing = fnKey;
                var intoId = self.nextId();
                self.recurse(watch, intoId), self.return_(intoId), self.state.inputs.push({
                    name: fnKey,
                    isPure: watch.isPure
                }), watch.watchId = key;
            }), this.state.computing = "fn", this.stage = "main", this.recurse(ast);
            var fnString = '"' + this.USE + " " + this.STRICT + '";\n' + this.filterPrefix() + "var fn=" + this.generateFunction("fn", "s,l,a,i") + extra + this.watchFns() + "return fn;", fn = new Function("$filter", "getStringValue", "ifDefined", "plus", fnString)(this.$filter, getStringValue, ifDefined, plusFn);
            return this.state = this.stage = void 0, fn;
        },
        USE: "use",
        STRICT: "strict",
        watchFns: function() {
            var result = [], inputs = this.state.inputs, self = this;
            return forEach(inputs, function(input) {
                result.push("var " + input.name + "=" + self.generateFunction(input.name, "s")), 
                input.isPure && result.push(input.name, ".isPure=" + JSON.stringify(input.isPure) + ";");
            }), inputs.length && result.push("fn.inputs=[" + inputs.map(function(i) {
                return i.name;
            }).join(",") + "];"), result.join("");
        },
        generateFunction: function(name, params) {
            return "function(" + params + "){" + this.varsPrefix(name) + this.body(name) + "};";
        },
        filterPrefix: function() {
            var parts = [], self = this;
            return forEach(this.state.filters, function(id, filter) {
                parts.push(id + "=$filter(" + self.escape(filter) + ")");
            }), parts.length ? "var " + parts.join(",") + ";" : "";
        },
        varsPrefix: function(section) {
            return this.state[section].vars.length ? "var " + this.state[section].vars.join(",") + ";" : "";
        },
        body: function(section) {
            return this.state[section].body.join("");
        },
        recurse: function(ast, intoId, nameId, recursionFn, create, skipWatchIdCheck) {
            var left, right, args, expression, computed, self = this;
            if (recursionFn = recursionFn || noop, !skipWatchIdCheck && isDefined(ast.watchId)) return intoId = intoId || this.nextId(), 
            void this.if_("i", this.lazyAssign(intoId, this.computedMember("i", ast.watchId)), this.lazyRecurse(ast, intoId, nameId, recursionFn, create, !0));
            switch (ast.type) {
              case AST.Program:
                forEach(ast.body, function(expression, pos) {
                    self.recurse(expression.expression, void 0, void 0, function(expr) {
                        right = expr;
                    }), pos !== ast.body.length - 1 ? self.current().body.push(right, ";") : self.return_(right);
                });
                break;

              case AST.Literal:
                expression = this.escape(ast.value), this.assign(intoId, expression), recursionFn(intoId || expression);
                break;

              case AST.UnaryExpression:
                this.recurse(ast.argument, void 0, void 0, function(expr) {
                    right = expr;
                }), expression = ast.operator + "(" + this.ifDefined(right, 0) + ")", this.assign(intoId, expression), 
                recursionFn(expression);
                break;

              case AST.BinaryExpression:
                this.recurse(ast.left, void 0, void 0, function(expr) {
                    left = expr;
                }), this.recurse(ast.right, void 0, void 0, function(expr) {
                    right = expr;
                }), expression = "+" === ast.operator ? this.plus(left, right) : "-" === ast.operator ? this.ifDefined(left, 0) + ast.operator + this.ifDefined(right, 0) : "(" + left + ")" + ast.operator + "(" + right + ")", 
                this.assign(intoId, expression), recursionFn(expression);
                break;

              case AST.LogicalExpression:
                intoId = intoId || this.nextId(), self.recurse(ast.left, intoId), self.if_("&&" === ast.operator ? intoId : self.not(intoId), self.lazyRecurse(ast.right, intoId)), 
                recursionFn(intoId);
                break;

              case AST.ConditionalExpression:
                intoId = intoId || this.nextId(), self.recurse(ast.test, intoId), self.if_(intoId, self.lazyRecurse(ast.alternate, intoId), self.lazyRecurse(ast.consequent, intoId)), 
                recursionFn(intoId);
                break;

              case AST.Identifier:
                intoId = intoId || this.nextId(), nameId && (nameId.context = "inputs" === self.stage ? "s" : this.assign(this.nextId(), this.getHasOwnProperty("l", ast.name) + "?l:s"), 
                nameId.computed = !1, nameId.name = ast.name), self.if_("inputs" === self.stage || self.not(self.getHasOwnProperty("l", ast.name)), function() {
                    self.if_("inputs" === self.stage || "s", function() {
                        create && 1 !== create && self.if_(self.isNull(self.nonComputedMember("s", ast.name)), self.lazyAssign(self.nonComputedMember("s", ast.name), "{}")), 
                        self.assign(intoId, self.nonComputedMember("s", ast.name));
                    });
                }, intoId && self.lazyAssign(intoId, self.nonComputedMember("l", ast.name))), recursionFn(intoId);
                break;

              case AST.MemberExpression:
                left = nameId && (nameId.context = this.nextId()) || this.nextId(), intoId = intoId || this.nextId(), 
                self.recurse(ast.object, left, void 0, function() {
                    self.if_(self.notNull(left), function() {
                        ast.computed ? (right = self.nextId(), self.recurse(ast.property, right), self.getStringValue(right), 
                        create && 1 !== create && self.if_(self.not(self.computedMember(left, right)), self.lazyAssign(self.computedMember(left, right), "{}")), 
                        expression = self.computedMember(left, right), self.assign(intoId, expression), 
                        nameId && (nameId.computed = !0, nameId.name = right)) : (create && 1 !== create && self.if_(self.isNull(self.nonComputedMember(left, ast.property.name)), self.lazyAssign(self.nonComputedMember(left, ast.property.name), "{}")), 
                        expression = self.nonComputedMember(left, ast.property.name), self.assign(intoId, expression), 
                        nameId && (nameId.computed = !1, nameId.name = ast.property.name));
                    }, function() {
                        self.assign(intoId, "undefined");
                    }), recursionFn(intoId);
                }, !!create);
                break;

              case AST.CallExpression:
                intoId = intoId || this.nextId(), ast.filter ? (right = self.filter(ast.callee.name), 
                args = [], forEach(ast.arguments, function(expr) {
                    var argument = self.nextId();
                    self.recurse(expr, argument), args.push(argument);
                }), expression = right + "(" + args.join(",") + ")", self.assign(intoId, expression), 
                recursionFn(intoId)) : (right = self.nextId(), left = {}, args = [], self.recurse(ast.callee, right, left, function() {
                    self.if_(self.notNull(right), function() {
                        forEach(ast.arguments, function(expr) {
                            self.recurse(expr, ast.constant ? void 0 : self.nextId(), void 0, function(argument) {
                                args.push(argument);
                            });
                        }), expression = left.name ? self.member(left.context, left.name, left.computed) + "(" + args.join(",") + ")" : right + "(" + args.join(",") + ")", 
                        self.assign(intoId, expression);
                    }, function() {
                        self.assign(intoId, "undefined");
                    }), recursionFn(intoId);
                }));
                break;

              case AST.AssignmentExpression:
                right = this.nextId(), left = {}, this.recurse(ast.left, void 0, left, function() {
                    self.if_(self.notNull(left.context), function() {
                        self.recurse(ast.right, right), expression = self.member(left.context, left.name, left.computed) + ast.operator + right, 
                        self.assign(intoId, expression), recursionFn(intoId || expression);
                    });
                }, 1);
                break;

              case AST.ArrayExpression:
                args = [], forEach(ast.elements, function(expr) {
                    self.recurse(expr, ast.constant ? void 0 : self.nextId(), void 0, function(argument) {
                        args.push(argument);
                    });
                }), expression = "[" + args.join(",") + "]", this.assign(intoId, expression), recursionFn(intoId || expression);
                break;

              case AST.ObjectExpression:
                args = [], computed = !1, forEach(ast.properties, function(property) {
                    property.computed && (computed = !0);
                }), computed ? (intoId = intoId || this.nextId(), this.assign(intoId, "{}"), forEach(ast.properties, function(property) {
                    property.computed ? (left = self.nextId(), self.recurse(property.key, left)) : left = property.key.type === AST.Identifier ? property.key.name : "" + property.key.value, 
                    right = self.nextId(), self.recurse(property.value, right), self.assign(self.member(intoId, left, property.computed), right);
                })) : (forEach(ast.properties, function(property) {
                    self.recurse(property.value, ast.constant ? void 0 : self.nextId(), void 0, function(expr) {
                        args.push(self.escape(property.key.type === AST.Identifier ? property.key.name : "" + property.key.value) + ":" + expr);
                    });
                }), expression = "{" + args.join(",") + "}", this.assign(intoId, expression)), recursionFn(intoId || expression);
                break;

              case AST.ThisExpression:
                this.assign(intoId, "s"), recursionFn(intoId || "s");
                break;

              case AST.LocalsExpression:
                this.assign(intoId, "l"), recursionFn(intoId || "l");
                break;

              case AST.NGValueParameter:
                this.assign(intoId, "v"), recursionFn(intoId || "v");
            }
        },
        getHasOwnProperty: function(element, property) {
            var key = element + "." + property, own = this.current().own;
            return own.hasOwnProperty(key) || (own[key] = this.nextId(!1, element + "&&(" + this.escape(property) + " in " + element + ")")), 
            own[key];
        },
        assign: function(id, value) {
            return id ? (this.current().body.push(id, "=", value, ";"), id) : void 0;
        },
        filter: function(filterName) {
            return this.state.filters.hasOwnProperty(filterName) || (this.state.filters[filterName] = this.nextId(!0)), 
            this.state.filters[filterName];
        },
        ifDefined: function(id, defaultValue) {
            return "ifDefined(" + id + "," + this.escape(defaultValue) + ")";
        },
        plus: function(left, right) {
            return "plus(" + left + "," + right + ")";
        },
        return_: function(id) {
            this.current().body.push("return ", id, ";");
        },
        if_: function(test, alternate, consequent) {
            if (test === !0) alternate(); else {
                var body = this.current().body;
                body.push("if(", test, "){"), alternate(), body.push("}"), consequent && (body.push("else{"), 
                consequent(), body.push("}"));
            }
        },
        not: function(expression) {
            return "!(" + expression + ")";
        },
        isNull: function(expression) {
            return expression + "==null";
        },
        notNull: function(expression) {
            return expression + "!=null";
        },
        nonComputedMember: function(left, right) {
            var SAFE_IDENTIFIER = /^[$_a-zA-Z][$_a-zA-Z0-9]*$/, UNSAFE_CHARACTERS = /[^$_a-zA-Z0-9]/g;
            return SAFE_IDENTIFIER.test(right) ? left + "." + right : left + '["' + right.replace(UNSAFE_CHARACTERS, this.stringEscapeFn) + '"]';
        },
        computedMember: function(left, right) {
            return left + "[" + right + "]";
        },
        member: function(left, right, computed) {
            return computed ? this.computedMember(left, right) : this.nonComputedMember(left, right);
        },
        getStringValue: function(item) {
            this.assign(item, "getStringValue(" + item + ")");
        },
        lazyRecurse: function(ast, intoId, nameId, recursionFn, create, skipWatchIdCheck) {
            var self = this;
            return function() {
                self.recurse(ast, intoId, nameId, recursionFn, create, skipWatchIdCheck);
            };
        },
        lazyAssign: function(id, value) {
            var self = this;
            return function() {
                self.assign(id, value);
            };
        },
        stringEscapeRegex: /[^ a-zA-Z0-9]/g,
        stringEscapeFn: function(c) {
            return "\\u" + ("0000" + c.charCodeAt(0).toString(16)).slice(-4);
        },
        escape: function(value) {
            if (isString(value)) return "'" + value.replace(this.stringEscapeRegex, this.stringEscapeFn) + "'";
            if (isNumber(value)) return value.toString();
            if (value === !0) return "true";
            if (value === !1) return "false";
            if (null === value) return "null";
            if ("undefined" == typeof value) return "undefined";
            throw $parseMinErr("esc", "IMPOSSIBLE");
        },
        nextId: function(skip, init) {
            var id = "v" + this.state.nextId++;
            return skip || this.current().vars.push(id + (init ? "=" + init : "")), id;
        },
        current: function() {
            return this.state[this.state.computing];
        }
    }, ASTInterpreter.prototype = {
        compile: function(ast) {
            var self = this;
            findConstantAndWatchExpressions(ast, self.$filter);
            var assignable, assign;
            (assignable = assignableAST(ast)) && (assign = this.recurse(assignable));
            var inputs, toWatch = getInputs(ast.body);
            toWatch && (inputs = [], forEach(toWatch, function(watch, key) {
                var input = self.recurse(watch);
                input.isPure = watch.isPure, watch.input = input, inputs.push(input), watch.watchId = key;
            }));
            var expressions = [];
            forEach(ast.body, function(expression) {
                expressions.push(self.recurse(expression.expression));
            });
            var fn = 0 === ast.body.length ? noop : 1 === ast.body.length ? expressions[0] : function(scope, locals) {
                var lastValue;
                return forEach(expressions, function(exp) {
                    lastValue = exp(scope, locals);
                }), lastValue;
            };
            return assign && (fn.assign = function(scope, value, locals) {
                return assign(scope, locals, value);
            }), inputs && (fn.inputs = inputs), fn;
        },
        recurse: function(ast, context, create) {
            var left, right, args, self = this;
            if (ast.input) return this.inputs(ast.input, ast.watchId);
            switch (ast.type) {
              case AST.Literal:
                return this.value(ast.value, context);

              case AST.UnaryExpression:
                return right = this.recurse(ast.argument), this["unary" + ast.operator](right, context);

              case AST.BinaryExpression:
                return left = this.recurse(ast.left), right = this.recurse(ast.right), this["binary" + ast.operator](left, right, context);

              case AST.LogicalExpression:
                return left = this.recurse(ast.left), right = this.recurse(ast.right), this["binary" + ast.operator](left, right, context);

              case AST.ConditionalExpression:
                return this["ternary?:"](this.recurse(ast.test), this.recurse(ast.alternate), this.recurse(ast.consequent), context);

              case AST.Identifier:
                return self.identifier(ast.name, context, create);

              case AST.MemberExpression:
                return left = this.recurse(ast.object, !1, !!create), ast.computed || (right = ast.property.name), 
                ast.computed && (right = this.recurse(ast.property)), ast.computed ? this.computedMember(left, right, context, create) : this.nonComputedMember(left, right, context, create);

              case AST.CallExpression:
                return args = [], forEach(ast.arguments, function(expr) {
                    args.push(self.recurse(expr));
                }), ast.filter && (right = this.$filter(ast.callee.name)), ast.filter || (right = this.recurse(ast.callee, !0)), 
                ast.filter ? function(scope, locals, assign, inputs) {
                    for (var values = [], i = 0; i < args.length; ++i) values.push(args[i](scope, locals, assign, inputs));
                    var value = right.apply(void 0, values, inputs);
                    return context ? {
                        context: void 0,
                        name: void 0,
                        value: value
                    } : value;
                } : function(scope, locals, assign, inputs) {
                    var value, rhs = right(scope, locals, assign, inputs);
                    if (null != rhs.value) {
                        for (var values = [], i = 0; i < args.length; ++i) values.push(args[i](scope, locals, assign, inputs));
                        value = rhs.value.apply(rhs.context, values);
                    }
                    return context ? {
                        value: value
                    } : value;
                };

              case AST.AssignmentExpression:
                return left = this.recurse(ast.left, !0, 1), right = this.recurse(ast.right), function(scope, locals, assign, inputs) {
                    var lhs = left(scope, locals, assign, inputs), rhs = right(scope, locals, assign, inputs);
                    return lhs.context[lhs.name] = rhs, context ? {
                        value: rhs
                    } : rhs;
                };

              case AST.ArrayExpression:
                return args = [], forEach(ast.elements, function(expr) {
                    args.push(self.recurse(expr));
                }), function(scope, locals, assign, inputs) {
                    for (var value = [], i = 0; i < args.length; ++i) value.push(args[i](scope, locals, assign, inputs));
                    return context ? {
                        value: value
                    } : value;
                };

              case AST.ObjectExpression:
                return args = [], forEach(ast.properties, function(property) {
                    args.push(property.computed ? {
                        key: self.recurse(property.key),
                        computed: !0,
                        value: self.recurse(property.value)
                    } : {
                        key: property.key.type === AST.Identifier ? property.key.name : "" + property.key.value,
                        computed: !1,
                        value: self.recurse(property.value)
                    });
                }), function(scope, locals, assign, inputs) {
                    for (var value = {}, i = 0; i < args.length; ++i) args[i].computed ? value[args[i].key(scope, locals, assign, inputs)] = args[i].value(scope, locals, assign, inputs) : value[args[i].key] = args[i].value(scope, locals, assign, inputs);
                    return context ? {
                        value: value
                    } : value;
                };

              case AST.ThisExpression:
                return function(scope) {
                    return context ? {
                        value: scope
                    } : scope;
                };

              case AST.LocalsExpression:
                return function(scope, locals) {
                    return context ? {
                        value: locals
                    } : locals;
                };

              case AST.NGValueParameter:
                return function(scope, locals, assign) {
                    return context ? {
                        value: assign
                    } : assign;
                };
            }
        },
        "unary+": function(argument, context) {
            return function(scope, locals, assign, inputs) {
                var arg = argument(scope, locals, assign, inputs);
                return arg = isDefined(arg) ? +arg : 0, context ? {
                    value: arg
                } : arg;
            };
        },
        "unary-": function(argument, context) {
            return function(scope, locals, assign, inputs) {
                var arg = argument(scope, locals, assign, inputs);
                return arg = isDefined(arg) ? -arg : -0, context ? {
                    value: arg
                } : arg;
            };
        },
        "unary!": function(argument, context) {
            return function(scope, locals, assign, inputs) {
                var arg = !argument(scope, locals, assign, inputs);
                return context ? {
                    value: arg
                } : arg;
            };
        },
        "binary+": function(left, right, context) {
            return function(scope, locals, assign, inputs) {
                var lhs = left(scope, locals, assign, inputs), rhs = right(scope, locals, assign, inputs), arg = plusFn(lhs, rhs);
                return context ? {
                    value: arg
                } : arg;
            };
        },
        "binary-": function(left, right, context) {
            return function(scope, locals, assign, inputs) {
                var lhs = left(scope, locals, assign, inputs), rhs = right(scope, locals, assign, inputs), arg = (isDefined(lhs) ? lhs : 0) - (isDefined(rhs) ? rhs : 0);
                return context ? {
                    value: arg
                } : arg;
            };
        },
        "binary*": function(left, right, context) {
            return function(scope, locals, assign, inputs) {
                var arg = left(scope, locals, assign, inputs) * right(scope, locals, assign, inputs);
                return context ? {
                    value: arg
                } : arg;
            };
        },
        "binary/": function(left, right, context) {
            return function(scope, locals, assign, inputs) {
                var arg = left(scope, locals, assign, inputs) / right(scope, locals, assign, inputs);
                return context ? {
                    value: arg
                } : arg;
            };
        },
        "binary%": function(left, right, context) {
            return function(scope, locals, assign, inputs) {
                var arg = left(scope, locals, assign, inputs) % right(scope, locals, assign, inputs);
                return context ? {
                    value: arg
                } : arg;
            };
        },
        "binary===": function(left, right, context) {
            return function(scope, locals, assign, inputs) {
                var arg = left(scope, locals, assign, inputs) === right(scope, locals, assign, inputs);
                return context ? {
                    value: arg
                } : arg;
            };
        },
        "binary!==": function(left, right, context) {
            return function(scope, locals, assign, inputs) {
                var arg = left(scope, locals, assign, inputs) !== right(scope, locals, assign, inputs);
                return context ? {
                    value: arg
                } : arg;
            };
        },
        "binary==": function(left, right, context) {
            return function(scope, locals, assign, inputs) {
                var arg = left(scope, locals, assign, inputs) == right(scope, locals, assign, inputs);
                return context ? {
                    value: arg
                } : arg;
            };
        },
        "binary!=": function(left, right, context) {
            return function(scope, locals, assign, inputs) {
                var arg = left(scope, locals, assign, inputs) != right(scope, locals, assign, inputs);
                return context ? {
                    value: arg
                } : arg;
            };
        },
        "binary<": function(left, right, context) {
            return function(scope, locals, assign, inputs) {
                var arg = left(scope, locals, assign, inputs) < right(scope, locals, assign, inputs);
                return context ? {
                    value: arg
                } : arg;
            };
        },
        "binary>": function(left, right, context) {
            return function(scope, locals, assign, inputs) {
                var arg = left(scope, locals, assign, inputs) > right(scope, locals, assign, inputs);
                return context ? {
                    value: arg
                } : arg;
            };
        },
        "binary<=": function(left, right, context) {
            return function(scope, locals, assign, inputs) {
                var arg = left(scope, locals, assign, inputs) <= right(scope, locals, assign, inputs);
                return context ? {
                    value: arg
                } : arg;
            };
        },
        "binary>=": function(left, right, context) {
            return function(scope, locals, assign, inputs) {
                var arg = left(scope, locals, assign, inputs) >= right(scope, locals, assign, inputs);
                return context ? {
                    value: arg
                } : arg;
            };
        },
        "binary&&": function(left, right, context) {
            return function(scope, locals, assign, inputs) {
                var arg = left(scope, locals, assign, inputs) && right(scope, locals, assign, inputs);
                return context ? {
                    value: arg
                } : arg;
            };
        },
        "binary||": function(left, right, context) {
            return function(scope, locals, assign, inputs) {
                var arg = left(scope, locals, assign, inputs) || right(scope, locals, assign, inputs);
                return context ? {
                    value: arg
                } : arg;
            };
        },
        "ternary?:": function(test, alternate, consequent, context) {
            return function(scope, locals, assign, inputs) {
                var arg = test(scope, locals, assign, inputs) ? alternate(scope, locals, assign, inputs) : consequent(scope, locals, assign, inputs);
                return context ? {
                    value: arg
                } : arg;
            };
        },
        value: function(value, context) {
            return function() {
                return context ? {
                    context: void 0,
                    name: void 0,
                    value: value
                } : value;
            };
        },
        identifier: function(name, context, create) {
            return function(scope, locals) {
                var base = locals && name in locals ? locals : scope;
                create && 1 !== create && base && null == base[name] && (base[name] = {});
                var value = base ? base[name] : void 0;
                return context ? {
                    context: base,
                    name: name,
                    value: value
                } : value;
            };
        },
        computedMember: function(left, right, context, create) {
            return function(scope, locals, assign, inputs) {
                var rhs, value, lhs = left(scope, locals, assign, inputs);
                return null != lhs && (rhs = right(scope, locals, assign, inputs), rhs = getStringValue(rhs), 
                create && 1 !== create && lhs && !lhs[rhs] && (lhs[rhs] = {}), value = lhs[rhs]), 
                context ? {
                    context: lhs,
                    name: rhs,
                    value: value
                } : value;
            };
        },
        nonComputedMember: function(left, right, context, create) {
            return function(scope, locals, assign, inputs) {
                var lhs = left(scope, locals, assign, inputs);
                create && 1 !== create && lhs && null == lhs[right] && (lhs[right] = {});
                var value = null != lhs ? lhs[right] : void 0;
                return context ? {
                    context: lhs,
                    name: right,
                    value: value
                } : value;
            };
        },
        inputs: function(input, watchId) {
            return function(scope, value, locals, inputs) {
                return inputs ? inputs[watchId] : input(scope, value, locals);
            };
        }
    }, Parser.prototype = {
        constructor: Parser,
        parse: function(text) {
            var ast = this.getAst(text), fn = this.astCompiler.compile(ast.ast);
            return fn.literal = isLiteral(ast.ast), fn.constant = isConstant(ast.ast), fn.oneTime = ast.oneTime, 
            fn;
        },
        getAst: function(exp) {
            var oneTime = !1;
            return exp = exp.trim(), ":" === exp.charAt(0) && ":" === exp.charAt(1) && (oneTime = !0, 
            exp = exp.substring(2)), {
                ast: this.ast.ast(exp),
                oneTime: oneTime
            };
        }
    };
    var baseUrlParsingNode, $sceMinErr = minErr("$sce"), SCE_CONTEXTS = {
        HTML: "html",
        CSS: "css",
        MEDIA_URL: "mediaUrl",
        URL: "url",
        RESOURCE_URL: "resourceUrl",
        JS: "js"
    }, UNDERSCORE_LOWERCASE_REGEXP = /_([a-z])/g, $templateRequestMinErr = minErr("$templateRequest"), $timeoutMinErr = minErr("$timeout"), urlParsingNode = window.document.createElement("a"), originUrl = urlResolve(window.location.href);
    $$CookieReader.$inject = [ "$document" ], $FilterProvider.$inject = [ "$provide" ];
    var MAX_DIGITS = 22, DECIMAL_SEP = ".", ZERO_CHAR = "0";
    currencyFilter.$inject = [ "$locale" ], numberFilter.$inject = [ "$locale" ];
    var DATE_FORMATS = {
        yyyy: dateGetter("FullYear", 4, 0, !1, !0),
        yy: dateGetter("FullYear", 2, 0, !0, !0),
        y: dateGetter("FullYear", 1, 0, !1, !0),
        MMMM: dateStrGetter("Month"),
        MMM: dateStrGetter("Month", !0),
        MM: dateGetter("Month", 2, 1),
        M: dateGetter("Month", 1, 1),
        LLLL: dateStrGetter("Month", !1, !0),
        dd: dateGetter("Date", 2),
        d: dateGetter("Date", 1),
        HH: dateGetter("Hours", 2),
        H: dateGetter("Hours", 1),
        hh: dateGetter("Hours", 2, -12),
        h: dateGetter("Hours", 1, -12),
        mm: dateGetter("Minutes", 2),
        m: dateGetter("Minutes", 1),
        ss: dateGetter("Seconds", 2),
        s: dateGetter("Seconds", 1),
        sss: dateGetter("Milliseconds", 3),
        EEEE: dateStrGetter("Day"),
        EEE: dateStrGetter("Day", !0),
        a: ampmGetter,
        Z: timeZoneGetter,
        ww: weekGetter(2),
        w: weekGetter(1),
        G: eraGetter,
        GG: eraGetter,
        GGG: eraGetter,
        GGGG: longEraGetter
    }, DATE_FORMATS_SPLIT = /((?:[^yMLdHhmsaZEwG']+)|(?:'(?:[^']|'')*')|(?:E+|y+|M+|L+|d+|H+|h+|m+|s+|a|Z|G+|w+))([\s\S]*)/, NUMBER_STRING = /^-?\d+$/;
    dateFilter.$inject = [ "$locale" ];
    var lowercaseFilter = valueFn(lowercase), uppercaseFilter = valueFn(uppercase);
    orderByFilter.$inject = [ "$parse" ];
    var htmlAnchorDirective = valueFn({
        restrict: "E",
        compile: function(element, attr) {
            return attr.href || attr.xlinkHref ? void 0 : function(scope, element) {
                if ("a" === element[0].nodeName.toLowerCase()) {
                    var href = "[object SVGAnimatedString]" === toString.call(element.prop("href")) ? "xlink:href" : "href";
                    element.on("click", function(event) {
                        element.attr(href) || event.preventDefault();
                    });
                }
            };
        }
    }), ngAttributeAliasDirectives = {};
    forEach(BOOLEAN_ATTR, function(propName, attrName) {
        function defaultLinkFn(scope, element, attr) {
            scope.$watch(attr[normalized], function(value) {
                attr.$set(attrName, !!value);
            });
        }
        if ("multiple" !== propName) {
            var normalized = directiveNormalize("ng-" + attrName), linkFn = defaultLinkFn;
            "checked" === propName && (linkFn = function(scope, element, attr) {
                attr.ngModel !== attr[normalized] && defaultLinkFn(scope, element, attr);
            }), ngAttributeAliasDirectives[normalized] = function() {
                return {
                    restrict: "A",
                    priority: 100,
                    link: linkFn
                };
            };
        }
    }), forEach(ALIASED_ATTR, function(htmlAttr, ngAttr) {
        ngAttributeAliasDirectives[ngAttr] = function() {
            return {
                priority: 100,
                link: function(scope, element, attr) {
                    if ("ngPattern" === ngAttr && "/" === attr.ngPattern.charAt(0)) {
                        var match = attr.ngPattern.match(REGEX_STRING_REGEXP);
                        if (match) return void attr.$set("ngPattern", new RegExp(match[1], match[2]));
                    }
                    scope.$watch(attr[ngAttr], function(value) {
                        attr.$set(ngAttr, value);
                    });
                }
            };
        };
    }), forEach([ "src", "srcset", "href" ], function(attrName) {
        var normalized = directiveNormalize("ng-" + attrName);
        ngAttributeAliasDirectives[normalized] = function() {
            return {
                priority: 99,
                link: function(scope, element, attr) {
                    var propName = attrName, name = attrName;
                    "href" === attrName && "[object SVGAnimatedString]" === toString.call(element.prop("href")) && (name = "xlinkHref", 
                    attr.$attr[name] = "xlink:href", propName = null), attr.$observe(normalized, function(value) {
                        return value ? (attr.$set(name, value), void (msie && propName && element.prop(propName, attr[name]))) : void ("href" === attrName && attr.$set(name, null));
                    });
                }
            };
        };
    });
    var nullFormCtrl = {
        $addControl: noop,
        $$renameControl: nullFormRenameControl,
        $removeControl: noop,
        $setValidity: noop,
        $setDirty: noop,
        $setPristine: noop,
        $setSubmitted: noop,
        $$setSubmitted: noop
    }, PENDING_CLASS = "ng-pending", SUBMITTED_CLASS = "ng-submitted";
    FormController.$inject = [ "$element", "$attrs", "$scope", "$animate", "$interpolate" ], 
    FormController.prototype = {
        $rollbackViewValue: function() {
            forEach(this.$$controls, function(control) {
                control.$rollbackViewValue();
            });
        },
        $commitViewValue: function() {
            forEach(this.$$controls, function(control) {
                control.$commitViewValue();
            });
        },
        $addControl: function(control) {
            assertNotHasOwnProperty(control.$name, "input"), this.$$controls.push(control), 
            control.$name && (this[control.$name] = control), control.$$parentForm = this;
        },
        $$renameControl: function(control, newName) {
            var oldName = control.$name;
            this[oldName] === control && delete this[oldName], this[newName] = control, control.$name = newName;
        },
        $removeControl: function(control) {
            control.$name && this[control.$name] === control && delete this[control.$name], 
            forEach(this.$pending, function(value, name) {
                this.$setValidity(name, null, control);
            }, this), forEach(this.$error, function(value, name) {
                this.$setValidity(name, null, control);
            }, this), forEach(this.$$success, function(value, name) {
                this.$setValidity(name, null, control);
            }, this), arrayRemove(this.$$controls, control), control.$$parentForm = nullFormCtrl;
        },
        $setDirty: function() {
            this.$$animate.removeClass(this.$$element, PRISTINE_CLASS), this.$$animate.addClass(this.$$element, DIRTY_CLASS), 
            this.$dirty = !0, this.$pristine = !1, this.$$parentForm.$setDirty();
        },
        $setPristine: function() {
            this.$$animate.setClass(this.$$element, PRISTINE_CLASS, DIRTY_CLASS + " " + SUBMITTED_CLASS), 
            this.$dirty = !1, this.$pristine = !0, this.$submitted = !1, forEach(this.$$controls, function(control) {
                control.$setPristine();
            });
        },
        $setUntouched: function() {
            forEach(this.$$controls, function(control) {
                control.$setUntouched();
            });
        },
        $setSubmitted: function() {
            for (var rootForm = this; rootForm.$$parentForm && rootForm.$$parentForm !== nullFormCtrl; ) rootForm = rootForm.$$parentForm;
            rootForm.$$setSubmitted();
        },
        $$setSubmitted: function() {
            this.$$animate.addClass(this.$$element, SUBMITTED_CLASS), this.$submitted = !0, 
            forEach(this.$$controls, function(control) {
                control.$$setSubmitted && control.$$setSubmitted();
            });
        }
    }, addSetValidityMethod({
        clazz: FormController,
        set: function(object, property, controller) {
            var list = object[property];
            if (list) {
                var index = list.indexOf(controller);
                -1 === index && list.push(controller);
            } else object[property] = [ controller ];
        },
        unset: function(object, property, controller) {
            var list = object[property];
            list && (arrayRemove(list, controller), 0 === list.length && delete object[property]);
        }
    });
    var formDirectiveFactory = function(isNgForm) {
        return [ "$timeout", "$parse", function($timeout, $parse) {
            function getSetter(expression) {
                return "" === expression ? $parse('this[""]').assign : $parse(expression).assign || noop;
            }
            var formDirective = {
                name: "form",
                restrict: isNgForm ? "EAC" : "E",
                require: [ "form", "^^?form" ],
                controller: FormController,
                compile: function(formElement, attr) {
                    formElement.addClass(PRISTINE_CLASS).addClass(VALID_CLASS);
                    var nameAttr = attr.name ? "name" : isNgForm && attr.ngForm ? "ngForm" : !1;
                    return {
                        pre: function(scope, formElement, attr, ctrls) {
                            var controller = ctrls[0];
                            if (!("action" in attr)) {
                                var handleFormSubmission = function(event) {
                                    scope.$apply(function() {
                                        controller.$commitViewValue(), controller.$setSubmitted();
                                    }), event.preventDefault();
                                };
                                formElement[0].addEventListener("submit", handleFormSubmission), formElement.on("$destroy", function() {
                                    $timeout(function() {
                                        formElement[0].removeEventListener("submit", handleFormSubmission);
                                    }, 0, !1);
                                });
                            }
                            var parentFormCtrl = ctrls[1] || controller.$$parentForm;
                            parentFormCtrl.$addControl(controller);
                            var setter = nameAttr ? getSetter(controller.$name) : noop;
                            nameAttr && (setter(scope, controller), attr.$observe(nameAttr, function(newValue) {
                                controller.$name !== newValue && (setter(scope, void 0), controller.$$parentForm.$$renameControl(controller, newValue), 
                                (setter = getSetter(controller.$name))(scope, controller));
                            })), formElement.on("$destroy", function() {
                                controller.$$parentForm.$removeControl(controller), setter(scope, void 0), extend(controller, nullFormCtrl);
                            });
                        }
                    };
                }
            };
            return formDirective;
        } ];
    }, formDirective = formDirectiveFactory(), ngFormDirective = formDirectiveFactory(!0), ISO_DATE_REGEXP = /^\d{4,}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+(?:[+-][0-2]\d:[0-5]\d|Z)$/, URL_REGEXP = /^[a-z][a-z\d.+-]*:\/*(?:[^:@]+(?::[^@]+)?@)?(?:[^\s:\/?#]+|\[[a-f\d:]+])(?::\d+)?(?:\/[^?#]*)?(?:\?[^#]*)?(?:#.*)?$/i, EMAIL_REGEXP = /^(?=.{1,254}$)(?=.{1,64}@)[-!#$%&'*+\/0-9=?A-Z^_`a-z{|}~]+(\.[-!#$%&'*+\/0-9=?A-Z^_`a-z{|}~]+)*@[A-Za-z0-9]([A-Za-z0-9-]{0,61}[A-Za-z0-9])?(\.[A-Za-z0-9]([A-Za-z0-9-]{0,61}[A-Za-z0-9])?)*$/, NUMBER_REGEXP = /^\s*(-|\+)?(\d+|(\d*(\.\d*)))([eE][+-]?\d+)?\s*$/, DATE_REGEXP = /^(\d{4,})-(\d{2})-(\d{2})$/, DATETIMELOCAL_REGEXP = /^(\d{4,})-(\d\d)-(\d\d)T(\d\d):(\d\d)(?::(\d\d)(\.\d{1,3})?)?$/, WEEK_REGEXP = /^(\d{4,})-W(\d\d)$/, MONTH_REGEXP = /^(\d{4,})-(\d\d)$/, TIME_REGEXP = /^(\d\d):(\d\d)(?::(\d\d)(\.\d{1,3})?)?$/, PARTIAL_VALIDATION_EVENTS = "keydown wheel mousedown", PARTIAL_VALIDATION_TYPES = createMap();
    forEach("date,datetime-local,month,time,week".split(","), function(type) {
        PARTIAL_VALIDATION_TYPES[type] = !0;
    });
    var inputType = {
        text: textInputType,
        date: createDateInputType("date", DATE_REGEXP, createDateParser(DATE_REGEXP, [ "yyyy", "MM", "dd" ]), "yyyy-MM-dd"),
        "datetime-local": createDateInputType("datetimelocal", DATETIMELOCAL_REGEXP, createDateParser(DATETIMELOCAL_REGEXP, [ "yyyy", "MM", "dd", "HH", "mm", "ss", "sss" ]), "yyyy-MM-ddTHH:mm:ss.sss"),
        time: createDateInputType("time", TIME_REGEXP, createDateParser(TIME_REGEXP, [ "HH", "mm", "ss", "sss" ]), "HH:mm:ss.sss"),
        week: createDateInputType("week", WEEK_REGEXP, weekParser, "yyyy-Www"),
        month: createDateInputType("month", MONTH_REGEXP, createDateParser(MONTH_REGEXP, [ "yyyy", "MM" ]), "yyyy-MM"),
        number: numberInputType,
        url: urlInputType,
        email: emailInputType,
        radio: radioInputType,
        range: rangeInputType,
        checkbox: checkboxInputType,
        hidden: noop,
        button: noop,
        submit: noop,
        reset: noop,
        file: noop
    }, inputDirective = [ "$browser", "$sniffer", "$filter", "$parse", function($browser, $sniffer, $filter, $parse) {
        return {
            restrict: "E",
            require: [ "?ngModel" ],
            link: {
                pre: function(scope, element, attr, ctrls) {
                    ctrls[0] && (inputType[lowercase(attr.type)] || inputType.text)(scope, element, attr, ctrls[0], $sniffer, $browser, $filter, $parse);
                }
            }
        };
    } ], CONSTANT_VALUE_REGEXP = /^(true|false|\d+)$/, ngValueDirective = function() {
        function updateElementValue(element, attr, value) {
            var propValue = isDefined(value) ? value : 9 === msie ? "" : null;
            element.prop("value", propValue), attr.$set("value", value);
        }
        return {
            restrict: "A",
            priority: 100,
            compile: function(tpl, tplAttr) {
                return CONSTANT_VALUE_REGEXP.test(tplAttr.ngValue) ? function(scope, elm, attr) {
                    var value = scope.$eval(attr.ngValue);
                    updateElementValue(elm, attr, value);
                } : function(scope, elm, attr) {
                    scope.$watch(attr.ngValue, function(value) {
                        updateElementValue(elm, attr, value);
                    });
                };
            }
        };
    }, ngBindDirective = [ "$compile", function($compile) {
        return {
            restrict: "AC",
            compile: function(templateElement) {
                return $compile.$$addBindingClass(templateElement), function(scope, element, attr) {
                    $compile.$$addBindingInfo(element, attr.ngBind), element = element[0], scope.$watch(attr.ngBind, function(value) {
                        element.textContent = stringify(value);
                    });
                };
            }
        };
    } ], ngBindTemplateDirective = [ "$interpolate", "$compile", function($interpolate, $compile) {
        return {
            compile: function(templateElement) {
                return $compile.$$addBindingClass(templateElement), function(scope, element, attr) {
                    var interpolateFn = $interpolate(element.attr(attr.$attr.ngBindTemplate));
                    $compile.$$addBindingInfo(element, interpolateFn.expressions), element = element[0], 
                    attr.$observe("ngBindTemplate", function(value) {
                        element.textContent = isUndefined(value) ? "" : value;
                    });
                };
            }
        };
    } ], ngBindHtmlDirective = [ "$sce", "$parse", "$compile", function($sce, $parse, $compile) {
        return {
            restrict: "A",
            compile: function(tElement, tAttrs) {
                var ngBindHtmlGetter = $parse(tAttrs.ngBindHtml), ngBindHtmlWatch = $parse(tAttrs.ngBindHtml, function(val) {
                    return $sce.valueOf(val);
                });
                return $compile.$$addBindingClass(tElement), function(scope, element, attr) {
                    $compile.$$addBindingInfo(element, attr.ngBindHtml), scope.$watch(ngBindHtmlWatch, function() {
                        var value = ngBindHtmlGetter(scope);
                        element.html($sce.getTrustedHtml(value) || "");
                    });
                };
            }
        };
    } ], ngChangeDirective = valueFn({
        restrict: "A",
        require: "ngModel",
        link: function(scope, element, attr, ctrl) {
            ctrl.$viewChangeListeners.push(function() {
                scope.$eval(attr.ngChange);
            });
        }
    }), ngClassDirective = classDirective("", !0), ngClassOddDirective = classDirective("Odd", 0), ngClassEvenDirective = classDirective("Even", 1), ngCloakDirective = ngDirective({
        compile: function(element, attr) {
            attr.$set("ngCloak", void 0), element.removeClass("ng-cloak");
        }
    }), ngControllerDirective = [ function() {
        return {
            restrict: "A",
            scope: !0,
            controller: "@",
            priority: 500
        };
    } ], ngEventDirectives = {}, forceAsyncEvents = {
        blur: !0,
        focus: !0
    };
    forEach("click dblclick mousedown mouseup mouseover mouseout mousemove mouseenter mouseleave keydown keyup keypress submit focus blur copy cut paste".split(" "), function(eventName) {
        var directiveName = directiveNormalize("ng-" + eventName);
        ngEventDirectives[directiveName] = [ "$parse", "$rootScope", function($parse, $rootScope) {
            return {
                restrict: "A",
                compile: function($element, attr) {
                    var fn = $parse(attr[directiveName]);
                    return function(scope, element) {
                        element.on(eventName, function(event) {
                            var callback = function() {
                                fn(scope, {
                                    $event: event
                                });
                            };
                            forceAsyncEvents[eventName] && $rootScope.$$phase ? scope.$evalAsync(callback) : scope.$apply(callback);
                        });
                    };
                }
            };
        } ];
    });
    var ngIfDirective = [ "$animate", "$compile", function($animate, $compile) {
        return {
            multiElement: !0,
            transclude: "element",
            priority: 600,
            terminal: !0,
            restrict: "A",
            $$tlb: !0,
            link: function($scope, $element, $attr, ctrl, $transclude) {
                var block, childScope, previousElements;
                $scope.$watch($attr.ngIf, function(value) {
                    value ? childScope || $transclude(function(clone, newScope) {
                        childScope = newScope, clone[clone.length++] = $compile.$$createComment("end ngIf", $attr.ngIf), 
                        block = {
                            clone: clone
                        }, $animate.enter(clone, $element.parent(), $element);
                    }) : (previousElements && (previousElements.remove(), previousElements = null), 
                    childScope && (childScope.$destroy(), childScope = null), block && (previousElements = getBlockNodes(block.clone), 
                    $animate.leave(previousElements).done(function(response) {
                        response !== !1 && (previousElements = null);
                    }), block = null));
                });
            }
        };
    } ], ngIncludeDirective = [ "$templateRequest", "$anchorScroll", "$animate", function($templateRequest, $anchorScroll, $animate) {
        return {
            restrict: "ECA",
            priority: 400,
            terminal: !0,
            transclude: "element",
            controller: angular.noop,
            compile: function(element, attr) {
                var srcExp = attr.ngInclude || attr.src, onloadExp = attr.onload || "", autoScrollExp = attr.autoscroll;
                return function(scope, $element, $attr, ctrl, $transclude) {
                    var currentScope, previousElement, currentElement, changeCounter = 0, cleanupLastIncludeContent = function() {
                        previousElement && (previousElement.remove(), previousElement = null), currentScope && (currentScope.$destroy(), 
                        currentScope = null), currentElement && ($animate.leave(currentElement).done(function(response) {
                            response !== !1 && (previousElement = null);
                        }), previousElement = currentElement, currentElement = null);
                    };
                    scope.$watch(srcExp, function(src) {
                        var afterAnimation = function(response) {
                            response === !1 || !isDefined(autoScrollExp) || autoScrollExp && !scope.$eval(autoScrollExp) || $anchorScroll();
                        }, thisChangeId = ++changeCounter;
                        src ? ($templateRequest(src, !0).then(function(response) {
                            if (!scope.$$destroyed && thisChangeId === changeCounter) {
                                var newScope = scope.$new();
                                ctrl.template = response;
                                var clone = $transclude(newScope, function(clone) {
                                    cleanupLastIncludeContent(), $animate.enter(clone, null, $element).done(afterAnimation);
                                });
                                currentScope = newScope, currentElement = clone, currentScope.$emit("$includeContentLoaded", src), 
                                scope.$eval(onloadExp);
                            }
                        }, function() {
                            scope.$$destroyed || thisChangeId === changeCounter && (cleanupLastIncludeContent(), 
                            scope.$emit("$includeContentError", src));
                        }), scope.$emit("$includeContentRequested", src)) : (cleanupLastIncludeContent(), 
                        ctrl.template = null);
                    });
                };
            }
        };
    } ], ngIncludeFillContentDirective = [ "$compile", function($compile) {
        return {
            restrict: "ECA",
            priority: -400,
            require: "ngInclude",
            link: function(scope, $element, $attr, ctrl) {
                return toString.call($element[0]).match(/SVG/) ? ($element.empty(), void $compile(jqLiteBuildFragment(ctrl.template, window.document).childNodes)(scope, function(clone) {
                    $element.append(clone);
                }, {
                    futureParentElement: $element
                })) : ($element.html(ctrl.template), void $compile($element.contents())(scope));
            }
        };
    } ], ngInitDirective = ngDirective({
        priority: 450,
        compile: function() {
            return {
                pre: function(scope, element, attrs) {
                    scope.$eval(attrs.ngInit);
                }
            };
        }
    }), ngListDirective = function() {
        return {
            restrict: "A",
            priority: 100,
            require: "ngModel",
            link: function(scope, element, attr, ctrl) {
                var ngList = attr.ngList || ", ", trimValues = "false" !== attr.ngTrim, separator = trimValues ? trim(ngList) : ngList, parse = function(viewValue) {
                    if (!isUndefined(viewValue)) {
                        var list = [];
                        return viewValue && forEach(viewValue.split(separator), function(value) {
                            value && list.push(trimValues ? trim(value) : value);
                        }), list;
                    }
                };
                ctrl.$parsers.push(parse), ctrl.$formatters.push(function(value) {
                    return isArray(value) ? value.join(ngList) : void 0;
                }), ctrl.$isEmpty = function(value) {
                    return !value || !value.length;
                };
            }
        };
    }, VALID_CLASS = "ng-valid", INVALID_CLASS = "ng-invalid", PRISTINE_CLASS = "ng-pristine", DIRTY_CLASS = "ng-dirty", UNTOUCHED_CLASS = "ng-untouched", TOUCHED_CLASS = "ng-touched", EMPTY_CLASS = "ng-empty", NOT_EMPTY_CLASS = "ng-not-empty", ngModelMinErr = minErr("ngModel");
    NgModelController.$inject = [ "$scope", "$exceptionHandler", "$attrs", "$element", "$parse", "$animate", "$timeout", "$q", "$interpolate" ], 
    NgModelController.prototype = {
        $$initGetterSetters: function() {
            if (this.$options.getOption("getterSetter")) {
                var invokeModelGetter = this.$$parse(this.$$attr.ngModel + "()"), invokeModelSetter = this.$$parse(this.$$attr.ngModel + "($$$p)");
                this.$$ngModelGet = function($scope) {
                    var modelValue = this.$$parsedNgModel($scope);
                    return isFunction(modelValue) && (modelValue = invokeModelGetter($scope)), modelValue;
                }, this.$$ngModelSet = function($scope, newValue) {
                    isFunction(this.$$parsedNgModel($scope)) ? invokeModelSetter($scope, {
                        $$$p: newValue
                    }) : this.$$parsedNgModelAssign($scope, newValue);
                };
            } else if (!this.$$parsedNgModel.assign) throw ngModelMinErr("nonassign", "Expression '{0}' is non-assignable. Element: {1}", this.$$attr.ngModel, startingTag(this.$$element));
        },
        $render: noop,
        $isEmpty: function(value) {
            return isUndefined(value) || "" === value || null === value || value !== value;
        },
        $$updateEmptyClasses: function(value) {
            this.$isEmpty(value) ? (this.$$animate.removeClass(this.$$element, NOT_EMPTY_CLASS), 
            this.$$animate.addClass(this.$$element, EMPTY_CLASS)) : (this.$$animate.removeClass(this.$$element, EMPTY_CLASS), 
            this.$$animate.addClass(this.$$element, NOT_EMPTY_CLASS));
        },
        $setPristine: function() {
            this.$dirty = !1, this.$pristine = !0, this.$$animate.removeClass(this.$$element, DIRTY_CLASS), 
            this.$$animate.addClass(this.$$element, PRISTINE_CLASS);
        },
        $setDirty: function() {
            this.$dirty = !0, this.$pristine = !1, this.$$animate.removeClass(this.$$element, PRISTINE_CLASS), 
            this.$$animate.addClass(this.$$element, DIRTY_CLASS), this.$$parentForm.$setDirty();
        },
        $setUntouched: function() {
            this.$touched = !1, this.$untouched = !0, this.$$animate.setClass(this.$$element, UNTOUCHED_CLASS, TOUCHED_CLASS);
        },
        $setTouched: function() {
            this.$touched = !0, this.$untouched = !1, this.$$animate.setClass(this.$$element, TOUCHED_CLASS, UNTOUCHED_CLASS);
        },
        $rollbackViewValue: function() {
            this.$$timeout.cancel(this.$$pendingDebounce), this.$viewValue = this.$$lastCommittedViewValue, 
            this.$render();
        },
        $validate: function() {
            if (!isNumberNaN(this.$modelValue)) {
                var viewValue = this.$$lastCommittedViewValue, modelValue = this.$$rawModelValue, prevValid = this.$valid, prevModelValue = this.$modelValue, allowInvalid = this.$options.getOption("allowInvalid"), that = this;
                this.$$runValidators(modelValue, viewValue, function(allValid) {
                    allowInvalid || prevValid === allValid || (that.$modelValue = allValid ? modelValue : void 0, 
                    that.$modelValue !== prevModelValue && that.$$writeModelToScope());
                });
            }
        },
        $$runValidators: function(modelValue, viewValue, doneCallback) {
            function processParseErrors() {
                var errorKey = that.$$parserName;
                return isUndefined(that.$$parserValid) ? (setValidity(errorKey, null), !0) : (that.$$parserValid || (forEach(that.$validators, function(v, name) {
                    setValidity(name, null);
                }), forEach(that.$asyncValidators, function(v, name) {
                    setValidity(name, null);
                })), setValidity(errorKey, that.$$parserValid), that.$$parserValid);
            }
            function processSyncValidators() {
                var syncValidatorsValid = !0;
                return forEach(that.$validators, function(validator, name) {
                    var result = Boolean(validator(modelValue, viewValue));
                    syncValidatorsValid = syncValidatorsValid && result, setValidity(name, result);
                }), syncValidatorsValid ? !0 : (forEach(that.$asyncValidators, function(v, name) {
                    setValidity(name, null);
                }), !1);
            }
            function processAsyncValidators() {
                var validatorPromises = [], allValid = !0;
                forEach(that.$asyncValidators, function(validator, name) {
                    var promise = validator(modelValue, viewValue);
                    if (!isPromiseLike(promise)) throw ngModelMinErr("nopromise", "Expected asynchronous validator to return a promise but got '{0}' instead.", promise);
                    setValidity(name, void 0), validatorPromises.push(promise.then(function() {
                        setValidity(name, !0);
                    }, function() {
                        allValid = !1, setValidity(name, !1);
                    }));
                }), validatorPromises.length ? that.$$q.all(validatorPromises).then(function() {
                    validationDone(allValid);
                }, noop) : validationDone(!0);
            }
            function setValidity(name, isValid) {
                localValidationRunId === that.$$currentValidationRunId && that.$setValidity(name, isValid);
            }
            function validationDone(allValid) {
                localValidationRunId === that.$$currentValidationRunId && doneCallback(allValid);
            }
            this.$$currentValidationRunId++;
            var localValidationRunId = this.$$currentValidationRunId, that = this;
            return processParseErrors() && processSyncValidators() ? void processAsyncValidators() : void validationDone(!1);
        },
        $commitViewValue: function() {
            var viewValue = this.$viewValue;
            this.$$timeout.cancel(this.$$pendingDebounce), (this.$$lastCommittedViewValue !== viewValue || "" === viewValue && this.$$hasNativeValidators) && (this.$$updateEmptyClasses(viewValue), 
            this.$$lastCommittedViewValue = viewValue, this.$pristine && this.$setDirty(), this.$$parseAndValidate());
        },
        $$parseAndValidate: function() {
            function writeToModelIfNeeded() {
                that.$modelValue !== prevModelValue && that.$$writeModelToScope();
            }
            var viewValue = this.$$lastCommittedViewValue, modelValue = viewValue, that = this;
            if (this.$$parserValid = isUndefined(modelValue) ? void 0 : !0, this.$setValidity(this.$$parserName, null), 
            this.$$parserName = "parse", this.$$parserValid) for (var i = 0; i < this.$parsers.length; i++) if (modelValue = this.$parsers[i](modelValue), 
            isUndefined(modelValue)) {
                this.$$parserValid = !1;
                break;
            }
            isNumberNaN(this.$modelValue) && (this.$modelValue = this.$$ngModelGet(this.$$scope));
            var prevModelValue = this.$modelValue, allowInvalid = this.$options.getOption("allowInvalid");
            this.$$rawModelValue = modelValue, allowInvalid && (this.$modelValue = modelValue, 
            writeToModelIfNeeded()), this.$$runValidators(modelValue, this.$$lastCommittedViewValue, function(allValid) {
                allowInvalid || (that.$modelValue = allValid ? modelValue : void 0, writeToModelIfNeeded());
            });
        },
        $$writeModelToScope: function() {
            this.$$ngModelSet(this.$$scope, this.$modelValue), forEach(this.$viewChangeListeners, function(listener) {
                try {
                    listener();
                } catch (e) {
                    this.$$exceptionHandler(e);
                }
            }, this);
        },
        $setViewValue: function(value, trigger) {
            this.$viewValue = value, this.$options.getOption("updateOnDefault") && this.$$debounceViewValueCommit(trigger);
        },
        $$debounceViewValueCommit: function(trigger) {
            var debounceDelay = this.$options.getOption("debounce");
            isNumber(debounceDelay[trigger]) ? debounceDelay = debounceDelay[trigger] : isNumber(debounceDelay["default"]) && -1 === this.$options.getOption("updateOn").indexOf(trigger) ? debounceDelay = debounceDelay["default"] : isNumber(debounceDelay["*"]) && (debounceDelay = debounceDelay["*"]), 
            this.$$timeout.cancel(this.$$pendingDebounce);
            var that = this;
            debounceDelay > 0 ? this.$$pendingDebounce = this.$$timeout(function() {
                that.$commitViewValue();
            }, debounceDelay) : this.$$rootScope.$$phase ? this.$commitViewValue() : this.$$scope.$apply(function() {
                that.$commitViewValue();
            });
        },
        $overrideModelOptions: function(options) {
            this.$options = this.$options.createChild(options), this.$$setUpdateOnEvents();
        },
        $processModelValue: function() {
            var viewValue = this.$$format();
            this.$viewValue !== viewValue && (this.$$updateEmptyClasses(viewValue), this.$viewValue = this.$$lastCommittedViewValue = viewValue, 
            this.$render(), this.$$runValidators(this.$modelValue, this.$viewValue, noop));
        },
        $$format: function() {
            for (var formatters = this.$formatters, idx = formatters.length, viewValue = this.$modelValue; idx--; ) viewValue = formatters[idx](viewValue);
            return viewValue;
        },
        $$setModelValue: function(modelValue) {
            this.$modelValue = this.$$rawModelValue = modelValue, this.$$parserValid = void 0, 
            this.$processModelValue();
        },
        $$setUpdateOnEvents: function() {
            this.$$updateEvents && this.$$element.off(this.$$updateEvents, this.$$updateEventHandler), 
            this.$$updateEvents = this.$options.getOption("updateOn"), this.$$updateEvents && this.$$element.on(this.$$updateEvents, this.$$updateEventHandler);
        },
        $$updateEventHandler: function(ev) {
            this.$$debounceViewValueCommit(ev && ev.type);
        }
    }, addSetValidityMethod({
        clazz: NgModelController,
        set: function(object, property) {
            object[property] = !0;
        },
        unset: function(object, property) {
            delete object[property];
        }
    });
    var defaultModelOptions, ngModelDirective = [ "$rootScope", function($rootScope) {
        return {
            restrict: "A",
            require: [ "ngModel", "^?form", "^?ngModelOptions" ],
            controller: NgModelController,
            priority: 1,
            compile: function(element) {
                return element.addClass(PRISTINE_CLASS).addClass(UNTOUCHED_CLASS).addClass(VALID_CLASS), 
                {
                    pre: function(scope, element, attr, ctrls) {
                        var modelCtrl = ctrls[0], formCtrl = ctrls[1] || modelCtrl.$$parentForm, optionsCtrl = ctrls[2];
                        optionsCtrl && (modelCtrl.$options = optionsCtrl.$options), modelCtrl.$$initGetterSetters(), 
                        formCtrl.$addControl(modelCtrl), attr.$observe("name", function(newValue) {
                            modelCtrl.$name !== newValue && modelCtrl.$$parentForm.$$renameControl(modelCtrl, newValue);
                        }), scope.$on("$destroy", function() {
                            modelCtrl.$$parentForm.$removeControl(modelCtrl);
                        });
                    },
                    post: function(scope, element, attr, ctrls) {
                        function setTouched() {
                            modelCtrl.$setTouched();
                        }
                        var modelCtrl = ctrls[0];
                        modelCtrl.$$setUpdateOnEvents(), element.on("blur", function() {
                            modelCtrl.$touched || ($rootScope.$$phase ? scope.$evalAsync(setTouched) : scope.$apply(setTouched));
                        });
                    }
                };
            }
        };
    } ], DEFAULT_REGEXP = /(\s+|^)default(\s+|$)/;
    ModelOptions.prototype = {
        getOption: function(name) {
            return this.$$options[name];
        },
        createChild: function(options) {
            var inheritAll = !1;
            return options = extend({}, options), forEach(options, function(option, key) {
                "$inherit" === option ? "*" === key ? inheritAll = !0 : (options[key] = this.$$options[key], 
                "updateOn" === key && (options.updateOnDefault = this.$$options.updateOnDefault)) : "updateOn" === key && (options.updateOnDefault = !1, 
                options[key] = trim(option.replace(DEFAULT_REGEXP, function() {
                    return options.updateOnDefault = !0, " ";
                })));
            }, this), inheritAll && (delete options["*"], defaults(options, this.$$options)), 
            defaults(options, defaultModelOptions.$$options), new ModelOptions(options);
        }
    }, defaultModelOptions = new ModelOptions({
        updateOn: "",
        updateOnDefault: !0,
        debounce: 0,
        getterSetter: !1,
        allowInvalid: !1,
        timezone: null
    });
    var ngModelOptionsDirective = function() {
        function NgModelOptionsController($attrs, $scope) {
            this.$$attrs = $attrs, this.$$scope = $scope;
        }
        return NgModelOptionsController.$inject = [ "$attrs", "$scope" ], NgModelOptionsController.prototype = {
            $onInit: function() {
                var parentOptions = this.parentCtrl ? this.parentCtrl.$options : defaultModelOptions, modelOptionsDefinition = this.$$scope.$eval(this.$$attrs.ngModelOptions);
                this.$options = parentOptions.createChild(modelOptionsDefinition);
            }
        }, {
            restrict: "A",
            priority: 10,
            require: {
                parentCtrl: "?^^ngModelOptions"
            },
            bindToController: !0,
            controller: NgModelOptionsController
        };
    }, ngNonBindableDirective = ngDirective({
        terminal: !0,
        priority: 1e3
    }), ngOptionsMinErr = minErr("ngOptions"), NG_OPTIONS_REGEXP = /^\s*([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+group\s+by\s+([\s\S]+?))?(?:\s+disable\s+when\s+([\s\S]+?))?\s+for\s+(?:([$\w][$\w]*)|(?:\(\s*([$\w][$\w]*)\s*,\s*([$\w][$\w]*)\s*\)))\s+in\s+([\s\S]+?)(?:\s+track\s+by\s+([\s\S]+?))?$/, ngOptionsDirective = [ "$compile", "$document", "$parse", function($compile, $document, $parse) {
        function parseOptionsExpression(optionsExp, selectElement, scope) {
            function Option(selectValue, viewValue, label, group, disabled) {
                this.selectValue = selectValue, this.viewValue = viewValue, this.label = label, 
                this.group = group, this.disabled = disabled;
            }
            function getOptionValuesKeys(optionValues) {
                var optionValuesKeys;
                if (!keyName && isArrayLike(optionValues)) optionValuesKeys = optionValues; else {
                    optionValuesKeys = [];
                    for (var itemKey in optionValues) optionValues.hasOwnProperty(itemKey) && "$" !== itemKey.charAt(0) && optionValuesKeys.push(itemKey);
                }
                return optionValuesKeys;
            }
            var match = optionsExp.match(NG_OPTIONS_REGEXP);
            if (!match) throw ngOptionsMinErr("iexp", "Expected expression in form of '_select_ (as _label_)? for (_key_,)?_value_ in _collection_' but got '{0}'. Element: {1}", optionsExp, startingTag(selectElement));
            var valueName = match[5] || match[7], keyName = match[6], selectAs = / as /.test(match[0]) && match[1], trackBy = match[9], valueFn = $parse(match[2] ? match[1] : valueName), selectAsFn = selectAs && $parse(selectAs), viewValueFn = selectAsFn || valueFn, trackByFn = trackBy && $parse(trackBy), getTrackByValueFn = trackBy ? function(value, locals) {
                return trackByFn(scope, locals);
            } : function(value) {
                return hashKey(value);
            }, getTrackByValue = function(value, key) {
                return getTrackByValueFn(value, getLocals(value, key));
            }, displayFn = $parse(match[2] || match[1]), groupByFn = $parse(match[3] || ""), disableWhenFn = $parse(match[4] || ""), valuesFn = $parse(match[8]), locals = {}, getLocals = keyName ? function(value, key) {
                return locals[keyName] = key, locals[valueName] = value, locals;
            } : function(value) {
                return locals[valueName] = value, locals;
            };
            return {
                trackBy: trackBy,
                getTrackByValue: getTrackByValue,
                getWatchables: $parse(valuesFn, function(optionValues) {
                    var watchedArray = [];
                    optionValues = optionValues || [];
                    for (var optionValuesKeys = getOptionValuesKeys(optionValues), optionValuesLength = optionValuesKeys.length, index = 0; optionValuesLength > index; index++) {
                        var key = optionValues === optionValuesKeys ? index : optionValuesKeys[index], value = optionValues[key], locals = getLocals(value, key), selectValue = getTrackByValueFn(value, locals);
                        if (watchedArray.push(selectValue), match[2] || match[1]) {
                            var label = displayFn(scope, locals);
                            watchedArray.push(label);
                        }
                        if (match[4]) {
                            var disableWhen = disableWhenFn(scope, locals);
                            watchedArray.push(disableWhen);
                        }
                    }
                    return watchedArray;
                }),
                getOptions: function() {
                    for (var optionItems = [], selectValueMap = {}, optionValues = valuesFn(scope) || [], optionValuesKeys = getOptionValuesKeys(optionValues), optionValuesLength = optionValuesKeys.length, index = 0; optionValuesLength > index; index++) {
                        var key = optionValues === optionValuesKeys ? index : optionValuesKeys[index], value = optionValues[key], locals = getLocals(value, key), viewValue = viewValueFn(scope, locals), selectValue = getTrackByValueFn(viewValue, locals), label = displayFn(scope, locals), group = groupByFn(scope, locals), disabled = disableWhenFn(scope, locals), optionItem = new Option(selectValue, viewValue, label, group, disabled);
                        optionItems.push(optionItem), selectValueMap[selectValue] = optionItem;
                    }
                    return {
                        items: optionItems,
                        selectValueMap: selectValueMap,
                        getOptionFromViewValue: function(value) {
                            return selectValueMap[getTrackByValue(value)];
                        },
                        getViewValueFromOption: function(option) {
                            return trackBy ? copy(option.viewValue) : option.viewValue;
                        }
                    };
                }
            };
        }
        function ngOptionsPostLink(scope, selectElement, attr, ctrls) {
            function addOptionElement(option, parent) {
                var optionElement = optionTemplate.cloneNode(!1);
                parent.appendChild(optionElement), updateOptionElement(option, optionElement);
            }
            function getAndUpdateSelectedOption(viewValue) {
                var option = options.getOptionFromViewValue(viewValue), element = option && option.element;
                return element && !element.selected && (element.selected = !0), option;
            }
            function updateOptionElement(option, element) {
                option.element = element, element.disabled = option.disabled, option.label !== element.label && (element.label = option.label, 
                element.textContent = option.label), element.value = option.selectValue;
            }
            function updateOptions() {
                var previousValue = options && selectCtrl.readValue();
                if (options) for (var i = options.items.length - 1; i >= 0; i--) {
                    var option = options.items[i];
                    jqLiteRemove(isDefined(option.group) ? option.element.parentNode : option.element);
                }
                options = ngOptions.getOptions();
                var groupElementMap = {};
                if (options.items.forEach(function(option) {
                    var groupElement;
                    isDefined(option.group) ? (groupElement = groupElementMap[option.group], groupElement || (groupElement = optGroupTemplate.cloneNode(!1), 
                    listFragment.appendChild(groupElement), groupElement.label = null === option.group ? "null" : option.group, 
                    groupElementMap[option.group] = groupElement), addOptionElement(option, groupElement)) : addOptionElement(option, listFragment);
                }), selectElement[0].appendChild(listFragment), ngModelCtrl.$render(), !ngModelCtrl.$isEmpty(previousValue)) {
                    var nextValue = selectCtrl.readValue(), isNotPrimitive = ngOptions.trackBy || multiple;
                    (isNotPrimitive ? equals(previousValue, nextValue) : previousValue === nextValue) || (ngModelCtrl.$setViewValue(nextValue), 
                    ngModelCtrl.$render());
                }
            }
            for (var selectCtrl = ctrls[0], ngModelCtrl = ctrls[1], multiple = attr.multiple, i = 0, children = selectElement.children(), ii = children.length; ii > i; i++) if ("" === children[i].value) {
                selectCtrl.hasEmptyOption = !0, selectCtrl.emptyOption = children.eq(i);
                break;
            }
            selectElement.empty();
            var providedEmptyOption = !!selectCtrl.emptyOption, unknownOption = jqLite(optionTemplate.cloneNode(!1));
            unknownOption.val("?");
            var options, ngOptions = parseOptionsExpression(attr.ngOptions, selectElement, scope), listFragment = $document[0].createDocumentFragment();
            selectCtrl.generateUnknownOptionValue = function() {
                return "?";
            }, multiple ? (selectCtrl.writeValue = function(values) {
                if (options) {
                    var selectedOptions = values && values.map(getAndUpdateSelectedOption) || [];
                    options.items.forEach(function(option) {
                        option.element.selected && !includes(selectedOptions, option) && (option.element.selected = !1);
                    });
                }
            }, selectCtrl.readValue = function() {
                var selectedValues = selectElement.val() || [], selections = [];
                return forEach(selectedValues, function(value) {
                    var option = options.selectValueMap[value];
                    option && !option.disabled && selections.push(options.getViewValueFromOption(option));
                }), selections;
            }, ngOptions.trackBy && scope.$watchCollection(function() {
                return isArray(ngModelCtrl.$viewValue) ? ngModelCtrl.$viewValue.map(function(value) {
                    return ngOptions.getTrackByValue(value);
                }) : void 0;
            }, function() {
                ngModelCtrl.$render();
            })) : (selectCtrl.writeValue = function(value) {
                if (options) {
                    var selectedOption = selectElement[0].options[selectElement[0].selectedIndex], option = options.getOptionFromViewValue(value);
                    selectedOption && selectedOption.removeAttribute("selected"), option ? (selectElement[0].value !== option.selectValue && (selectCtrl.removeUnknownOption(), 
                    selectElement[0].value = option.selectValue, option.element.selected = !0), option.element.setAttribute("selected", "selected")) : selectCtrl.selectUnknownOrEmptyOption(value);
                }
            }, selectCtrl.readValue = function() {
                var selectedOption = options.selectValueMap[selectElement.val()];
                return selectedOption && !selectedOption.disabled ? (selectCtrl.unselectEmptyOption(), 
                selectCtrl.removeUnknownOption(), options.getViewValueFromOption(selectedOption)) : null;
            }, ngOptions.trackBy && scope.$watch(function() {
                return ngOptions.getTrackByValue(ngModelCtrl.$viewValue);
            }, function() {
                ngModelCtrl.$render();
            })), providedEmptyOption && ($compile(selectCtrl.emptyOption)(scope), selectElement.prepend(selectCtrl.emptyOption), 
            selectCtrl.emptyOption[0].nodeType === NODE_TYPE_COMMENT ? (selectCtrl.hasEmptyOption = !1, 
            selectCtrl.registerOption = function(optionScope, optionEl) {
                "" === optionEl.val() && (selectCtrl.hasEmptyOption = !0, selectCtrl.emptyOption = optionEl, 
                selectCtrl.emptyOption.removeClass("ng-scope"), ngModelCtrl.$render(), optionEl.on("$destroy", function() {
                    var needsRerender = selectCtrl.$isEmptyOptionSelected();
                    selectCtrl.hasEmptyOption = !1, selectCtrl.emptyOption = void 0, needsRerender && ngModelCtrl.$render();
                }));
            }) : selectCtrl.emptyOption.removeClass("ng-scope")), scope.$watchCollection(ngOptions.getWatchables, updateOptions);
        }
        var optionTemplate = window.document.createElement("option"), optGroupTemplate = window.document.createElement("optgroup");
        return {
            restrict: "A",
            terminal: !0,
            require: [ "select", "ngModel" ],
            link: {
                pre: function(scope, selectElement, attr, ctrls) {
                    ctrls[0].registerOption = noop;
                },
                post: ngOptionsPostLink
            }
        };
    } ], ngPluralizeDirective = [ "$locale", "$interpolate", "$log", function($locale, $interpolate, $log) {
        var BRACE = /{}/g, IS_WHEN = /^when(Minus)?(.+)$/;
        return {
            link: function(scope, element, attr) {
                function updateElementText(newText) {
                    element.text(newText || "");
                }
                var lastCount, numberExp = attr.count, whenExp = attr.$attr.when && element.attr(attr.$attr.when), offset = attr.offset || 0, whens = scope.$eval(whenExp) || {}, whensExpFns = {}, startSymbol = $interpolate.startSymbol(), endSymbol = $interpolate.endSymbol(), braceReplacement = startSymbol + numberExp + "-" + offset + endSymbol, watchRemover = angular.noop;
                forEach(attr, function(expression, attributeName) {
                    var tmpMatch = IS_WHEN.exec(attributeName);
                    if (tmpMatch) {
                        var whenKey = (tmpMatch[1] ? "-" : "") + lowercase(tmpMatch[2]);
                        whens[whenKey] = element.attr(attr.$attr[attributeName]);
                    }
                }), forEach(whens, function(expression, key) {
                    whensExpFns[key] = $interpolate(expression.replace(BRACE, braceReplacement));
                }), scope.$watch(numberExp, function(newVal) {
                    var count = parseFloat(newVal), countIsNaN = isNumberNaN(count);
                    if (countIsNaN || count in whens || (count = $locale.pluralCat(count - offset)), 
                    !(count === lastCount || countIsNaN && isNumberNaN(lastCount))) {
                        watchRemover();
                        var whenExpFn = whensExpFns[count];
                        isUndefined(whenExpFn) ? (null != newVal && $log.debug("ngPluralize: no rule defined for '" + count + "' in " + whenExp), 
                        watchRemover = noop, updateElementText()) : watchRemover = scope.$watch(whenExpFn, updateElementText), 
                        lastCount = count;
                    }
                });
            }
        };
    } ], ngRefMinErr = minErr("ngRef"), ngRefDirective = [ "$parse", function($parse) {
        return {
            priority: -1,
            restrict: "A",
            compile: function(tElement, tAttrs) {
                var controllerName = directiveNormalize(nodeName_(tElement)), getter = $parse(tAttrs.ngRef), setter = getter.assign || function() {
                    throw ngRefMinErr("nonassign", 'Expression in ngRef="{0}" is non-assignable!', tAttrs.ngRef);
                };
                return function(scope, element, attrs) {
                    var refValue;
                    if (attrs.hasOwnProperty("ngRefRead")) {
                        if ("$element" === attrs.ngRefRead) refValue = element; else if (refValue = element.data("$" + attrs.ngRefRead + "Controller"), 
                        !refValue) throw ngRefMinErr("noctrl", 'The controller for ngRefRead="{0}" could not be found on ngRef="{1}"', attrs.ngRefRead, tAttrs.ngRef);
                    } else refValue = element.data("$" + controllerName + "Controller");
                    refValue = refValue || element, setter(scope, refValue), element.on("$destroy", function() {
                        getter(scope) === refValue && setter(scope, null);
                    });
                };
            }
        };
    } ], ngRepeatDirective = [ "$parse", "$animate", "$compile", function($parse, $animate, $compile) {
        var NG_REMOVED = "$$NG_REMOVED", ngRepeatMinErr = minErr("ngRepeat"), updateScope = function(scope, index, valueIdentifier, value, keyIdentifier, key, arrayLength) {
            scope[valueIdentifier] = value, keyIdentifier && (scope[keyIdentifier] = key), scope.$index = index, 
            scope.$first = 0 === index, scope.$last = index === arrayLength - 1, scope.$middle = !(scope.$first || scope.$last), 
            scope.$odd = !(scope.$even = 0 === (1 & index));
        }, getBlockStart = function(block) {
            return block.clone[0];
        }, getBlockEnd = function(block) {
            return block.clone[block.clone.length - 1];
        };
        return {
            restrict: "A",
            multiElement: !0,
            transclude: "element",
            priority: 1e3,
            terminal: !0,
            $$tlb: !0,
            compile: function($element, $attr) {
                var expression = $attr.ngRepeat, ngRepeatEndComment = $compile.$$createComment("end ngRepeat", expression), match = expression.match(/^\s*([\s\S]+?)\s+in\s+([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+track\s+by\s+([\s\S]+?))?\s*$/);
                if (!match) throw ngRepeatMinErr("iexp", "Expected expression in form of '_item_ in _collection_[ track by _id_]' but got '{0}'.", expression);
                var lhs = match[1], rhs = match[2], aliasAs = match[3], trackByExp = match[4];
                if (match = lhs.match(/^(?:(\s*[$\w]+)|\(\s*([$\w]+)\s*,\s*([$\w]+)\s*\))$/), !match) throw ngRepeatMinErr("iidexp", "'_item_' in '_item_ in _collection_' should be an identifier or '(_key_, _value_)' expression, but got '{0}'.", lhs);
                var valueIdentifier = match[3] || match[1], keyIdentifier = match[2];
                if (aliasAs && (!/^[$a-zA-Z_][$a-zA-Z0-9_]*$/.test(aliasAs) || /^(null|undefined|this|\$index|\$first|\$middle|\$last|\$even|\$odd|\$parent|\$root|\$id)$/.test(aliasAs))) throw ngRepeatMinErr("badident", "alias '{0}' is invalid --- must be a valid JS identifier which is not a reserved name.", aliasAs);
                var trackByExpGetter, trackByIdExpFn, trackByIdArrayFn, trackByIdObjFn, hashFnLocals = {
                    $id: hashKey
                };
                return trackByExp ? trackByExpGetter = $parse(trackByExp) : (trackByIdArrayFn = function(key, value) {
                    return hashKey(value);
                }, trackByIdObjFn = function(key) {
                    return key;
                }), function($scope, $element, $attr, ctrl, $transclude) {
                    trackByExpGetter && (trackByIdExpFn = function(key, value, index) {
                        return keyIdentifier && (hashFnLocals[keyIdentifier] = key), hashFnLocals[valueIdentifier] = value, 
                        hashFnLocals.$index = index, trackByExpGetter($scope, hashFnLocals);
                    });
                    var lastBlockMap = createMap();
                    $scope.$watchCollection(rhs, function(collection) {
                        var index, length, nextNode, collectionLength, key, value, trackById, trackByIdFn, collectionKeys, block, nextBlockOrder, elementsToRemove, previousNode = $element[0], nextBlockMap = createMap();
                        if (aliasAs && ($scope[aliasAs] = collection), isArrayLike(collection)) collectionKeys = collection, 
                        trackByIdFn = trackByIdExpFn || trackByIdArrayFn; else {
                            trackByIdFn = trackByIdExpFn || trackByIdObjFn, collectionKeys = [];
                            for (var itemKey in collection) hasOwnProperty.call(collection, itemKey) && "$" !== itemKey.charAt(0) && collectionKeys.push(itemKey);
                        }
                        for (collectionLength = collectionKeys.length, nextBlockOrder = new Array(collectionLength), 
                        index = 0; collectionLength > index; index++) if (key = collection === collectionKeys ? index : collectionKeys[index], 
                        value = collection[key], trackById = trackByIdFn(key, value, index), lastBlockMap[trackById]) block = lastBlockMap[trackById], 
                        delete lastBlockMap[trackById], nextBlockMap[trackById] = block, nextBlockOrder[index] = block; else {
                            if (nextBlockMap[trackById]) throw forEach(nextBlockOrder, function(block) {
                                block && block.scope && (lastBlockMap[block.id] = block);
                            }), ngRepeatMinErr("dupes", "Duplicates in a repeater are not allowed. Use 'track by' expression to specify unique keys. Repeater: {0}, Duplicate key: {1}, Duplicate value: {2}", expression, trackById, value);
                            nextBlockOrder[index] = {
                                id: trackById,
                                scope: void 0,
                                clone: void 0
                            }, nextBlockMap[trackById] = !0;
                        }
                        for (var blockKey in lastBlockMap) {
                            if (block = lastBlockMap[blockKey], elementsToRemove = getBlockNodes(block.clone), 
                            $animate.leave(elementsToRemove), elementsToRemove[0].parentNode) for (index = 0, 
                            length = elementsToRemove.length; length > index; index++) elementsToRemove[index][NG_REMOVED] = !0;
                            block.scope.$destroy();
                        }
                        for (index = 0; collectionLength > index; index++) if (key = collection === collectionKeys ? index : collectionKeys[index], 
                        value = collection[key], block = nextBlockOrder[index], block.scope) {
                            nextNode = previousNode;
                            do nextNode = nextNode.nextSibling; while (nextNode && nextNode[NG_REMOVED]);
                            getBlockStart(block) !== nextNode && $animate.move(getBlockNodes(block.clone), null, previousNode), 
                            previousNode = getBlockEnd(block), updateScope(block.scope, index, valueIdentifier, value, keyIdentifier, key, collectionLength);
                        } else $transclude(function(clone, scope) {
                            block.scope = scope;
                            var endNode = ngRepeatEndComment.cloneNode(!1);
                            clone[clone.length++] = endNode, $animate.enter(clone, null, previousNode), previousNode = endNode, 
                            block.clone = clone, nextBlockMap[block.id] = block, updateScope(block.scope, index, valueIdentifier, value, keyIdentifier, key, collectionLength);
                        });
                        lastBlockMap = nextBlockMap;
                    });
                };
            }
        };
    } ], NG_HIDE_CLASS = "ng-hide", NG_HIDE_IN_PROGRESS_CLASS = "ng-hide-animate", ngShowDirective = [ "$animate", function($animate) {
        return {
            restrict: "A",
            multiElement: !0,
            link: function(scope, element, attr) {
                scope.$watch(attr.ngShow, function(value) {
                    $animate[value ? "removeClass" : "addClass"](element, NG_HIDE_CLASS, {
                        tempClasses: NG_HIDE_IN_PROGRESS_CLASS
                    });
                });
            }
        };
    } ], ngHideDirective = [ "$animate", function($animate) {
        return {
            restrict: "A",
            multiElement: !0,
            link: function(scope, element, attr) {
                scope.$watch(attr.ngHide, function(value) {
                    $animate[value ? "addClass" : "removeClass"](element, NG_HIDE_CLASS, {
                        tempClasses: NG_HIDE_IN_PROGRESS_CLASS
                    });
                });
            }
        };
    } ], ngStyleDirective = ngDirective(function(scope, element, attr) {
        scope.$watchCollection(attr.ngStyle, function(newStyles, oldStyles) {
            oldStyles && newStyles !== oldStyles && forEach(oldStyles, function(val, style) {
                element.css(style, "");
            }), newStyles && element.css(newStyles);
        });
    }), ngSwitchDirective = [ "$animate", "$compile", function($animate, $compile) {
        return {
            require: "ngSwitch",
            controller: [ "$scope", function() {
                this.cases = {};
            } ],
            link: function(scope, element, attr, ngSwitchController) {
                var watchExpr = attr.ngSwitch || attr.on, selectedTranscludes = [], selectedElements = [], previousLeaveAnimations = [], selectedScopes = [], spliceFactory = function(array, index) {
                    return function(response) {
                        response !== !1 && array.splice(index, 1);
                    };
                };
                scope.$watch(watchExpr, function(value) {
                    for (var i, ii; previousLeaveAnimations.length; ) $animate.cancel(previousLeaveAnimations.pop());
                    for (i = 0, ii = selectedScopes.length; ii > i; ++i) {
                        var selected = getBlockNodes(selectedElements[i].clone);
                        selectedScopes[i].$destroy();
                        var runner = previousLeaveAnimations[i] = $animate.leave(selected);
                        runner.done(spliceFactory(previousLeaveAnimations, i));
                    }
                    selectedElements.length = 0, selectedScopes.length = 0, (selectedTranscludes = ngSwitchController.cases["!" + value] || ngSwitchController.cases["?"]) && forEach(selectedTranscludes, function(selectedTransclude) {
                        selectedTransclude.transclude(function(caseElement, selectedScope) {
                            selectedScopes.push(selectedScope);
                            var anchor = selectedTransclude.element;
                            caseElement[caseElement.length++] = $compile.$$createComment("end ngSwitchWhen");
                            var block = {
                                clone: caseElement
                            };
                            selectedElements.push(block), $animate.enter(caseElement, anchor.parent(), anchor);
                        });
                    });
                });
            }
        };
    } ], ngSwitchWhenDirective = ngDirective({
        transclude: "element",
        priority: 1200,
        require: "^ngSwitch",
        multiElement: !0,
        link: function(scope, element, attrs, ctrl, $transclude) {
            var cases = attrs.ngSwitchWhen.split(attrs.ngSwitchWhenSeparator).sort().filter(function(element, index, array) {
                return array[index - 1] !== element;
            });
            forEach(cases, function(whenCase) {
                ctrl.cases["!" + whenCase] = ctrl.cases["!" + whenCase] || [], ctrl.cases["!" + whenCase].push({
                    transclude: $transclude,
                    element: element
                });
            });
        }
    }), ngSwitchDefaultDirective = ngDirective({
        transclude: "element",
        priority: 1200,
        require: "^ngSwitch",
        multiElement: !0,
        link: function(scope, element, attr, ctrl, $transclude) {
            ctrl.cases["?"] = ctrl.cases["?"] || [], ctrl.cases["?"].push({
                transclude: $transclude,
                element: element
            });
        }
    }), ngTranscludeMinErr = minErr("ngTransclude"), ngTranscludeDirective = [ "$compile", function($compile) {
        return {
            restrict: "EAC",
            compile: function(tElement) {
                var fallbackLinkFn = $compile(tElement.contents());
                return tElement.empty(), function($scope, $element, $attrs, controller, $transclude) {
                    function ngTranscludeCloneAttachFn(clone, transcludedScope) {
                        clone.length && notWhitespace(clone) ? $element.append(clone) : (useFallbackContent(), 
                        transcludedScope.$destroy());
                    }
                    function useFallbackContent() {
                        fallbackLinkFn($scope, function(clone) {
                            $element.append(clone);
                        });
                    }
                    function notWhitespace(nodes) {
                        for (var i = 0, ii = nodes.length; ii > i; i++) {
                            var node = nodes[i];
                            if (node.nodeType !== NODE_TYPE_TEXT || node.nodeValue.trim()) return !0;
                        }
                    }
                    if (!$transclude) throw ngTranscludeMinErr("orphan", "Illegal use of ngTransclude directive in the template! No parent directive that requires a transclusion found. Element: {0}", startingTag($element));
                    $attrs.ngTransclude === $attrs.$attr.ngTransclude && ($attrs.ngTransclude = "");
                    var slotName = $attrs.ngTransclude || $attrs.ngTranscludeSlot;
                    $transclude(ngTranscludeCloneAttachFn, null, slotName), slotName && !$transclude.isSlotFilled(slotName) && useFallbackContent();
                };
            }
        };
    } ], scriptDirective = [ "$templateCache", function($templateCache) {
        return {
            restrict: "E",
            terminal: !0,
            compile: function(element, attr) {
                if ("text/ng-template" === attr.type) {
                    var templateUrl = attr.id, text = element[0].text;
                    $templateCache.put(templateUrl, text);
                }
            }
        };
    } ], noopNgModelController = {
        $setViewValue: noop,
        $render: noop
    }, SelectController = [ "$element", "$scope", function($element, $scope) {
        function scheduleRender() {
            renderScheduled || (renderScheduled = !0, $scope.$$postDigest(function() {
                renderScheduled = !1, self.ngModelCtrl.$render();
            }));
        }
        function scheduleViewValueUpdate(renderAfter) {
            updateScheduled || (updateScheduled = !0, $scope.$$postDigest(function() {
                $scope.$$destroyed || (updateScheduled = !1, self.ngModelCtrl.$setViewValue(self.readValue()), 
                renderAfter && self.ngModelCtrl.$render());
            }));
        }
        var self = this, optionsMap = new NgMap();
        self.selectValueMap = {}, self.ngModelCtrl = noopNgModelController, self.multiple = !1, 
        self.unknownOption = jqLite(window.document.createElement("option")), self.hasEmptyOption = !1, 
        self.emptyOption = void 0, self.renderUnknownOption = function(val) {
            var unknownVal = self.generateUnknownOptionValue(val);
            self.unknownOption.val(unknownVal), $element.prepend(self.unknownOption), setOptionSelectedStatus(self.unknownOption, !0), 
            $element.val(unknownVal);
        }, self.updateUnknownOption = function(val) {
            var unknownVal = self.generateUnknownOptionValue(val);
            self.unknownOption.val(unknownVal), setOptionSelectedStatus(self.unknownOption, !0), 
            $element.val(unknownVal);
        }, self.generateUnknownOptionValue = function(val) {
            return "? " + hashKey(val) + " ?";
        }, self.removeUnknownOption = function() {
            self.unknownOption.parent() && self.unknownOption.remove();
        }, self.selectEmptyOption = function() {
            self.emptyOption && ($element.val(""), setOptionSelectedStatus(self.emptyOption, !0));
        }, self.unselectEmptyOption = function() {
            self.hasEmptyOption && setOptionSelectedStatus(self.emptyOption, !1);
        }, $scope.$on("$destroy", function() {
            self.renderUnknownOption = noop;
        }), self.readValue = function() {
            var val = $element.val(), realVal = val in self.selectValueMap ? self.selectValueMap[val] : val;
            return self.hasOption(realVal) ? realVal : null;
        }, self.writeValue = function(value) {
            var currentlySelectedOption = $element[0].options[$element[0].selectedIndex];
            if (currentlySelectedOption && setOptionSelectedStatus(jqLite(currentlySelectedOption), !1), 
            self.hasOption(value)) {
                self.removeUnknownOption();
                var hashedVal = hashKey(value);
                $element.val(hashedVal in self.selectValueMap ? hashedVal : value);
                var selectedOption = $element[0].options[$element[0].selectedIndex];
                setOptionSelectedStatus(jqLite(selectedOption), !0);
            } else self.selectUnknownOrEmptyOption(value);
        }, self.addOption = function(value, element) {
            if (element[0].nodeType !== NODE_TYPE_COMMENT) {
                assertNotHasOwnProperty(value, '"option value"'), "" === value && (self.hasEmptyOption = !0, 
                self.emptyOption = element);
                var count = optionsMap.get(value) || 0;
                optionsMap.set(value, count + 1), scheduleRender();
            }
        }, self.removeOption = function(value) {
            var count = optionsMap.get(value);
            count && (1 === count ? (optionsMap.delete(value), "" === value && (self.hasEmptyOption = !1, 
            self.emptyOption = void 0)) : optionsMap.set(value, count - 1));
        }, self.hasOption = function(value) {
            return !!optionsMap.get(value);
        }, self.$hasEmptyOption = function() {
            return self.hasEmptyOption;
        }, self.$isUnknownOptionSelected = function() {
            return $element[0].options[0] === self.unknownOption[0];
        }, self.$isEmptyOptionSelected = function() {
            return self.hasEmptyOption && $element[0].options[$element[0].selectedIndex] === self.emptyOption[0];
        }, self.selectUnknownOrEmptyOption = function(value) {
            null == value && self.emptyOption ? (self.removeUnknownOption(), self.selectEmptyOption()) : self.unknownOption.parent().length ? self.updateUnknownOption(value) : self.renderUnknownOption(value);
        };
        var renderScheduled = !1, updateScheduled = !1;
        self.registerOption = function(optionScope, optionElement, optionAttrs, interpolateValueFn, interpolateTextFn) {
            if (optionAttrs.$attr.ngValue) {
                var oldVal, hashedVal = 0/0;
                optionAttrs.$observe("value", function(newVal) {
                    var removal, previouslySelected = optionElement.prop("selected");
                    isDefined(hashedVal) && (self.removeOption(oldVal), delete self.selectValueMap[hashedVal], 
                    removal = !0), hashedVal = hashKey(newVal), oldVal = newVal, self.selectValueMap[hashedVal] = newVal, 
                    self.addOption(newVal, optionElement), optionElement.attr("value", hashedVal), removal && previouslySelected && scheduleViewValueUpdate();
                });
            } else interpolateValueFn ? optionAttrs.$observe("value", function(newVal) {
                self.readValue();
                var removal, previouslySelected = optionElement.prop("selected");
                isDefined(oldVal) && (self.removeOption(oldVal), removal = !0), oldVal = newVal, 
                self.addOption(newVal, optionElement), removal && previouslySelected && scheduleViewValueUpdate();
            }) : interpolateTextFn ? optionScope.$watch(interpolateTextFn, function(newVal, oldVal) {
                optionAttrs.$set("value", newVal);
                var previouslySelected = optionElement.prop("selected");
                oldVal !== newVal && self.removeOption(oldVal), self.addOption(newVal, optionElement), 
                oldVal && previouslySelected && scheduleViewValueUpdate();
            }) : self.addOption(optionAttrs.value, optionElement);
            optionAttrs.$observe("disabled", function(newVal) {
                ("true" === newVal || newVal && optionElement.prop("selected")) && (self.multiple ? scheduleViewValueUpdate(!0) : (self.ngModelCtrl.$setViewValue(null), 
                self.ngModelCtrl.$render()));
            }), optionElement.on("$destroy", function() {
                var currentValue = self.readValue(), removeValue = optionAttrs.value;
                self.removeOption(removeValue), scheduleRender(), (self.multiple && currentValue && -1 !== currentValue.indexOf(removeValue) || currentValue === removeValue) && scheduleViewValueUpdate(!0);
            });
        };
    } ], selectDirective = function() {
        function selectPreLink(scope, element, attr, ctrls) {
            var selectCtrl = ctrls[0], ngModelCtrl = ctrls[1];
            if (!ngModelCtrl) return void (selectCtrl.registerOption = noop);
            if (selectCtrl.ngModelCtrl = ngModelCtrl, element.on("change", function() {
                selectCtrl.removeUnknownOption(), scope.$apply(function() {
                    ngModelCtrl.$setViewValue(selectCtrl.readValue());
                });
            }), attr.multiple) {
                selectCtrl.multiple = !0, selectCtrl.readValue = function() {
                    var array = [];
                    return forEach(element.find("option"), function(option) {
                        if (option.selected && !option.disabled) {
                            var val = option.value;
                            array.push(val in selectCtrl.selectValueMap ? selectCtrl.selectValueMap[val] : val);
                        }
                    }), array;
                }, selectCtrl.writeValue = function(value) {
                    forEach(element.find("option"), function(option) {
                        var shouldBeSelected = !!value && (includes(value, option.value) || includes(value, selectCtrl.selectValueMap[option.value])), currentlySelected = option.selected;
                        shouldBeSelected !== currentlySelected && setOptionSelectedStatus(jqLite(option), shouldBeSelected);
                    });
                };
                var lastView, lastViewRef = 0/0;
                scope.$watch(function() {
                    lastViewRef !== ngModelCtrl.$viewValue || equals(lastView, ngModelCtrl.$viewValue) || (lastView = shallowCopy(ngModelCtrl.$viewValue), 
                    ngModelCtrl.$render()), lastViewRef = ngModelCtrl.$viewValue;
                }), ngModelCtrl.$isEmpty = function(value) {
                    return !value || 0 === value.length;
                };
            }
        }
        function selectPostLink(scope, element, attrs, ctrls) {
            var ngModelCtrl = ctrls[1];
            if (ngModelCtrl) {
                var selectCtrl = ctrls[0];
                ngModelCtrl.$render = function() {
                    selectCtrl.writeValue(ngModelCtrl.$viewValue);
                };
            }
        }
        return {
            restrict: "E",
            require: [ "select", "?ngModel" ],
            controller: SelectController,
            priority: 1,
            link: {
                pre: selectPreLink,
                post: selectPostLink
            }
        };
    }, optionDirective = [ "$interpolate", function($interpolate) {
        return {
            restrict: "E",
            priority: 100,
            compile: function(element, attr) {
                var interpolateValueFn, interpolateTextFn;
                return isDefined(attr.ngValue) || (isDefined(attr.value) ? interpolateValueFn = $interpolate(attr.value, !0) : (interpolateTextFn = $interpolate(element.text(), !0), 
                interpolateTextFn || attr.$set("value", element.text()))), function(scope, element, attr) {
                    var selectCtrlName = "$selectController", parent = element.parent(), selectCtrl = parent.data(selectCtrlName) || parent.parent().data(selectCtrlName);
                    selectCtrl && selectCtrl.registerOption(scope, element, attr, interpolateValueFn, interpolateTextFn);
                };
            }
        };
    } ], requiredDirective = function() {
        return {
            restrict: "A",
            require: "?ngModel",
            link: function(scope, elm, attr, ctrl) {
                ctrl && (attr.required = !0, ctrl.$validators.required = function(modelValue, viewValue) {
                    return !attr.required || !ctrl.$isEmpty(viewValue);
                }, attr.$observe("required", function() {
                    ctrl.$validate();
                }));
            }
        };
    }, patternDirective = function() {
        return {
            restrict: "A",
            require: "?ngModel",
            link: function(scope, elm, attr, ctrl) {
                if (ctrl) {
                    var regexp, patternExp = attr.ngPattern || attr.pattern;
                    attr.$observe("pattern", function(regex) {
                        if (isString(regex) && regex.length > 0 && (regex = new RegExp("^" + regex + "$")), 
                        regex && !regex.test) throw minErr("ngPattern")("noregexp", "Expected {0} to be a RegExp but was {1}. Element: {2}", patternExp, regex, startingTag(elm));
                        regexp = regex || void 0, ctrl.$validate();
                    }), ctrl.$validators.pattern = function(modelValue, viewValue) {
                        return ctrl.$isEmpty(viewValue) || isUndefined(regexp) || regexp.test(viewValue);
                    };
                }
            }
        };
    }, maxlengthDirective = function() {
        return {
            restrict: "A",
            require: "?ngModel",
            link: function(scope, elm, attr, ctrl) {
                if (ctrl) {
                    var maxlength = -1;
                    attr.$observe("maxlength", function(value) {
                        var intVal = toInt(value);
                        maxlength = isNumberNaN(intVal) ? -1 : intVal, ctrl.$validate();
                    }), ctrl.$validators.maxlength = function(modelValue, viewValue) {
                        return 0 > maxlength || ctrl.$isEmpty(viewValue) || viewValue.length <= maxlength;
                    };
                }
            }
        };
    }, minlengthDirective = function() {
        return {
            restrict: "A",
            require: "?ngModel",
            link: function(scope, elm, attr, ctrl) {
                if (ctrl) {
                    var minlength = 0;
                    attr.$observe("minlength", function(value) {
                        minlength = toInt(value) || 0, ctrl.$validate();
                    }), ctrl.$validators.minlength = function(modelValue, viewValue) {
                        return ctrl.$isEmpty(viewValue) || viewValue.length >= minlength;
                    };
                }
            }
        };
    };
    return window.angular.bootstrap ? void (window.console && console.log("WARNING: Tried to load AngularJS more than once.")) : (bindJQuery(), 
    publishExternalAPI(angular), angular.module("ngLocale", [], [ "$provide", function($provide) {
        function getDecimals(n) {
            n += "";
            var i = n.indexOf(".");
            return -1 == i ? 0 : n.length - i - 1;
        }
        function getVF(n, opt_precision) {
            var v = opt_precision;
            void 0 === v && (v = Math.min(getDecimals(n), 3));
            var base = Math.pow(10, v), f = (n * base | 0) % base;
            return {
                v: v,
                f: f
            };
        }
        var PLURAL_CATEGORY = {
            ZERO: "zero",
            ONE: "one",
            TWO: "two",
            FEW: "few",
            MANY: "many",
            OTHER: "other"
        };
        $provide.value("$locale", {
            DATETIME_FORMATS: {
                AMPMS: [ "AM", "PM" ],
                DAY: [ "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday" ],
                ERANAMES: [ "Before Christ", "Anno Domini" ],
                ERAS: [ "BC", "AD" ],
                FIRSTDAYOFWEEK: 6,
                MONTH: [ "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December" ],
                SHORTDAY: [ "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" ],
                SHORTMONTH: [ "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" ],
                STANDALONEMONTH: [ "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December" ],
                WEEKENDRANGE: [ 5, 6 ],
                fullDate: "EEEE, MMMM d, y",
                longDate: "MMMM d, y",
                medium: "MMM d, y h:mm:ss a",
                mediumDate: "MMM d, y",
                mediumTime: "h:mm:ss a",
                "short": "M/d/yy h:mm a",
                shortDate: "M/d/yy",
                shortTime: "h:mm a"
            },
            NUMBER_FORMATS: {
                CURRENCY_SYM: "$",
                DECIMAL_SEP: ".",
                GROUP_SEP: ",",
                PATTERNS: [ {
                    gSize: 3,
                    lgSize: 3,
                    maxFrac: 3,
                    minFrac: 0,
                    minInt: 1,
                    negPre: "-",
                    negSuf: "",
                    posPre: "",
                    posSuf: ""
                }, {
                    gSize: 3,
                    lgSize: 3,
                    maxFrac: 2,
                    minFrac: 2,
                    minInt: 1,
                    negPre: "-",
                    negSuf: "",
                    posPre: "",
                    posSuf: ""
                } ]
            },
            id: "en-us",
            localeID: "en_US",
            pluralCat: function(n, opt_precision) {
                var i = 0 | n, vf = getVF(n, opt_precision);
                return 1 == i && 0 == vf.v ? PLURAL_CATEGORY.ONE : PLURAL_CATEGORY.OTHER;
            }
        });
    } ]), void jqLite(function() {
        angularInit(window.document, bootstrap);
    }));
}(window), !window.angular.$$csp().noInlineStyle && window.angular.element(document.head).prepend('<style type="text/css">@charset "UTF-8";[ng\\:cloak],[ng-cloak],[data-ng-cloak],[x-ng-cloak],.ng-cloak,.x-ng-cloak,.ng-hide:not(.ng-hide-animate){display:none !important;}ng\\:form{display:block;}.ng-animate-shim{visibility:hidden;}.ng-anchor{position:absolute;}</style>'), 
define("angular", function(global) {
    return function() {
        var ret;
        return ret || global.angular;
    };
}(this)), function(window, angular) {
    function assertArg(arg, name, reason) {
        if (!arg) throw ngMinErr("areq", "Argument '{0}' is {1}", name || "?", reason || "required");
        return arg;
    }
    function mergeClasses(a, b) {
        return a || b ? a ? b ? (isArray(a) && (a = a.join(" ")), isArray(b) && (b = b.join(" ")), 
        a + " " + b) : a : b : "";
    }
    function packageStyles(options) {
        var styles = {};
        return options && (options.to || options.from) && (styles.to = options.to, styles.from = options.from), 
        styles;
    }
    function pendClasses(classes, fix, isPrefix) {
        var className = "";
        return classes = isArray(classes) ? classes : classes && isString(classes) && classes.length ? classes.split(/\s+/) : [], 
        forEach(classes, function(klass, i) {
            klass && klass.length > 0 && (className += i > 0 ? " " : "", className += isPrefix ? fix + klass : klass + fix);
        }), className;
    }
    function removeFromArray(arr, val) {
        var index = arr.indexOf(val);
        val >= 0 && arr.splice(index, 1);
    }
    function stripCommentsFromElement(element) {
        if (element instanceof jqLite) switch (element.length) {
          case 0:
            return element;

          case 1:
            if (element[0].nodeType === ELEMENT_NODE) return element;
            break;

          default:
            return jqLite(extractElementNode(element));
        }
        return element.nodeType === ELEMENT_NODE ? jqLite(element) : void 0;
    }
    function extractElementNode(element) {
        if (!element[0]) return element;
        for (var i = 0; i < element.length; i++) {
            var elm = element[i];
            if (elm.nodeType === ELEMENT_NODE) return elm;
        }
    }
    function $$addClass($$jqLite, element, className) {
        forEach(element, function(elm) {
            $$jqLite.addClass(elm, className);
        });
    }
    function $$removeClass($$jqLite, element, className) {
        forEach(element, function(elm) {
            $$jqLite.removeClass(elm, className);
        });
    }
    function applyAnimationClassesFactory($$jqLite) {
        return function(element, options) {
            options.addClass && ($$addClass($$jqLite, element, options.addClass), options.addClass = null), 
            options.removeClass && ($$removeClass($$jqLite, element, options.removeClass), options.removeClass = null);
        };
    }
    function prepareAnimationOptions(options) {
        if (options = options || {}, !options.$$prepared) {
            var domOperation = options.domOperation || noop;
            options.domOperation = function() {
                options.$$domOperationFired = !0, domOperation(), domOperation = noop;
            }, options.$$prepared = !0;
        }
        return options;
    }
    function applyAnimationStyles(element, options) {
        applyAnimationFromStyles(element, options), applyAnimationToStyles(element, options);
    }
    function applyAnimationFromStyles(element, options) {
        options.from && (element.css(options.from), options.from = null);
    }
    function applyAnimationToStyles(element, options) {
        options.to && (element.css(options.to), options.to = null);
    }
    function mergeAnimationDetails(element, oldAnimation, newAnimation) {
        var target = oldAnimation.options || {}, newOptions = newAnimation.options || {}, toAdd = (target.addClass || "") + " " + (newOptions.addClass || ""), toRemove = (target.removeClass || "") + " " + (newOptions.removeClass || ""), classes = resolveElementClasses(element.attr("class"), toAdd, toRemove);
        newOptions.preparationClasses && (target.preparationClasses = concatWithSpace(newOptions.preparationClasses, target.preparationClasses), 
        delete newOptions.preparationClasses);
        var realDomOperation = target.domOperation !== noop ? target.domOperation : null;
        return extend(target, newOptions), realDomOperation && (target.domOperation = realDomOperation), 
        target.addClass = classes.addClass ? classes.addClass : null, target.removeClass = classes.removeClass ? classes.removeClass : null, 
        oldAnimation.addClass = target.addClass, oldAnimation.removeClass = target.removeClass, 
        target;
    }
    function resolveElementClasses(existing, toAdd, toRemove) {
        function splitClassesToLookup(classes) {
            isString(classes) && (classes = classes.split(" "));
            var obj = {};
            return forEach(classes, function(klass) {
                klass.length && (obj[klass] = !0);
            }), obj;
        }
        var ADD_CLASS = 1, REMOVE_CLASS = -1, flags = {};
        existing = splitClassesToLookup(existing), toAdd = splitClassesToLookup(toAdd), 
        forEach(toAdd, function(value, key) {
            flags[key] = ADD_CLASS;
        }), toRemove = splitClassesToLookup(toRemove), forEach(toRemove, function(value, key) {
            flags[key] = flags[key] === ADD_CLASS ? null : REMOVE_CLASS;
        });
        var classes = {
            addClass: "",
            removeClass: ""
        };
        return forEach(flags, function(val, klass) {
            var prop, allow;
            val === ADD_CLASS ? (prop = "addClass", allow = !existing[klass] || existing[klass + REMOVE_CLASS_SUFFIX]) : val === REMOVE_CLASS && (prop = "removeClass", 
            allow = existing[klass] || existing[klass + ADD_CLASS_SUFFIX]), allow && (classes[prop].length && (classes[prop] += " "), 
            classes[prop] += klass);
        }), classes;
    }
    function getDomNode(element) {
        return element instanceof jqLite ? element[0] : element;
    }
    function applyGeneratedPreparationClasses(element, event, options) {
        var classes = "";
        event && (classes = pendClasses(event, EVENT_CLASS_PREFIX, !0)), options.addClass && (classes = concatWithSpace(classes, pendClasses(options.addClass, ADD_CLASS_SUFFIX))), 
        options.removeClass && (classes = concatWithSpace(classes, pendClasses(options.removeClass, REMOVE_CLASS_SUFFIX))), 
        classes.length && (options.preparationClasses = classes, element.addClass(classes));
    }
    function clearGeneratedClasses(element, options) {
        options.preparationClasses && (element.removeClass(options.preparationClasses), 
        options.preparationClasses = null), options.activeClasses && (element.removeClass(options.activeClasses), 
        options.activeClasses = null);
    }
    function blockTransitions(node, duration) {
        var value = duration ? "-" + duration + "s" : "";
        return applyInlineStyle(node, [ TRANSITION_DELAY_PROP, value ]), [ TRANSITION_DELAY_PROP, value ];
    }
    function blockKeyframeAnimations(node, applyBlock) {
        var value = applyBlock ? "paused" : "", key = ANIMATION_PROP + ANIMATION_PLAYSTATE_KEY;
        return applyInlineStyle(node, [ key, value ]), [ key, value ];
    }
    function applyInlineStyle(node, styleTuple) {
        var prop = styleTuple[0], value = styleTuple[1];
        node.style[prop] = value;
    }
    function concatWithSpace(a, b) {
        return a ? b ? a + " " + b : a : b;
    }
    function getCssKeyframeDurationStyle(duration) {
        return [ ANIMATION_DURATION_PROP, duration + "s" ];
    }
    function getCssDelayStyle(delay, isKeyframeAnimation) {
        var prop = isKeyframeAnimation ? ANIMATION_DELAY_PROP : TRANSITION_DELAY_PROP;
        return [ prop, delay + "s" ];
    }
    function computeCssStyles($window, element, properties) {
        var styles = Object.create(null), detectedStyles = $window.getComputedStyle(element) || {};
        return forEach(properties, function(formalStyleName, actualStyleName) {
            var val = detectedStyles[formalStyleName];
            if (val) {
                var c = val.charAt(0);
                ("-" === c || "+" === c || c >= 0) && (val = parseMaxTime(val)), 0 === val && (val = null), 
                styles[actualStyleName] = val;
            }
        }), styles;
    }
    function parseMaxTime(str) {
        var maxValue = 0, values = str.split(/\s*,\s*/);
        return forEach(values, function(value) {
            "s" === value.charAt(value.length - 1) && (value = value.substring(0, value.length - 1)), 
            value = parseFloat(value) || 0, maxValue = maxValue ? Math.max(value, maxValue) : value;
        }), maxValue;
    }
    function truthyTimingValue(val) {
        return 0 === val || null != val;
    }
    function getCssTransitionDurationStyle(duration, applyOnlyDuration) {
        var style = TRANSITION_PROP, value = duration + "s";
        return applyOnlyDuration ? style += DURATION_KEY : value += " linear all", [ style, value ];
    }
    function createLocalCacheLookup() {
        var cache = Object.create(null);
        return {
            flush: function() {
                cache = Object.create(null);
            },
            count: function(key) {
                var entry = cache[key];
                return entry ? entry.total : 0;
            },
            get: function(key) {
                var entry = cache[key];
                return entry && entry.value;
            },
            put: function(key, value) {
                cache[key] ? cache[key].total++ : cache[key] = {
                    total: 1,
                    value: value
                };
            }
        };
    }
    function registerRestorableStyles(backup, node, properties) {
        forEach(properties, function(prop) {
            backup[prop] = isDefined(backup[prop]) ? backup[prop] : node.style.getPropertyValue(prop);
        });
    }
    var TRANSITION_PROP, TRANSITIONEND_EVENT, ANIMATION_PROP, ANIMATIONEND_EVENT, ELEMENT_NODE = 1, ADD_CLASS_SUFFIX = "-add", REMOVE_CLASS_SUFFIX = "-remove", EVENT_CLASS_PREFIX = "ng-", ACTIVE_CLASS_SUFFIX = "-active", PREPARE_CLASS_SUFFIX = "-prepare", NG_ANIMATE_CLASSNAME = "ng-animate", NG_ANIMATE_CHILDREN_DATA = "$$ngAnimateChildren", CSS_PREFIX = "";
    void 0 === window.ontransitionend && void 0 !== window.onwebkittransitionend ? (CSS_PREFIX = "-webkit-", 
    TRANSITION_PROP = "WebkitTransition", TRANSITIONEND_EVENT = "webkitTransitionEnd transitionend") : (TRANSITION_PROP = "transition", 
    TRANSITIONEND_EVENT = "transitionend"), void 0 === window.onanimationend && void 0 !== window.onwebkitanimationend ? (CSS_PREFIX = "-webkit-", 
    ANIMATION_PROP = "WebkitAnimation", ANIMATIONEND_EVENT = "webkitAnimationEnd animationend") : (ANIMATION_PROP = "animation", 
    ANIMATIONEND_EVENT = "animationend");
    var copy, extend, forEach, isArray, isDefined, isElement, isFunction, isObject, isString, isUndefined, jqLite, noop, DURATION_KEY = "Duration", PROPERTY_KEY = "Property", DELAY_KEY = "Delay", TIMING_KEY = "TimingFunction", ANIMATION_ITERATION_COUNT_KEY = "IterationCount", ANIMATION_PLAYSTATE_KEY = "PlayState", SAFE_FAST_FORWARD_DURATION_VALUE = 9999, ANIMATION_DELAY_PROP = ANIMATION_PROP + DELAY_KEY, ANIMATION_DURATION_PROP = ANIMATION_PROP + DURATION_KEY, TRANSITION_DELAY_PROP = TRANSITION_PROP + DELAY_KEY, TRANSITION_DURATION_PROP = TRANSITION_PROP + DURATION_KEY, ngMinErr = angular.$$minErr("ng"), $$rAFSchedulerFactory = [ "$$rAF", function($$rAF) {
        function scheduler(tasks) {
            queue = queue.concat(tasks), nextTick();
        }
        function nextTick() {
            if (queue.length) {
                for (var items = queue.shift(), i = 0; i < items.length; i++) items[i]();
                cancelFn || $$rAF(function() {
                    cancelFn || nextTick();
                });
            }
        }
        var queue, cancelFn;
        return queue = scheduler.queue = [], scheduler.waitUntilQuiet = function(fn) {
            cancelFn && cancelFn(), cancelFn = $$rAF(function() {
                cancelFn = null, fn(), nextTick();
            });
        }, scheduler;
    } ], $$AnimateChildrenDirective = [ "$interpolate", function($interpolate) {
        return {
            link: function(scope, element, attrs) {
                function setData(value) {
                    value = "on" === value || "true" === value, element.data(NG_ANIMATE_CHILDREN_DATA, value);
                }
                var val = attrs.ngAnimateChildren;
                isString(val) && 0 === val.length ? element.data(NG_ANIMATE_CHILDREN_DATA, !0) : (setData($interpolate(val)(scope)), 
                attrs.$observe("ngAnimateChildren", setData));
            }
        };
    } ], ANIMATE_TIMER_KEY = "$$animateCss", ONE_SECOND = 1e3, ELAPSED_TIME_MAX_DECIMAL_PLACES = 3, CLOSING_TIME_BUFFER = 1.5, DETECT_CSS_PROPERTIES = {
        transitionDuration: TRANSITION_DURATION_PROP,
        transitionDelay: TRANSITION_DELAY_PROP,
        transitionProperty: TRANSITION_PROP + PROPERTY_KEY,
        animationDuration: ANIMATION_DURATION_PROP,
        animationDelay: ANIMATION_DELAY_PROP,
        animationIterationCount: ANIMATION_PROP + ANIMATION_ITERATION_COUNT_KEY
    }, DETECT_STAGGER_CSS_PROPERTIES = {
        transitionDuration: TRANSITION_DURATION_PROP,
        transitionDelay: TRANSITION_DELAY_PROP,
        animationDuration: ANIMATION_DURATION_PROP,
        animationDelay: ANIMATION_DELAY_PROP
    }, $AnimateCssProvider = [ "$animateProvider", function() {
        var gcsLookup = createLocalCacheLookup(), gcsStaggerLookup = createLocalCacheLookup();
        this.$get = [ "$window", "$$jqLite", "$$AnimateRunner", "$timeout", "$$forceReflow", "$sniffer", "$$rAFScheduler", "$$animateQueue", function($window, $$jqLite, $$AnimateRunner, $timeout, $$forceReflow, $sniffer, $$rAFScheduler, $$animateQueue) {
            function gcsHashFn(node, extraClasses) {
                var KEY = "$$ngAnimateParentKey", parentNode = node.parentNode, parentID = parentNode[KEY] || (parentNode[KEY] = ++parentCounter);
                return parentID + "-" + node.getAttribute("class") + "-" + extraClasses;
            }
            function computeCachedCssStyles(node, className, cacheKey, properties) {
                var timings = gcsLookup.get(cacheKey);
                return timings || (timings = computeCssStyles($window, node, properties), "infinite" === timings.animationIterationCount && (timings.animationIterationCount = 1)), 
                gcsLookup.put(cacheKey, timings), timings;
            }
            function computeCachedCssStaggerStyles(node, className, cacheKey, properties) {
                var stagger;
                if (gcsLookup.count(cacheKey) > 0 && (stagger = gcsStaggerLookup.get(cacheKey), 
                !stagger)) {
                    var staggerClassName = pendClasses(className, "-stagger");
                    $$jqLite.addClass(node, staggerClassName), stagger = computeCssStyles($window, node, properties), 
                    stagger.animationDuration = Math.max(stagger.animationDuration, 0), stagger.transitionDuration = Math.max(stagger.transitionDuration, 0), 
                    $$jqLite.removeClass(node, staggerClassName), gcsStaggerLookup.put(cacheKey, stagger);
                }
                return stagger || {};
            }
            function waitUntilQuiet(callback) {
                rafWaitQueue.push(callback), $$rAFScheduler.waitUntilQuiet(function() {
                    gcsLookup.flush(), gcsStaggerLookup.flush();
                    for (var pageWidth = $$forceReflow(), i = 0; i < rafWaitQueue.length; i++) rafWaitQueue[i](pageWidth);
                    rafWaitQueue.length = 0;
                });
            }
            function computeTimings(node, className, cacheKey) {
                var timings = computeCachedCssStyles(node, className, cacheKey, DETECT_CSS_PROPERTIES), aD = timings.animationDelay, tD = timings.transitionDelay;
                return timings.maxDelay = aD && tD ? Math.max(aD, tD) : aD || tD, timings.maxDuration = Math.max(timings.animationDuration * timings.animationIterationCount, timings.transitionDuration), 
                timings;
            }
            var applyAnimationClasses = applyAnimationClassesFactory($$jqLite), parentCounter = 0, rafWaitQueue = [];
            return function(element, initialOptions) {
                function endFn() {
                    close();
                }
                function cancelFn() {
                    close(!0);
                }
                function close(rejected) {
                    if (!(animationClosed || animationCompleted && animationPaused)) {
                        animationClosed = !0, animationPaused = !1, options.$$skipPreparationClasses || $$jqLite.removeClass(element, preparationClasses), 
                        $$jqLite.removeClass(element, activeClasses), blockKeyframeAnimations(node, !1), 
                        blockTransitions(node, !1), forEach(temporaryStyles, function(entry) {
                            node.style[entry[0]] = "";
                        }), applyAnimationClasses(element, options), applyAnimationStyles(element, options), 
                        Object.keys(restoreStyles).length && forEach(restoreStyles, function(value, prop) {
                            value ? node.style.setProperty(prop, value) : node.style.removeProperty(prop);
                        }), options.onDone && options.onDone(), events && events.length && element.off(events.join(" "), onAnimationProgress);
                        var animationTimerData = element.data(ANIMATE_TIMER_KEY);
                        animationTimerData && ($timeout.cancel(animationTimerData[0].timer), element.removeData(ANIMATE_TIMER_KEY)), 
                        runner && runner.complete(!rejected);
                    }
                }
                function applyBlocking(duration) {
                    flags.blockTransition && blockTransitions(node, duration), flags.blockKeyframeAnimation && blockKeyframeAnimations(node, !!duration);
                }
                function closeAndReturnNoopAnimator() {
                    return runner = new $$AnimateRunner({
                        end: endFn,
                        cancel: cancelFn
                    }), waitUntilQuiet(noop), close(), {
                        $$willAnimate: !1,
                        start: function() {
                            return runner;
                        },
                        end: endFn
                    };
                }
                function onAnimationProgress(event) {
                    event.stopPropagation();
                    var ev = event.originalEvent || event;
                    if (ev.target === node) {
                        var timeStamp = ev.$manualTimeStamp || Date.now(), elapsedTime = parseFloat(ev.elapsedTime.toFixed(ELAPSED_TIME_MAX_DECIMAL_PLACES));
                        Math.max(timeStamp - startTime, 0) >= maxDelayTime && elapsedTime >= maxDuration && (animationCompleted = !0, 
                        close());
                    }
                }
                function start() {
                    function triggerAnimationStart() {
                        if (!animationClosed) {
                            if (applyBlocking(!1), forEach(temporaryStyles, function(entry) {
                                var key = entry[0], value = entry[1];
                                node.style[key] = value;
                            }), applyAnimationClasses(element, options), $$jqLite.addClass(element, activeClasses), 
                            flags.recalculateTimingStyles) {
                                if (fullClassName = node.getAttribute("class") + " " + preparationClasses, cacheKey = gcsHashFn(node, fullClassName), 
                                timings = computeTimings(node, fullClassName, cacheKey), relativeDelay = timings.maxDelay, 
                                maxDelay = Math.max(relativeDelay, 0), maxDuration = timings.maxDuration, 0 === maxDuration) return void close();
                                flags.hasTransitions = timings.transitionDuration > 0, flags.hasAnimations = timings.animationDuration > 0;
                            }
                            if (flags.applyAnimationDelay && (relativeDelay = "boolean" != typeof options.delay && truthyTimingValue(options.delay) ? parseFloat(options.delay) : relativeDelay, 
                            maxDelay = Math.max(relativeDelay, 0), timings.animationDelay = relativeDelay, delayStyle = getCssDelayStyle(relativeDelay, !0), 
                            temporaryStyles.push(delayStyle), node.style[delayStyle[0]] = delayStyle[1]), maxDelayTime = maxDelay * ONE_SECOND, 
                            maxDurationTime = maxDuration * ONE_SECOND, options.easing) {
                                var easeProp, easeVal = options.easing;
                                flags.hasTransitions && (easeProp = TRANSITION_PROP + TIMING_KEY, temporaryStyles.push([ easeProp, easeVal ]), 
                                node.style[easeProp] = easeVal), flags.hasAnimations && (easeProp = ANIMATION_PROP + TIMING_KEY, 
                                temporaryStyles.push([ easeProp, easeVal ]), node.style[easeProp] = easeVal);
                            }
                            timings.transitionDuration && events.push(TRANSITIONEND_EVENT), timings.animationDuration && events.push(ANIMATIONEND_EVENT), 
                            startTime = Date.now();
                            var timerTime = maxDelayTime + CLOSING_TIME_BUFFER * maxDurationTime, endTime = startTime + timerTime, animationsData = element.data(ANIMATE_TIMER_KEY) || [], setupFallbackTimer = !0;
                            if (animationsData.length) {
                                var currentTimerData = animationsData[0];
                                setupFallbackTimer = endTime > currentTimerData.expectedEndTime, setupFallbackTimer ? $timeout.cancel(currentTimerData.timer) : animationsData.push(close);
                            }
                            if (setupFallbackTimer) {
                                var timer = $timeout(onAnimationExpired, timerTime, !1);
                                animationsData[0] = {
                                    timer: timer,
                                    expectedEndTime: endTime
                                }, animationsData.push(close), element.data(ANIMATE_TIMER_KEY, animationsData);
                            }
                            events.length && element.on(events.join(" "), onAnimationProgress), options.to && (options.cleanupStyles && registerRestorableStyles(restoreStyles, node, Object.keys(options.to)), 
                            applyAnimationToStyles(element, options));
                        }
                    }
                    function onAnimationExpired() {
                        var animationsData = element.data(ANIMATE_TIMER_KEY);
                        if (animationsData) {
                            for (var i = 1; i < animationsData.length; i++) animationsData[i]();
                            element.removeData(ANIMATE_TIMER_KEY);
                        }
                    }
                    if (!animationClosed) {
                        if (!node.parentNode) return void close();
                        var playPause = function(playAnimation) {
                            if (animationCompleted) animationPaused && playAnimation && (animationPaused = !1, 
                            close()); else if (animationPaused = !playAnimation, timings.animationDuration) {
                                var value = blockKeyframeAnimations(node, animationPaused);
                                animationPaused ? temporaryStyles.push(value) : removeFromArray(temporaryStyles, value);
                            }
                        }, maxStagger = itemIndex > 0 && (timings.transitionDuration && 0 === stagger.transitionDuration || timings.animationDuration && 0 === stagger.animationDuration) && Math.max(stagger.animationDelay, stagger.transitionDelay);
                        maxStagger ? $timeout(triggerAnimationStart, Math.floor(maxStagger * itemIndex * ONE_SECOND), !1) : triggerAnimationStart(), 
                        runnerHost.resume = function() {
                            playPause(!0);
                        }, runnerHost.pause = function() {
                            playPause(!1);
                        };
                    }
                }
                var options = initialOptions || {};
                options.$$prepared || (options = prepareAnimationOptions(copy(options)));
                var restoreStyles = {}, node = getDomNode(element);
                if (!node || !node.parentNode || !$$animateQueue.enabled()) return closeAndReturnNoopAnimator();
                var animationClosed, animationPaused, animationCompleted, runner, runnerHost, maxDelay, maxDelayTime, maxDuration, maxDurationTime, startTime, temporaryStyles = [], classes = element.attr("class"), styles = packageStyles(options), events = [];
                if (0 === options.duration || !$sniffer.animations && !$sniffer.transitions) return closeAndReturnNoopAnimator();
                var method = options.event && isArray(options.event) ? options.event.join(" ") : options.event, isStructural = method && options.structural, structuralClassName = "", addRemoveClassName = "";
                isStructural ? structuralClassName = pendClasses(method, EVENT_CLASS_PREFIX, !0) : method && (structuralClassName = method), 
                options.addClass && (addRemoveClassName += pendClasses(options.addClass, ADD_CLASS_SUFFIX)), 
                options.removeClass && (addRemoveClassName.length && (addRemoveClassName += " "), 
                addRemoveClassName += pendClasses(options.removeClass, REMOVE_CLASS_SUFFIX)), options.applyClassesEarly && addRemoveClassName.length && applyAnimationClasses(element, options);
                var preparationClasses = [ structuralClassName, addRemoveClassName ].join(" ").trim(), fullClassName = classes + " " + preparationClasses, activeClasses = pendClasses(preparationClasses, ACTIVE_CLASS_SUFFIX), hasToStyles = styles.to && Object.keys(styles.to).length > 0, containsKeyframeAnimation = (options.keyframeStyle || "").length > 0;
                if (!containsKeyframeAnimation && !hasToStyles && !preparationClasses) return closeAndReturnNoopAnimator();
                var cacheKey, stagger;
                if (options.stagger > 0) {
                    var staggerVal = parseFloat(options.stagger);
                    stagger = {
                        transitionDelay: staggerVal,
                        animationDelay: staggerVal,
                        transitionDuration: 0,
                        animationDuration: 0
                    };
                } else cacheKey = gcsHashFn(node, fullClassName), stagger = computeCachedCssStaggerStyles(node, preparationClasses, cacheKey, DETECT_STAGGER_CSS_PROPERTIES);
                options.$$skipPreparationClasses || $$jqLite.addClass(element, preparationClasses);
                var applyOnlyDuration;
                if (options.transitionStyle) {
                    var transitionStyle = [ TRANSITION_PROP, options.transitionStyle ];
                    applyInlineStyle(node, transitionStyle), temporaryStyles.push(transitionStyle);
                }
                if (options.duration >= 0) {
                    applyOnlyDuration = node.style[TRANSITION_PROP].length > 0;
                    var durationStyle = getCssTransitionDurationStyle(options.duration, applyOnlyDuration);
                    applyInlineStyle(node, durationStyle), temporaryStyles.push(durationStyle);
                }
                if (options.keyframeStyle) {
                    var keyframeStyle = [ ANIMATION_PROP, options.keyframeStyle ];
                    applyInlineStyle(node, keyframeStyle), temporaryStyles.push(keyframeStyle);
                }
                var itemIndex = stagger ? options.staggerIndex >= 0 ? options.staggerIndex : gcsLookup.count(cacheKey) : 0, isFirst = 0 === itemIndex;
                isFirst && !options.skipBlocking && blockTransitions(node, SAFE_FAST_FORWARD_DURATION_VALUE);
                var timings = computeTimings(node, fullClassName, cacheKey), relativeDelay = timings.maxDelay;
                maxDelay = Math.max(relativeDelay, 0), maxDuration = timings.maxDuration;
                var flags = {};
                if (flags.hasTransitions = timings.transitionDuration > 0, flags.hasAnimations = timings.animationDuration > 0, 
                flags.hasTransitionAll = flags.hasTransitions && "all" === timings.transitionProperty, 
                flags.applyTransitionDuration = hasToStyles && (flags.hasTransitions && !flags.hasTransitionAll || flags.hasAnimations && !flags.hasTransitions), 
                flags.applyAnimationDuration = options.duration && flags.hasAnimations, flags.applyTransitionDelay = truthyTimingValue(options.delay) && (flags.applyTransitionDuration || flags.hasTransitions), 
                flags.applyAnimationDelay = truthyTimingValue(options.delay) && flags.hasAnimations, 
                flags.recalculateTimingStyles = addRemoveClassName.length > 0, (flags.applyTransitionDuration || flags.applyAnimationDuration) && (maxDuration = options.duration ? parseFloat(options.duration) : maxDuration, 
                flags.applyTransitionDuration && (flags.hasTransitions = !0, timings.transitionDuration = maxDuration, 
                applyOnlyDuration = node.style[TRANSITION_PROP + PROPERTY_KEY].length > 0, temporaryStyles.push(getCssTransitionDurationStyle(maxDuration, applyOnlyDuration))), 
                flags.applyAnimationDuration && (flags.hasAnimations = !0, timings.animationDuration = maxDuration, 
                temporaryStyles.push(getCssKeyframeDurationStyle(maxDuration)))), 0 === maxDuration && !flags.recalculateTimingStyles) return closeAndReturnNoopAnimator();
                if (null != options.delay) {
                    var delayStyle;
                    "boolean" != typeof options.delay && (delayStyle = parseFloat(options.delay), maxDelay = Math.max(delayStyle, 0)), 
                    flags.applyTransitionDelay && temporaryStyles.push(getCssDelayStyle(delayStyle)), 
                    flags.applyAnimationDelay && temporaryStyles.push(getCssDelayStyle(delayStyle, !0));
                }
                return null == options.duration && timings.transitionDuration > 0 && (flags.recalculateTimingStyles = flags.recalculateTimingStyles || isFirst), 
                maxDelayTime = maxDelay * ONE_SECOND, maxDurationTime = maxDuration * ONE_SECOND, 
                options.skipBlocking || (flags.blockTransition = timings.transitionDuration > 0, 
                flags.blockKeyframeAnimation = timings.animationDuration > 0 && stagger.animationDelay > 0 && 0 === stagger.animationDuration), 
                options.from && (options.cleanupStyles && registerRestorableStyles(restoreStyles, node, Object.keys(options.from)), 
                applyAnimationFromStyles(element, options)), flags.blockTransition || flags.blockKeyframeAnimation ? applyBlocking(maxDuration) : options.skipBlocking || blockTransitions(node, !1), 
                {
                    $$willAnimate: !0,
                    end: endFn,
                    start: function() {
                        return animationClosed ? void 0 : (runnerHost = {
                            end: endFn,
                            cancel: cancelFn,
                            resume: null,
                            pause: null
                        }, runner = new $$AnimateRunner(runnerHost), waitUntilQuiet(start), runner);
                    }
                };
            };
        } ];
    } ], $$AnimateCssDriverProvider = [ "$$animationProvider", function($$animationProvider) {
        function isDocumentFragment(node) {
            return node.parentNode && 11 === node.parentNode.nodeType;
        }
        $$animationProvider.drivers.push("$$animateCssDriver");
        var NG_ANIMATE_SHIM_CLASS_NAME = "ng-animate-shim", NG_ANIMATE_ANCHOR_CLASS_NAME = "ng-anchor", NG_OUT_ANCHOR_CLASS_NAME = "ng-anchor-out", NG_IN_ANCHOR_CLASS_NAME = "ng-anchor-in";
        this.$get = [ "$animateCss", "$rootScope", "$$AnimateRunner", "$rootElement", "$sniffer", "$$jqLite", "$document", function($animateCss, $rootScope, $$AnimateRunner, $rootElement, $sniffer, $$jqLite, $document) {
            function filterCssClasses(classes) {
                return classes.replace(/\bng-\S+\b/g, "");
            }
            function getUniqueValues(a, b) {
                return isString(a) && (a = a.split(" ")), isString(b) && (b = b.split(" ")), a.filter(function(val) {
                    return -1 === b.indexOf(val);
                }).join(" ");
            }
            function prepareAnchoredAnimation(classes, outAnchor, inAnchor) {
                function calculateAnchorStyles(anchor) {
                    var styles = {}, coords = getDomNode(anchor).getBoundingClientRect();
                    return forEach([ "width", "height", "top", "left" ], function(key) {
                        var value = coords[key];
                        switch (key) {
                          case "top":
                            value += bodyNode.scrollTop;
                            break;

                          case "left":
                            value += bodyNode.scrollLeft;
                        }
                        styles[key] = Math.floor(value) + "px";
                    }), styles;
                }
                function prepareOutAnimation() {
                    var animator = $animateCss(clone, {
                        addClass: NG_OUT_ANCHOR_CLASS_NAME,
                        delay: !0,
                        from: calculateAnchorStyles(outAnchor)
                    });
                    return animator.$$willAnimate ? animator : null;
                }
                function getClassVal(element) {
                    return element.attr("class") || "";
                }
                function prepareInAnimation() {
                    var endingClasses = filterCssClasses(getClassVal(inAnchor)), toAdd = getUniqueValues(endingClasses, startingClasses), toRemove = getUniqueValues(startingClasses, endingClasses), animator = $animateCss(clone, {
                        to: calculateAnchorStyles(inAnchor),
                        addClass: NG_IN_ANCHOR_CLASS_NAME + " " + toAdd,
                        removeClass: NG_OUT_ANCHOR_CLASS_NAME + " " + toRemove,
                        delay: !0
                    });
                    return animator.$$willAnimate ? animator : null;
                }
                function end() {
                    clone.remove(), outAnchor.removeClass(NG_ANIMATE_SHIM_CLASS_NAME), inAnchor.removeClass(NG_ANIMATE_SHIM_CLASS_NAME);
                }
                var clone = jqLite(getDomNode(outAnchor).cloneNode(!0)), startingClasses = filterCssClasses(getClassVal(clone));
                outAnchor.addClass(NG_ANIMATE_SHIM_CLASS_NAME), inAnchor.addClass(NG_ANIMATE_SHIM_CLASS_NAME), 
                clone.addClass(NG_ANIMATE_ANCHOR_CLASS_NAME), rootBodyElement.append(clone);
                var animatorIn, animatorOut = prepareOutAnimation();
                if (!animatorOut && (animatorIn = prepareInAnimation(), !animatorIn)) return end();
                var startingAnimator = animatorOut || animatorIn;
                return {
                    start: function() {
                        function endFn() {
                            currentAnimation && currentAnimation.end();
                        }
                        var runner, currentAnimation = startingAnimator.start();
                        return currentAnimation.done(function() {
                            return currentAnimation = null, !animatorIn && (animatorIn = prepareInAnimation()) ? (currentAnimation = animatorIn.start(), 
                            currentAnimation.done(function() {
                                currentAnimation = null, end(), runner.complete();
                            }), currentAnimation) : (end(), void runner.complete());
                        }), runner = new $$AnimateRunner({
                            end: endFn,
                            cancel: endFn
                        });
                    }
                };
            }
            function prepareFromToAnchorAnimation(from, to, classes, anchors) {
                var fromAnimation = prepareRegularAnimation(from, noop), toAnimation = prepareRegularAnimation(to, noop), anchorAnimations = [];
                return forEach(anchors, function(anchor) {
                    var outElement = anchor.out, inElement = anchor["in"], animator = prepareAnchoredAnimation(classes, outElement, inElement);
                    animator && anchorAnimations.push(animator);
                }), fromAnimation || toAnimation || 0 !== anchorAnimations.length ? {
                    start: function() {
                        function endFn() {
                            forEach(animationRunners, function(runner) {
                                runner.end();
                            });
                        }
                        var animationRunners = [];
                        fromAnimation && animationRunners.push(fromAnimation.start()), toAnimation && animationRunners.push(toAnimation.start()), 
                        forEach(anchorAnimations, function(animation) {
                            animationRunners.push(animation.start());
                        });
                        var runner = new $$AnimateRunner({
                            end: endFn,
                            cancel: endFn
                        });
                        return $$AnimateRunner.all(animationRunners, function(status) {
                            runner.complete(status);
                        }), runner;
                    }
                } : void 0;
            }
            function prepareRegularAnimation(animationDetails) {
                var element = animationDetails.element, options = animationDetails.options || {};
                animationDetails.structural && (options.event = animationDetails.event, options.structural = !0, 
                options.applyClassesEarly = !0, "leave" === animationDetails.event && (options.onDone = options.domOperation)), 
                options.preparationClasses && (options.event = concatWithSpace(options.event, options.preparationClasses));
                var animator = $animateCss(element, options);
                return animator.$$willAnimate ? animator : null;
            }
            if (!$sniffer.animations && !$sniffer.transitions) return noop;
            var bodyNode = $document[0].body, rootNode = getDomNode($rootElement), rootBodyElement = jqLite(isDocumentFragment(rootNode) || bodyNode.contains(rootNode) ? rootNode : bodyNode);
            return function(animationDetails) {
                return animationDetails.from && animationDetails.to ? prepareFromToAnchorAnimation(animationDetails.from, animationDetails.to, animationDetails.classes, animationDetails.anchors) : prepareRegularAnimation(animationDetails);
            };
        } ];
    } ], $$AnimateJsProvider = [ "$animateProvider", function($animateProvider) {
        this.$get = [ "$injector", "$$AnimateRunner", "$$jqLite", function($injector, $$AnimateRunner, $$jqLite) {
            function lookupAnimations(classes) {
                classes = isArray(classes) ? classes : classes.split(" ");
                for (var matches = [], flagMap = {}, i = 0; i < classes.length; i++) {
                    var klass = classes[i], animationFactory = $animateProvider.$$registeredAnimations[klass];
                    animationFactory && !flagMap[klass] && (matches.push($injector.get(animationFactory)), 
                    flagMap[klass] = !0);
                }
                return matches;
            }
            var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);
            return function(element, event, classes, options) {
                function applyOptions() {
                    options.domOperation(), applyAnimationClasses(element, options);
                }
                function close() {
                    animationClosed = !0, applyOptions(), applyAnimationStyles(element, options);
                }
                function executeAnimationFn(fn, element, event, options, onDone) {
                    var args;
                    switch (event) {
                      case "animate":
                        args = [ element, options.from, options.to, onDone ];
                        break;

                      case "setClass":
                        args = [ element, classesToAdd, classesToRemove, onDone ];
                        break;

                      case "addClass":
                        args = [ element, classesToAdd, onDone ];
                        break;

                      case "removeClass":
                        args = [ element, classesToRemove, onDone ];
                        break;

                      default:
                        args = [ element, onDone ];
                    }
                    args.push(options);
                    var value = fn.apply(fn, args);
                    if (value) if (isFunction(value.start) && (value = value.start()), value instanceof $$AnimateRunner) value.done(onDone); else if (isFunction(value)) return value;
                    return noop;
                }
                function groupEventedAnimations(element, event, options, animations, fnName) {
                    var operations = [];
                    return forEach(animations, function(ani) {
                        var animation = ani[fnName];
                        animation && operations.push(function() {
                            var runner, endProgressCb, resolved = !1, onAnimationComplete = function(rejected) {
                                resolved || (resolved = !0, (endProgressCb || noop)(rejected), runner.complete(!rejected));
                            };
                            return runner = new $$AnimateRunner({
                                end: function() {
                                    onAnimationComplete();
                                },
                                cancel: function() {
                                    onAnimationComplete(!0);
                                }
                            }), endProgressCb = executeAnimationFn(animation, element, event, options, function(result) {
                                var cancelled = result === !1;
                                onAnimationComplete(cancelled);
                            }), runner;
                        });
                    }), operations;
                }
                function packageAnimations(element, event, options, animations, fnName) {
                    var operations = groupEventedAnimations(element, event, options, animations, fnName);
                    if (0 === operations.length) {
                        var a, b;
                        "beforeSetClass" === fnName ? (a = groupEventedAnimations(element, "removeClass", options, animations, "beforeRemoveClass"), 
                        b = groupEventedAnimations(element, "addClass", options, animations, "beforeAddClass")) : "setClass" === fnName && (a = groupEventedAnimations(element, "removeClass", options, animations, "removeClass"), 
                        b = groupEventedAnimations(element, "addClass", options, animations, "addClass")), 
                        a && (operations = operations.concat(a)), b && (operations = operations.concat(b));
                    }
                    if (0 !== operations.length) return function(callback) {
                        var runners = [];
                        return operations.length && forEach(operations, function(animateFn) {
                            runners.push(animateFn());
                        }), runners.length ? $$AnimateRunner.all(runners, callback) : callback(), function(reject) {
                            forEach(runners, function(runner) {
                                reject ? runner.cancel() : runner.end();
                            });
                        };
                    };
                }
                var animationClosed = !1;
                3 === arguments.length && isObject(classes) && (options = classes, classes = null), 
                options = prepareAnimationOptions(options), classes || (classes = element.attr("class") || "", 
                options.addClass && (classes += " " + options.addClass), options.removeClass && (classes += " " + options.removeClass));
                var before, after, classesToAdd = options.addClass, classesToRemove = options.removeClass, animations = lookupAnimations(classes);
                if (animations.length) {
                    var afterFn, beforeFn;
                    "leave" === event ? (beforeFn = "leave", afterFn = "afterLeave") : (beforeFn = "before" + event.charAt(0).toUpperCase() + event.substr(1), 
                    afterFn = event), "enter" !== event && "move" !== event && (before = packageAnimations(element, event, options, animations, beforeFn)), 
                    after = packageAnimations(element, event, options, animations, afterFn);
                }
                if (before || after) {
                    var runner;
                    return {
                        $$willAnimate: !0,
                        end: function() {
                            return runner ? runner.end() : (close(), runner = new $$AnimateRunner(), runner.complete(!0)), 
                            runner;
                        },
                        start: function() {
                            function onComplete(success) {
                                close(success), runner.complete(success);
                            }
                            function endAnimations(cancelled) {
                                animationClosed || ((closeActiveAnimations || noop)(cancelled), onComplete(cancelled));
                            }
                            if (runner) return runner;
                            runner = new $$AnimateRunner();
                            var closeActiveAnimations, chain = [];
                            return before && chain.push(function(fn) {
                                closeActiveAnimations = before(fn);
                            }), chain.length ? chain.push(function(fn) {
                                applyOptions(), fn(!0);
                            }) : applyOptions(), after && chain.push(function(fn) {
                                closeActiveAnimations = after(fn);
                            }), runner.setHost({
                                end: function() {
                                    endAnimations();
                                },
                                cancel: function() {
                                    endAnimations(!0);
                                }
                            }), $$AnimateRunner.chain(chain, onComplete), runner;
                        }
                    };
                }
            };
        } ];
    } ], $$AnimateJsDriverProvider = [ "$$animationProvider", function($$animationProvider) {
        $$animationProvider.drivers.push("$$animateJsDriver"), this.$get = [ "$$animateJs", "$$AnimateRunner", function($$animateJs, $$AnimateRunner) {
            function prepareAnimation(animationDetails) {
                var element = animationDetails.element, event = animationDetails.event, options = animationDetails.options, classes = animationDetails.classes;
                return $$animateJs(element, event, classes, options);
            }
            return function(animationDetails) {
                if (animationDetails.from && animationDetails.to) {
                    var fromAnimation = prepareAnimation(animationDetails.from), toAnimation = prepareAnimation(animationDetails.to);
                    if (!fromAnimation && !toAnimation) return;
                    return {
                        start: function() {
                            function endFnFactory() {
                                return function() {
                                    forEach(animationRunners, function(runner) {
                                        runner.end();
                                    });
                                };
                            }
                            function done(status) {
                                runner.complete(status);
                            }
                            var animationRunners = [];
                            fromAnimation && animationRunners.push(fromAnimation.start()), toAnimation && animationRunners.push(toAnimation.start()), 
                            $$AnimateRunner.all(animationRunners, done);
                            var runner = new $$AnimateRunner({
                                end: endFnFactory(),
                                cancel: endFnFactory()
                            });
                            return runner;
                        }
                    };
                }
                return prepareAnimation(animationDetails);
            };
        } ];
    } ], NG_ANIMATE_ATTR_NAME = "data-ng-animate", NG_ANIMATE_PIN_DATA = "$ngAnimatePin", $$AnimateQueueProvider = [ "$animateProvider", function($animateProvider) {
        function makeTruthyCssClassMap(classString) {
            if (!classString) return null;
            var keys = classString.split(ONE_SPACE), map = Object.create(null);
            return forEach(keys, function(key) {
                map[key] = !0;
            }), map;
        }
        function hasMatchingClasses(newClassString, currentClassString) {
            if (newClassString && currentClassString) {
                var currentClassMap = makeTruthyCssClassMap(currentClassString);
                return newClassString.split(ONE_SPACE).some(function(className) {
                    return currentClassMap[className];
                });
            }
        }
        function isAllowed(ruleType, currentAnimation, previousAnimation) {
            return rules[ruleType].some(function(fn) {
                return fn(currentAnimation, previousAnimation);
            });
        }
        function hasAnimationClasses(animation, and) {
            var a = (animation.addClass || "").length > 0, b = (animation.removeClass || "").length > 0;
            return and ? a && b : a || b;
        }
        var PRE_DIGEST_STATE = 1, RUNNING_STATE = 2, ONE_SPACE = " ", rules = this.rules = {
            skip: [],
            cancel: [],
            join: []
        };
        rules.join.push(function(newAnimation) {
            return !newAnimation.structural && hasAnimationClasses(newAnimation);
        }), rules.skip.push(function(newAnimation) {
            return !newAnimation.structural && !hasAnimationClasses(newAnimation);
        }), rules.skip.push(function(newAnimation, currentAnimation) {
            return "leave" === currentAnimation.event && newAnimation.structural;
        }), rules.skip.push(function(newAnimation, currentAnimation) {
            return currentAnimation.structural && currentAnimation.state === RUNNING_STATE && !newAnimation.structural;
        }), rules.cancel.push(function(newAnimation, currentAnimation) {
            return currentAnimation.structural && newAnimation.structural;
        }), rules.cancel.push(function(newAnimation, currentAnimation) {
            return currentAnimation.state === RUNNING_STATE && newAnimation.structural;
        }), rules.cancel.push(function(newAnimation, currentAnimation) {
            if (currentAnimation.structural) return !1;
            var nA = newAnimation.addClass, nR = newAnimation.removeClass, cA = currentAnimation.addClass, cR = currentAnimation.removeClass;
            return isUndefined(nA) && isUndefined(nR) || isUndefined(cA) && isUndefined(cR) ? !1 : hasMatchingClasses(nA, cR) || hasMatchingClasses(nR, cA);
        }), this.$get = [ "$$rAF", "$rootScope", "$rootElement", "$document", "$$Map", "$$animation", "$$AnimateRunner", "$templateRequest", "$$jqLite", "$$forceReflow", "$$isDocumentHidden", function($$rAF, $rootScope, $rootElement, $document, $$Map, $$animation, $$AnimateRunner, $templateRequest, $$jqLite, $$forceReflow, $$isDocumentHidden) {
            function postDigestTaskFactory() {
                var postDigestCalled = !1;
                return function(fn) {
                    postDigestCalled ? fn() : $rootScope.$$postDigest(function() {
                        postDigestCalled = !0, fn();
                    });
                };
            }
            function normalizeAnimationDetails(element, animation) {
                return mergeAnimationDetails(element, animation, {});
            }
            function findCallbacks(targetParentNode, targetNode, event) {
                var matches = [], entries = callbackRegistry[event];
                return entries && forEach(entries, function(entry) {
                    contains.call(entry.node, targetNode) ? matches.push(entry.callback) : "leave" === event && contains.call(entry.node, targetParentNode) && matches.push(entry.callback);
                }), matches;
            }
            function filterFromRegistry(list, matchContainer, matchCallback) {
                var containerNode = extractElementNode(matchContainer);
                return list.filter(function(entry) {
                    var isMatch = entry.node === containerNode && (!matchCallback || entry.callback === matchCallback);
                    return !isMatch;
                });
            }
            function cleanupEventListeners(phase, node) {
                "close" !== phase || node.parentNode || $animate.off(node);
            }
            function queueAnimation(originalElement, event, initialOptions) {
                function notifyProgress(runner, event, phase, data) {
                    runInNextPostDigestOrNow(function() {
                        var callbacks = findCallbacks(parentNode, node, event);
                        callbacks.length ? $$rAF(function() {
                            forEach(callbacks, function(callback) {
                                callback(element, phase, data);
                            }), cleanupEventListeners(phase, node);
                        }) : cleanupEventListeners(phase, node);
                    }), runner.progress(event, phase, data);
                }
                function close(reject) {
                    clearGeneratedClasses(element, options), applyAnimationClasses(element, options), 
                    applyAnimationStyles(element, options), options.domOperation(), runner.complete(!reject);
                }
                var options = copy(initialOptions), element = stripCommentsFromElement(originalElement), node = getDomNode(element), parentNode = node && node.parentNode;
                options = prepareAnimationOptions(options);
                var runner = new $$AnimateRunner(), runInNextPostDigestOrNow = postDigestTaskFactory();
                if (isArray(options.addClass) && (options.addClass = options.addClass.join(" ")), 
                options.addClass && !isString(options.addClass) && (options.addClass = null), isArray(options.removeClass) && (options.removeClass = options.removeClass.join(" ")), 
                options.removeClass && !isString(options.removeClass) && (options.removeClass = null), 
                options.from && !isObject(options.from) && (options.from = null), options.to && !isObject(options.to) && (options.to = null), 
                !(animationsEnabled && node && isAnimatableByFilter(node, event, initialOptions) && isAnimatableClassName(node, options))) return close(), 
                runner;
                var isStructural = [ "enter", "move", "leave" ].indexOf(event) >= 0, documentHidden = $$isDocumentHidden(), skipAnimations = documentHidden || disabledElementsLookup.get(node), existingAnimation = !skipAnimations && activeAnimationsLookup.get(node) || {}, hasExistingAnimation = !!existingAnimation.state;
                if (skipAnimations || hasExistingAnimation && existingAnimation.state === PRE_DIGEST_STATE || (skipAnimations = !areAnimationsAllowed(node, parentNode, event)), 
                skipAnimations) return documentHidden && notifyProgress(runner, event, "start"), 
                close(), documentHidden && notifyProgress(runner, event, "close"), runner;
                isStructural && closeChildAnimations(node);
                var newAnimation = {
                    structural: isStructural,
                    element: element,
                    event: event,
                    addClass: options.addClass,
                    removeClass: options.removeClass,
                    close: close,
                    options: options,
                    runner: runner
                };
                if (hasExistingAnimation) {
                    var skipAnimationFlag = isAllowed("skip", newAnimation, existingAnimation);
                    if (skipAnimationFlag) return existingAnimation.state === RUNNING_STATE ? (close(), 
                    runner) : (mergeAnimationDetails(element, existingAnimation, newAnimation), existingAnimation.runner);
                    var cancelAnimationFlag = isAllowed("cancel", newAnimation, existingAnimation);
                    if (cancelAnimationFlag) if (existingAnimation.state === RUNNING_STATE) existingAnimation.runner.end(); else {
                        if (!existingAnimation.structural) return mergeAnimationDetails(element, existingAnimation, newAnimation), 
                        existingAnimation.runner;
                        existingAnimation.close();
                    } else {
                        var joinAnimationFlag = isAllowed("join", newAnimation, existingAnimation);
                        if (joinAnimationFlag) {
                            if (existingAnimation.state !== RUNNING_STATE) return applyGeneratedPreparationClasses(element, isStructural ? event : null, options), 
                            event = newAnimation.event = existingAnimation.event, options = mergeAnimationDetails(element, existingAnimation, newAnimation), 
                            existingAnimation.runner;
                            normalizeAnimationDetails(element, newAnimation);
                        }
                    }
                } else normalizeAnimationDetails(element, newAnimation);
                var isValidAnimation = newAnimation.structural;
                if (isValidAnimation || (isValidAnimation = "animate" === newAnimation.event && Object.keys(newAnimation.options.to || {}).length > 0 || hasAnimationClasses(newAnimation)), 
                !isValidAnimation) return close(), clearElementAnimationState(node), runner;
                var counter = (existingAnimation.counter || 0) + 1;
                return newAnimation.counter = counter, markElementAnimationState(node, PRE_DIGEST_STATE, newAnimation), 
                $rootScope.$$postDigest(function() {
                    element = stripCommentsFromElement(originalElement);
                    var animationDetails = activeAnimationsLookup.get(node), animationCancelled = !animationDetails;
                    animationDetails = animationDetails || {};
                    var parentElement = element.parent() || [], isValidAnimation = parentElement.length > 0 && ("animate" === animationDetails.event || animationDetails.structural || hasAnimationClasses(animationDetails));
                    if (animationCancelled || animationDetails.counter !== counter || !isValidAnimation) return animationCancelled && (applyAnimationClasses(element, options), 
                    applyAnimationStyles(element, options)), (animationCancelled || isStructural && animationDetails.event !== event) && (options.domOperation(), 
                    runner.end()), void (isValidAnimation || clearElementAnimationState(node));
                    event = !animationDetails.structural && hasAnimationClasses(animationDetails, !0) ? "setClass" : animationDetails.event, 
                    markElementAnimationState(node, RUNNING_STATE);
                    var realRunner = $$animation(element, event, animationDetails.options);
                    runner.setHost(realRunner), notifyProgress(runner, event, "start", {}), realRunner.done(function(status) {
                        close(!status);
                        var animationDetails = activeAnimationsLookup.get(node);
                        animationDetails && animationDetails.counter === counter && clearElementAnimationState(node), 
                        notifyProgress(runner, event, "close", {});
                    });
                }), runner;
            }
            function closeChildAnimations(node) {
                var children = node.querySelectorAll("[" + NG_ANIMATE_ATTR_NAME + "]");
                forEach(children, function(child) {
                    var state = parseInt(child.getAttribute(NG_ANIMATE_ATTR_NAME), 10), animationDetails = activeAnimationsLookup.get(child);
                    if (animationDetails) switch (state) {
                      case RUNNING_STATE:
                        animationDetails.runner.end();

                      case PRE_DIGEST_STATE:
                        activeAnimationsLookup.delete(child);
                    }
                });
            }
            function clearElementAnimationState(node) {
                node.removeAttribute(NG_ANIMATE_ATTR_NAME), activeAnimationsLookup.delete(node);
            }
            function areAnimationsAllowed(node, parentNode) {
                var animateChildren, bodyNode = $document[0].body, rootNode = getDomNode($rootElement), bodyNodeDetected = node === bodyNode || "HTML" === node.nodeName, rootNodeDetected = node === rootNode, parentAnimationDetected = !1, elementDisabled = disabledElementsLookup.get(node), parentHost = jqLite.data(node, NG_ANIMATE_PIN_DATA);
                for (parentHost && (parentNode = getDomNode(parentHost)); parentNode && (rootNodeDetected || (rootNodeDetected = parentNode === rootNode), 
                parentNode.nodeType === ELEMENT_NODE); ) {
                    var details = activeAnimationsLookup.get(parentNode) || {};
                    if (!parentAnimationDetected) {
                        var parentNodeDisabled = disabledElementsLookup.get(parentNode);
                        if (parentNodeDisabled === !0 && elementDisabled !== !1) {
                            elementDisabled = !0;
                            break;
                        }
                        parentNodeDisabled === !1 && (elementDisabled = !1), parentAnimationDetected = details.structural;
                    }
                    if (isUndefined(animateChildren) || animateChildren === !0) {
                        var value = jqLite.data(parentNode, NG_ANIMATE_CHILDREN_DATA);
                        isDefined(value) && (animateChildren = value);
                    }
                    if (parentAnimationDetected && animateChildren === !1) break;
                    if (bodyNodeDetected || (bodyNodeDetected = parentNode === bodyNode), bodyNodeDetected && rootNodeDetected) break;
                    parentNode = rootNodeDetected || !(parentHost = jqLite.data(parentNode, NG_ANIMATE_PIN_DATA)) ? parentNode.parentNode : getDomNode(parentHost);
                }
                var allowAnimation = (!parentAnimationDetected || animateChildren) && elementDisabled !== !0;
                return allowAnimation && rootNodeDetected && bodyNodeDetected;
            }
            function markElementAnimationState(node, state, details) {
                details = details || {}, details.state = state, node.setAttribute(NG_ANIMATE_ATTR_NAME, state);
                var oldValue = activeAnimationsLookup.get(node), newValue = oldValue ? extend(oldValue, details) : details;
                activeAnimationsLookup.set(node, newValue);
            }
            var activeAnimationsLookup = new $$Map(), disabledElementsLookup = new $$Map(), animationsEnabled = null, deregisterWatch = $rootScope.$watch(function() {
                return 0 === $templateRequest.totalPendingRequests;
            }, function(isEmpty) {
                isEmpty && (deregisterWatch(), $rootScope.$$postDigest(function() {
                    $rootScope.$$postDigest(function() {
                        null === animationsEnabled && (animationsEnabled = !0);
                    });
                }));
            }), callbackRegistry = Object.create(null), customFilter = $animateProvider.customFilter(), classNameFilter = $animateProvider.classNameFilter(), returnTrue = function() {
                return !0;
            }, isAnimatableByFilter = customFilter || returnTrue, isAnimatableClassName = classNameFilter ? function(node, options) {
                var className = [ node.getAttribute("class"), options.addClass, options.removeClass ].join(" ");
                return classNameFilter.test(className);
            } : returnTrue, applyAnimationClasses = applyAnimationClassesFactory($$jqLite), contains = window.Node.prototype.contains || function(arg) {
                return this === arg || !!(16 & this.compareDocumentPosition(arg));
            }, $animate = {
                on: function(event, container, callback) {
                    var node = extractElementNode(container);
                    callbackRegistry[event] = callbackRegistry[event] || [], callbackRegistry[event].push({
                        node: node,
                        callback: callback
                    }), jqLite(container).on("$destroy", function() {
                        var animationDetails = activeAnimationsLookup.get(node);
                        animationDetails || $animate.off(event, container, callback);
                    });
                },
                off: function(event, container, callback) {
                    if (1 !== arguments.length || isString(arguments[0])) {
                        var entries = callbackRegistry[event];
                        entries && (callbackRegistry[event] = 1 === arguments.length ? null : filterFromRegistry(entries, container, callback));
                    } else {
                        container = arguments[0];
                        for (var eventType in callbackRegistry) callbackRegistry[eventType] = filterFromRegistry(callbackRegistry[eventType], container);
                    }
                },
                pin: function(element, parentElement) {
                    assertArg(isElement(element), "element", "not an element"), assertArg(isElement(parentElement), "parentElement", "not an element"), 
                    element.data(NG_ANIMATE_PIN_DATA, parentElement);
                },
                push: function(element, event, options, domOperation) {
                    return options = options || {}, options.domOperation = domOperation, queueAnimation(element, event, options);
                },
                enabled: function(element, bool) {
                    var argCount = arguments.length;
                    if (0 === argCount) bool = !!animationsEnabled; else {
                        var hasElement = isElement(element);
                        if (hasElement) {
                            var node = getDomNode(element);
                            1 === argCount ? bool = !disabledElementsLookup.get(node) : disabledElementsLookup.set(node, !bool);
                        } else bool = animationsEnabled = !!element;
                    }
                    return bool;
                }
            };
            return $animate;
        } ];
    } ], $$AnimationProvider = [ "$animateProvider", function() {
        function setRunner(element, runner) {
            element.data(RUNNER_STORAGE_KEY, runner);
        }
        function removeRunner(element) {
            element.removeData(RUNNER_STORAGE_KEY);
        }
        function getRunner(element) {
            return element.data(RUNNER_STORAGE_KEY);
        }
        var NG_ANIMATE_REF_ATTR = "ng-animate-ref", drivers = this.drivers = [], RUNNER_STORAGE_KEY = "$$animationRunner";
        this.$get = [ "$$jqLite", "$rootScope", "$injector", "$$AnimateRunner", "$$Map", "$$rAFScheduler", function($$jqLite, $rootScope, $injector, $$AnimateRunner, $$Map, $$rAFScheduler) {
            function sortAnimations(animations) {
                function processNode(entry) {
                    if (entry.processed) return entry;
                    entry.processed = !0;
                    var elementNode = entry.domNode, parentNode = elementNode.parentNode;
                    lookup.set(elementNode, entry);
                    for (var parentEntry; parentNode; ) {
                        if (parentEntry = lookup.get(parentNode)) {
                            parentEntry.processed || (parentEntry = processNode(parentEntry));
                            break;
                        }
                        parentNode = parentNode.parentNode;
                    }
                    return (parentEntry || tree).children.push(entry), entry;
                }
                function flatten(tree) {
                    var i, result = [], queue = [];
                    for (i = 0; i < tree.children.length; i++) queue.push(tree.children[i]);
                    var remainingLevelEntries = queue.length, nextLevelEntries = 0, row = [];
                    for (i = 0; i < queue.length; i++) {
                        var entry = queue[i];
                        0 >= remainingLevelEntries && (remainingLevelEntries = nextLevelEntries, nextLevelEntries = 0, 
                        result.push(row), row = []), row.push(entry.fn), entry.children.forEach(function(childEntry) {
                            nextLevelEntries++, queue.push(childEntry);
                        }), remainingLevelEntries--;
                    }
                    return row.length && result.push(row), result;
                }
                var i, tree = {
                    children: []
                }, lookup = new $$Map();
                for (i = 0; i < animations.length; i++) {
                    var animation = animations[i];
                    lookup.set(animation.domNode, animations[i] = {
                        domNode: animation.domNode,
                        fn: animation.fn,
                        children: []
                    });
                }
                for (i = 0; i < animations.length; i++) processNode(animations[i]);
                return flatten(tree);
            }
            var animationQueue = [], applyAnimationClasses = applyAnimationClassesFactory($$jqLite);
            return function(element, event, options) {
                function getAnchorNodes(node) {
                    var SELECTOR = "[" + NG_ANIMATE_REF_ATTR + "]", items = node.hasAttribute(NG_ANIMATE_REF_ATTR) ? [ node ] : node.querySelectorAll(SELECTOR), anchors = [];
                    return forEach(items, function(node) {
                        var attr = node.getAttribute(NG_ANIMATE_REF_ATTR);
                        attr && attr.length && anchors.push(node);
                    }), anchors;
                }
                function groupAnimations(animations) {
                    var preparedAnimations = [], refLookup = {};
                    forEach(animations, function(animation, index) {
                        var element = animation.element, node = getDomNode(element), event = animation.event, enterOrMove = [ "enter", "move" ].indexOf(event) >= 0, anchorNodes = animation.structural ? getAnchorNodes(node) : [];
                        if (anchorNodes.length) {
                            var direction = enterOrMove ? "to" : "from";
                            forEach(anchorNodes, function(anchor) {
                                var key = anchor.getAttribute(NG_ANIMATE_REF_ATTR);
                                refLookup[key] = refLookup[key] || {}, refLookup[key][direction] = {
                                    animationID: index,
                                    element: jqLite(anchor)
                                };
                            });
                        } else preparedAnimations.push(animation);
                    });
                    var usedIndicesLookup = {}, anchorGroups = {};
                    return forEach(refLookup, function(operations) {
                        var from = operations.from, to = operations.to;
                        if (!from || !to) {
                            var index = from ? from.animationID : to.animationID, indexKey = index.toString();
                            return void (usedIndicesLookup[indexKey] || (usedIndicesLookup[indexKey] = !0, preparedAnimations.push(animations[index])));
                        }
                        var fromAnimation = animations[from.animationID], toAnimation = animations[to.animationID], lookupKey = from.animationID.toString();
                        if (!anchorGroups[lookupKey]) {
                            var group = anchorGroups[lookupKey] = {
                                structural: !0,
                                beforeStart: function() {
                                    fromAnimation.beforeStart(), toAnimation.beforeStart();
                                },
                                close: function() {
                                    fromAnimation.close(), toAnimation.close();
                                },
                                classes: cssClassesIntersection(fromAnimation.classes, toAnimation.classes),
                                from: fromAnimation,
                                to: toAnimation,
                                anchors: []
                            };
                            group.classes.length ? preparedAnimations.push(group) : (preparedAnimations.push(fromAnimation), 
                            preparedAnimations.push(toAnimation));
                        }
                        anchorGroups[lookupKey].anchors.push({
                            out: from.element,
                            "in": to.element
                        });
                    }), preparedAnimations;
                }
                function cssClassesIntersection(a, b) {
                    a = a.split(" "), b = b.split(" ");
                    for (var matches = [], i = 0; i < a.length; i++) {
                        var aa = a[i];
                        if ("ng-" !== aa.substring(0, 3)) for (var j = 0; j < b.length; j++) if (aa === b[j]) {
                            matches.push(aa);
                            break;
                        }
                    }
                    return matches.join(" ");
                }
                function invokeFirstDriver(animationDetails) {
                    for (var i = drivers.length - 1; i >= 0; i--) {
                        var driverName = drivers[i], factory = $injector.get(driverName), driver = factory(animationDetails);
                        if (driver) return driver;
                    }
                }
                function beforeStart() {
                    element.addClass(NG_ANIMATE_CLASSNAME), tempClasses && $$jqLite.addClass(element, tempClasses), 
                    prepareClassName && ($$jqLite.removeClass(element, prepareClassName), prepareClassName = null);
                }
                function updateAnimationRunners(animation, newRunner) {
                    function update(element) {
                        var runner = getRunner(element);
                        runner && runner.setHost(newRunner);
                    }
                    animation.from && animation.to ? (update(animation.from.element), update(animation.to.element)) : update(animation.element);
                }
                function handleDestroyedElement() {
                    var runner = getRunner(element);
                    !runner || "leave" === event && options.$$domOperationFired || runner.end();
                }
                function close(rejected) {
                    element.off("$destroy", handleDestroyedElement), removeRunner(element), applyAnimationClasses(element, options), 
                    applyAnimationStyles(element, options), options.domOperation(), tempClasses && $$jqLite.removeClass(element, tempClasses), 
                    element.removeClass(NG_ANIMATE_CLASSNAME), runner.complete(!rejected);
                }
                options = prepareAnimationOptions(options);
                var isStructural = [ "enter", "move", "leave" ].indexOf(event) >= 0, runner = new $$AnimateRunner({
                    end: function() {
                        close();
                    },
                    cancel: function() {
                        close(!0);
                    }
                });
                if (!drivers.length) return close(), runner;
                setRunner(element, runner);
                var classes = mergeClasses(element.attr("class"), mergeClasses(options.addClass, options.removeClass)), tempClasses = options.tempClasses;
                tempClasses && (classes += " " + tempClasses, options.tempClasses = null);
                var prepareClassName;
                return isStructural && (prepareClassName = "ng-" + event + PREPARE_CLASS_SUFFIX, 
                $$jqLite.addClass(element, prepareClassName)), animationQueue.push({
                    element: element,
                    classes: classes,
                    event: event,
                    structural: isStructural,
                    options: options,
                    beforeStart: beforeStart,
                    close: close
                }), element.on("$destroy", handleDestroyedElement), animationQueue.length > 1 ? runner : ($rootScope.$$postDigest(function() {
                    var animations = [];
                    forEach(animationQueue, function(entry) {
                        getRunner(entry.element) ? animations.push(entry) : entry.close();
                    }), animationQueue.length = 0;
                    var groupedAnimations = groupAnimations(animations), toBeSortedAnimations = [];
                    forEach(groupedAnimations, function(animationEntry) {
                        toBeSortedAnimations.push({
                            domNode: getDomNode(animationEntry.from ? animationEntry.from.element : animationEntry.element),
                            fn: function() {
                                animationEntry.beforeStart();
                                var startAnimationFn, closeFn = animationEntry.close, targetElement = animationEntry.anchors ? animationEntry.from.element || animationEntry.to.element : animationEntry.element;
                                if (getRunner(targetElement)) {
                                    var operation = invokeFirstDriver(animationEntry);
                                    operation && (startAnimationFn = operation.start);
                                }
                                if (startAnimationFn) {
                                    var animationRunner = startAnimationFn();
                                    animationRunner.done(function(status) {
                                        closeFn(!status);
                                    }), updateAnimationRunners(animationEntry, animationRunner);
                                } else closeFn();
                            }
                        });
                    }), $$rAFScheduler(sortAnimations(toBeSortedAnimations));
                }), runner);
            };
        } ];
    } ], ngAnimateSwapDirective = [ "$animate", function($animate) {
        return {
            restrict: "A",
            transclude: "element",
            terminal: !0,
            priority: 600,
            link: function(scope, $element, attrs, ctrl, $transclude) {
                var previousElement, previousScope;
                scope.$watchCollection(attrs.ngAnimateSwap || attrs["for"], function(value) {
                    previousElement && $animate.leave(previousElement), previousScope && (previousScope.$destroy(), 
                    previousScope = null), (value || 0 === value) && $transclude(function(clone, childScope) {
                        previousElement = clone, previousScope = childScope, $animate.enter(clone, null, $element);
                    });
                });
            }
        };
    } ];
    angular.module("ngAnimate", [], function() {
        noop = angular.noop, copy = angular.copy, extend = angular.extend, jqLite = angular.element, 
        forEach = angular.forEach, isArray = angular.isArray, isString = angular.isString, 
        isObject = angular.isObject, isUndefined = angular.isUndefined, isDefined = angular.isDefined, 
        isFunction = angular.isFunction, isElement = angular.isElement;
    }).info({
        angularVersion: "1.7.2"
    }).directive("ngAnimateSwap", ngAnimateSwapDirective).directive("ngAnimateChildren", $$AnimateChildrenDirective).factory("$$rAFScheduler", $$rAFSchedulerFactory).provider("$$animateQueue", $$AnimateQueueProvider).provider("$$animation", $$AnimationProvider).provider("$animateCss", $AnimateCssProvider).provider("$$animateCssDriver", $$AnimateCssDriverProvider).provider("$$animateJs", $$AnimateJsProvider).provider("$$animateJsDriver", $$AnimateJsDriverProvider);
}(window, window.angular), define("ngdir/angular-animate", [ "angular" ], function() {}), 
function(global, factory) {
    "object" == typeof exports && "undefined" != typeof module ? factory(exports, require("angular")) : "function" == typeof define && define.amd ? define("ngdir/angular-ui-router", [ "exports", "angular" ], factory) : factory(global["@uirouter/angularjs"] = {}, global.angular);
}(this, function(exports, ng_from_import) {
    function curry(fn) {
        function curried(args) {
            return args.length >= func_args_length ? fn.apply(null, args) : function() {
                return curried(args.concat([].slice.apply(arguments)));
            };
        }
        var initial_args = [].slice.apply(arguments, [ 1 ]), func_args_length = fn.length;
        return curried(initial_args);
    }
    function compose() {
        var args = arguments, start = args.length - 1;
        return function() {
            for (var i = start, result = args[start].apply(this, arguments); i--; ) result = args[i].call(this, result);
            return result;
        };
    }
    function pipe() {
        for (var funcs = [], _i = 0; _i < arguments.length; _i++) funcs[_i] = arguments[_i];
        return compose.apply(null, [].slice.call(arguments).reverse());
    }
    function and(fn1, fn2) {
        return function() {
            for (var args = [], _i = 0; _i < arguments.length; _i++) args[_i] = arguments[_i];
            return fn1.apply(null, args) && fn2.apply(null, args);
        };
    }
    function or(fn1, fn2) {
        return function() {
            for (var args = [], _i = 0; _i < arguments.length; _i++) args[_i] = arguments[_i];
            return fn1.apply(null, args) || fn2.apply(null, args);
        };
    }
    function invoke(fnName, args) {
        return function(obj) {
            return obj[fnName].apply(obj, args);
        };
    }
    function pattern(struct) {
        return function(x) {
            for (var i = 0; i < struct.length; i++) if (struct[i][0](x)) return struct[i][1](x);
        };
    }
    function isInjectable(val$$1) {
        if (isArray(val$$1) && val$$1.length) {
            var head = val$$1.slice(0, -1), tail = val$$1.slice(-1);
            return !(head.filter(not(isString)).length || tail.filter(not(isFunction)).length);
        }
        return isFunction(val$$1);
    }
    function identity(x) {
        return x;
    }
    function noop() {}
    function createProxyFunctions(source, target, bind, fnNames, latebind) {
        void 0 === latebind && (latebind = !1);
        var bindFunction = function(fnName) {
            return source()[fnName].bind(bind());
        }, makeLateRebindFn = function(fnName) {
            return function() {
                return target[fnName] = bindFunction(fnName), target[fnName].apply(null, arguments);
            };
        };
        return fnNames = fnNames || Object.keys(source()), fnNames.reduce(function(acc, name) {
            return acc[name] = latebind ? makeLateRebindFn(name) : bindFunction(name), acc;
        }, target);
    }
    function _inArray(array, obj) {
        return -1 !== array.indexOf(obj);
    }
    function _removeFrom(array, obj) {
        var idx = array.indexOf(obj);
        return idx >= 0 && array.splice(idx, 1), array;
    }
    function _pushTo(arr, val$$1) {
        return arr.push(val$$1), val$$1;
    }
    function defaults(opts) {
        for (var defaultsList = [], _i = 1; _i < arguments.length; _i++) defaultsList[_i - 1] = arguments[_i];
        var defaultVals = extend.apply(void 0, [ {} ].concat(defaultsList.reverse()));
        return extend(defaultVals, pick(opts || {}, Object.keys(defaultVals)));
    }
    function ancestors(first, second) {
        var path = [];
        for (var n in first.path) {
            if (first.path[n] !== second.path[n]) break;
            path.push(first.path[n]);
        }
        return path;
    }
    function pick(obj, propNames) {
        var objCopy = {};
        for (var _prop in obj) -1 !== propNames.indexOf(_prop) && (objCopy[_prop] = obj[_prop]);
        return objCopy;
    }
    function omit(obj, propNames) {
        return Object.keys(obj).filter(not(inArray(propNames))).reduce(function(acc, key) {
            return acc[key] = obj[key], acc;
        }, {});
    }
    function pluck(collection, propName) {
        return map(collection, prop(propName));
    }
    function filter(collection, callback) {
        var arr = isArray(collection), result = arr ? [] : {}, accept = arr ? function(x) {
            return result.push(x);
        } : function(x, key) {
            return result[key] = x;
        };
        return forEach(collection, function(item, i) {
            callback(item, i) && accept(item, i);
        }), result;
    }
    function find(collection, callback) {
        var result;
        return forEach(collection, function(item, i) {
            result || callback(item, i) && (result = item);
        }), result;
    }
    function map(collection, callback, target) {
        return target = target || (isArray(collection) ? [] : {}), forEach(collection, function(item, i) {
            return target[i] = callback(item, i);
        }), target;
    }
    function pushR(arr, obj) {
        return arr.push(obj), arr;
    }
    function assertFn(predicateOrMap, errMsg) {
        return void 0 === errMsg && (errMsg = "assert failure"), function(obj) {
            var result = predicateOrMap(obj);
            if (!result) throw new Error(isFunction(errMsg) ? errMsg(obj) : errMsg);
            return result;
        };
    }
    function arrayTuples() {
        for (var args = [], _i = 0; _i < arguments.length; _i++) args[_i] = arguments[_i];
        if (0 === args.length) return [];
        for (var maxArrayLen = args.reduce(function(min, arr) {
            return Math.min(arr.length, min);
        }, 9007199254740991), result = [], _loop_1 = function(i) {
            switch (args.length) {
              case 1:
                result.push([ args[0][i] ]);
                break;

              case 2:
                result.push([ args[0][i], args[1][i] ]);
                break;

              case 3:
                result.push([ args[0][i], args[1][i], args[2][i] ]);
                break;

              case 4:
                result.push([ args[0][i], args[1][i], args[2][i], args[3][i] ]);
                break;

              default:
                result.push(args.map(function(array) {
                    return array[i];
                }));
            }
        }, i = 0; maxArrayLen > i; i++) _loop_1(i);
        return result;
    }
    function applyPairs(memo, keyValTuple) {
        var key, value;
        if (isArray(keyValTuple) && (key = keyValTuple[0], value = keyValTuple[1]), !isString(key)) throw new Error("invalid parameters to applyPairs");
        return memo[key] = value, memo;
    }
    function tail(arr) {
        return arr.length && arr[arr.length - 1] || void 0;
    }
    function copy(src, dest) {
        return dest && Object.keys(dest).forEach(function(key) {
            return delete dest[key];
        }), dest || (dest = {}), extend(dest, src);
    }
    function _forEach(obj, cb, _this) {
        return isArray(obj) ? obj.forEach(cb, _this) : void Object.keys(obj).forEach(function(key) {
            return cb(obj[key], key);
        });
    }
    function _extend(toObj) {
        for (var i = 1; i < arguments.length; i++) {
            var obj = arguments[i];
            if (obj) for (var keys = Object.keys(obj), j = 0; j < keys.length; j++) toObj[keys[j]] = obj[keys[j]];
        }
        return toObj;
    }
    function _equals(o1, o2) {
        if (o1 === o2) return !0;
        if (null === o1 || null === o2) return !1;
        if (o1 !== o1 && o2 !== o2) return !0;
        var t1 = typeof o1, t2 = typeof o2;
        if (t1 !== t2 || "object" !== t1) return !1;
        var tup = [ o1, o2 ];
        if (all(isArray)(tup)) return _arraysEq(o1, o2);
        if (all(isDate)(tup)) return o1.getTime() === o2.getTime();
        if (all(isRegExp)(tup)) return o1.toString() === o2.toString();
        if (all(isFunction)(tup)) return !0;
        var predicates = [ isFunction, isArray, isDate, isRegExp ];
        if (predicates.map(any).reduce(function(b, fn) {
            return b || !!fn(tup);
        }, !1)) return !1;
        var keys = {};
        for (var key in o1) {
            if (!_equals(o1[key], o2[key])) return !1;
            keys[key] = !0;
        }
        for (var key in o2) if (!keys[key]) return !1;
        return !0;
    }
    function _arraysEq(a1, a2) {
        return a1.length !== a2.length ? !1 : arrayTuples(a1, a2).reduce(function(b, t) {
            return b && _equals(t[0], t[1]);
        }, !0);
    }
    function maxLength(max, str) {
        return str.length <= max ? str : str.substr(0, max - 3) + "...";
    }
    function padString(length, str) {
        for (;str.length < length; ) str += " ";
        return str;
    }
    function kebobString(camelCase) {
        return camelCase.replace(/^([A-Z])/, function($1) {
            return $1.toLowerCase();
        }).replace(/([A-Z])/g, function($1) {
            return "-" + $1.toLowerCase();
        });
    }
    function functionToString(fn) {
        var fnStr = fnToString(fn), namedFunctionMatch = fnStr.match(/^(function [^ ]+\([^)]*\))/), toStr = namedFunctionMatch ? namedFunctionMatch[1] : fnStr, fnName = fn.name || "";
        return fnName && toStr.match(/function \(/) ? "function " + fnName + toStr.substr(9) : toStr;
    }
    function fnToString(fn) {
        var _fn = isArray(fn) ? fn.slice(-1)[0] : fn;
        return _fn && _fn.toString() || "undefined";
    }
    function stringify(o) {
        function format(value) {
            if (isObject(value)) {
                if (-1 !== seen.indexOf(value)) return "[circular ref]";
                seen.push(value);
            }
            return stringifyPattern(value);
        }
        var seen = [];
        return isUndefined(o) ? format(o) : JSON.stringify(o, function(key, value) {
            return format(value);
        }).replace(/\\"/g, '"');
    }
    function splitOnDelim(delim) {
        var re = new RegExp("(" + delim + ")", "g");
        return function(str) {
            return str.split(re).filter(identity);
        };
    }
    function joinNeighborsR(acc, x) {
        return isString(tail(acc)) && isString(x) ? acc.slice(0, -1).concat(tail(acc) + x) : pushR(acc, x);
    }
    function uiViewString(uiview) {
        if (!uiview) return "ui-view (defunct)";
        var state = uiview.creationContext ? uiview.creationContext.name || "(root)" : "(none)";
        return "[ui-view#" + uiview.id + " " + uiview.$type + ":" + uiview.fqn + " (" + uiview.name + "@" + state + ")]";
    }
    function normalizedCat(input) {
        return isNumber(input) ? exports.Category[input] : exports.Category[exports.Category[input]];
    }
    function ArrayType(type, mode) {
        function arrayWrap(val) {
            return isArray(val) ? val : isDefined(val) ? [ val ] : [];
        }
        function arrayUnwrap(val) {
            switch (val.length) {
              case 0:
                return void 0;

              case 1:
                return "auto" === mode ? val[0] : val;

              default:
                return val;
            }
        }
        function arrayHandler(callback, allTruthyMode) {
            return function(val) {
                if (isArray(val) && 0 === val.length) return val;
                var arr = arrayWrap(val), result = map(arr, callback);
                return allTruthyMode === !0 ? 0 === filter(result, function(x) {
                    return !x;
                }).length : arrayUnwrap(result);
            };
        }
        function arrayEqualsHandler(callback) {
            return function(val1, val2) {
                var left = arrayWrap(val1), right = arrayWrap(val2);
                if (left.length !== right.length) return !1;
                for (var i = 0; i < left.length; i++) if (!callback(left[i], right[i])) return !1;
                return !0;
            };
        }
        var _this = this;
        [ "encode", "decode", "equals", "$normalize" ].forEach(function(name) {
            var paramTypeFn = type[name].bind(type), wrapperFn = "equals" === name ? arrayEqualsHandler : arrayHandler;
            _this[name] = wrapperFn(paramTypeFn);
        }), extend(this, {
            dynamic: type.dynamic,
            name: type.name,
            pattern: type.pattern,
            inherit: type.inherit,
            raw: type.raw,
            is: arrayHandler(type.is.bind(type), !0),
            $arrayMode: mode
        });
    }
    function getParamDeclaration(paramName, location, state) {
        var noReloadOnSearch = state.reloadOnSearch === !1 && location === exports.DefType.SEARCH || void 0, dynamic = find([ state.dynamic, noReloadOnSearch ], isDefined), defaultConfig = isDefined(dynamic) ? {
            dynamic: dynamic
        } : {}, paramConfig = unwrapShorthand(state && state.params && state.params[paramName]);
        return extend(defaultConfig, paramConfig);
    }
    function unwrapShorthand(cfg) {
        function getStaticDefaultValue() {
            return cfg.value;
        }
        cfg = isShorthand(cfg) ? {
            value: cfg
        } : cfg, getStaticDefaultValue.__cacheable = !0;
        var $$fn = isInjectable(cfg.value) ? cfg.value : getStaticDefaultValue;
        return extend(cfg, {
            $$fn: $$fn
        });
    }
    function getType(cfg, urlType, location, id, paramTypes) {
        if (cfg.type && urlType && "string" !== urlType.name) throw new Error("Param '" + id + "' has two type configurations.");
        if (cfg.type && urlType && "string" === urlType.name && paramTypes.type(cfg.type)) return paramTypes.type(cfg.type);
        if (urlType) return urlType;
        if (!cfg.type) {
            var type = location === exports.DefType.CONFIG ? "any" : location === exports.DefType.PATH ? "path" : location === exports.DefType.SEARCH ? "query" : "string";
            return paramTypes.type(type);
        }
        return cfg.type instanceof ParamType ? cfg.type : paramTypes.type(cfg.type);
    }
    function getSquashPolicy(config, isOptional, defaultPolicy) {
        var squash = config.squash;
        if (!isOptional || squash === !1) return !1;
        if (!isDefined(squash) || null == squash) return defaultPolicy;
        if (squash === !0 || isString(squash)) return squash;
        throw new Error("Invalid squash policy: '" + squash + "'. Valid policies: false, true, or arbitrary string");
    }
    function getReplace(config, arrayMode, isOptional, squash) {
        var defaultPolicy = [ {
            from: "",
            to: isOptional || arrayMode ? void 0 : ""
        }, {
            from: null,
            to: isOptional || arrayMode ? void 0 : ""
        } ], replace = isArray(config.replace) ? config.replace : [];
        isString(squash) && replace.push({
            from: squash,
            to: void 0
        });
        var configuredKeys = map(replace, prop("from"));
        return filter(defaultPolicy, function(item) {
            return -1 === configuredKeys.indexOf(item.from);
        }).concat(replace);
    }
    function initDefaultTypes() {
        var makeDefaultType = function(def) {
            var valToString = function(val$$1) {
                return null != val$$1 ? val$$1.toString() : val$$1;
            }, defaultTypeBase = {
                encode: valToString,
                decode: valToString,
                is: is(String),
                pattern: /.*/,
                equals: function(a, b) {
                    return a == b;
                }
            };
            return extend({}, defaultTypeBase, def);
        };
        extend(ParamTypes.prototype, {
            string: makeDefaultType({}),
            path: makeDefaultType({
                pattern: /[^\/]*/
            }),
            query: makeDefaultType({}),
            hash: makeDefaultType({
                inherit: !1
            }),
            "int": makeDefaultType({
                decode: function(val$$1) {
                    return parseInt(val$$1, 10);
                },
                is: function(val$$1) {
                    return !isNullOrUndefined(val$$1) && this.decode(val$$1.toString()) === val$$1;
                },
                pattern: /-?\d+/
            }),
            bool: makeDefaultType({
                encode: function(val$$1) {
                    return val$$1 && 1 || 0;
                },
                decode: function(val$$1) {
                    return 0 !== parseInt(val$$1, 10);
                },
                is: is(Boolean),
                pattern: /0|1/
            }),
            date: makeDefaultType({
                encode: function(val$$1) {
                    return this.is(val$$1) ? [ val$$1.getFullYear(), ("0" + (val$$1.getMonth() + 1)).slice(-2), ("0" + val$$1.getDate()).slice(-2) ].join("-") : void 0;
                },
                decode: function(val$$1) {
                    if (this.is(val$$1)) return val$$1;
                    var match = this.capture.exec(val$$1);
                    return match ? new Date(match[1], match[2] - 1, match[3]) : void 0;
                },
                is: function(val$$1) {
                    return val$$1 instanceof Date && !isNaN(val$$1.valueOf());
                },
                equals: function(l, r) {
                    return [ "getFullYear", "getMonth", "getDate" ].reduce(function(acc, fn) {
                        return acc && l[fn]() === r[fn]();
                    }, !0);
                },
                pattern: /[0-9]{4}-(?:0[1-9]|1[0-2])-(?:0[1-9]|[1-2][0-9]|3[0-1])/,
                capture: /([0-9]{4})-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])/
            }),
            json: makeDefaultType({
                encode: toJson,
                decode: fromJson,
                is: is(Object),
                equals: equals,
                pattern: /[^\/]*/
            }),
            any: makeDefaultType({
                encode: identity,
                decode: identity,
                is: function() {
                    return !0;
                },
                equals: equals
            })
        });
    }
    function nameBuilder(state) {
        return state.name;
    }
    function selfBuilder(state) {
        return state.self.$$state = function() {
            return state;
        }, state.self;
    }
    function dataBuilder(state) {
        return state.parent && state.parent.data && (state.data = state.self.data = inherit(state.parent.data, state.data)), 
        state.data;
    }
    function pathBuilder(state) {
        return state.parent ? state.parent.path.concat(state) : [ state ];
    }
    function includesBuilder(state) {
        var includes = state.parent ? extend({}, state.parent.includes) : {};
        return includes[state.name] = !0, includes;
    }
    function resolvablesBuilder(state) {
        var objects2Tuples = function(resolveObj, resolvePolicies) {
            return Object.keys(resolveObj || {}).map(function(token) {
                return {
                    token: token,
                    val: resolveObj[token],
                    deps: void 0,
                    policy: resolvePolicies[token]
                };
            });
        }, annotate = function(fn) {
            var $injector = services.$injector;
            return fn.$inject || $injector && $injector.annotate(fn, $injector.strictDi) || "deferred";
        }, isResolveLiteral = function(obj) {
            return !(!obj.token || !obj.resolveFn);
        }, isLikeNg2Provider = function(obj) {
            return !(!obj.provide && !obj.token || !(obj.useValue || obj.useFactory || obj.useExisting || obj.useClass));
        }, isTupleFromObj = function(obj) {
            return !!(obj && obj.val && (isString(obj.val) || isArray(obj.val) || isFunction(obj.val)));
        }, getToken = function(p) {
            return p.provide || p.token;
        }, literal2Resolvable = pattern([ [ prop("resolveFn"), function(p) {
            return new Resolvable(getToken(p), p.resolveFn, p.deps, p.policy);
        } ], [ prop("useFactory"), function(p) {
            return new Resolvable(getToken(p), p.useFactory, p.deps || p.dependencies, p.policy);
        } ], [ prop("useClass"), function(p) {
            return new Resolvable(getToken(p), function() {
                return new p.useClass();
            }, [], p.policy);
        } ], [ prop("useValue"), function(p) {
            return new Resolvable(getToken(p), function() {
                return p.useValue;
            }, [], p.policy, p.useValue);
        } ], [ prop("useExisting"), function(p) {
            return new Resolvable(getToken(p), identity, [ p.useExisting ], p.policy);
        } ] ]), tuple2Resolvable = pattern([ [ pipe(prop("val"), isString), function(tuple) {
            return new Resolvable(tuple.token, identity, [ tuple.val ], tuple.policy);
        } ], [ pipe(prop("val"), isArray), function(tuple) {
            return new Resolvable(tuple.token, tail(tuple.val), tuple.val.slice(0, -1), tuple.policy);
        } ], [ pipe(prop("val"), isFunction), function(tuple) {
            return new Resolvable(tuple.token, tuple.val, annotate(tuple.val), tuple.policy);
        } ] ]), item2Resolvable = pattern([ [ is(Resolvable), function(r) {
            return r;
        } ], [ isResolveLiteral, literal2Resolvable ], [ isLikeNg2Provider, literal2Resolvable ], [ isTupleFromObj, tuple2Resolvable ], [ val(!0), function(obj) {
            throw new Error("Invalid resolve value: " + stringify(obj));
        } ] ]), decl = state.resolve, items = isArray(decl) ? decl : objects2Tuples(decl, state.resolvePolicy || {});
        return items.map(item2Resolvable);
    }
    function matchState(state, criterion) {
        function matchGlobs(_state) {
            for (var globStrings = toMatch, i = 0; i < globStrings.length; i++) {
                var glob = new Glob(globStrings[i]);
                if (glob && glob.matches(_state.name) || !glob && globStrings[i] === _state.name) return !0;
            }
            return !1;
        }
        var toMatch = isString(criterion) ? [ criterion ] : criterion, matchFn = isFunction(toMatch) ? toMatch : matchGlobs;
        return !!matchFn(state);
    }
    function makeEvent(registry, transitionService, eventType) {
        function hookRegistrationFn(matchObject, callback, options) {
            void 0 === options && (options = {});
            var registeredHook = new RegisteredHook(transitionService, eventType, callback, matchObject, removeHookFn, options);
            return hooks.push(registeredHook), registeredHook.deregister.bind(registeredHook);
        }
        var _registeredHooks = registry._registeredHooks = registry._registeredHooks || {}, hooks = _registeredHooks[eventType.name] = [], removeHookFn = removeFrom(hooks);
        return registry[eventType.name] = hookRegistrationFn, hookRegistrationFn;
    }
    function tupleSort(reverseDepthSort) {
        return void 0 === reverseDepthSort && (reverseDepthSort = !1), function(l, r) {
            var factor = reverseDepthSort ? -1 : 1, depthDelta = (l.node.state.path.length - r.node.state.path.length) * factor;
            return 0 !== depthDelta ? depthDelta : r.hook.priority - l.hook.priority;
        };
    }
    function quoteRegExp(str, param) {
        var surroundPattern = [ "", "" ], result = str.replace(/[\\\[\]\^$*+?.()|{}]/g, "\\$&");
        if (!param) return result;
        switch (param.squash) {
          case !1:
            surroundPattern = [ "(", ")" + (param.isOptional ? "?" : "") ];
            break;

          case !0:
            result = result.replace(/\/$/, ""), surroundPattern = [ "(?:/(", ")|/)?" ];
            break;

          default:
            surroundPattern = [ "(" + param.squash + "|", ")?" ];
        }
        return result + surroundPattern[0] + param.type.pattern.source + surroundPattern[1];
    }
    function appendBasePath(url, isHtml5, absolute, baseHref) {
        return "/" === baseHref ? url : isHtml5 ? stripLastPathElement(baseHref) + url : absolute ? baseHref.slice(1) + url : url;
    }
    function getHandlerFn(handler) {
        if (!(isFunction(handler) || isString(handler) || is(TargetState)(handler) || TargetState.isDef(handler))) throw new Error("'handler' must be a string, function, TargetState, or have a state: 'newtarget' property");
        return isFunction(handler) ? handler : val(handler);
    }
    function addCoreResolvables(trans) {
        trans.addResolvable(Resolvable.fromData(UIRouter, trans.router), ""), trans.addResolvable(Resolvable.fromData(Transition, trans), ""), 
        trans.addResolvable(Resolvable.fromData("$transition$", trans), ""), trans.addResolvable(Resolvable.fromData("$stateParams", trans.params()), ""), 
        trans.entering().forEach(function(state) {
            trans.addResolvable(Resolvable.fromData("$state$", state), state);
        });
    }
    function makeEnterExitRetainHook(hookName) {
        return function(transition, state) {
            var _state = state.$$state(), hookFn = _state[hookName];
            return hookFn(transition, state);
        };
    }
    function lazyLoadState(transition, state) {
        function updateStateRegistry(result) {
            return result && Array.isArray(result.states) && result.states.forEach(function(_state) {
                return transition.router.stateRegistry.register(_state);
            }), result;
        }
        var lazyLoadFn = state.$$state().lazyLoad, promise = lazyLoadFn._promise;
        if (!promise) {
            var success = function(result) {
                return delete state.lazyLoad, delete state.$$state().lazyLoad, delete lazyLoadFn._promise, 
                result;
            }, error = function(err) {
                return delete lazyLoadFn._promise, services.$q.reject(err);
            };
            promise = lazyLoadFn._promise = services.$q.when(lazyLoadFn(transition, state)).then(updateStateRegistry).then(success, error);
        }
        return promise;
    }
    function ignoredHook(trans) {
        var ignoredReason = trans._ignoredReason();
        if (ignoredReason) {
            trace.traceTransitionIgnored(trans);
            var pending = trans.router.globals.transition;
            return "SameAsCurrent" === ignoredReason && pending && pending.abort(), Rejection.ignored().toPromise();
        }
    }
    function invalidTransitionHook(trans) {
        if (!trans.valid()) throw new Error(trans.error().toString());
    }
    function parseUrl$1(url) {
        var orEmptyString = function(x) {
            return x || "";
        }, _a = splitHash(url).map(orEmptyString), beforehash = _a[0], hash = _a[1], _b = splitQuery(beforehash).map(orEmptyString), path = _b[0], search = _b[1];
        return {
            path: path,
            search: search,
            hash: hash,
            url: url
        };
    }
    function locationPluginFactory(name, isHtml5, serviceClass, configurationClass) {
        return function(uiRouter) {
            function dispose(router) {
                router.dispose(service), router.dispose(configuration);
            }
            var service = uiRouter.locationService = new serviceClass(uiRouter), configuration = uiRouter.locationConfig = new configurationClass(uiRouter, isHtml5);
            return {
                name: name,
                service: service,
                configuration: configuration,
                dispose: dispose
            };
        };
    }
    function servicesPlugin() {
        return services.$injector = $injector, services.$q = $q, {
            name: "vanilla.services",
            $q: $q,
            $injector: $injector,
            dispose: function() {
                return null;
            }
        };
    }
    function getNg1ViewConfigFactory() {
        var templateFactory = null;
        return function(path, view) {
            return templateFactory = templateFactory || services.$injector.get("$templateFactory"), 
            [ new Ng1ViewConfig(path, view, templateFactory) ];
        };
    }
    function ng1ViewsBuilder(state) {
        if (!state.parent) return {};
        var tplKeys = [ "templateProvider", "templateUrl", "template", "notify", "async" ], ctrlKeys = [ "controller", "controllerProvider", "controllerAs", "resolveAs" ], compKeys = [ "component", "bindings", "componentProvider" ], nonCompKeys = tplKeys.concat(ctrlKeys), allViewKeys = compKeys.concat(nonCompKeys);
        if (isDefined(state.views) && hasAnyKey(allViewKeys, state)) throw new Error("State '" + state.name + "' has a 'views' object. It cannot also have \"view properties\" at the state level.  Move the following properties into a view (in the 'views' object):  " + allViewKeys.filter(function(key) {
            return isDefined(state[key]);
        }).join(", "));
        var views = {}, viewsObject = state.views || {
            $default: pick(state, allViewKeys)
        };
        return forEach(viewsObject, function(config, name) {
            if (name = name || "$default", isString(config) && (config = {
                component: config
            }), config = extend({}, config), hasAnyKey(compKeys, config) && hasAnyKey(nonCompKeys, config)) throw new Error("Cannot combine: " + compKeys.join("|") + " with: " + nonCompKeys.join("|") + " in stateview: '" + name + "@" + state.name + "'");
            config.resolveAs = config.resolveAs || "$resolve", config.$type = "ng1", config.$context = state, 
            config.$name = name;
            var normalized = ViewService.normalizeUIViewTarget(config.$context, config.$name);
            config.$uiViewName = normalized.uiViewName, config.$uiViewContextAnchor = normalized.uiViewContextAnchor, 
            views[name] = config;
        }), views;
    }
    function getComponentBindings(name) {
        var cmpDefs = services.$injector.get(name + "Directive");
        if (!cmpDefs || !cmpDefs.length) throw new Error("Unable to find component named '" + name + "'");
        return cmpDefs.map(getBindings).reduce(unnestR, []);
    }
    function $uiRouterProvider($locationProvider) {
        function $get($location, $browser, $window, $sniffer, $rootScope) {
            return ng1LocationService._runtimeServices($rootScope, $location, $sniffer, $browser, $window), 
            delete router.router, delete router.$get, router;
        }
        router = this.router = new UIRouter(), router.stateProvider = new StateProvider(router.stateRegistry, router.stateService), 
        router.stateRegistry.decorator("views", ng1ViewsBuilder), router.stateRegistry.decorator("onExit", getStateHookBuilder("onExit")), 
        router.stateRegistry.decorator("onRetain", getStateHookBuilder("onRetain")), router.stateRegistry.decorator("onEnter", getStateHookBuilder("onEnter")), 
        router.viewService._pluginapi._viewConfigFactory("ng1", getNg1ViewConfigFactory());
        var ng1LocationService = router.locationService = router.locationConfig = new Ng1LocationServices($locationProvider);
        return Ng1LocationServices.monkeyPatchPathParameterType(router), router.router = router, 
        router.$get = $get, $get.$inject = [ "$location", "$browser", "$window", "$sniffer", "$rootScope", "$http", "$templateCache" ], 
        router;
    }
    function runBlock($injector$$1, $q$$1, $uiRouter) {
        if (services.$injector = $injector$$1, services.$q = $q$$1, !$injector$$1.hasOwnProperty("strictDi")) try {
            $injector$$1.invoke(function() {});
        } catch (error) {
            $injector$$1.strictDi = !!/strict mode/.exec(error && error.toString());
        }
        $uiRouter.stateRegistry.get().map(function(x) {
            return x.$$state().resolvables;
        }).reduce(unnestR, []).filter(function(x) {
            return "deferred" === x.deps;
        }).forEach(function(resolvable) {
            return resolvable.deps = $injector$$1.annotate(resolvable.resolveFn, $injector$$1.strictDi);
        });
    }
    function watchDigests($rootScope) {
        $rootScope.$watch(function() {
            trace.approximateDigests++;
        });
    }
    function parseStateRef(ref) {
        var parsed, paramsOnly = ref.match(/^\s*({[^}]*})\s*$/);
        if (paramsOnly && (ref = "(" + paramsOnly[1] + ")"), parsed = ref.replace(/\n/g, " ").match(/^\s*([^(]*?)\s*(\((.*)\))?\s*$/), 
        !parsed || 4 !== parsed.length) throw new Error("Invalid state ref '" + ref + "'");
        return {
            state: parsed[1] || null,
            paramExpr: parsed[3] || null
        };
    }
    function stateContext(el) {
        var $uiView = el.parent().inheritedData("$uiView"), path = parse("$cfg.path")($uiView);
        return path ? tail(path).state.name : void 0;
    }
    function processedDef($state, $element, def) {
        var uiState = def.uiState || $state.current.name, uiStateOpts = extend(defaultOpts($element, $state), def.uiStateOpts || {}), href = $state.href(uiState, def.uiStateParams, uiStateOpts);
        return {
            uiState: uiState,
            uiStateParams: def.uiStateParams,
            uiStateOpts: uiStateOpts,
            href: href
        };
    }
    function getTypeInfo(el) {
        var isSvg = "[object SVGAnimatedString]" === Object.prototype.toString.call(el.prop("href")), isForm = "FORM" === el[0].nodeName;
        return {
            attr: isForm ? "action" : isSvg ? "xlink:href" : "href",
            isAnchor: "A" === el.prop("tagName").toUpperCase(),
            clickable: !isForm
        };
    }
    function clickHook(el, $state, $timeout, type, getDef) {
        return function(e) {
            var button = e.which || e.button, target = getDef();
            if (!(button > 1 || e.ctrlKey || e.metaKey || e.shiftKey || el.attr("target"))) {
                var transition_1 = $timeout(function() {
                    el.attr("disabled") || $state.go(target.uiState, target.uiStateParams, target.uiStateOpts);
                });
                e.preventDefault();
                var ignorePreventDefaultCount_1 = type.isAnchor && !target.href ? 1 : 0;
                e.preventDefault = function() {
                    ignorePreventDefaultCount_1-- <= 0 && $timeout.cancel(transition_1);
                };
            }
        };
    }
    function defaultOpts(el, $state) {
        return {
            relative: stateContext(el) || $state.$current,
            inherit: !0,
            source: "sref"
        };
    }
    function bindEvents(element, scope, hookFn, uiStateOpts) {
        var events;
        uiStateOpts && (events = uiStateOpts.events), isArray(events) || (events = [ "click" ]);
        for (var on = element.on ? "on" : "bind", _i = 0, events_1 = events; _i < events_1.length; _i++) {
            var event_1 = events_1[_i];
            element[on](event_1, hookFn);
        }
        scope.$on("$destroy", function() {
            for (var off = element.off ? "off" : "unbind", _i = 0, events_2 = events; _i < events_2.length; _i++) {
                var event_2 = events_2[_i];
                element[off](event_2, hookFn);
            }
        });
    }
    function $IsStateFilter($state) {
        var isFilter = function(state, params, options) {
            return $state.is(state, params, options);
        };
        return isFilter.$stateful = !0, isFilter;
    }
    function $IncludedByStateFilter($state) {
        var includesFilter = function(state, params, options) {
            return $state.includes(state, params, options);
        };
        return includesFilter.$stateful = !0, includesFilter;
    }
    function $ViewDirectiveFill($compile, $controller, $transitions, $view, $q$$1) {
        var getControllerAs = parse("viewDecl.controllerAs"), getResolveAs = parse("viewDecl.resolveAs");
        return {
            restrict: "ECA",
            priority: -400,
            compile: function(tElement) {
                var initial = tElement.html();
                return tElement.empty(), function(scope, $element) {
                    var data = $element.data("$uiView");
                    if (!data) return $element.html(initial), void $compile($element.contents())(scope);
                    var cfg = data.$cfg || {
                        viewDecl: {},
                        getTemplate: noop
                    }, resolveCtx = cfg.path && new ResolveContext(cfg.path);
                    $element.html(cfg.getTemplate($element, resolveCtx) || initial), trace.traceUIViewFill(data.$uiView, $element.html());
                    var link = $compile($element.contents()), controller = cfg.controller, controllerAs = getControllerAs(cfg), resolveAs = getResolveAs(cfg), locals = resolveCtx && getLocals(resolveCtx);
                    if (scope[resolveAs] = locals, controller) {
                        var controllerInstance = $controller(controller, extend({}, locals, {
                            $scope: scope,
                            $element: $element
                        }));
                        controllerAs && (scope[controllerAs] = controllerInstance, scope[controllerAs][resolveAs] = locals), 
                        $element.data("$ngControllerController", controllerInstance), $element.children().data("$ngControllerController", controllerInstance), 
                        registerControllerCallbacks($q$$1, $transitions, controllerInstance, scope, cfg);
                    }
                    if (isString(cfg.component)) var kebobName = kebobString(cfg.component), tagRegexp_1 = new RegExp("^(x-|data-)?" + kebobName + "$", "i"), getComponentController = function() {
                        var directiveEl = [].slice.call($element[0].children).filter(function(el) {
                            return el && el.tagName && tagRegexp_1.exec(el.tagName);
                        });
                        return directiveEl && ng.element(directiveEl).data("$" + cfg.component + "Controller");
                    }, deregisterWatch_1 = scope.$watch(getComponentController, function(ctrlInstance) {
                        ctrlInstance && (registerControllerCallbacks($q$$1, $transitions, ctrlInstance, scope, cfg), 
                        deregisterWatch_1());
                    });
                    link(scope);
                };
            }
        };
    }
    function registerControllerCallbacks($q$$1, $transitions, controllerInstance, $scope, cfg) {
        !isFunction(controllerInstance.$onInit) || cfg.viewDecl.component && hasComponentImpl || controllerInstance.$onInit();
        var viewState = tail(cfg.path).state.self, hookOptions = {
            bind: controllerInstance
        };
        if (isFunction(controllerInstance.uiOnParamsChanged)) {
            var resolveContext = new ResolveContext(cfg.path), viewCreationTrans_1 = resolveContext.getResolvable("$transition$").data, paramsUpdated = function($transition$) {
                if ($transition$ !== viewCreationTrans_1 && -1 === $transition$.exiting().indexOf(viewState)) {
                    var toParams = $transition$.params("to"), fromParams = $transition$.params("from"), getNodeSchema = function(node) {
                        return node.paramSchema;
                    }, toSchema = $transition$.treeChanges("to").map(getNodeSchema).reduce(unnestR, []), fromSchema = $transition$.treeChanges("from").map(getNodeSchema).reduce(unnestR, []), changedToParams = toSchema.filter(function(param) {
                        var idx = fromSchema.indexOf(param);
                        return -1 === idx || !fromSchema[idx].type.equals(toParams[param.id], fromParams[param.id]);
                    });
                    if (changedToParams.length) {
                        var changedKeys_1 = changedToParams.map(function(x) {
                            return x.id;
                        }), newValues = filter(toParams, function(val$$1, key) {
                            return -1 !== changedKeys_1.indexOf(key);
                        });
                        controllerInstance.uiOnParamsChanged(newValues, $transition$);
                    }
                }
            };
            $scope.$on("$destroy", $transitions.onSuccess({}, paramsUpdated, hookOptions));
        }
        if (isFunction(controllerInstance.uiCanExit)) {
            var id_1 = _uiCanExitId++, cacheProp_1 = "_uiCanExitIds", prevTruthyAnswer_1 = function(trans) {
                return !!trans && (trans[cacheProp_1] && trans[cacheProp_1][id_1] === !0 || prevTruthyAnswer_1(trans.redirectedFrom()));
            }, wrappedHook = function(trans) {
                var promise, ids = trans[cacheProp_1] = trans[cacheProp_1] || {};
                return prevTruthyAnswer_1(trans) || (promise = $q$$1.when(controllerInstance.uiCanExit(trans)), 
                promise.then(function(val$$1) {
                    return ids[id_1] = val$$1 !== !1;
                })), promise;
            }, criteria = {
                exiting: viewState.name
            };
            $scope.$on("$destroy", $transitions.onBefore(criteria, wrappedHook, hookOptions));
        }
    }
    function $ViewScrollProvider() {
        var useAnchorScroll = !1;
        this.useAnchorScroll = function() {
            useAnchorScroll = !0;
        }, this.$get = [ "$anchorScroll", "$timeout", function($anchorScroll, $timeout) {
            return useAnchorScroll ? $anchorScroll : function($element) {
                return $timeout(function() {
                    $element[0].scrollIntoView();
                }, 0, !1);
            };
        } ];
    }
    var ng_from_global = angular, ng = ng_from_import && ng_from_import.module ? ng_from_import : ng_from_global, prop = function(name) {
        return function(obj) {
            return obj && obj[name];
        };
    }, propEq = curry(function(name, _val, obj) {
        return obj && obj[name] === _val;
    }), parse = function(name) {
        return pipe.apply(null, name.split(".").map(prop));
    }, not = function(fn) {
        return function() {
            for (var args = [], _i = 0; _i < arguments.length; _i++) args[_i] = arguments[_i];
            return !fn.apply(null, args);
        };
    }, all = function(fn1) {
        return function(arr) {
            return arr.reduce(function(b, x) {
                return b && !!fn1(x);
            }, !0);
        };
    }, any = function(fn1) {
        return function(arr) {
            return arr.reduce(function(b, x) {
                return b || !!fn1(x);
            }, !1);
        };
    }, is = function(ctor) {
        return function(obj) {
            return null != obj && obj.constructor === ctor || obj instanceof ctor;
        };
    }, eq = function(value) {
        return function(other) {
            return value === other;
        };
    }, val = function(v) {
        return function() {
            return v;
        };
    }, toStr = Object.prototype.toString, tis = function(t) {
        return function(x) {
            return typeof x === t;
        };
    }, isUndefined = tis("undefined"), isDefined = not(isUndefined), isNull = function(o) {
        return null === o;
    }, isNullOrUndefined = or(isNull, isUndefined), isFunction = tis("function"), isNumber = tis("number"), isString = tis("string"), isObject = function(x) {
        return null !== x && "object" == typeof x;
    }, isArray = Array.isArray, isDate = function(x) {
        return "[object Date]" === toStr.call(x);
    }, isRegExp = function(x) {
        return "[object RegExp]" === toStr.call(x);
    }, isPromise = and(isObject, pipe(prop("then"), isFunction)), noImpl = function(fnname) {
        return function() {
            throw new Error("No implementation for " + fnname + ". The framework specific code did not implement this method.");
        };
    }, makeStub = function(service, methods) {
        return methods.reduce(function(acc, key) {
            return acc[key] = noImpl(service + "." + key + "()"), acc;
        }, {});
    }, services = {
        $q: void 0,
        $injector: void 0
    }, root = "object" == typeof self && self.self === self && self || "object" == typeof global && global.global === global && global || void 0, angular$1 = root.angular || {}, fromJson = angular$1.fromJson || JSON.parse.bind(JSON), toJson = angular$1.toJson || JSON.stringify.bind(JSON), forEach = angular$1.forEach || _forEach, extend = Object.assign || _extend, equals = angular$1.equals || _equals, inherit = function(parent, extra) {
        return extend(Object.create(parent), extra);
    }, inArray = curry(_inArray), removeFrom = curry(_removeFrom), pushTo = curry(_pushTo), deregAll = function(functions) {
        return functions.slice().forEach(function(fn) {
            "function" == typeof fn && fn(), removeFrom(functions, fn);
        });
    }, mergeR = function(memo, item) {
        return extend(memo, item);
    }, mapObj = map, values = function(obj) {
        return Object.keys(obj).map(function(key) {
            return obj[key];
        });
    }, allTrueR = function(memo, elem) {
        return memo && elem;
    }, anyTrueR = function(memo, elem) {
        return memo || elem;
    }, unnestR = function(memo, elem) {
        return memo.concat(elem);
    }, flattenR = function(memo, elem) {
        return isArray(elem) ? memo.concat(elem.reduce(flattenR, [])) : pushR(memo, elem);
    }, uniqR = function(acc, token) {
        return inArray(acc, token) ? acc : pushR(acc, token);
    }, unnest = function(arr) {
        return arr.reduce(unnestR, []);
    }, flatten = function(arr) {
        return arr.reduce(flattenR, []);
    }, assertPredicate = assertFn, assertMap = assertFn, pairs = function(obj) {
        return Object.keys(obj).map(function(key) {
            return [ key, obj[key] ];
        });
    }, silenceUncaughtInPromise = function(promise) {
        return promise.catch(function() {
            return 0;
        }) && promise;
    }, silentRejection = function(error) {
        return silenceUncaughtInPromise(services.$q.reject(error));
    }, Glob = function() {
        function Glob(text) {
            this.text = text, this.glob = text.split(".");
            var regexpString = this.text.split(".").map(function(seg) {
                return "**" === seg ? "(?:|(?:\\.[^.]*)*)" : "*" === seg ? "\\.[^.]*" : "\\." + seg;
            }).join("");
            this.regexp = new RegExp("^" + regexpString + "$");
        }
        return Glob.is = function(text) {
            return !!/[!,*]+/.exec(text);
        }, Glob.fromString = function(text) {
            return Glob.is(text) ? new Glob(text) : null;
        }, Glob.prototype.matches = function(name) {
            return this.regexp.test("." + name);
        }, Glob;
    }(), Queue = function() {
        function Queue(_items, _limit) {
            void 0 === _items && (_items = []), void 0 === _limit && (_limit = null), this._items = _items, 
            this._limit = _limit, this._evictListeners = [], this.onEvict = pushTo(this._evictListeners);
        }
        return Queue.prototype.enqueue = function(item) {
            var items = this._items;
            return items.push(item), this._limit && items.length > this._limit && this.evict(), 
            item;
        }, Queue.prototype.evict = function() {
            var item = this._items.shift();
            return this._evictListeners.forEach(function(fn) {
                return fn(item);
            }), item;
        }, Queue.prototype.dequeue = function() {
            return this.size() ? this._items.splice(0, 1)[0] : void 0;
        }, Queue.prototype.clear = function() {
            var current = this._items;
            return this._items = [], current;
        }, Queue.prototype.size = function() {
            return this._items.length;
        }, Queue.prototype.remove = function(item) {
            var idx = this._items.indexOf(item);
            return idx > -1 && this._items.splice(idx, 1)[0];
        }, Queue.prototype.peekTail = function() {
            return this._items[this._items.length - 1];
        }, Queue.prototype.peekHead = function() {
            return this.size() ? this._items[0] : void 0;
        }, Queue;
    }();
    !function(RejectType) {
        RejectType[RejectType.SUPERSEDED = 2] = "SUPERSEDED", RejectType[RejectType.ABORTED = 3] = "ABORTED", 
        RejectType[RejectType.INVALID = 4] = "INVALID", RejectType[RejectType.IGNORED = 5] = "IGNORED", 
        RejectType[RejectType.ERROR = 6] = "ERROR";
    }(exports.RejectType || (exports.RejectType = {}));
    var id = 0, Rejection = function() {
        function Rejection(type, message, detail) {
            this.$id = id++, this.type = type, this.message = message, this.detail = detail;
        }
        return Rejection.isRejectionPromise = function(obj) {
            return obj && "function" == typeof obj.then && is(Rejection)(obj._transitionRejection);
        }, Rejection.superseded = function(detail, options) {
            var message = "The transition has been superseded by a different transition", rejection = new Rejection(exports.RejectType.SUPERSEDED, message, detail);
            return options && options.redirected && (rejection.redirected = !0), rejection;
        }, Rejection.redirected = function(detail) {
            return Rejection.superseded(detail, {
                redirected: !0
            });
        }, Rejection.invalid = function(detail) {
            var message = "This transition is invalid";
            return new Rejection(exports.RejectType.INVALID, message, detail);
        }, Rejection.ignored = function(detail) {
            var message = "The transition was ignored";
            return new Rejection(exports.RejectType.IGNORED, message, detail);
        }, Rejection.aborted = function(detail) {
            var message = "The transition has been aborted";
            return new Rejection(exports.RejectType.ABORTED, message, detail);
        }, Rejection.errored = function(detail) {
            var message = "The transition errored";
            return new Rejection(exports.RejectType.ERROR, message, detail);
        }, Rejection.normalize = function(detail) {
            return is(Rejection)(detail) ? detail : Rejection.errored(detail);
        }, Rejection.prototype.toString = function() {
            var detailString = function(d) {
                return d && d.toString !== Object.prototype.toString ? d.toString() : stringify(d);
            }, detail = detailString(this.detail), _a = this, $id = _a.$id, type = _a.type, message = _a.message;
            return "Transition Rejection($id: " + $id + " type: " + type + ", message: " + message + ", detail: " + detail + ")";
        }, Rejection.prototype.toPromise = function() {
            return extend(silentRejection(this), {
                _transitionRejection: this
            });
        }, Rejection;
    }(), isRejection = Rejection.isRejectionPromise, hasToString = function(obj) {
        return isObject(obj) && !isArray(obj) && obj.constructor !== Object && isFunction(obj.toString);
    }, stringifyPattern = pattern([ [ isUndefined, val("undefined") ], [ isNull, val("null") ], [ isPromise, val("[Promise]") ], [ isRejection, function(x) {
        return x._transitionRejection.toString();
    } ], [ hasToString, function(x) {
        return x.toString();
    } ], [ isInjectable, functionToString ], [ val(!0), identity ] ]), beforeAfterSubstr = function(char) {
        return function(str) {
            if (!str) return [ "", "" ];
            var idx = str.indexOf(char);
            return -1 === idx ? [ str, "" ] : [ str.substr(0, idx), str.substr(idx + 1) ];
        };
    }, hostRegex = new RegExp("^(?:[a-z]+:)?//[^/]+/"), stripLastPathElement = function(str) {
        return str.replace(/\/[^\/]*$/, "");
    }, splitHash = beforeAfterSubstr("#"), splitQuery = beforeAfterSubstr("?"), splitEqual = beforeAfterSubstr("="), trimHashVal = function(str) {
        return str ? str.replace(/^#/, "") : "";
    }, viewConfigString = function(viewConfig) {
        var view = viewConfig.viewDecl, state = view.$context.name || "(root)";
        return "[View#" + viewConfig.$id + " from '" + state + "' state]: target ui-view: '" + view.$uiViewName + "@" + view.$uiViewContextAnchor + "'";
    }, consoleLog = Function.prototype.bind.call(console.log, console), consoletable = isFunction(console.table) ? console.table.bind(console) : consoleLog.bind(console);
    !function(Category) {
        Category[Category.RESOLVE = 0] = "RESOLVE", Category[Category.TRANSITION = 1] = "TRANSITION", 
        Category[Category.HOOK = 2] = "HOOK", Category[Category.UIVIEW = 3] = "UIVIEW", 
        Category[Category.VIEWCONFIG = 4] = "VIEWCONFIG";
    }(exports.Category || (exports.Category = {}));
    var _tid = parse("$id"), _rid = parse("router.$id"), transLbl = function(trans) {
        return "Transition #" + _tid(trans) + "-" + _rid(trans);
    }, Trace = function() {
        function Trace() {
            this._enabled = {}, this.approximateDigests = 0;
        }
        return Trace.prototype._set = function(enabled, categories) {
            var _this = this;
            categories.length || (categories = Object.keys(exports.Category).map(function(k) {
                return parseInt(k, 10);
            }).filter(function(k) {
                return !isNaN(k);
            }).map(function(key) {
                return exports.Category[key];
            })), categories.map(normalizedCat).forEach(function(category) {
                return _this._enabled[category] = enabled;
            });
        }, Trace.prototype.enable = function() {
            for (var categories = [], _i = 0; _i < arguments.length; _i++) categories[_i] = arguments[_i];
            this._set(!0, categories);
        }, Trace.prototype.disable = function() {
            for (var categories = [], _i = 0; _i < arguments.length; _i++) categories[_i] = arguments[_i];
            this._set(!1, categories);
        }, Trace.prototype.enabled = function(category) {
            return !!this._enabled[normalizedCat(category)];
        }, Trace.prototype.traceTransitionStart = function(trans) {
            this.enabled(exports.Category.TRANSITION) && console.log(transLbl(trans) + ": Started  -> " + stringify(trans));
        }, Trace.prototype.traceTransitionIgnored = function(trans) {
            this.enabled(exports.Category.TRANSITION) && console.log(transLbl(trans) + ": Ignored  <> " + stringify(trans));
        }, Trace.prototype.traceHookInvocation = function(step, trans, options) {
            if (this.enabled(exports.Category.HOOK)) {
                var event = parse("traceData.hookType")(options) || "internal", context = parse("traceData.context.state.name")(options) || parse("traceData.context")(options) || "unknown", name = functionToString(step.registeredHook.callback);
                console.log(transLbl(trans) + ":   Hook -> " + event + " context: " + context + ", " + maxLength(200, name));
            }
        }, Trace.prototype.traceHookResult = function(hookResult, trans) {
            this.enabled(exports.Category.HOOK) && console.log(transLbl(trans) + ":   <- Hook returned: " + maxLength(200, stringify(hookResult)));
        }, Trace.prototype.traceResolvePath = function(path, when, trans) {
            this.enabled(exports.Category.RESOLVE) && console.log(transLbl(trans) + ":         Resolving " + path + " (" + when + ")");
        }, Trace.prototype.traceResolvableResolved = function(resolvable, trans) {
            this.enabled(exports.Category.RESOLVE) && console.log(transLbl(trans) + ":               <- Resolved  " + resolvable + " to: " + maxLength(200, stringify(resolvable.data)));
        }, Trace.prototype.traceError = function(reason, trans) {
            this.enabled(exports.Category.TRANSITION) && console.log(transLbl(trans) + ": <- Rejected " + stringify(trans) + ", reason: " + reason);
        }, Trace.prototype.traceSuccess = function(finalState, trans) {
            this.enabled(exports.Category.TRANSITION) && console.log(transLbl(trans) + ": <- Success  " + stringify(trans) + ", final state: " + finalState.name);
        }, Trace.prototype.traceUIViewEvent = function(event, viewData, extra) {
            void 0 === extra && (extra = ""), this.enabled(exports.Category.UIVIEW) && console.log("ui-view: " + padString(30, event) + " " + uiViewString(viewData) + extra);
        }, Trace.prototype.traceUIViewConfigUpdated = function(viewData, context) {
            this.enabled(exports.Category.UIVIEW) && this.traceUIViewEvent("Updating", viewData, " with ViewConfig from context='" + context + "'");
        }, Trace.prototype.traceUIViewFill = function(viewData, html) {
            this.enabled(exports.Category.UIVIEW) && this.traceUIViewEvent("Fill", viewData, " with: " + maxLength(200, html));
        }, Trace.prototype.traceViewSync = function(pairs) {
            if (this.enabled(exports.Category.VIEWCONFIG)) {
                var uivheader = "uiview component fqn", cfgheader = "view config state (view name)", mapping = pairs.map(function(_a) {
                    var _b, uiView = _a.uiView, viewConfig = _a.viewConfig, uiv = uiView && uiView.fqn, cfg = viewConfig && viewConfig.viewDecl.$context.name + ": (" + viewConfig.viewDecl.$name + ")";
                    return _b = {}, _b[uivheader] = uiv, _b[cfgheader] = cfg, _b;
                }).sort(function(a, b) {
                    return (a[uivheader] || "").localeCompare(b[uivheader] || "");
                });
                consoletable(mapping);
            }
        }, Trace.prototype.traceViewServiceEvent = function(event, viewConfig) {
            this.enabled(exports.Category.VIEWCONFIG) && console.log("VIEWCONFIG: " + event + " " + viewConfigString(viewConfig));
        }, Trace.prototype.traceViewServiceUIViewEvent = function(event, viewData) {
            this.enabled(exports.Category.VIEWCONFIG) && console.log("VIEWCONFIG: " + event + " " + uiViewString(viewData));
        }, Trace;
    }(), trace = new Trace(), ParamType = function() {
        function ParamType(def) {
            this.pattern = /.*/, this.inherit = !0, extend(this, def);
        }
        return ParamType.prototype.is = function() {
            return !0;
        }, ParamType.prototype.encode = function(val) {
            return val;
        }, ParamType.prototype.decode = function(val) {
            return val;
        }, ParamType.prototype.equals = function(a, b) {
            return a == b;
        }, ParamType.prototype.$subPattern = function() {
            var sub = this.pattern.toString();
            return sub.substr(1, sub.length - 2);
        }, ParamType.prototype.toString = function() {
            return "{ParamType:" + this.name + "}";
        }, ParamType.prototype.$normalize = function(val) {
            return this.is(val) ? val : this.decode(val);
        }, ParamType.prototype.$asArray = function(mode, isSearch) {
            if (!mode) return this;
            if ("auto" === mode && !isSearch) throw new Error("'auto' array mode is for query parameters only");
            return new ArrayType(this, mode);
        }, ParamType;
    }(), hasOwn = Object.prototype.hasOwnProperty, isShorthand = function(cfg) {
        return 0 === [ "value", "type", "squash", "array", "dynamic" ].filter(hasOwn.bind(cfg || {})).length;
    };
    !function(DefType) {
        DefType[DefType.PATH = 0] = "PATH", DefType[DefType.SEARCH = 1] = "SEARCH", DefType[DefType.CONFIG = 2] = "CONFIG";
    }(exports.DefType || (exports.DefType = {}));
    var Param = function() {
        function Param(id, type, location, urlConfig, state) {
            function getArrayMode() {
                var arrayDefaults = {
                    array: location === exports.DefType.SEARCH ? "auto" : !1
                }, arrayParamNomenclature = id.match(/\[\]$/) ? {
                    array: !0
                } : {};
                return extend(arrayDefaults, arrayParamNomenclature, config).array;
            }
            var config = getParamDeclaration(id, location, state);
            type = getType(config, type, location, id, urlConfig.paramTypes);
            var arrayMode = getArrayMode();
            type = arrayMode ? type.$asArray(arrayMode, location === exports.DefType.SEARCH) : type;
            var isOptional = void 0 !== config.value || location === exports.DefType.SEARCH, dynamic = isDefined(config.dynamic) ? !!config.dynamic : !!type.dynamic, raw = isDefined(config.raw) ? !!config.raw : !!type.raw, squash = getSquashPolicy(config, isOptional, urlConfig.defaultSquashPolicy()), replace = getReplace(config, arrayMode, isOptional, squash), inherit$$1 = isDefined(config.inherit) ? !!config.inherit : !!type.inherit;
            extend(this, {
                id: id,
                type: type,
                location: location,
                isOptional: isOptional,
                dynamic: dynamic,
                raw: raw,
                squash: squash,
                replace: replace,
                inherit: inherit$$1,
                array: arrayMode,
                config: config
            });
        }
        return Param.values = function(params, values$$1) {
            void 0 === values$$1 && (values$$1 = {});
            for (var paramValues = {}, _i = 0, params_1 = params; _i < params_1.length; _i++) {
                var param = params_1[_i];
                paramValues[param.id] = param.value(values$$1[param.id]);
            }
            return paramValues;
        }, Param.changed = function(params, values1, values2) {
            return void 0 === values1 && (values1 = {}), void 0 === values2 && (values2 = {}), 
            params.filter(function(param) {
                return !param.type.equals(values1[param.id], values2[param.id]);
            });
        }, Param.equals = function(params, values1, values2) {
            return void 0 === values1 && (values1 = {}), void 0 === values2 && (values2 = {}), 
            0 === Param.changed(params, values1, values2).length;
        }, Param.validates = function(params, values$$1) {
            return void 0 === values$$1 && (values$$1 = {}), params.map(function(param) {
                return param.validates(values$$1[param.id]);
            }).reduce(allTrueR, !0);
        }, Param.prototype.isDefaultValue = function(value) {
            return this.isOptional && this.type.equals(this.value(), value);
        }, Param.prototype.value = function(value) {
            var _this = this, getDefaultValue = function() {
                if (_this._defaultValueCache) return _this._defaultValueCache.defaultValue;
                if (!services.$injector) throw new Error("Injectable functions cannot be called at configuration time");
                var defaultValue = services.$injector.invoke(_this.config.$$fn);
                if (null !== defaultValue && void 0 !== defaultValue && !_this.type.is(defaultValue)) throw new Error("Default value (" + defaultValue + ") for parameter '" + _this.id + "' is not an instance of ParamType (" + _this.type.name + ")");
                return _this.config.$$fn.__cacheable && (_this._defaultValueCache = {
                    defaultValue: defaultValue
                }), defaultValue;
            }, replaceSpecialValues = function(val$$1) {
                for (var _i = 0, _a = _this.replace; _i < _a.length; _i++) {
                    var tuple = _a[_i];
                    if (tuple.from === val$$1) return tuple.to;
                }
                return val$$1;
            };
            return value = replaceSpecialValues(value), isUndefined(value) ? getDefaultValue() : this.type.$normalize(value);
        }, Param.prototype.isSearch = function() {
            return this.location === exports.DefType.SEARCH;
        }, Param.prototype.validates = function(value) {
            if ((isUndefined(value) || null === value) && this.isOptional) return !0;
            var normalized = this.type.$normalize(value);
            if (!this.type.is(normalized)) return !1;
            var encoded = this.type.encode(normalized);
            return !(isString(encoded) && !this.type.pattern.exec(encoded));
        }, Param.prototype.toString = function() {
            return "{Param:" + this.id + " " + this.type + " squash: '" + this.squash + "' optional: " + this.isOptional + "}";
        }, Param;
    }(), ParamTypes = function() {
        function ParamTypes() {
            this.enqueue = !0, this.typeQueue = [], this.defaultTypes = pick(ParamTypes.prototype, [ "hash", "string", "query", "path", "int", "bool", "date", "json", "any" ]);
            var makeType = function(definition, name) {
                return new ParamType(extend({
                    name: name
                }, definition));
            };
            this.types = inherit(map(this.defaultTypes, makeType), {});
        }
        return ParamTypes.prototype.dispose = function() {
            this.types = {};
        }, ParamTypes.prototype.type = function(name, definition, definitionFn) {
            if (!isDefined(definition)) return this.types[name];
            if (this.types.hasOwnProperty(name)) throw new Error("A type named '" + name + "' has already been defined.");
            return this.types[name] = new ParamType(extend({
                name: name
            }, definition)), definitionFn && (this.typeQueue.push({
                name: name,
                def: definitionFn
            }), this.enqueue || this._flushTypeQueue()), this;
        }, ParamTypes.prototype._flushTypeQueue = function() {
            for (;this.typeQueue.length; ) {
                var type = this.typeQueue.shift();
                if (type.pattern) throw new Error("You cannot override a type's .pattern at runtime.");
                extend(this.types[type.name], services.$injector.invoke(type.def));
            }
        }, ParamTypes;
    }();
    initDefaultTypes();
    var StateParams = function() {
        function StateParams(params) {
            void 0 === params && (params = {}), extend(this, params);
        }
        return StateParams.prototype.$inherit = function(newParams, $current, $to) {
            var parentParams, parents = ancestors($current, $to), inherited = {}, inheritList = [];
            for (var i in parents) if (parents[i] && parents[i].params && (parentParams = Object.keys(parents[i].params), 
            parentParams.length)) for (var j in parentParams) inheritList.indexOf(parentParams[j]) >= 0 || (inheritList.push(parentParams[j]), 
            inherited[parentParams[j]] = this[parentParams[j]]);
            return extend({}, inherited, newParams);
        }, StateParams;
    }(), PathNode = function() {
        function PathNode(stateOrNode) {
            if (stateOrNode instanceof PathNode) {
                var node = stateOrNode;
                this.state = node.state, this.paramSchema = node.paramSchema.slice(), this.paramValues = extend({}, node.paramValues), 
                this.resolvables = node.resolvables.slice(), this.views = node.views && node.views.slice();
            } else {
                var state = stateOrNode;
                this.state = state, this.paramSchema = state.parameters({
                    inherit: !1
                }), this.paramValues = {}, this.resolvables = state.resolvables.map(function(res) {
                    return res.clone();
                });
            }
        }
        return PathNode.prototype.clone = function() {
            return new PathNode(this);
        }, PathNode.prototype.applyRawParams = function(params) {
            var getParamVal = function(paramDef) {
                return [ paramDef.id, paramDef.value(params[paramDef.id]) ];
            };
            return this.paramValues = this.paramSchema.reduce(function(memo, pDef) {
                return applyPairs(memo, getParamVal(pDef));
            }, {}), this;
        }, PathNode.prototype.parameter = function(name) {
            return find(this.paramSchema, propEq("id", name));
        }, PathNode.prototype.equals = function(node, paramsFn) {
            var diff = this.diff(node, paramsFn);
            return diff && 0 === diff.length;
        }, PathNode.prototype.diff = function(node, paramsFn) {
            if (this.state !== node.state) return !1;
            var params = paramsFn ? paramsFn(this) : this.paramSchema;
            return Param.changed(params, this.paramValues, node.paramValues);
        }, PathNode.clone = function(node) {
            return node.clone();
        }, PathNode;
    }(), TargetState = function() {
        function TargetState(_stateRegistry, _identifier, _params, _options) {
            this._stateRegistry = _stateRegistry, this._identifier = _identifier, this._identifier = _identifier, 
            this._params = extend({}, _params || {}), this._options = extend({}, _options || {}), 
            this._definition = _stateRegistry.matcher.find(_identifier, this._options.relative);
        }
        return TargetState.prototype.name = function() {
            return this._definition && this._definition.name || this._identifier;
        }, TargetState.prototype.identifier = function() {
            return this._identifier;
        }, TargetState.prototype.params = function() {
            return this._params;
        }, TargetState.prototype.$state = function() {
            return this._definition;
        }, TargetState.prototype.state = function() {
            return this._definition && this._definition.self;
        }, TargetState.prototype.options = function() {
            return this._options;
        }, TargetState.prototype.exists = function() {
            return !(!this._definition || !this._definition.self);
        }, TargetState.prototype.valid = function() {
            return !this.error();
        }, TargetState.prototype.error = function() {
            var base = this.options().relative;
            if (!this._definition && base) {
                var stateName = base.name ? base.name : base;
                return "Could not resolve '" + this.name() + "' from state '" + stateName + "'";
            }
            return this._definition ? this._definition.self ? void 0 : "State '" + this.name() + "' has an invalid definition" : "No such state '" + this.name() + "'";
        }, TargetState.prototype.toString = function() {
            return "'" + this.name() + "'" + stringify(this.params());
        }, TargetState.prototype.withState = function(state) {
            return new TargetState(this._stateRegistry, state, this._params, this._options);
        }, TargetState.prototype.withParams = function(params, replace) {
            void 0 === replace && (replace = !1);
            var newParams = replace ? params : extend({}, this._params, params);
            return new TargetState(this._stateRegistry, this._identifier, newParams, this._options);
        }, TargetState.prototype.withOptions = function(options, replace) {
            void 0 === replace && (replace = !1);
            var newOpts = replace ? options : extend({}, this._options, options);
            return new TargetState(this._stateRegistry, this._identifier, this._params, newOpts);
        }, TargetState.isDef = function(obj) {
            return obj && obj.state && (isString(obj.state) || isString(obj.state.name));
        }, TargetState;
    }(), PathUtils = function() {
        function PathUtils() {}
        return PathUtils.makeTargetState = function(registry, path) {
            var state = tail(path).state;
            return new TargetState(registry, state, path.map(prop("paramValues")).reduce(mergeR, {}), {});
        }, PathUtils.buildPath = function(targetState) {
            var toParams = targetState.params();
            return targetState.$state().path.map(function(state) {
                return new PathNode(state).applyRawParams(toParams);
            });
        }, PathUtils.buildToPath = function(fromPath, targetState) {
            var toPath = PathUtils.buildPath(targetState);
            return targetState.options().inherit ? PathUtils.inheritParams(fromPath, toPath, Object.keys(targetState.params())) : toPath;
        }, PathUtils.applyViewConfigs = function($view, path, states) {
            path.filter(function(node) {
                return inArray(states, node.state);
            }).forEach(function(node) {
                var viewDecls = values(node.state.views || {}), subPath = PathUtils.subPath(path, function(n) {
                    return n === node;
                }), viewConfigs = viewDecls.map(function(view) {
                    return $view.createViewConfig(subPath, view);
                });
                node.views = viewConfigs.reduce(unnestR, []);
            });
        }, PathUtils.inheritParams = function(fromPath, toPath, toKeys) {
            function nodeParamVals(path, state) {
                var node = find(path, propEq("state", state));
                return extend({}, node && node.paramValues);
            }
            function makeInheritedParamsNode(toNode) {
                var toParamVals = extend({}, toNode && toNode.paramValues), incomingParamVals = pick(toParamVals, toKeys);
                toParamVals = omit(toParamVals, toKeys);
                var fromParamVals = omit(nodeParamVals(fromPath, toNode.state) || {}, noInherit), ownParamVals = extend(toParamVals, fromParamVals, incomingParamVals);
                return new PathNode(toNode.state).applyRawParams(ownParamVals);
            }
            void 0 === toKeys && (toKeys = []);
            var noInherit = fromPath.map(function(node) {
                return node.paramSchema;
            }).reduce(unnestR, []).filter(function(param) {
                return !param.inherit;
            }).map(prop("id"));
            return toPath.map(makeInheritedParamsNode);
        }, PathUtils.treeChanges = function(fromPath, toPath, reloadState) {
            function applyToParams(retainedNode, idx) {
                var cloned = retainedNode.clone();
                return cloned.paramValues = toPath[idx].paramValues, cloned;
            }
            for (var max = Math.min(fromPath.length, toPath.length), keep = 0, nodesMatch = function(node1, node2) {
                return node1.equals(node2, PathUtils.nonDynamicParams);
            }; max > keep && fromPath[keep].state !== reloadState && nodesMatch(fromPath[keep], toPath[keep]); ) keep++;
            var from, retained, exiting, entering, to;
            from = fromPath, retained = from.slice(0, keep), exiting = from.slice(keep);
            var retainedWithToParams = retained.map(applyToParams);
            return entering = toPath.slice(keep), to = retainedWithToParams.concat(entering), 
            {
                from: from,
                to: to,
                retained: retained,
                retainedWithToParams: retainedWithToParams,
                exiting: exiting,
                entering: entering
            };
        }, PathUtils.matching = function(pathA, pathB, paramsFn) {
            var done = !1, tuples = arrayTuples(pathA, pathB);
            return tuples.reduce(function(matching, _a) {
                var nodeA = _a[0], nodeB = _a[1];
                return done = done || !nodeA.equals(nodeB, paramsFn), done ? matching : matching.concat(nodeA);
            }, []);
        }, PathUtils.equals = function(pathA, pathB, paramsFn) {
            return pathA.length === pathB.length && PathUtils.matching(pathA, pathB, paramsFn).length === pathA.length;
        }, PathUtils.subPath = function(path, predicate) {
            var node = find(path, predicate), elementIdx = path.indexOf(node);
            return -1 === elementIdx ? void 0 : path.slice(0, elementIdx + 1);
        }, PathUtils.nonDynamicParams = function(node) {
            return node.state.parameters({
                inherit: !1
            }).filter(function(param) {
                return !param.dynamic;
            });
        }, PathUtils.paramValues = function(path) {
            return path.reduce(function(acc, node) {
                return extend(acc, node.paramValues);
            }, {});
        }, PathUtils;
    }(), resolvePolicies = {
        when: {
            LAZY: "LAZY",
            EAGER: "EAGER"
        },
        async: {
            WAIT: "WAIT",
            NOWAIT: "NOWAIT",
            RXWAIT: "RXWAIT"
        }
    }, defaultResolvePolicy = {
        when: "LAZY",
        async: "WAIT"
    }, Resolvable = function() {
        function Resolvable(arg1, resolveFn, deps, policy, data) {
            if (this.resolved = !1, this.promise = void 0, arg1 instanceof Resolvable) extend(this, arg1); else if (isFunction(resolveFn)) {
                if (isNullOrUndefined(arg1)) throw new Error("new Resolvable(): token argument is required");
                if (!isFunction(resolveFn)) throw new Error("new Resolvable(): resolveFn argument must be a function");
                this.token = arg1, this.policy = policy, this.resolveFn = resolveFn, this.deps = deps || [], 
                this.data = data, this.resolved = void 0 !== data, this.promise = this.resolved ? services.$q.when(this.data) : void 0;
            } else if (isObject(arg1) && arg1.token && (arg1.hasOwnProperty("resolveFn") || arg1.hasOwnProperty("data"))) {
                var literal = arg1;
                return new Resolvable(literal.token, literal.resolveFn, literal.deps, literal.policy, literal.data);
            }
        }
        return Resolvable.prototype.getPolicy = function(state) {
            var thisPolicy = this.policy || {}, statePolicy = state && state.resolvePolicy || {};
            return {
                when: thisPolicy.when || statePolicy.when || defaultResolvePolicy.when,
                async: thisPolicy.async || statePolicy.async || defaultResolvePolicy.async
            };
        }, Resolvable.prototype.resolve = function(resolveContext, trans) {
            var _this = this, $q = services.$q, getResolvableDependencies = function() {
                return $q.all(resolveContext.getDependencies(_this).map(function(resolvable) {
                    return resolvable.get(resolveContext, trans);
                }));
            }, invokeResolveFn = function(resolvedDeps) {
                return _this.resolveFn.apply(null, resolvedDeps);
            }, waitForRx = function(observable$) {
                var cached = observable$.cache(1);
                return cached.take(1).toPromise().then(function() {
                    return cached;
                });
            }, node = resolveContext.findNode(this), state = node && node.state, maybeWaitForRx = "RXWAIT" === this.getPolicy(state).async ? waitForRx : identity, applyResolvedValue = function(resolvedValue) {
                return _this.data = resolvedValue, _this.resolved = !0, _this.resolveFn = null, 
                trace.traceResolvableResolved(_this, trans), _this.data;
            };
            return this.promise = $q.when().then(getResolvableDependencies).then(invokeResolveFn).then(maybeWaitForRx).then(applyResolvedValue);
        }, Resolvable.prototype.get = function(resolveContext, trans) {
            return this.promise || this.resolve(resolveContext, trans);
        }, Resolvable.prototype.toString = function() {
            return "Resolvable(token: " + stringify(this.token) + ", requires: [" + this.deps.map(stringify) + "])";
        }, Resolvable.prototype.clone = function() {
            return new Resolvable(this);
        }, Resolvable.fromData = function(token, data) {
            return new Resolvable(token, function() {
                return data;
            }, null, null, data);
        }, Resolvable;
    }(), whens = resolvePolicies.when, ALL_WHENS = [ whens.EAGER, whens.LAZY ], EAGER_WHENS = [ whens.EAGER ], NATIVE_INJECTOR_TOKEN = "Native Injector", ResolveContext = function() {
        function ResolveContext(_path) {
            this._path = _path;
        }
        return ResolveContext.prototype.getTokens = function() {
            return this._path.reduce(function(acc, node) {
                return acc.concat(node.resolvables.map(function(r) {
                    return r.token;
                }));
            }, []).reduce(uniqR, []);
        }, ResolveContext.prototype.getResolvable = function(token) {
            var matching = this._path.map(function(node) {
                return node.resolvables;
            }).reduce(unnestR, []).filter(function(r) {
                return r.token === token;
            });
            return tail(matching);
        }, ResolveContext.prototype.getPolicy = function(resolvable) {
            var node = this.findNode(resolvable);
            return resolvable.getPolicy(node.state);
        }, ResolveContext.prototype.subContext = function(state) {
            return new ResolveContext(PathUtils.subPath(this._path, function(node) {
                return node.state === state;
            }));
        }, ResolveContext.prototype.addResolvables = function(newResolvables, state) {
            var node = find(this._path, propEq("state", state)), keys = newResolvables.map(function(r) {
                return r.token;
            });
            node.resolvables = node.resolvables.filter(function(r) {
                return -1 === keys.indexOf(r.token);
            }).concat(newResolvables);
        }, ResolveContext.prototype.resolvePath = function(when, trans) {
            var _this = this;
            void 0 === when && (when = "LAZY");
            var whenOption = inArray(ALL_WHENS, when) ? when : "LAZY", matchedWhens = whenOption === resolvePolicies.when.EAGER ? EAGER_WHENS : ALL_WHENS;
            trace.traceResolvePath(this._path, when, trans);
            var matchesPolicy = function(acceptedVals, whenOrAsync) {
                return function(resolvable) {
                    return inArray(acceptedVals, _this.getPolicy(resolvable)[whenOrAsync]);
                };
            }, promises = this._path.reduce(function(acc, node) {
                var nodeResolvables = node.resolvables.filter(matchesPolicy(matchedWhens, "when")), nowait = nodeResolvables.filter(matchesPolicy([ "NOWAIT" ], "async")), wait = nodeResolvables.filter(not(matchesPolicy([ "NOWAIT" ], "async"))), subContext = _this.subContext(node.state), getResult = function(r) {
                    return r.get(subContext, trans).then(function(value) {
                        return {
                            token: r.token,
                            value: value
                        };
                    });
                };
                return nowait.forEach(getResult), acc.concat(wait.map(getResult));
            }, []);
            return services.$q.all(promises);
        }, ResolveContext.prototype.injector = function() {
            return this._injector || (this._injector = new UIInjectorImpl(this));
        }, ResolveContext.prototype.findNode = function(resolvable) {
            return find(this._path, function(node) {
                return inArray(node.resolvables, resolvable);
            });
        }, ResolveContext.prototype.getDependencies = function(resolvable) {
            var _this = this, node = this.findNode(resolvable), subPath = PathUtils.subPath(this._path, function(x) {
                return x === node;
            }) || this._path, availableResolvables = subPath.reduce(function(acc, _node) {
                return acc.concat(_node.resolvables);
            }, []).filter(function(res) {
                return res !== resolvable;
            }), getDependency = function(token) {
                var matching = availableResolvables.filter(function(r) {
                    return r.token === token;
                });
                if (matching.length) return tail(matching);
                var fromInjector = _this.injector().getNative(token);
                if (isUndefined(fromInjector)) throw new Error("Could not find Dependency Injection token: " + stringify(token));
                return new Resolvable(token, function() {
                    return fromInjector;
                }, [], fromInjector);
            };
            return resolvable.deps.map(getDependency);
        }, ResolveContext;
    }(), UIInjectorImpl = function() {
        function UIInjectorImpl(context) {
            this.context = context, this.native = this.get(NATIVE_INJECTOR_TOKEN) || services.$injector;
        }
        return UIInjectorImpl.prototype.get = function(token) {
            var resolvable = this.context.getResolvable(token);
            if (resolvable) {
                if ("NOWAIT" === this.context.getPolicy(resolvable).async) return resolvable.get(this.context);
                if (!resolvable.resolved) throw new Error("Resolvable async .get() not complete:" + stringify(resolvable.token));
                return resolvable.data;
            }
            return this.getNative(token);
        }, UIInjectorImpl.prototype.getAsync = function(token) {
            var resolvable = this.context.getResolvable(token);
            return resolvable ? resolvable.get(this.context) : services.$q.when(this.native.get(token));
        }, UIInjectorImpl.prototype.getNative = function(token) {
            return this.native && this.native.get(token);
        }, UIInjectorImpl;
    }(), parseUrl = function(url) {
        if (!isString(url)) return !1;
        var root$$1 = "^" === url.charAt(0);
        return {
            val: root$$1 ? url.substring(1) : url,
            root: root$$1
        };
    }, getUrlBuilder = function($urlMatcherFactoryProvider, root$$1) {
        return function(stateObject) {
            var state = stateObject.self;
            state && state.url && state.name && state.name.match(/\.\*\*$/) && (state.url += "{remainder:any}");
            var parent = stateObject.parent, parsed = parseUrl(state.url), url = parsed ? $urlMatcherFactoryProvider.compile(parsed.val, {
                state: state
            }) : state.url;
            if (!url) return null;
            if (!$urlMatcherFactoryProvider.isMatcher(url)) throw new Error("Invalid url '" + url + "' in state '" + stateObject + "'");
            return parsed && parsed.root ? url : (parent && parent.navigable || root$$1()).url.append(url);
        };
    }, getNavigableBuilder = function(isRoot) {
        return function(state) {
            return !isRoot(state) && state.url ? state : state.parent ? state.parent.navigable : null;
        };
    }, getParamsBuilder = function(paramFactory) {
        return function(state) {
            var makeConfigParam = function(config, id) {
                return paramFactory.fromConfig(id, null, state.self);
            }, urlParams = state.url && state.url.parameters({
                inherit: !1
            }) || [], nonUrlParams = values(mapObj(omit(state.params || {}, urlParams.map(prop("id"))), makeConfigParam));
            return urlParams.concat(nonUrlParams).map(function(p) {
                return [ p.id, p ];
            }).reduce(applyPairs, {});
        };
    }, StateBuilder = function() {
        function StateBuilder(matcher, urlMatcherFactory) {
            function parentBuilder(state) {
                return isRoot(state) ? null : matcher.find(self.parentName(state)) || root$$1();
            }
            this.matcher = matcher;
            var self = this, root$$1 = function() {
                return matcher.find("");
            }, isRoot = function(state) {
                return "" === state.name;
            };
            this.builders = {
                name: [ nameBuilder ],
                self: [ selfBuilder ],
                parent: [ parentBuilder ],
                data: [ dataBuilder ],
                url: [ getUrlBuilder(urlMatcherFactory, root$$1) ],
                navigable: [ getNavigableBuilder(isRoot) ],
                params: [ getParamsBuilder(urlMatcherFactory.paramFactory) ],
                views: [],
                path: [ pathBuilder ],
                includes: [ includesBuilder ],
                resolvables: [ resolvablesBuilder ]
            };
        }
        return StateBuilder.prototype.builder = function(name, fn) {
            var builders = this.builders, array = builders[name] || [];
            return isString(name) && !isDefined(fn) ? array.length > 1 ? array : array[0] : isString(name) && isFunction(fn) ? (builders[name] = array, 
            builders[name].push(fn), function() {
                return builders[name].splice(builders[name].indexOf(fn, 1)) && null;
            }) : void 0;
        }, StateBuilder.prototype.build = function(state) {
            var _a = this, matcher = _a.matcher, builders = _a.builders, parent = this.parentName(state);
            if (parent && !matcher.find(parent, void 0, !1)) return null;
            for (var key in builders) if (builders.hasOwnProperty(key)) {
                var chain = builders[key].reduce(function(parentFn, step) {
                    return function(_state) {
                        return step(_state, parentFn);
                    };
                }, noop);
                state[key] = chain(state);
            }
            return state;
        }, StateBuilder.prototype.parentName = function(state) {
            var name = state.name || "", segments = name.split("."), lastSegment = segments.pop();
            if ("**" === lastSegment && segments.pop(), segments.length) {
                if (state.parent) throw new Error("States that specify the 'parent:' property should not have a '.' in their name (" + name + ")");
                return segments.join(".");
            }
            return state.parent ? isString(state.parent) ? state.parent : state.parent.name : "";
        }, StateBuilder.prototype.name = function(state) {
            var name = state.name;
            if (-1 !== name.indexOf(".") || !state.parent) return name;
            var parentName = isString(state.parent) ? state.parent : state.parent.name;
            return parentName ? parentName + "." + name : name;
        }, StateBuilder;
    }(), StateObject = function() {
        function StateObject(config) {
            return StateObject.create(config || {});
        }
        return StateObject.create = function(stateDecl) {
            stateDecl = StateObject.isStateClass(stateDecl) ? new stateDecl() : stateDecl;
            var state = inherit(inherit(stateDecl, StateObject.prototype));
            return stateDecl.$$state = function() {
                return state;
            }, state.self = stateDecl, state.__stateObjectCache = {
                nameGlob: Glob.fromString(state.name)
            }, state;
        }, StateObject.prototype.is = function(ref) {
            return this === ref || this.self === ref || this.fqn() === ref;
        }, StateObject.prototype.fqn = function() {
            if (!(this.parent && this.parent instanceof this.constructor)) return this.name;
            var name = this.parent.fqn();
            return name ? name + "." + this.name : this.name;
        }, StateObject.prototype.root = function() {
            return this.parent && this.parent.root() || this;
        }, StateObject.prototype.parameters = function(opts) {
            opts = defaults(opts, {
                inherit: !0,
                matchingKeys: null
            });
            var inherited = opts.inherit && this.parent && this.parent.parameters() || [];
            return inherited.concat(values(this.params)).filter(function(param) {
                return !opts.matchingKeys || opts.matchingKeys.hasOwnProperty(param.id);
            });
        }, StateObject.prototype.parameter = function(id, opts) {
            return void 0 === opts && (opts = {}), this.url && this.url.parameter(id, opts) || find(values(this.params), propEq("id", id)) || opts.inherit && this.parent && this.parent.parameter(id);
        }, StateObject.prototype.toString = function() {
            return this.fqn();
        }, StateObject.isStateClass = function(stateDecl) {
            return isFunction(stateDecl) && stateDecl.__uiRouterState === !0;
        }, StateObject.isState = function(obj) {
            return isObject(obj.__stateObjectCache);
        }, StateObject;
    }(), StateMatcher = function() {
        function StateMatcher(_states) {
            this._states = _states;
        }
        return StateMatcher.prototype.isRelative = function(stateName) {
            return stateName = stateName || "", 0 === stateName.indexOf(".") || 0 === stateName.indexOf("^");
        }, StateMatcher.prototype.find = function(stateOrName, base, matchGlob) {
            if (void 0 === matchGlob && (matchGlob = !0), !stateOrName && "" !== stateOrName) return void 0;
            var isStr = isString(stateOrName), name = isStr ? stateOrName : stateOrName.name;
            this.isRelative(name) && (name = this.resolvePath(name, base));
            var state = this._states[name];
            if (state && (isStr || !(isStr || state !== stateOrName && state.self !== stateOrName))) return state;
            if (isStr && matchGlob) {
                var _states = values(this._states), matches = _states.filter(function(_state) {
                    return _state.__stateObjectCache.nameGlob && _state.__stateObjectCache.nameGlob.matches(name);
                });
                return matches.length > 1 && console.log("stateMatcher.find: Found multiple matches for " + name + " using glob: ", matches.map(function(match) {
                    return match.name;
                })), matches[0];
            }
            return void 0;
        }, StateMatcher.prototype.resolvePath = function(name, base) {
            if (!base) throw new Error("No reference point given for path '" + name + "'");
            for (var baseState = this.find(base), splitName = name.split("."), pathLength = splitName.length, i = 0, current = baseState; pathLength > i; i++) if ("" !== splitName[i] || 0 !== i) {
                if ("^" !== splitName[i]) break;
                if (!current.parent) throw new Error("Path '" + name + "' not valid for state '" + baseState.name + "'");
                current = current.parent;
            } else current = baseState;
            var relName = splitName.slice(i).join(".");
            return current.name + (current.name && relName ? "." : "") + relName;
        }, StateMatcher;
    }(), StateQueueManager = function() {
        function StateQueueManager(router, states, builder, listeners) {
            this.router = router, this.states = states, this.builder = builder, this.listeners = listeners, 
            this.queue = [];
        }
        return StateQueueManager.prototype.dispose = function() {
            this.queue = [];
        }, StateQueueManager.prototype.register = function(stateDecl) {
            var queue = this.queue, state = StateObject.create(stateDecl), name = state.name;
            if (!isString(name)) throw new Error("State must have a valid name");
            if (this.states.hasOwnProperty(name) || inArray(queue.map(prop("name")), name)) throw new Error("State '" + name + "' is already defined");
            return queue.push(state), this.flush(), state;
        }, StateQueueManager.prototype.flush = function() {
            for (var _this = this, _a = this, queue = _a.queue, states = _a.states, builder = _a.builder, registered = [], orphans = [], previousQueueLength = {}, getState = function(name) {
                return _this.states.hasOwnProperty(name) && _this.states[name];
            }, notifyListeners = function() {
                registered.length && _this.listeners.forEach(function(listener) {
                    return listener("registered", registered.map(function(s) {
                        return s.self;
                    }));
                });
            }; queue.length > 0; ) {
                var state = queue.shift(), name_1 = state.name, result = builder.build(state), orphanIdx = orphans.indexOf(state);
                if (result) {
                    var existingState = getState(name_1);
                    if (existingState && existingState.name === name_1) throw new Error("State '" + name_1 + "' is already defined");
                    var existingFutureState = getState(name_1 + ".**");
                    existingFutureState && this.router.stateRegistry.deregister(existingFutureState), 
                    states[name_1] = state, this.attachRoute(state), orphanIdx >= 0 && orphans.splice(orphanIdx, 1), 
                    registered.push(state);
                } else {
                    var prev = previousQueueLength[name_1];
                    if (previousQueueLength[name_1] = queue.length, orphanIdx >= 0 && prev === queue.length) return queue.push(state), 
                    notifyListeners(), states;
                    0 > orphanIdx && orphans.push(state), queue.push(state);
                }
            }
            return notifyListeners(), states;
        }, StateQueueManager.prototype.attachRoute = function(state) {
            if (!state.abstract && state.url) {
                var rulesApi = this.router.urlService.rules;
                rulesApi.rule(rulesApi.urlRuleFactory.create(state));
            }
        }, StateQueueManager;
    }(), StateRegistry = function() {
        function StateRegistry(router) {
            this.router = router, this.states = {}, this.listeners = [], this.matcher = new StateMatcher(this.states), 
            this.builder = new StateBuilder(this.matcher, router.urlMatcherFactory), this.stateQueue = new StateQueueManager(router, this.states, this.builder, this.listeners), 
            this._registerRoot();
        }
        return StateRegistry.prototype._registerRoot = function() {
            var rootStateDef = {
                name: "",
                url: "^",
                views: null,
                params: {
                    "#": {
                        value: null,
                        type: "hash",
                        dynamic: !0
                    }
                },
                "abstract": !0
            }, _root = this._root = this.stateQueue.register(rootStateDef);
            _root.navigable = null;
        }, StateRegistry.prototype.dispose = function() {
            var _this = this;
            this.stateQueue.dispose(), this.listeners = [], this.get().forEach(function(state) {
                return _this.get(state) && _this.deregister(state);
            });
        }, StateRegistry.prototype.onStatesChanged = function(listener) {
            return this.listeners.push(listener), function() {
                removeFrom(this.listeners)(listener);
            }.bind(this);
        }, StateRegistry.prototype.root = function() {
            return this._root;
        }, StateRegistry.prototype.register = function(stateDefinition) {
            return this.stateQueue.register(stateDefinition);
        }, StateRegistry.prototype._deregisterTree = function(state) {
            var _this = this, all$$1 = this.get().map(function(s) {
                return s.$$state();
            }), getChildren = function(states) {
                var _children = all$$1.filter(function(s) {
                    return -1 !== states.indexOf(s.parent);
                });
                return 0 === _children.length ? _children : _children.concat(getChildren(_children));
            }, children = getChildren([ state ]), deregistered = [ state ].concat(children).reverse();
            return deregistered.forEach(function(_state) {
                var rulesApi = _this.router.urlService.rules;
                rulesApi.rules().filter(propEq("state", _state)).forEach(function(rule) {
                    return rulesApi.removeRule(rule);
                }), delete _this.states[_state.name];
            }), deregistered;
        }, StateRegistry.prototype.deregister = function(stateOrName) {
            var _state = this.get(stateOrName);
            if (!_state) throw new Error("Can't deregister state; not found: " + stateOrName);
            var deregisteredStates = this._deregisterTree(_state.$$state());
            return this.listeners.forEach(function(listener) {
                return listener("deregistered", deregisteredStates.map(function(s) {
                    return s.self;
                }));
            }), deregisteredStates;
        }, StateRegistry.prototype.get = function(stateOrName, base) {
            var _this = this;
            if (0 === arguments.length) return Object.keys(this.states).map(function(name) {
                return _this.states[name].self;
            });
            var found = this.matcher.find(stateOrName, base);
            return found && found.self || null;
        }, StateRegistry.prototype.decorator = function(name, func) {
            return this.builder.builder(name, func);
        }, StateRegistry;
    }();
    !function(TransitionHookPhase) {
        TransitionHookPhase[TransitionHookPhase.CREATE = 0] = "CREATE", TransitionHookPhase[TransitionHookPhase.BEFORE = 1] = "BEFORE", 
        TransitionHookPhase[TransitionHookPhase.RUN = 2] = "RUN", TransitionHookPhase[TransitionHookPhase.SUCCESS = 3] = "SUCCESS", 
        TransitionHookPhase[TransitionHookPhase.ERROR = 4] = "ERROR";
    }(exports.TransitionHookPhase || (exports.TransitionHookPhase = {})), function(TransitionHookScope) {
        TransitionHookScope[TransitionHookScope.TRANSITION = 0] = "TRANSITION", TransitionHookScope[TransitionHookScope.STATE = 1] = "STATE";
    }(exports.TransitionHookScope || (exports.TransitionHookScope = {}));
    var defaultRuleSortFn, defaultOptions = {
        current: noop,
        transition: null,
        traceData: {},
        bind: null
    }, TransitionHook = function() {
        function TransitionHook(transition, stateContext, registeredHook, options) {
            var _this = this;
            this.transition = transition, this.stateContext = stateContext, this.registeredHook = registeredHook, 
            this.options = options, this.isSuperseded = function() {
                return _this.type.hookPhase === exports.TransitionHookPhase.RUN && !_this.options.transition.isActive();
            }, this.options = defaults(options, defaultOptions), this.type = registeredHook.eventType;
        }
        return TransitionHook.chain = function(hooks, waitFor) {
            var createHookChainR = function(prev, nextHook) {
                return prev.then(function() {
                    return nextHook.invokeHook();
                });
            };
            return hooks.reduce(createHookChainR, waitFor || services.$q.when());
        }, TransitionHook.invokeHooks = function(hooks, doneCallback) {
            for (var idx = 0; idx < hooks.length; idx++) {
                var hookResult = hooks[idx].invokeHook();
                if (isPromise(hookResult)) {
                    var remainingHooks = hooks.slice(idx + 1);
                    return TransitionHook.chain(remainingHooks, hookResult).then(doneCallback);
                }
            }
            return doneCallback();
        }, TransitionHook.runAllHooks = function(hooks) {
            hooks.forEach(function(hook) {
                return hook.invokeHook();
            });
        }, TransitionHook.prototype.logError = function(err) {
            this.transition.router.stateService.defaultErrorHandler()(err);
        }, TransitionHook.prototype.invokeHook = function() {
            var _this = this, hook = this.registeredHook;
            if (!hook._deregistered) {
                var notCurrent = this.getNotCurrentRejection();
                if (notCurrent) return notCurrent;
                var options = this.options;
                trace.traceHookInvocation(this, this.transition, options);
                var invokeCallback = function() {
                    return hook.callback.call(options.bind, _this.transition, _this.stateContext);
                }, normalizeErr = function(err) {
                    return Rejection.normalize(err).toPromise();
                }, handleError = function(err) {
                    return hook.eventType.getErrorHandler(_this)(err);
                }, handleResult = function(result) {
                    return hook.eventType.getResultHandler(_this)(result);
                };
                try {
                    var result = invokeCallback();
                    return !this.type.synchronous && isPromise(result) ? result.catch(normalizeErr).then(handleResult, handleError) : handleResult(result);
                } catch (err) {
                    return handleError(Rejection.normalize(err));
                } finally {
                    hook.invokeLimit && ++hook.invokeCount >= hook.invokeLimit && hook.deregister();
                }
            }
        }, TransitionHook.prototype.handleHookResult = function(result) {
            var _this = this, notCurrent = this.getNotCurrentRejection();
            if (notCurrent) return notCurrent;
            if (isPromise(result)) return result.then(function(val$$1) {
                return _this.handleHookResult(val$$1);
            });
            if (trace.traceHookResult(result, this.transition, this.options), result === !1) return Rejection.aborted("Hook aborted transition").toPromise();
            var isTargetState = is(TargetState);
            return isTargetState(result) ? Rejection.redirected(result).toPromise() : void 0;
        }, TransitionHook.prototype.getNotCurrentRejection = function() {
            var router = this.transition.router;
            return router._disposed ? Rejection.aborted("UIRouter instance #" + router.$id + " has been stopped (disposed)").toPromise() : this.transition._aborted ? Rejection.aborted().toPromise() : this.isSuperseded() ? Rejection.superseded(this.options.current()).toPromise() : void 0;
        }, TransitionHook.prototype.toString = function() {
            var _a = this, options = _a.options, registeredHook = _a.registeredHook, event = parse("traceData.hookType")(options) || "internal", context = parse("traceData.context.state.name")(options) || parse("traceData.context")(options) || "unknown", name = fnToString(registeredHook.callback);
            return event + " context: " + context + ", " + maxLength(200, name);
        }, TransitionHook.HANDLE_RESULT = function(hook) {
            return function(result) {
                return hook.handleHookResult(result);
            };
        }, TransitionHook.LOG_REJECTED_RESULT = function(hook) {
            return function(result) {
                return void (isPromise(result) && result.catch(function(err) {
                    return hook.logError(Rejection.normalize(err));
                }));
            };
        }, TransitionHook.LOG_ERROR = function(hook) {
            return function(error) {
                return hook.logError(error);
            };
        }, TransitionHook.REJECT_ERROR = function() {
            return function(error) {
                return silentRejection(error);
            };
        }, TransitionHook.THROW_ERROR = function() {
            return function(error) {
                throw error;
            };
        }, TransitionHook;
    }(), RegisteredHook = function() {
        function RegisteredHook(tranSvc, eventType, callback, matchCriteria, removeHookFromRegistry, options) {
            void 0 === options && (options = {}), this.tranSvc = tranSvc, this.eventType = eventType, 
            this.callback = callback, this.matchCriteria = matchCriteria, this.removeHookFromRegistry = removeHookFromRegistry, 
            this.invokeCount = 0, this._deregistered = !1, this.priority = options.priority || 0, 
            this.bind = options.bind || null, this.invokeLimit = options.invokeLimit;
        }
        return RegisteredHook.prototype._matchingNodes = function(nodes, criterion) {
            if (criterion === !0) return nodes;
            var matching = nodes.filter(function(node) {
                return matchState(node.state, criterion);
            });
            return matching.length ? matching : null;
        }, RegisteredHook.prototype._getDefaultMatchCriteria = function() {
            return mapObj(this.tranSvc._pluginapi._getPathTypes(), function() {
                return !0;
            });
        }, RegisteredHook.prototype._getMatchingNodes = function(treeChanges) {
            var _this = this, criteria = extend(this._getDefaultMatchCriteria(), this.matchCriteria), paths = values(this.tranSvc._pluginapi._getPathTypes());
            return paths.reduce(function(mn, pathtype) {
                var isStateHook = pathtype.scope === exports.TransitionHookScope.STATE, path = treeChanges[pathtype.name] || [], nodes = isStateHook ? path : [ tail(path) ];
                return mn[pathtype.name] = _this._matchingNodes(nodes, criteria[pathtype.name]), 
                mn;
            }, {});
        }, RegisteredHook.prototype.matches = function(treeChanges) {
            var matches = this._getMatchingNodes(treeChanges), allMatched = values(matches).every(identity);
            return allMatched ? matches : null;
        }, RegisteredHook.prototype.deregister = function() {
            this.removeHookFromRegistry(this), this._deregistered = !0;
        }, RegisteredHook;
    }(), HookBuilder = function() {
        function HookBuilder(transition) {
            this.transition = transition;
        }
        return HookBuilder.prototype.buildHooksForPhase = function(phase) {
            var _this = this, $transitions = this.transition.router.transitionService;
            return $transitions._pluginapi._getEvents(phase).map(function(type) {
                return _this.buildHooks(type);
            }).reduce(unnestR, []).filter(identity);
        }, HookBuilder.prototype.buildHooks = function(hookType) {
            var transition = this.transition, treeChanges = transition.treeChanges(), matchingHooks = this.getMatchingHooks(hookType, treeChanges);
            if (!matchingHooks) return [];
            var baseHookOptions = {
                transition: transition,
                current: transition.options().current
            }, makeTransitionHooks = function(hook) {
                var matches = hook.matches(treeChanges), matchingNodes = matches[hookType.criteriaMatchPath.name];
                return matchingNodes.map(function(node) {
                    var _options = extend({
                        bind: hook.bind,
                        traceData: {
                            hookType: hookType.name,
                            context: node
                        }
                    }, baseHookOptions), state = hookType.criteriaMatchPath.scope === exports.TransitionHookScope.STATE ? node.state.self : null, transitionHook = new TransitionHook(transition, state, hook, _options);
                    return {
                        hook: hook,
                        node: node,
                        transitionHook: transitionHook
                    };
                });
            };
            return matchingHooks.map(makeTransitionHooks).reduce(unnestR, []).sort(tupleSort(hookType.reverseSort)).map(function(tuple) {
                return tuple.transitionHook;
            });
        }, HookBuilder.prototype.getMatchingHooks = function(hookType, treeChanges) {
            var isCreate = hookType.hookPhase === exports.TransitionHookPhase.CREATE, $transitions = this.transition.router.transitionService, registries = isCreate ? [ $transitions ] : [ this.transition, $transitions ];
            return registries.map(function(reg) {
                return reg.getHooks(hookType.name);
            }).filter(assertPredicate(isArray, "broken event named: " + hookType.name)).reduce(unnestR, []).filter(function(hook) {
                return hook.matches(treeChanges);
            });
        }, HookBuilder;
    }(), stateSelf = prop("self"), Transition = function() {
        function Transition(fromPath, targetState, router) {
            var _this = this;
            if (this._deferred = services.$q.defer(), this.promise = this._deferred.promise, 
            this._registeredHooks = {}, this._hookBuilder = new HookBuilder(this), this.isActive = function() {
                return _this.router.globals.transition === _this;
            }, this.router = router, this._targetState = targetState, !targetState.valid()) throw new Error(targetState.error());
            this._options = extend({
                current: val(this)
            }, targetState.options()), this.$id = router.transitionService._transitionCount++;
            var toPath = PathUtils.buildToPath(fromPath, targetState);
            this._treeChanges = PathUtils.treeChanges(fromPath, toPath, this._options.reloadState), 
            this.createTransitionHookRegFns();
            var onCreateHooks = this._hookBuilder.buildHooksForPhase(exports.TransitionHookPhase.CREATE);
            TransitionHook.invokeHooks(onCreateHooks, function() {
                return null;
            }), this.applyViewConfigs(router);
        }
        return Transition.prototype.onBefore = function() {}, Transition.prototype.onStart = function() {}, 
        Transition.prototype.onExit = function() {}, Transition.prototype.onRetain = function() {}, 
        Transition.prototype.onEnter = function() {}, Transition.prototype.onFinish = function() {}, 
        Transition.prototype.onSuccess = function() {}, Transition.prototype.onError = function() {}, 
        Transition.prototype.createTransitionHookRegFns = function() {
            var _this = this;
            this.router.transitionService._pluginapi._getEvents().filter(function(type) {
                return type.hookPhase !== exports.TransitionHookPhase.CREATE;
            }).forEach(function(type) {
                return makeEvent(_this, _this.router.transitionService, type);
            });
        }, Transition.prototype.getHooks = function(hookName) {
            return this._registeredHooks[hookName];
        }, Transition.prototype.applyViewConfigs = function(router) {
            var enteringStates = this._treeChanges.entering.map(function(node) {
                return node.state;
            });
            PathUtils.applyViewConfigs(router.transitionService.$view, this._treeChanges.to, enteringStates);
        }, Transition.prototype.$from = function() {
            return tail(this._treeChanges.from).state;
        }, Transition.prototype.$to = function() {
            return tail(this._treeChanges.to).state;
        }, Transition.prototype.from = function() {
            return this.$from().self;
        }, Transition.prototype.to = function() {
            return this.$to().self;
        }, Transition.prototype.targetState = function() {
            return this._targetState;
        }, Transition.prototype.is = function(compare) {
            return compare instanceof Transition ? this.is({
                to: compare.$to().name,
                from: compare.$from().name
            }) : !(compare.to && !matchState(this.$to(), compare.to) || compare.from && !matchState(this.$from(), compare.from));
        }, Transition.prototype.params = function(pathname) {
            return void 0 === pathname && (pathname = "to"), Object.freeze(this._treeChanges[pathname].map(prop("paramValues")).reduce(mergeR, {}));
        }, Transition.prototype.paramsChanged = function() {
            var fromParams = this.params("from"), toParams = this.params("to"), allParamDescriptors = [].concat(this._treeChanges.to).concat(this._treeChanges.from).map(function(pathNode) {
                return pathNode.paramSchema;
            }).reduce(flattenR, []).reduce(uniqR, []), changedParamDescriptors = Param.changed(allParamDescriptors, fromParams, toParams);
            return changedParamDescriptors.reduce(function(changedValues, descriptor) {
                return changedValues[descriptor.id] = toParams[descriptor.id], changedValues;
            }, {});
        }, Transition.prototype.injector = function(state, pathName) {
            void 0 === pathName && (pathName = "to");
            var path = this._treeChanges[pathName];
            return state && (path = PathUtils.subPath(path, function(node) {
                return node.state === state || node.state.name === state;
            })), new ResolveContext(path).injector();
        }, Transition.prototype.getResolveTokens = function(pathname) {
            return void 0 === pathname && (pathname = "to"), new ResolveContext(this._treeChanges[pathname]).getTokens();
        }, Transition.prototype.addResolvable = function(resolvable, state) {
            void 0 === state && (state = ""), resolvable = is(Resolvable)(resolvable) ? resolvable : new Resolvable(resolvable);
            var stateName = "string" == typeof state ? state : state.name, topath = this._treeChanges.to, targetNode = find(topath, function(node) {
                return node.state.name === stateName;
            }), resolveContext = new ResolveContext(topath);
            resolveContext.addResolvables([ resolvable ], targetNode.state);
        }, Transition.prototype.redirectedFrom = function() {
            return this._options.redirectedFrom || null;
        }, Transition.prototype.originalTransition = function() {
            var rf = this.redirectedFrom();
            return rf && rf.originalTransition() || this;
        }, Transition.prototype.options = function() {
            return this._options;
        }, Transition.prototype.entering = function() {
            return map(this._treeChanges.entering, prop("state")).map(stateSelf);
        }, Transition.prototype.exiting = function() {
            return map(this._treeChanges.exiting, prop("state")).map(stateSelf).reverse();
        }, Transition.prototype.retained = function() {
            return map(this._treeChanges.retained, prop("state")).map(stateSelf);
        }, Transition.prototype.views = function(pathname, state) {
            void 0 === pathname && (pathname = "entering");
            var path = this._treeChanges[pathname];
            return path = state ? path.filter(propEq("state", state)) : path, path.map(prop("views")).filter(identity).reduce(unnestR, []);
        }, Transition.prototype.treeChanges = function(pathname) {
            return pathname ? this._treeChanges[pathname] : this._treeChanges;
        }, Transition.prototype.redirect = function(targetState) {
            for (var redirects = 1, trans = this; null != (trans = trans.redirectedFrom()); ) if (++redirects > 20) throw new Error("Too many consecutive Transition redirects (20+)");
            var redirectOpts = {
                redirectedFrom: this,
                source: "redirect"
            };
            "url" === this.options().source && targetState.options().location !== !1 && (redirectOpts.location = "replace");
            var newOptions = extend({}, this.options(), targetState.options(), redirectOpts);
            targetState = targetState.withOptions(newOptions, !0);
            var newTransition = this.router.transitionService.create(this._treeChanges.from, targetState), originalEnteringNodes = this._treeChanges.entering, redirectEnteringNodes = newTransition._treeChanges.entering, nodeIsReloading = function(reloadState) {
                return function(node) {
                    return reloadState && node.state.includes[reloadState.name];
                };
            }, matchingEnteringNodes = PathUtils.matching(redirectEnteringNodes, originalEnteringNodes, PathUtils.nonDynamicParams).filter(not(nodeIsReloading(targetState.options().reloadState)));
            return matchingEnteringNodes.forEach(function(node, idx) {
                node.resolvables = originalEnteringNodes[idx].resolvables;
            }), newTransition;
        }, Transition.prototype._changedParams = function() {
            var tc = this._treeChanges;
            if (this._options.reload) return void 0;
            if (tc.exiting.length || tc.entering.length) return void 0;
            if (tc.to.length !== tc.from.length) return void 0;
            var pathsDiffer = arrayTuples(tc.to, tc.from).map(function(tuple) {
                return tuple[0].state !== tuple[1].state;
            }).reduce(anyTrueR, !1);
            if (pathsDiffer) return void 0;
            var nodeSchemas = tc.to.map(function(node) {
                return node.paramSchema;
            }), _a = [ tc.to, tc.from ].map(function(path) {
                return path.map(function(x) {
                    return x.paramValues;
                });
            }), toValues = _a[0], fromValues = _a[1], tuples = arrayTuples(nodeSchemas, toValues, fromValues);
            return tuples.map(function(_a) {
                var schema = _a[0], toVals = _a[1], fromVals = _a[2];
                return Param.changed(schema, toVals, fromVals);
            }).reduce(unnestR, []);
        }, Transition.prototype.dynamic = function() {
            var changes = this._changedParams();
            return changes ? changes.map(function(x) {
                return x.dynamic;
            }).reduce(anyTrueR, !1) : !1;
        }, Transition.prototype.ignored = function() {
            return !!this._ignoredReason();
        }, Transition.prototype._ignoredReason = function() {
            var pending = this.router.globals.transition, reloadState = this._options.reloadState, same = function(pathA, pathB) {
                if (pathA.length !== pathB.length) return !1;
                var matching = PathUtils.matching(pathA, pathB);
                return pathA.length === matching.filter(function(node) {
                    return !reloadState || !node.state.includes[reloadState.name];
                }).length;
            }, newTC = this.treeChanges(), pendTC = pending && pending.treeChanges();
            return pendTC && same(pendTC.to, newTC.to) && same(pendTC.exiting, newTC.exiting) ? "SameAsPending" : 0 === newTC.exiting.length && 0 === newTC.entering.length && same(newTC.from, newTC.to) ? "SameAsCurrent" : void 0;
        }, Transition.prototype.run = function() {
            var _this = this, runAllHooks = TransitionHook.runAllHooks, getHooksFor = function(phase) {
                return _this._hookBuilder.buildHooksForPhase(phase);
            }, transitionSuccess = function() {
                trace.traceSuccess(_this.$to(), _this), _this.success = !0, _this._deferred.resolve(_this.to()), 
                runAllHooks(getHooksFor(exports.TransitionHookPhase.SUCCESS));
            }, transitionError = function(reason) {
                trace.traceError(reason, _this), _this.success = !1, _this._deferred.reject(reason), 
                _this._error = reason, runAllHooks(getHooksFor(exports.TransitionHookPhase.ERROR));
            }, runTransition = function() {
                var allRunHooks = getHooksFor(exports.TransitionHookPhase.RUN), done = function() {
                    return services.$q.when(void 0);
                };
                return TransitionHook.invokeHooks(allRunHooks, done);
            }, startTransition = function() {
                var globals = _this.router.globals;
                return globals.lastStartedTransitionId = _this.$id, globals.transition = _this, 
                globals.transitionHistory.enqueue(_this), trace.traceTransitionStart(_this), services.$q.when(void 0);
            }, allBeforeHooks = getHooksFor(exports.TransitionHookPhase.BEFORE);
            return TransitionHook.invokeHooks(allBeforeHooks, startTransition).then(runTransition).then(transitionSuccess, transitionError), 
            this.promise;
        }, Transition.prototype.valid = function() {
            return !this.error() || void 0 !== this.success;
        }, Transition.prototype.abort = function() {
            isUndefined(this.success) && (this._aborted = !0);
        }, Transition.prototype.error = function() {
            var state = this.$to();
            if (state.self.abstract) return Rejection.invalid("Cannot transition to abstract state '" + state.name + "'");
            var paramDefs = state.parameters(), values$$1 = this.params(), invalidParams = paramDefs.filter(function(param) {
                return !param.validates(values$$1[param.id]);
            });
            if (invalidParams.length) {
                var invalidValues = invalidParams.map(function(param) {
                    return "[" + param.id + ":" + stringify(values$$1[param.id]) + "]";
                }).join(", "), detail = "The following parameter values are not valid for state '" + state.name + "': " + invalidValues;
                return Rejection.invalid(detail);
            }
            return this.success === !1 ? this._error : void 0;
        }, Transition.prototype.toString = function() {
            var fromStateOrName = this.from(), toStateOrName = this.to(), avoidEmptyHash = function(params) {
                return null !== params["#"] && void 0 !== params["#"] ? params : omit(params, [ "#" ]);
            }, id = this.$id, from = isObject(fromStateOrName) ? fromStateOrName.name : fromStateOrName, fromParams = stringify(avoidEmptyHash(this._treeChanges.from.map(prop("paramValues")).reduce(mergeR, {}))), toValid = this.valid() ? "" : "(X) ", to = isObject(toStateOrName) ? toStateOrName.name : toStateOrName, toParams = stringify(avoidEmptyHash(this.params()));
            return "Transition#" + id + "( '" + from + "'" + fromParams + " -> " + toValid + "'" + to + "'" + toParams + " )";
        }, Transition.diToken = Transition, Transition;
    }(), memoizeTo = function(obj, _prop, fn) {
        return obj[_prop] = obj[_prop] || fn();
    }, splitOnSlash = splitOnDelim("/"), defaultConfig = {
        state: {
            params: {}
        },
        strict: !0,
        caseInsensitive: !0
    }, UrlMatcher = function() {
        function UrlMatcher(pattern$$1, paramTypes, paramFactory, config) {
            var _this = this;
            this._cache = {
                path: [ this ]
            }, this._children = [], this._params = [], this._segments = [], this._compiled = [], 
            this.config = config = defaults(config, defaultConfig), this.pattern = pattern$$1;
            for (var matchArray, details, segment, placeholder = /([:*])([\w\[\]]+)|\{([\w\[\]]+)(?:\:\s*((?:[^{}\\]+|\\.|\{(?:[^{}\\]+|\\.)*\})+))?\}/g, searchPlaceholder = /([:]?)([\w\[\].-]+)|\{([\w\[\].-]+)(?:\:\s*((?:[^{}\\]+|\\.|\{(?:[^{}\\]+|\\.)*\})+))?\}/g, patterns = [], last = 0, checkParamErrors = function(id) {
                if (!UrlMatcher.nameValidator.test(id)) throw new Error("Invalid parameter name '" + id + "' in pattern '" + pattern$$1 + "'");
                if (find(_this._params, propEq("id", id))) throw new Error("Duplicate parameter name '" + id + "' in pattern '" + pattern$$1 + "'");
            }, matchDetails = function(m, isSearch) {
                var id = m[2] || m[3], regexp = isSearch ? m[4] : m[4] || ("*" === m[1] ? "[\\s\\S]*" : null), makeRegexpType = function(str) {
                    return inherit(paramTypes.type(isSearch ? "query" : "path"), {
                        pattern: new RegExp(str, _this.config.caseInsensitive ? "i" : void 0)
                    });
                };
                return {
                    id: id,
                    regexp: regexp,
                    segment: pattern$$1.substring(last, m.index),
                    type: regexp ? paramTypes.type(regexp) || makeRegexpType(regexp) : null
                };
            }; (matchArray = placeholder.exec(pattern$$1)) && (details = matchDetails(matchArray, !1), 
            !(details.segment.indexOf("?") >= 0)); ) checkParamErrors(details.id), this._params.push(paramFactory.fromPath(details.id, details.type, config.state)), 
            this._segments.push(details.segment), patterns.push([ details.segment, tail(this._params) ]), 
            last = placeholder.lastIndex;
            segment = pattern$$1.substring(last);
            var i = segment.indexOf("?");
            if (i >= 0) {
                var search = segment.substring(i);
                if (segment = segment.substring(0, i), search.length > 0) for (last = 0; matchArray = searchPlaceholder.exec(search); ) details = matchDetails(matchArray, !0), 
                checkParamErrors(details.id), this._params.push(paramFactory.fromSearch(details.id, details.type, config.state)), 
                last = placeholder.lastIndex;
            }
            this._segments.push(segment), this._compiled = patterns.map(function(_pattern) {
                return quoteRegExp.apply(null, _pattern);
            }).concat(quoteRegExp(segment));
        }
        return UrlMatcher.encodeDashes = function(str) {
            return encodeURIComponent(str).replace(/-/g, function(c) {
                return "%5C%" + c.charCodeAt(0).toString(16).toUpperCase();
            });
        }, UrlMatcher.pathSegmentsAndParams = function(matcher) {
            var staticSegments = matcher._segments, pathParams = matcher._params.filter(function(p) {
                return p.location === exports.DefType.PATH;
            });
            return arrayTuples(staticSegments, pathParams.concat(void 0)).reduce(unnestR, []).filter(function(x) {
                return "" !== x && isDefined(x);
            });
        }, UrlMatcher.queryParams = function(matcher) {
            return matcher._params.filter(function(p) {
                return p.location === exports.DefType.SEARCH;
            });
        }, UrlMatcher.compare = function(a, b) {
            var segments = function(matcher) {
                return matcher._cache.segments = matcher._cache.segments || matcher._cache.path.map(UrlMatcher.pathSegmentsAndParams).reduce(unnestR, []).reduce(joinNeighborsR, []).map(function(x) {
                    return isString(x) ? splitOnSlash(x) : x;
                }).reduce(unnestR, []);
            }, weights = function(matcher) {
                return matcher._cache.weights = matcher._cache.weights || segments(matcher).map(function(segment) {
                    return "/" === segment ? 1 : isString(segment) ? 2 : segment instanceof Param ? 3 : void 0;
                });
            }, padArrays = function(l, r, padVal) {
                for (var len = Math.max(l.length, r.length); l.length < len; ) l.push(padVal);
                for (;r.length < len; ) r.push(padVal);
            }, weightsA = weights(a), weightsB = weights(b);
            padArrays(weightsA, weightsB, 0);
            var cmp, i, _pairs = arrayTuples(weightsA, weightsB);
            for (i = 0; i < _pairs.length; i++) if (cmp = _pairs[i][0] - _pairs[i][1], 0 !== cmp) return cmp;
            return 0;
        }, UrlMatcher.prototype.append = function(url) {
            return this._children.push(url), url._cache = {
                path: this._cache.path.concat(url),
                parent: this,
                pattern: null
            }, url;
        }, UrlMatcher.prototype.isRoot = function() {
            return this._cache.path[0] === this;
        }, UrlMatcher.prototype.toString = function() {
            return this.pattern;
        }, UrlMatcher.prototype.exec = function(path, search, hash, options) {
            function decodePathArray(paramVal) {
                var reverseString = function(str) {
                    return str.split("").reverse().join("");
                }, unquoteDashes = function(str) {
                    return str.replace(/\\-/g, "-");
                }, split = reverseString(paramVal).split(/-(?!\\)/), allReversed = map(split, reverseString);
                return map(allReversed, unquoteDashes).reverse();
            }
            var _this = this;
            void 0 === search && (search = {}), void 0 === options && (options = {});
            var match = memoizeTo(this._cache, "pattern", function() {
                return new RegExp([ "^", unnest(_this._cache.path.map(prop("_compiled"))).join(""), _this.config.strict === !1 ? "/?" : "", "$" ].join(""), _this.config.caseInsensitive ? "i" : void 0);
            }).exec(path);
            if (!match) return null;
            var allParams = this.parameters(), pathParams = allParams.filter(function(param) {
                return !param.isSearch();
            }), searchParams = allParams.filter(function(param) {
                return param.isSearch();
            }), nPathSegments = this._cache.path.map(function(urlm) {
                return urlm._segments.length - 1;
            }).reduce(function(a, x) {
                return a + x;
            }), values$$1 = {};
            if (nPathSegments !== match.length - 1) throw new Error("Unbalanced capture group in route '" + this.pattern + "'");
            for (var i = 0; nPathSegments > i; i++) {
                for (var param = pathParams[i], value = match[i + 1], j = 0; j < param.replace.length; j++) param.replace[j].from === value && (value = param.replace[j].to);
                value && param.array === !0 && (value = decodePathArray(value)), isDefined(value) && (value = param.type.decode(value)), 
                values$$1[param.id] = param.value(value);
            }
            return searchParams.forEach(function(param) {
                for (var value = search[param.id], j = 0; j < param.replace.length; j++) param.replace[j].from === value && (value = param.replace[j].to);
                isDefined(value) && (value = param.type.decode(value)), values$$1[param.id] = param.value(value);
            }), hash && (values$$1["#"] = hash), values$$1;
        }, UrlMatcher.prototype.parameters = function(opts) {
            return void 0 === opts && (opts = {}), opts.inherit === !1 ? this._params : unnest(this._cache.path.map(function(matcher) {
                return matcher._params;
            }));
        }, UrlMatcher.prototype.parameter = function(id, opts) {
            var _this = this;
            void 0 === opts && (opts = {});
            var findParam = function() {
                for (var _i = 0, _a = _this._params; _i < _a.length; _i++) {
                    var param = _a[_i];
                    if (param.id === id) return param;
                }
            }, parent = this._cache.parent;
            return findParam() || opts.inherit !== !1 && parent && parent.parameter(id, opts) || null;
        }, UrlMatcher.prototype.validates = function(params) {
            var validParamVal = function(param, val$$1) {
                return !param || param.validates(val$$1);
            };
            params = params || {};
            var paramSchema = this.parameters().filter(function(paramDef) {
                return params.hasOwnProperty(paramDef.id);
            });
            return paramSchema.map(function(paramDef) {
                return validParamVal(paramDef, params[paramDef.id]);
            }).reduce(allTrueR, !0);
        }, UrlMatcher.prototype.format = function(values$$1) {
            function getDetails(param) {
                var value = param.value(values$$1[param.id]), isValid = param.validates(value), isDefaultValue = param.isDefaultValue(value), squash = isDefaultValue ? param.squash : !1, encoded = param.type.encode(value);
                return {
                    param: param,
                    value: value,
                    isValid: isValid,
                    isDefaultValue: isDefaultValue,
                    squash: squash,
                    encoded: encoded
                };
            }
            void 0 === values$$1 && (values$$1 = {});
            var urlMatchers = this._cache.path, pathSegmentsAndParams = urlMatchers.map(UrlMatcher.pathSegmentsAndParams).reduce(unnestR, []).map(function(x) {
                return isString(x) ? x : getDetails(x);
            }), queryParams = urlMatchers.map(UrlMatcher.queryParams).reduce(unnestR, []).map(getDetails), isInvalid = function(param) {
                return param.isValid === !1;
            };
            if (pathSegmentsAndParams.concat(queryParams).filter(isInvalid).length) return null;
            var pathString = pathSegmentsAndParams.reduce(function(acc, x) {
                if (isString(x)) return acc + x;
                var squash = x.squash, encoded = x.encoded, param = x.param;
                return squash === !0 ? acc.match(/\/$/) ? acc.slice(0, -1) : acc : isString(squash) ? acc + squash : squash !== !1 ? acc : null == encoded ? acc : isArray(encoded) ? acc + map(encoded, UrlMatcher.encodeDashes).join("-") : param.raw ? acc + encoded : acc + encodeURIComponent(encoded);
            }, ""), queryString = queryParams.map(function(paramDetails) {
                var param = paramDetails.param, squash = paramDetails.squash, encoded = paramDetails.encoded, isDefaultValue = paramDetails.isDefaultValue;
                if (!(null == encoded || isDefaultValue && squash !== !1) && (isArray(encoded) || (encoded = [ encoded ]), 
                0 !== encoded.length)) return param.raw || (encoded = map(encoded, encodeURIComponent)), 
                encoded.map(function(val$$1) {
                    return param.id + "=" + val$$1;
                });
            }).filter(identity).reduce(unnestR, []).join("&");
            return pathString + (queryString ? "?" + queryString : "") + (values$$1["#"] ? "#" + values$$1["#"] : "");
        }, UrlMatcher.nameValidator = /^\w+([-.]+\w+)*(?:\[\])?$/, UrlMatcher;
    }(), __assign = void 0 || Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; n > i; i++) {
            s = arguments[i];
            for (var p in s) Object.prototype.hasOwnProperty.call(s, p) && (t[p] = s[p]);
        }
        return t;
    }, ParamFactory = function() {
        function ParamFactory(router) {
            this.router = router;
        }
        return ParamFactory.prototype.fromConfig = function(id, type, state) {
            return new Param(id, type, exports.DefType.CONFIG, this.router.urlService.config, state);
        }, ParamFactory.prototype.fromPath = function(id, type, state) {
            return new Param(id, type, exports.DefType.PATH, this.router.urlService.config, state);
        }, ParamFactory.prototype.fromSearch = function(id, type, state) {
            return new Param(id, type, exports.DefType.SEARCH, this.router.urlService.config, state);
        }, ParamFactory;
    }(), UrlMatcherFactory = function() {
        function UrlMatcherFactory(router) {
            var _this = this;
            this.router = router, this.paramFactory = new ParamFactory(this.router), this.caseInsensitive = function(value) {
                return _this.router.urlService.config.caseInsensitive(value);
            }, this.defaultSquashPolicy = function(value) {
                return _this.router.urlService.config.defaultSquashPolicy(value);
            }, this.strictMode = function(value) {
                return _this.router.urlService.config.strictMode(value);
            }, this.type = function(name, definition, definitionFn) {
                return _this.router.urlService.config.type(name, definition, definitionFn) || _this;
            }, extend(this, {
                UrlMatcher: UrlMatcher,
                Param: Param
            });
        }
        return UrlMatcherFactory.prototype.compile = function(pattern$$1, config) {
            var urlConfig = this.router.urlService.config, params = config && !config.state && config.params;
            config = params ? __assign({
                state: {
                    params: params
                }
            }, config) : config;
            var globalConfig = {
                strict: urlConfig._isStrictMode,
                caseInsensitive: urlConfig._isCaseInsensitive
            };
            return new UrlMatcher(pattern$$1, urlConfig.paramTypes, this.paramFactory, extend(globalConfig, config));
        }, UrlMatcherFactory.prototype.isMatcher = function(object) {
            if (!isObject(object)) return !1;
            var result = !0;
            return forEach(UrlMatcher.prototype, function(val$$1, name) {
                isFunction(val$$1) && (result = result && isDefined(object[name]) && isFunction(object[name]));
            }), result;
        }, UrlMatcherFactory.prototype.$get = function() {
            var urlConfig = this.router.urlService.config;
            return urlConfig.paramTypes.enqueue = !1, urlConfig.paramTypes._flushTypeQueue(), 
            this;
        }, UrlMatcherFactory;
    }(), UrlRuleFactory = function() {
        function UrlRuleFactory(router) {
            this.router = router;
        }
        return UrlRuleFactory.prototype.compile = function(str) {
            return this.router.urlMatcherFactory.compile(str);
        }, UrlRuleFactory.prototype.create = function(what, handler) {
            var _this = this, isState = StateObject.isState, makeRule = pattern([ [ isString, function(_what) {
                return makeRule(_this.compile(_what));
            } ], [ is(UrlMatcher), function(_what) {
                return _this.fromUrlMatcher(_what, handler);
            } ], [ isState, function(_what) {
                return _this.fromState(_what, _this.router);
            } ], [ is(RegExp), function(_what) {
                return _this.fromRegExp(_what, handler);
            } ], [ isFunction, function(_what) {
                return new BaseUrlRule(_what, handler);
            } ] ]), rule = makeRule(what);
            if (!rule) throw new Error("invalid 'what' in when()");
            return rule;
        }, UrlRuleFactory.prototype.fromUrlMatcher = function(urlMatcher, handler) {
            function matchUrlParamters(url) {
                var params = urlMatcher.exec(url.path, url.search, url.hash);
                return urlMatcher.validates(params) && params;
            }
            function matchPriority(params) {
                var optional = urlMatcher.parameters().filter(function(param) {
                    return param.isOptional;
                });
                if (!optional.length) return 1e-6;
                var matched = optional.filter(function(param) {
                    return params[param.id];
                });
                return matched.length / optional.length;
            }
            var _handler = handler;
            isString(handler) && (handler = this.router.urlMatcherFactory.compile(handler)), 
            is(UrlMatcher)(handler) && (_handler = function(match) {
                return handler.format(match);
            });
            var details = {
                urlMatcher: urlMatcher,
                matchPriority: matchPriority,
                type: "URLMATCHER"
            };
            return extend(new BaseUrlRule(matchUrlParamters, _handler), details);
        }, UrlRuleFactory.prototype.fromState = function(state, router) {
            var handler = function(match) {
                var $state = router.stateService, globals = router.globals;
                $state.href(state, match) !== $state.href(globals.current, globals.params) && $state.transitionTo(state, match, {
                    inherit: !0,
                    source: "url"
                });
            }, details = {
                state: state,
                type: "STATE"
            };
            return extend(this.fromUrlMatcher(state.url, handler), details);
        }, UrlRuleFactory.prototype.fromRegExp = function(regexp, handler) {
            if (regexp.global || regexp.sticky) throw new Error("Rule RegExp must not be global or sticky");
            var redirectUrlTo = function(match) {
                return handler.replace(/\$(\$|\d{1,2})/, function(m, what) {
                    return match["$" === what ? 0 : Number(what)];
                });
            }, _handler = isString(handler) ? redirectUrlTo : handler, matchParamsFromRegexp = function(url) {
                return regexp.exec(url.path);
            }, details = {
                regexp: regexp,
                type: "REGEXP"
            };
            return extend(new BaseUrlRule(matchParamsFromRegexp, _handler), details);
        }, UrlRuleFactory.isUrlRule = function(obj) {
            return obj && [ "type", "match", "handler" ].every(function(key) {
                return isDefined(obj[key]);
            });
        }, UrlRuleFactory;
    }(), BaseUrlRule = function() {
        function BaseUrlRule(match, handler) {
            var _this = this;
            this.match = match, this.type = "RAW", this.matchPriority = function() {
                return 0 - _this.$id;
            }, this.handler = handler || identity;
        }
        return BaseUrlRule;
    }(), UrlRouter = function() {
        function UrlRouter(router) {
            var _this = this;
            this.router = router, this.sync = function(evt) {
                return _this.router.urlService.sync(evt);
            }, this.listen = function(enabled) {
                return _this.router.urlService.listen(enabled);
            }, this.deferIntercept = function(defer) {
                return _this.router.urlService.deferIntercept(defer);
            }, this.match = function(urlParts) {
                return _this.router.urlService.match(urlParts);
            }, this.initial = function(handler) {
                return _this.router.urlService.rules.initial(handler);
            }, this.otherwise = function(handler) {
                return _this.router.urlService.rules.otherwise(handler);
            }, this.removeRule = function(rule) {
                return _this.router.urlService.rules.removeRule(rule);
            }, this.rule = function(rule) {
                return _this.router.urlService.rules.rule(rule);
            }, this.rules = function() {
                return _this.router.urlService.rules.rules();
            }, this.sort = function(compareFn) {
                return _this.router.urlService.rules.sort(compareFn);
            }, this.when = function(matcher, handler, options) {
                return _this.router.urlService.rules.when(matcher, handler, options);
            }, this.urlRuleFactory = new UrlRuleFactory(router);
        }
        return UrlRouter.prototype.update = function(read) {
            var $url = this.router.locationService;
            return read ? void (this.location = $url.url()) : void ($url.url() !== this.location && $url.url(this.location, !0));
        }, UrlRouter.prototype.push = function(urlMatcher, params, options) {
            var replace = options && !!options.replace;
            this.router.urlService.url(urlMatcher.format(params || {}), replace);
        }, UrlRouter.prototype.href = function(urlMatcher, params, options) {
            var url = urlMatcher.format(params);
            if (null == url) return null;
            options = options || {
                absolute: !1
            };
            var cfg = this.router.urlService.config, isHtml5 = cfg.html5Mode();
            if (isHtml5 || null === url || (url = "#" + cfg.hashPrefix() + url), url = appendBasePath(url, isHtml5, options.absolute, cfg.baseHref()), 
            !options.absolute || !url) return url;
            var slash = !isHtml5 && url ? "/" : "", cfgPort = cfg.port(), port = 80 === cfgPort || 443 === cfgPort ? "" : ":" + cfgPort;
            return [ cfg.protocol(), "://", cfg.host(), port, slash, url ].join("");
        }, Object.defineProperty(UrlRouter.prototype, "interceptDeferred", {
            get: function() {
                return this.router.urlService.interceptDeferred;
            },
            enumerable: !0,
            configurable: !0
        }), UrlRouter;
    }(), ViewService = function() {
        function ViewService(router) {
            var _this = this;
            this.router = router, this._uiViews = [], this._viewConfigs = [], this._viewConfigFactories = {}, 
            this._listeners = [], this._pluginapi = {
                _rootViewContext: this._rootViewContext.bind(this),
                _viewConfigFactory: this._viewConfigFactory.bind(this),
                _registeredUIView: function(id) {
                    return find(_this._uiViews, function(view) {
                        return _this.router.$id + "." + view.id === id;
                    });
                },
                _registeredUIViews: function() {
                    return _this._uiViews;
                },
                _activeViewConfigs: function() {
                    return _this._viewConfigs;
                },
                _onSync: function(listener) {
                    return _this._listeners.push(listener), function() {
                        return removeFrom(_this._listeners, listener);
                    };
                }
            };
        }
        return ViewService.normalizeUIViewTarget = function(context, rawViewName) {
            void 0 === rawViewName && (rawViewName = "");
            var viewAtContext = rawViewName.split("@"), uiViewName = viewAtContext[0] || "$default", uiViewContextAnchor = isString(viewAtContext[1]) ? viewAtContext[1] : "^", relativeViewNameSugar = /^(\^(?:\.\^)*)\.(.*$)/.exec(uiViewName);
            relativeViewNameSugar && (uiViewContextAnchor = relativeViewNameSugar[1], uiViewName = relativeViewNameSugar[2]), 
            "!" === uiViewName.charAt(0) && (uiViewName = uiViewName.substr(1), uiViewContextAnchor = "");
            var relativeMatch = /^(\^(?:\.\^)*)$/;
            if (relativeMatch.exec(uiViewContextAnchor)) {
                var anchorState = uiViewContextAnchor.split(".").reduce(function(anchor) {
                    return anchor.parent;
                }, context);
                uiViewContextAnchor = anchorState.name;
            } else "." === uiViewContextAnchor && (uiViewContextAnchor = context.name);
            return {
                uiViewName: uiViewName,
                uiViewContextAnchor: uiViewContextAnchor
            };
        }, ViewService.prototype._rootViewContext = function(context) {
            return this._rootContext = context || this._rootContext;
        }, ViewService.prototype._viewConfigFactory = function(viewType, factory) {
            this._viewConfigFactories[viewType] = factory;
        }, ViewService.prototype.createViewConfig = function(path, decl) {
            var cfgFactory = this._viewConfigFactories[decl.$type];
            if (!cfgFactory) throw new Error("ViewService: No view config factory registered for type " + decl.$type);
            var cfgs = cfgFactory(path, decl);
            return isArray(cfgs) ? cfgs : [ cfgs ];
        }, ViewService.prototype.deactivateViewConfig = function(viewConfig) {
            trace.traceViewServiceEvent("<- Removing", viewConfig), removeFrom(this._viewConfigs, viewConfig);
        }, ViewService.prototype.activateViewConfig = function(viewConfig) {
            trace.traceViewServiceEvent("-> Registering", viewConfig), this._viewConfigs.push(viewConfig);
        }, ViewService.prototype.sync = function() {
            function uiViewDepth(uiView) {
                var stateDepth = function(context) {
                    return context && context.parent ? stateDepth(context.parent) + 1 : 1;
                };
                return 1e4 * uiView.fqn.split(".").length + stateDepth(uiView.creationContext);
            }
            function viewConfigDepth(config) {
                for (var context = config.viewDecl.$context, count = 0; ++count && context.parent; ) context = context.parent;
                return count;
            }
            var _this = this, uiViewsByFqn = this._uiViews.map(function(uiv) {
                return [ uiv.fqn, uiv ];
            }).reduce(applyPairs, {}), depthCompare = curry(function(depthFn, posNeg, left, right) {
                return posNeg * (depthFn(left) - depthFn(right));
            }), matchingConfigPair = function(uiView) {
                var matchingConfigs = _this._viewConfigs.filter(ViewService.matches(uiViewsByFqn, uiView));
                return matchingConfigs.length > 1 && matchingConfigs.sort(depthCompare(viewConfigDepth, -1)), 
                {
                    uiView: uiView,
                    viewConfig: matchingConfigs[0]
                };
            }, configureUIView = function(tuple) {
                -1 !== _this._uiViews.indexOf(tuple.uiView) && tuple.uiView.configUpdated(tuple.viewConfig);
            }, uiViewTuples = this._uiViews.sort(depthCompare(uiViewDepth, 1)).map(matchingConfigPair), matchedViewConfigs = uiViewTuples.map(function(tuple) {
                return tuple.viewConfig;
            }), unmatchedConfigTuples = this._viewConfigs.filter(function(config) {
                return !inArray(matchedViewConfigs, config);
            }).map(function(viewConfig) {
                return {
                    uiView: void 0,
                    viewConfig: viewConfig
                };
            });
            uiViewTuples.forEach(configureUIView);
            var allTuples = uiViewTuples.concat(unmatchedConfigTuples);
            this._listeners.forEach(function(cb) {
                return cb(allTuples);
            }), trace.traceViewSync(allTuples);
        }, ViewService.prototype.registerUIView = function(uiView) {
            trace.traceViewServiceUIViewEvent("-> Registering", uiView);
            var uiViews = this._uiViews, fqnAndTypeMatches = function(uiv) {
                return uiv.fqn === uiView.fqn && uiv.$type === uiView.$type;
            };
            return uiViews.filter(fqnAndTypeMatches).length && trace.traceViewServiceUIViewEvent("!!!! duplicate uiView named:", uiView), 
            uiViews.push(uiView), this.sync(), function() {
                var idx = uiViews.indexOf(uiView);
                return -1 === idx ? void trace.traceViewServiceUIViewEvent("Tried removing non-registered uiView", uiView) : (trace.traceViewServiceUIViewEvent("<- Deregistering", uiView), 
                void removeFrom(uiViews)(uiView));
            };
        }, ViewService.prototype.available = function() {
            return this._uiViews.map(prop("fqn"));
        }, ViewService.prototype.active = function() {
            return this._uiViews.filter(prop("$config")).map(prop("name"));
        }, ViewService.matches = function(uiViewsByFqn, uiView) {
            return function(viewConfig) {
                if (uiView.$type !== viewConfig.viewDecl.$type) return !1;
                var vc = viewConfig.viewDecl, vcSegments = vc.$uiViewName.split("."), uivSegments = uiView.fqn.split(".");
                if (!equals(vcSegments, uivSegments.slice(0 - vcSegments.length))) return !1;
                var negOffset = 1 - vcSegments.length || void 0, fqnToFirstSegment = uivSegments.slice(0, negOffset).join("."), uiViewContext = uiViewsByFqn[fqnToFirstSegment].creationContext;
                return vc.$uiViewContextAnchor === (uiViewContext && uiViewContext.name);
            };
        }, ViewService;
    }(), UIRouterGlobals = function() {
        function UIRouterGlobals() {
            this.params = new StateParams(), this.lastStartedTransitionId = -1, this.transitionHistory = new Queue([], 1), 
            this.successfulTransitions = new Queue([], 1);
        }
        return UIRouterGlobals.prototype.dispose = function() {
            this.transitionHistory.clear(), this.successfulTransitions.clear(), this.transition = null;
        }, UIRouterGlobals;
    }(), prioritySort = function(a, b) {
        return (b.priority || 0) - (a.priority || 0);
    }, typeSort = function(a, b) {
        var weights = {
            STATE: 4,
            URLMATCHER: 4,
            REGEXP: 3,
            RAW: 2,
            OTHER: 1
        };
        return (weights[a.type] || 0) - (weights[b.type] || 0);
    }, urlMatcherSort = function(a, b) {
        return a.urlMatcher && b.urlMatcher ? UrlMatcher.compare(a.urlMatcher, b.urlMatcher) : 0;
    }, idSort = function(a, b) {
        var useMatchPriority = {
            STATE: !0,
            URLMATCHER: !0
        }, equal = useMatchPriority[a.type] && useMatchPriority[b.type];
        return equal ? 0 : (a.$id || 0) - (b.$id || 0);
    };
    defaultRuleSortFn = function(a, b) {
        var cmp = prioritySort(a, b);
        return 0 !== cmp ? cmp : (cmp = typeSort(a, b), 0 !== cmp ? cmp : (cmp = urlMatcherSort(a, b), 
        0 !== cmp ? cmp : idSort(a, b)));
    };
    var UrlRules = function() {
        function UrlRules(router) {
            this.router = router, this._sortFn = defaultRuleSortFn, this._rules = [], this._id = 0, 
            this.urlRuleFactory = new UrlRuleFactory(router);
        }
        return UrlRules.prototype.dispose = function() {
            this._rules = [], delete this._otherwiseFn;
        }, UrlRules.prototype.initial = function(handler) {
            var handlerFn = getHandlerFn(handler), matchFn = function(urlParts, router) {
                return 0 === router.globals.transitionHistory.size() && !!/^\/?$/.exec(urlParts.path);
            };
            this.rule(this.urlRuleFactory.create(matchFn, handlerFn));
        }, UrlRules.prototype.otherwise = function(handler) {
            var handlerFn = getHandlerFn(handler);
            this._otherwiseFn = this.urlRuleFactory.create(val(!0), handlerFn), this._sorted = !1;
        }, UrlRules.prototype.removeRule = function(rule) {
            removeFrom(this._rules, rule);
        }, UrlRules.prototype.rule = function(rule) {
            var _this = this;
            if (!UrlRuleFactory.isUrlRule(rule)) throw new Error("invalid rule");
            return rule.$id = this._id++, rule.priority = rule.priority || 0, this._rules.push(rule), 
            this._sorted = !1, function() {
                return _this.removeRule(rule);
            };
        }, UrlRules.prototype.rules = function() {
            return this.ensureSorted(), this._rules.concat(this._otherwiseFn ? [ this._otherwiseFn ] : []);
        }, UrlRules.prototype.sort = function(compareFn) {
            for (var sorted = this.stableSort(this._rules, this._sortFn = compareFn || this._sortFn), group = 0, i = 0; i < sorted.length; i++) sorted[i]._group = group, 
            i < sorted.length - 1 && 0 !== this._sortFn(sorted[i], sorted[i + 1]) && group++;
            this._rules = sorted, this._sorted = !0;
        }, UrlRules.prototype.ensureSorted = function() {
            this._sorted || this.sort();
        }, UrlRules.prototype.stableSort = function(arr, compareFn) {
            var arrOfWrapper = arr.map(function(elem, idx) {
                return {
                    elem: elem,
                    idx: idx
                };
            });
            return arrOfWrapper.sort(function(wrapperA, wrapperB) {
                var cmpDiff = compareFn(wrapperA.elem, wrapperB.elem);
                return 0 === cmpDiff ? wrapperA.idx - wrapperB.idx : cmpDiff;
            }), arrOfWrapper.map(function(wrapper) {
                return wrapper.elem;
            });
        }, UrlRules.prototype.when = function(matcher, handler, options) {
            var rule = this.urlRuleFactory.create(matcher, handler);
            return isDefined(options && options.priority) && (rule.priority = options.priority), 
            this.rule(rule), rule;
        }, UrlRules;
    }(), UrlConfig = function() {
        function UrlConfig(router) {
            var _this = this;
            this.router = router, this.paramTypes = new ParamTypes(), this._isCaseInsensitive = !1, 
            this._isStrictMode = !0, this._defaultSquashPolicy = !1, this.dispose = function() {
                return _this.paramTypes.dispose();
            }, this.baseHref = function() {
                return _this.router.locationConfig.baseHref();
            }, this.hashPrefix = function(newprefix) {
                return _this.router.locationConfig.hashPrefix(newprefix);
            }, this.host = function() {
                return _this.router.locationConfig.host();
            }, this.html5Mode = function() {
                return _this.router.locationConfig.html5Mode();
            }, this.port = function() {
                return _this.router.locationConfig.port();
            }, this.protocol = function() {
                return _this.router.locationConfig.protocol();
            };
        }
        return UrlConfig.prototype.caseInsensitive = function(value) {
            return this._isCaseInsensitive = isDefined(value) ? value : this._isCaseInsensitive;
        }, UrlConfig.prototype.defaultSquashPolicy = function(value) {
            if (isDefined(value) && value !== !0 && value !== !1 && !isString(value)) throw new Error("Invalid squash policy: " + value + ". Valid policies: false, true, arbitrary-string");
            return this._defaultSquashPolicy = isDefined(value) ? value : this._defaultSquashPolicy;
        }, UrlConfig.prototype.strictMode = function(value) {
            return this._isStrictMode = isDefined(value) ? value : this._isStrictMode;
        }, UrlConfig.prototype.type = function(name, definition, definitionFn) {
            var type = this.paramTypes.type(name, definition, definitionFn);
            return isDefined(definition) ? this : type;
        }, UrlConfig;
    }(), UrlService = function() {
        function UrlService(router) {
            var _this = this;
            this.router = router, this.interceptDeferred = !1, this.rules = new UrlRules(this.router), 
            this.config = new UrlConfig(this.router), this.url = function(newurl, replace, state) {
                return _this.router.locationService.url(newurl, replace, state);
            }, this.path = function() {
                return _this.router.locationService.path();
            }, this.search = function() {
                return _this.router.locationService.search();
            }, this.hash = function() {
                return _this.router.locationService.hash();
            }, this.onChange = function(callback) {
                return _this.router.locationService.onChange(callback);
            };
        }
        return UrlService.prototype.dispose = function() {
            this.listen(!1), this.rules.dispose();
        }, UrlService.prototype.parts = function() {
            return {
                path: this.path(),
                search: this.search(),
                hash: this.hash()
            };
        }, UrlService.prototype.sync = function(evt) {
            if (!evt || !evt.defaultPrevented) {
                var _a = this.router, urlService = _a.urlService, stateService = _a.stateService, url = {
                    path: urlService.path(),
                    search: urlService.search(),
                    hash: urlService.hash()
                }, best = this.match(url), applyResult = pattern([ [ isString, function(newurl) {
                    return urlService.url(newurl, !0);
                } ], [ TargetState.isDef, function(def) {
                    return stateService.go(def.state, def.params, def.options);
                } ], [ is(TargetState), function(target) {
                    return stateService.go(target.state(), target.params(), target.options());
                } ] ]);
                applyResult(best && best.rule.handler(best.match, url, this.router));
            }
        }, UrlService.prototype.listen = function(enabled) {
            var _this = this;
            return enabled !== !1 ? this._stopListeningFn = this._stopListeningFn || this.router.urlService.onChange(function(evt) {
                return _this.sync(evt);
            }) : (this._stopListeningFn && this._stopListeningFn(), void delete this._stopListeningFn);
        }, UrlService.prototype.deferIntercept = function(defer) {
            void 0 === defer && (defer = !0), this.interceptDeferred = defer;
        }, UrlService.prototype.match = function(url) {
            var _this = this;
            url = extend({
                path: "",
                search: {},
                hash: ""
            }, url);
            for (var best, rules = this.rules.rules(), checkRule = function(rule) {
                var match = rule.match(url, _this.router);
                return match && {
                    match: match,
                    rule: rule,
                    weight: rule.matchPriority(match)
                };
            }, i = 0; i < rules.length && (!best || best.rule._group === rules[i]._group); i++) {
                var current = checkRule(rules[i]);
                best = !best || current && current.weight > best.weight ? current : best;
            }
            return best;
        }, UrlService;
    }(), _routerInstance = 0, locSvcFns = [ "url", "path", "search", "hash", "onChange" ], locCfgFns = [ "port", "protocol", "host", "baseHref", "html5Mode", "hashPrefix" ], locationServiceStub = makeStub("LocationServices", locSvcFns), locationConfigStub = makeStub("LocationConfig", locCfgFns), UIRouter = function() {
        function UIRouter(locationService, locationConfig) {
            void 0 === locationService && (locationService = locationServiceStub), void 0 === locationConfig && (locationConfig = locationConfigStub), 
            this.locationService = locationService, this.locationConfig = locationConfig, this.$id = _routerInstance++, 
            this._disposed = !1, this._disposables = [], this.trace = trace, this.viewService = new ViewService(this), 
            this.globals = new UIRouterGlobals(), this.transitionService = new TransitionService(this), 
            this.urlMatcherFactory = new UrlMatcherFactory(this), this.urlRouter = new UrlRouter(this), 
            this.urlService = new UrlService(this), this.stateRegistry = new StateRegistry(this), 
            this.stateService = new StateService(this), this._plugins = {}, this.viewService._pluginapi._rootViewContext(this.stateRegistry.root()), 
            this.globals.$current = this.stateRegistry.root(), this.globals.current = this.globals.$current.self, 
            this.disposable(this.globals), this.disposable(this.stateService), this.disposable(this.stateRegistry), 
            this.disposable(this.transitionService), this.disposable(this.urlService), this.disposable(locationService), 
            this.disposable(locationConfig);
        }
        return UIRouter.prototype.disposable = function(disposable) {
            this._disposables.push(disposable);
        }, UIRouter.prototype.dispose = function(disposable) {
            var _this = this;
            return disposable && isFunction(disposable.dispose) ? void disposable.dispose(this) : (this._disposed = !0, 
            void this._disposables.slice().forEach(function(d) {
                try {
                    "function" == typeof d.dispose && d.dispose(_this), removeFrom(_this._disposables, d);
                } catch (ignored) {}
            }));
        }, UIRouter.prototype.plugin = function(plugin, options) {
            void 0 === options && (options = {});
            var pluginInstance = new plugin(this, options);
            if (!pluginInstance.name) throw new Error("Required property `name` missing on plugin: " + pluginInstance);
            return this._disposables.push(pluginInstance), this._plugins[pluginInstance.name] = pluginInstance;
        }, UIRouter.prototype.getPlugin = function(pluginName) {
            return pluginName ? this._plugins[pluginName] : values(this._plugins);
        }, UIRouter;
    }(), registerAddCoreResolvables = function(transitionService) {
        return transitionService.onCreate({}, addCoreResolvables);
    }, TRANSITION_TOKENS = [ "$transition$", Transition ], isTransition = inArray(TRANSITION_TOKENS), treeChangesCleanup = function(trans) {
        var nodes = values(trans.treeChanges()).reduce(unnestR, []).reduce(uniqR, []), replaceTransitionWithNull = function(r) {
            return isTransition(r.token) ? Resolvable.fromData(r.token, null) : r;
        };
        nodes.forEach(function(node) {
            node.resolvables = node.resolvables.map(replaceTransitionWithNull);
        });
    }, redirectToHook = function(trans) {
        function handleResult(result) {
            return result ? result instanceof TargetState ? result : isString(result) ? $state.target(result, trans.params(), trans.options()) : result.state || result.params ? $state.target(result.state || trans.to(), result.params || trans.params(), trans.options()) : void 0 : void 0;
        }
        var redirect = trans.to().redirectTo;
        if (redirect) {
            var $state = trans.router.stateService;
            return isFunction(redirect) ? services.$q.when(redirect(trans)).then(handleResult) : handleResult(redirect);
        }
    }, registerRedirectToHook = function(transitionService) {
        return transitionService.onStart({
            to: function(state) {
                return !!state.redirectTo;
            }
        }, redirectToHook);
    }, onExitHook = makeEnterExitRetainHook("onExit"), registerOnExitHook = function(transitionService) {
        return transitionService.onExit({
            exiting: function(state) {
                return !!state.onExit;
            }
        }, onExitHook);
    }, onRetainHook = makeEnterExitRetainHook("onRetain"), registerOnRetainHook = function(transitionService) {
        return transitionService.onRetain({
            retained: function(state) {
                return !!state.onRetain;
            }
        }, onRetainHook);
    }, onEnterHook = makeEnterExitRetainHook("onEnter"), registerOnEnterHook = function(transitionService) {
        return transitionService.onEnter({
            entering: function(state) {
                return !!state.onEnter;
            }
        }, onEnterHook);
    }, RESOLVE_HOOK_PRIORITY = 1e3, eagerResolvePath = function(trans) {
        return new ResolveContext(trans.treeChanges().to).resolvePath("EAGER", trans).then(noop);
    }, registerEagerResolvePath = function(transitionService) {
        return transitionService.onStart({}, eagerResolvePath, {
            priority: RESOLVE_HOOK_PRIORITY
        });
    }, lazyResolveState = function(trans, state) {
        return new ResolveContext(trans.treeChanges().to).subContext(state.$$state()).resolvePath("LAZY", trans).then(noop);
    }, registerLazyResolveState = function(transitionService) {
        return transitionService.onEnter({
            entering: val(!0)
        }, lazyResolveState, {
            priority: RESOLVE_HOOK_PRIORITY
        });
    }, resolveRemaining = function(trans) {
        return new ResolveContext(trans.treeChanges().to).resolvePath("LAZY", trans).then(noop);
    }, registerResolveRemaining = function(transitionService) {
        return transitionService.onFinish({}, resolveRemaining, {
            priority: RESOLVE_HOOK_PRIORITY
        });
    }, loadEnteringViews = function(transition) {
        var $q = services.$q, enteringViews = transition.views("entering");
        return enteringViews.length ? $q.all(enteringViews.map(function(view) {
            return $q.when(view.load());
        })).then(noop) : void 0;
    }, registerLoadEnteringViews = function(transitionService) {
        return transitionService.onFinish({}, loadEnteringViews);
    }, activateViews = function(transition) {
        var enteringViews = transition.views("entering"), exitingViews = transition.views("exiting");
        if (enteringViews.length || exitingViews.length) {
            var $view = transition.router.viewService;
            exitingViews.forEach(function(vc) {
                return $view.deactivateViewConfig(vc);
            }), enteringViews.forEach(function(vc) {
                return $view.activateViewConfig(vc);
            }), $view.sync();
        }
    }, registerActivateViews = function(transitionService) {
        return transitionService.onSuccess({}, activateViews);
    }, updateGlobalState = function(trans) {
        var globals = trans.router.globals, transitionSuccessful = function() {
            globals.successfulTransitions.enqueue(trans), globals.$current = trans.$to(), globals.current = globals.$current.self, 
            copy(trans.params(), globals.params);
        }, clearCurrentTransition = function() {
            globals.transition === trans && (globals.transition = null);
        };
        trans.onSuccess({}, transitionSuccessful, {
            priority: 1e4
        }), trans.promise.then(clearCurrentTransition, clearCurrentTransition);
    }, registerUpdateGlobalState = function(transitionService) {
        return transitionService.onCreate({}, updateGlobalState);
    }, updateUrl = function(transition) {
        var options = transition.options(), $state = transition.router.stateService, $urlRouter = transition.router.urlRouter;
        if ("url" !== options.source && options.location && $state.$current.navigable) {
            var urlOptions = {
                replace: "replace" === options.location
            };
            $urlRouter.push($state.$current.navigable.url, $state.params, urlOptions);
        }
        $urlRouter.update(!0);
    }, registerUpdateUrl = function(transitionService) {
        return transitionService.onSuccess({}, updateUrl, {
            priority: 9999
        });
    }, lazyLoadHook = function(transition) {
        function retryTransition() {
            if ("url" !== transition.originalTransition().options().source) {
                var orig = transition.targetState();
                return router.stateService.target(orig.identifier(), orig.params(), orig.options());
            }
            var $url = router.urlService, result = $url.match($url.parts()), rule = result && result.rule;
            if (rule && "STATE" === rule.type) {
                var state = rule.state, params = result.match;
                return router.stateService.target(state, params, transition.options());
            }
            router.urlService.sync();
        }
        var router = transition.router, promises = transition.entering().filter(function(state) {
            return !!state.$$state().lazyLoad;
        }).map(function(state) {
            return lazyLoadState(transition, state);
        });
        return services.$q.all(promises).then(retryTransition);
    }, registerLazyLoadHook = function(transitionService) {
        return transitionService.onBefore({
            entering: function(state) {
                return !!state.lazyLoad;
            }
        }, lazyLoadHook);
    }, TransitionEventType = function() {
        function TransitionEventType(name, hookPhase, hookOrder, criteriaMatchPath, reverseSort, getResultHandler, getErrorHandler, synchronous) {
            void 0 === reverseSort && (reverseSort = !1), void 0 === getResultHandler && (getResultHandler = TransitionHook.HANDLE_RESULT), 
            void 0 === getErrorHandler && (getErrorHandler = TransitionHook.REJECT_ERROR), void 0 === synchronous && (synchronous = !1), 
            this.name = name, this.hookPhase = hookPhase, this.hookOrder = hookOrder, this.criteriaMatchPath = criteriaMatchPath, 
            this.reverseSort = reverseSort, this.getResultHandler = getResultHandler, this.getErrorHandler = getErrorHandler, 
            this.synchronous = synchronous;
        }
        return TransitionEventType;
    }(), registerIgnoredTransitionHook = function(transitionService) {
        return transitionService.onBefore({}, ignoredHook, {
            priority: -9999
        });
    }, registerInvalidTransitionHook = function(transitionService) {
        return transitionService.onBefore({}, invalidTransitionHook, {
            priority: -1e4
        });
    }, defaultTransOpts = {
        location: !0,
        relative: null,
        inherit: !1,
        notify: !0,
        reload: !1,
        custom: {},
        current: function() {
            return null;
        },
        source: "unknown"
    }, TransitionService = function() {
        function TransitionService(_router) {
            this._transitionCount = 0, this._eventTypes = [], this._registeredHooks = {}, this._criteriaPaths = {}, 
            this._router = _router, this.$view = _router.viewService, this._deregisterHookFns = {}, 
            this._pluginapi = createProxyFunctions(val(this), {}, val(this), [ "_definePathType", "_defineEvent", "_getPathTypes", "_getEvents", "getHooks" ]), 
            this._defineCorePaths(), this._defineCoreEvents(), this._registerCoreTransitionHooks(), 
            _router.globals.successfulTransitions.onEvict(treeChangesCleanup);
        }
        return TransitionService.prototype.onCreate = function() {}, TransitionService.prototype.onBefore = function() {}, 
        TransitionService.prototype.onStart = function() {}, TransitionService.prototype.onExit = function() {}, 
        TransitionService.prototype.onRetain = function() {}, TransitionService.prototype.onEnter = function() {}, 
        TransitionService.prototype.onFinish = function() {}, TransitionService.prototype.onSuccess = function() {}, 
        TransitionService.prototype.onError = function() {}, TransitionService.prototype.dispose = function() {
            values(this._registeredHooks).forEach(function(hooksArray) {
                return hooksArray.forEach(function(hook) {
                    hook._deregistered = !0, removeFrom(hooksArray, hook);
                });
            });
        }, TransitionService.prototype.create = function(fromPath, targetState) {
            return new Transition(fromPath, targetState, this._router);
        }, TransitionService.prototype._defineCoreEvents = function() {
            var Phase = exports.TransitionHookPhase, TH = TransitionHook, paths = this._criteriaPaths, NORMAL_SORT = !1, REVERSE_SORT = !0, SYNCHRONOUS = !0;
            this._defineEvent("onCreate", Phase.CREATE, 0, paths.to, NORMAL_SORT, TH.LOG_REJECTED_RESULT, TH.THROW_ERROR, SYNCHRONOUS), 
            this._defineEvent("onBefore", Phase.BEFORE, 0, paths.to), this._defineEvent("onStart", Phase.RUN, 0, paths.to), 
            this._defineEvent("onExit", Phase.RUN, 100, paths.exiting, REVERSE_SORT), this._defineEvent("onRetain", Phase.RUN, 200, paths.retained), 
            this._defineEvent("onEnter", Phase.RUN, 300, paths.entering), this._defineEvent("onFinish", Phase.RUN, 400, paths.to), 
            this._defineEvent("onSuccess", Phase.SUCCESS, 0, paths.to, NORMAL_SORT, TH.LOG_REJECTED_RESULT, TH.LOG_ERROR, SYNCHRONOUS), 
            this._defineEvent("onError", Phase.ERROR, 0, paths.to, NORMAL_SORT, TH.LOG_REJECTED_RESULT, TH.LOG_ERROR, SYNCHRONOUS);
        }, TransitionService.prototype._defineCorePaths = function() {
            var STATE = exports.TransitionHookScope.STATE, TRANSITION = exports.TransitionHookScope.TRANSITION;
            this._definePathType("to", TRANSITION), this._definePathType("from", TRANSITION), 
            this._definePathType("exiting", STATE), this._definePathType("retained", STATE), 
            this._definePathType("entering", STATE);
        }, TransitionService.prototype._defineEvent = function(name, hookPhase, hookOrder, criteriaMatchPath, reverseSort, getResultHandler, getErrorHandler, synchronous) {
            void 0 === reverseSort && (reverseSort = !1), void 0 === getResultHandler && (getResultHandler = TransitionHook.HANDLE_RESULT), 
            void 0 === getErrorHandler && (getErrorHandler = TransitionHook.REJECT_ERROR), void 0 === synchronous && (synchronous = !1);
            var eventType = new TransitionEventType(name, hookPhase, hookOrder, criteriaMatchPath, reverseSort, getResultHandler, getErrorHandler, synchronous);
            this._eventTypes.push(eventType), makeEvent(this, this, eventType);
        }, TransitionService.prototype._getEvents = function(phase) {
            var transitionHookTypes = isDefined(phase) ? this._eventTypes.filter(function(type) {
                return type.hookPhase === phase;
            }) : this._eventTypes.slice();
            return transitionHookTypes.sort(function(l, r) {
                var cmpByPhase = l.hookPhase - r.hookPhase;
                return 0 === cmpByPhase ? l.hookOrder - r.hookOrder : cmpByPhase;
            });
        }, TransitionService.prototype._definePathType = function(name, hookScope) {
            this._criteriaPaths[name] = {
                name: name,
                scope: hookScope
            };
        }, TransitionService.prototype._getPathTypes = function() {
            return this._criteriaPaths;
        }, TransitionService.prototype.getHooks = function(hookName) {
            return this._registeredHooks[hookName];
        }, TransitionService.prototype._registerCoreTransitionHooks = function() {
            var fns = this._deregisterHookFns;
            fns.addCoreResolves = registerAddCoreResolvables(this), fns.ignored = registerIgnoredTransitionHook(this), 
            fns.invalid = registerInvalidTransitionHook(this), fns.redirectTo = registerRedirectToHook(this), 
            fns.onExit = registerOnExitHook(this), fns.onRetain = registerOnRetainHook(this), 
            fns.onEnter = registerOnEnterHook(this), fns.eagerResolve = registerEagerResolvePath(this), 
            fns.lazyResolve = registerLazyResolveState(this), fns.resolveAll = registerResolveRemaining(this), 
            fns.loadViews = registerLoadEnteringViews(this), fns.activateViews = registerActivateViews(this), 
            fns.updateGlobals = registerUpdateGlobalState(this), fns.updateUrl = registerUpdateUrl(this), 
            fns.lazyLoad = registerLazyLoadHook(this);
        }, TransitionService;
    }(), StateService = function() {
        function StateService(router) {
            this.router = router, this.invalidCallbacks = [], this._defaultErrorHandler = function($error$) {
                $error$ instanceof Error && $error$.stack ? (console.error($error$), console.error($error$.stack)) : $error$ instanceof Rejection ? (console.error($error$.toString()), 
                $error$.detail && $error$.detail.stack && console.error($error$.detail.stack)) : console.error($error$);
            };
            var getters = [ "current", "$current", "params", "transition" ], boundFns = Object.keys(StateService.prototype).filter(not(inArray(getters)));
            createProxyFunctions(val(StateService.prototype), this, val(this), boundFns);
        }
        return Object.defineProperty(StateService.prototype, "transition", {
            get: function() {
                return this.router.globals.transition;
            },
            enumerable: !0,
            configurable: !0
        }), Object.defineProperty(StateService.prototype, "params", {
            get: function() {
                return this.router.globals.params;
            },
            enumerable: !0,
            configurable: !0
        }), Object.defineProperty(StateService.prototype, "current", {
            get: function() {
                return this.router.globals.current;
            },
            enumerable: !0,
            configurable: !0
        }), Object.defineProperty(StateService.prototype, "$current", {
            get: function() {
                return this.router.globals.$current;
            },
            enumerable: !0,
            configurable: !0
        }), StateService.prototype.dispose = function() {
            this.defaultErrorHandler(noop), this.invalidCallbacks = [];
        }, StateService.prototype._handleInvalidTargetState = function(fromPath, toState) {
            function invokeNextCallback() {
                var nextCallback = callbackQueue.dequeue();
                if (void 0 === nextCallback) return Rejection.invalid(toState.error()).toPromise();
                var callbackResult = services.$q.when(nextCallback(toState, fromState, injector));
                return callbackResult.then(checkForRedirect).then(function(result) {
                    return result || invokeNextCallback();
                });
            }
            var _this = this, fromState = PathUtils.makeTargetState(this.router.stateRegistry, fromPath), globals = this.router.globals, latestThing = function() {
                return globals.transitionHistory.peekTail();
            }, latest = latestThing(), callbackQueue = new Queue(this.invalidCallbacks.slice()), injector = new ResolveContext(fromPath).injector(), checkForRedirect = function(result) {
                if (result instanceof TargetState) {
                    var target = result;
                    return target = _this.target(target.identifier(), target.params(), target.options()), 
                    target.valid() ? latestThing() !== latest ? Rejection.superseded().toPromise() : _this.transitionTo(target.identifier(), target.params(), target.options()) : Rejection.invalid(target.error()).toPromise();
                }
            };
            return invokeNextCallback();
        }, StateService.prototype.onInvalid = function(callback) {
            return this.invalidCallbacks.push(callback), function() {
                removeFrom(this.invalidCallbacks)(callback);
            }.bind(this);
        }, StateService.prototype.reload = function(reloadState) {
            return this.transitionTo(this.current, this.params, {
                reload: isDefined(reloadState) ? reloadState : !0,
                inherit: !1,
                notify: !1
            });
        }, StateService.prototype.go = function(to, params, options) {
            var defautGoOpts = {
                relative: this.$current,
                inherit: !0
            }, transOpts = defaults(options, defautGoOpts, defaultTransOpts);
            return this.transitionTo(to, params, transOpts);
        }, StateService.prototype.target = function(identifier, params, options) {
            if (void 0 === options && (options = {}), isObject(options.reload) && !options.reload.name) throw new Error("Invalid reload state object");
            var reg = this.router.stateRegistry;
            if (options.reloadState = options.reload === !0 ? reg.root() : reg.matcher.find(options.reload, options.relative), 
            options.reload && !options.reloadState) throw new Error("No such reload state '" + (isString(options.reload) ? options.reload : options.reload.name) + "'");
            return new TargetState(this.router.stateRegistry, identifier, params, options);
        }, StateService.prototype.getCurrentPath = function() {
            var _this = this, globals = this.router.globals, latestSuccess = globals.successfulTransitions.peekTail(), rootPath = function() {
                return [ new PathNode(_this.router.stateRegistry.root()) ];
            };
            return latestSuccess ? latestSuccess.treeChanges().to : rootPath();
        }, StateService.prototype.transitionTo = function(to, toParams, options) {
            var _this = this;
            void 0 === toParams && (toParams = {}), void 0 === options && (options = {});
            var router = this.router, globals = router.globals;
            options = defaults(options, defaultTransOpts);
            var getCurrent = function() {
                return globals.transition;
            };
            options = extend(options, {
                current: getCurrent
            });
            var ref = this.target(to, toParams, options), currentPath = this.getCurrentPath();
            if (!ref.exists()) return this._handleInvalidTargetState(currentPath, ref);
            if (!ref.valid()) return silentRejection(ref.error());
            var rejectedTransitionHandler = function(trans) {
                return function(error) {
                    if (error instanceof Rejection) {
                        var isLatest = router.globals.lastStartedTransitionId === trans.$id;
                        if (error.type === exports.RejectType.IGNORED) return isLatest && router.urlRouter.update(), 
                        services.$q.when(globals.current);
                        var detail = error.detail;
                        if (error.type === exports.RejectType.SUPERSEDED && error.redirected && detail instanceof TargetState) {
                            var redirect = trans.redirect(detail);
                            return redirect.run().catch(rejectedTransitionHandler(redirect));
                        }
                        if (error.type === exports.RejectType.ABORTED) return isLatest && router.urlRouter.update(), 
                        services.$q.reject(error);
                    }
                    var errorHandler = _this.defaultErrorHandler();
                    return errorHandler(error), services.$q.reject(error);
                };
            }, transition = this.router.transitionService.create(currentPath, ref), transitionToPromise = transition.run().catch(rejectedTransitionHandler(transition));
            return silenceUncaughtInPromise(transitionToPromise), extend(transitionToPromise, {
                transition: transition
            });
        }, StateService.prototype.is = function(stateOrName, params, options) {
            options = defaults(options, {
                relative: this.$current
            });
            var state = this.router.stateRegistry.matcher.find(stateOrName, options.relative);
            if (!isDefined(state)) return void 0;
            if (this.$current !== state) return !1;
            if (!params) return !0;
            var schema = state.parameters({
                inherit: !0,
                matchingKeys: params
            });
            return Param.equals(schema, Param.values(schema, params), this.params);
        }, StateService.prototype.includes = function(stateOrName, params, options) {
            options = defaults(options, {
                relative: this.$current
            });
            var glob = isString(stateOrName) && Glob.fromString(stateOrName);
            if (glob) {
                if (!glob.matches(this.$current.name)) return !1;
                stateOrName = this.$current.name;
            }
            var state = this.router.stateRegistry.matcher.find(stateOrName, options.relative), include = this.$current.includes;
            if (!isDefined(state)) return void 0;
            if (!isDefined(include[state.name])) return !1;
            if (!params) return !0;
            var schema = state.parameters({
                inherit: !0,
                matchingKeys: params
            });
            return Param.equals(schema, Param.values(schema, params), this.params);
        }, StateService.prototype.href = function(stateOrName, params, options) {
            var defaultHrefOpts = {
                lossy: !0,
                inherit: !0,
                absolute: !1,
                relative: this.$current
            };
            options = defaults(options, defaultHrefOpts), params = params || {};
            var state = this.router.stateRegistry.matcher.find(stateOrName, options.relative);
            if (!isDefined(state)) return null;
            options.inherit && (params = this.params.$inherit(params, this.$current, state));
            var nav = state && options.lossy ? state.navigable : state;
            return nav && void 0 !== nav.url && null !== nav.url ? this.router.urlRouter.href(nav.url, params, {
                absolute: options.absolute
            }) : null;
        }, StateService.prototype.defaultErrorHandler = function(handler) {
            return this._defaultErrorHandler = handler || this._defaultErrorHandler;
        }, StateService.prototype.get = function(stateOrName, base) {
            var reg = this.router.stateRegistry;
            return 0 === arguments.length ? reg.get() : reg.get(stateOrName, base || this.$current);
        }, StateService.prototype.lazyLoad = function(stateOrName, transition) {
            var state = this.get(stateOrName);
            if (!state || !state.lazyLoad) throw new Error("Can not lazy load " + stateOrName);
            var currentPath = this.getCurrentPath(), target = PathUtils.makeTargetState(this.router.stateRegistry, currentPath);
            return transition = transition || this.router.transitionService.create(currentPath, target), 
            lazyLoadState(transition, state);
        }, StateService;
    }(), $q = {
        when: function(val$$1) {
            return new Promise(function(resolve) {
                return resolve(val$$1);
            });
        },
        reject: function(val$$1) {
            return new Promise(function(resolve, reject) {
                reject(val$$1);
            });
        },
        defer: function() {
            var deferred = {};
            return deferred.promise = new Promise(function(resolve, reject) {
                deferred.resolve = resolve, deferred.reject = reject;
            }), deferred;
        },
        all: function(promises) {
            if (isArray(promises)) return Promise.all(promises);
            if (isObject(promises)) {
                var chain = Object.keys(promises).map(function(key) {
                    return promises[key].then(function(val$$1) {
                        return {
                            key: key,
                            val: val$$1
                        };
                    });
                });
                return $q.all(chain).then(function(values$$1) {
                    return values$$1.reduce(function(acc, tuple) {
                        return acc[tuple.key] = tuple.val, acc;
                    }, {});
                });
            }
        }
    }, globals = {}, STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/gm, ARGUMENT_NAMES = /([^\s,]+)/g, $injector = {
        get: function(name) {
            return globals[name];
        },
        has: function(name) {
            return null != $injector.get(name);
        },
        invoke: function(fn, context, locals) {
            var all$$1 = extend({}, globals, locals || {}), params = $injector.annotate(fn), ensureExist = assertPredicate(function(key) {
                return all$$1.hasOwnProperty(key);
            }, function(key) {
                return "DI can't find injectable: '" + key + "'";
            }), args = params.filter(ensureExist).map(function(x) {
                return all$$1[x];
            });
            return isFunction(fn) ? fn.apply(context, args) : fn.slice(-1)[0].apply(context, args);
        },
        annotate: function(fn) {
            if (!isInjectable(fn)) throw new Error("Not an injectable function: " + fn);
            if (fn && fn.$inject) return fn.$inject;
            if (isArray(fn)) return fn.slice(0, -1);
            var fnStr = fn.toString().replace(STRIP_COMMENTS, ""), result = fnStr.slice(fnStr.indexOf("(") + 1, fnStr.indexOf(")")).match(ARGUMENT_NAMES);
            return result || [];
        }
    }, keyValsToObjectR = function(accum, _a) {
        var key = _a[0], val$$1 = _a[1];
        return accum.hasOwnProperty(key) ? isArray(accum[key]) ? accum[key].push(val$$1) : accum[key] = [ accum[key], val$$1 ] : accum[key] = val$$1, 
        accum;
    }, getParams = function(queryString) {
        return queryString.split("&").filter(identity).map(splitEqual).reduce(keyValsToObjectR, {});
    }, buildUrl = function(loc) {
        var path = loc.path(), searchObject = loc.search(), hash = loc.hash(), search = Object.keys(searchObject).map(function(key) {
            var param = searchObject[key], vals = isArray(param) ? param : [ param ];
            return vals.map(function(val$$1) {
                return key + "=" + val$$1;
            });
        }).reduce(unnestR, []).join("&");
        return path + (search ? "?" + search : "") + (hash ? "#" + hash : "");
    }, BaseLocationServices = function() {
        function BaseLocationServices(router, fireAfterUpdate) {
            var _this = this;
            this.fireAfterUpdate = fireAfterUpdate, this._listeners = [], this._listener = function(evt) {
                return _this._listeners.forEach(function(cb) {
                    return cb(evt);
                });
            }, this.hash = function() {
                return parseUrl$1(_this._get()).hash;
            }, this.path = function() {
                return parseUrl$1(_this._get()).path;
            }, this.search = function() {
                return getParams(parseUrl$1(_this._get()).search);
            }, this._location = root.location, this._history = root.history;
        }
        return BaseLocationServices.prototype.url = function(url, replace) {
            return void 0 === replace && (replace = !0), isDefined(url) && url !== this._get() && (this._set(null, null, url, replace), 
            this.fireAfterUpdate && this._listeners.forEach(function(cb) {
                return cb({
                    url: url
                });
            })), buildUrl(this);
        }, BaseLocationServices.prototype.onChange = function(cb) {
            var _this = this;
            return this._listeners.push(cb), function() {
                return removeFrom(_this._listeners, cb);
            };
        }, BaseLocationServices.prototype.dispose = function() {
            deregAll(this._listeners);
        }, BaseLocationServices;
    }(), __extends = void 0 || function() {
        var extendStatics = Object.setPrototypeOf || {
            __proto__: []
        } instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for (var p in b) b.hasOwnProperty(p) && (d[p] = b[p]);
        };
        return function(d, b) {
            function __() {
                this.constructor = d;
            }
            extendStatics(d, b), d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, 
            new __());
        };
    }(), HashLocationService = function(_super) {
        function HashLocationService(router) {
            var _this = _super.call(this, router, !1) || this;
            return root.addEventListener("hashchange", _this._listener, !1), _this;
        }
        return __extends(HashLocationService, _super), HashLocationService.prototype._get = function() {
            return trimHashVal(this._location.hash);
        }, HashLocationService.prototype._set = function(state, title, url) {
            this._location.hash = url;
        }, HashLocationService.prototype.dispose = function(router) {
            _super.prototype.dispose.call(this, router), root.removeEventListener("hashchange", this._listener);
        }, HashLocationService;
    }(BaseLocationServices), __extends$1 = void 0 || function() {
        var extendStatics = Object.setPrototypeOf || {
            __proto__: []
        } instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for (var p in b) b.hasOwnProperty(p) && (d[p] = b[p]);
        };
        return function(d, b) {
            function __() {
                this.constructor = d;
            }
            extendStatics(d, b), d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, 
            new __());
        };
    }(), MemoryLocationService = function(_super) {
        function MemoryLocationService(router) {
            return _super.call(this, router, !0) || this;
        }
        return __extends$1(MemoryLocationService, _super), MemoryLocationService.prototype._get = function() {
            return this._url;
        }, MemoryLocationService.prototype._set = function(state, title, url) {
            this._url = url;
        }, MemoryLocationService;
    }(BaseLocationServices), __extends$2 = void 0 || function() {
        var extendStatics = Object.setPrototypeOf || {
            __proto__: []
        } instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for (var p in b) b.hasOwnProperty(p) && (d[p] = b[p]);
        };
        return function(d, b) {
            function __() {
                this.constructor = d;
            }
            extendStatics(d, b), d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, 
            new __());
        };
    }(), PushStateLocationService = function(_super) {
        function PushStateLocationService(router) {
            var _this = _super.call(this, router, !0) || this;
            return _this._config = router.urlService.config, root.addEventListener("popstate", _this._listener, !1), 
            _this;
        }
        return __extends$2(PushStateLocationService, _super), PushStateLocationService.prototype._getBasePrefix = function() {
            return stripLastPathElement(this._config.baseHref());
        }, PushStateLocationService.prototype._get = function() {
            var _a = this._location, pathname = _a.pathname, hash = _a.hash, search = _a.search;
            search = splitQuery(search)[1], hash = splitHash(hash)[1];
            var basePrefix = this._getBasePrefix(), exactBaseHrefMatch = pathname === this._config.baseHref(), startsWithBase = pathname.substr(0, basePrefix.length) === basePrefix;
            return pathname = exactBaseHrefMatch ? "/" : startsWithBase ? pathname.substring(basePrefix.length) : pathname, 
            pathname + (search ? "?" + search : "") + (hash ? "#" + hash : "");
        }, PushStateLocationService.prototype._set = function(state, title, url, replace) {
            var basePrefix = this._getBasePrefix(), slash = url && "/" !== url[0] ? "/" : "", fullUrl = "" === url || "/" === url ? this._config.baseHref() : basePrefix + slash + url;
            replace ? this._history.replaceState(state, title, fullUrl) : this._history.pushState(state, title, fullUrl);
        }, PushStateLocationService.prototype.dispose = function(router) {
            _super.prototype.dispose.call(this, router), root.removeEventListener("popstate", this._listener);
        }, PushStateLocationService;
    }(BaseLocationServices), MemoryLocationConfig = function() {
        function MemoryLocationConfig() {
            var _this = this;
            this.dispose = noop, this._baseHref = "", this._port = 80, this._protocol = "http", 
            this._host = "localhost", this._hashPrefix = "", this.port = function() {
                return _this._port;
            }, this.protocol = function() {
                return _this._protocol;
            }, this.host = function() {
                return _this._host;
            }, this.baseHref = function() {
                return _this._baseHref;
            }, this.html5Mode = function() {
                return !1;
            }, this.hashPrefix = function(newval) {
                return isDefined(newval) ? _this._hashPrefix = newval : _this._hashPrefix;
            };
        }
        return MemoryLocationConfig;
    }(), BrowserLocationConfig = function() {
        function BrowserLocationConfig(router, _isHtml5) {
            void 0 === _isHtml5 && (_isHtml5 = !1), this._isHtml5 = _isHtml5, this._baseHref = void 0, 
            this._hashPrefix = "";
        }
        return BrowserLocationConfig.prototype.port = function() {
            return location.port ? Number(location.port) : "https" === this.protocol() ? 443 : 80;
        }, BrowserLocationConfig.prototype.protocol = function() {
            return location.protocol.replace(/:/g, "");
        }, BrowserLocationConfig.prototype.host = function() {
            return location.hostname;
        }, BrowserLocationConfig.prototype.html5Mode = function() {
            return this._isHtml5;
        }, BrowserLocationConfig.prototype.hashPrefix = function(newprefix) {
            return isDefined(newprefix) ? this._hashPrefix = newprefix : this._hashPrefix;
        }, BrowserLocationConfig.prototype.baseHref = function(href) {
            return isDefined(href) && (this._baseHref = href), isUndefined(this._baseHref) && (this._baseHref = this.getBaseHref()), 
            this._baseHref;
        }, BrowserLocationConfig.prototype.getBaseHref = function() {
            var baseTag = document.getElementsByTagName("base")[0];
            return baseTag && baseTag.href ? baseTag.href.replace(/^(https?:)?\/\/[^\/]*/, "") : this._isHtml5 ? "/" : location.pathname || "/";
        }, BrowserLocationConfig.prototype.dispose = function() {}, BrowserLocationConfig;
    }(), hashLocationPlugin = locationPluginFactory("vanilla.hashBangLocation", !1, HashLocationService, BrowserLocationConfig), pushStateLocationPlugin = locationPluginFactory("vanilla.pushStateLocation", !0, PushStateLocationService, BrowserLocationConfig), memoryLocationPlugin = locationPluginFactory("vanilla.memoryLocation", !1, MemoryLocationService, MemoryLocationConfig), UIRouterPluginBase = function() {
        function UIRouterPluginBase() {}
        return UIRouterPluginBase.prototype.dispose = function() {}, UIRouterPluginBase;
    }(), index = Object.freeze({
        root: root,
        fromJson: fromJson,
        toJson: toJson,
        forEach: forEach,
        extend: extend,
        equals: equals,
        identity: identity,
        noop: noop,
        createProxyFunctions: createProxyFunctions,
        inherit: inherit,
        inArray: inArray,
        _inArray: _inArray,
        removeFrom: removeFrom,
        _removeFrom: _removeFrom,
        pushTo: pushTo,
        _pushTo: _pushTo,
        deregAll: deregAll,
        defaults: defaults,
        mergeR: mergeR,
        ancestors: ancestors,
        pick: pick,
        omit: omit,
        pluck: pluck,
        filter: filter,
        find: find,
        mapObj: mapObj,
        map: map,
        values: values,
        allTrueR: allTrueR,
        anyTrueR: anyTrueR,
        unnestR: unnestR,
        flattenR: flattenR,
        pushR: pushR,
        uniqR: uniqR,
        unnest: unnest,
        flatten: flatten,
        assertPredicate: assertPredicate,
        assertMap: assertMap,
        assertFn: assertFn,
        pairs: pairs,
        arrayTuples: arrayTuples,
        applyPairs: applyPairs,
        tail: tail,
        copy: copy,
        _extend: _extend,
        silenceUncaughtInPromise: silenceUncaughtInPromise,
        silentRejection: silentRejection,
        makeStub: makeStub,
        services: services,
        Glob: Glob,
        curry: curry,
        compose: compose,
        pipe: pipe,
        prop: prop,
        propEq: propEq,
        parse: parse,
        not: not,
        and: and,
        or: or,
        all: all,
        any: any,
        is: is,
        eq: eq,
        val: val,
        invoke: invoke,
        pattern: pattern,
        isUndefined: isUndefined,
        isDefined: isDefined,
        isNull: isNull,
        isNullOrUndefined: isNullOrUndefined,
        isFunction: isFunction,
        isNumber: isNumber,
        isString: isString,
        isObject: isObject,
        isArray: isArray,
        isDate: isDate,
        isRegExp: isRegExp,
        isInjectable: isInjectable,
        isPromise: isPromise,
        Queue: Queue,
        maxLength: maxLength,
        padString: padString,
        kebobString: kebobString,
        functionToString: functionToString,
        fnToString: fnToString,
        stringify: stringify,
        beforeAfterSubstr: beforeAfterSubstr,
        hostRegex: hostRegex,
        stripLastPathElement: stripLastPathElement,
        splitHash: splitHash,
        splitQuery: splitQuery,
        splitEqual: splitEqual,
        trimHashVal: trimHashVal,
        splitOnDelim: splitOnDelim,
        joinNeighborsR: joinNeighborsR,
        get Category() {
            return exports.Category;
        },
        Trace: Trace,
        trace: trace,
        get DefType() {
            return exports.DefType;
        },
        Param: Param,
        ParamTypes: ParamTypes,
        StateParams: StateParams,
        ParamType: ParamType,
        PathNode: PathNode,
        PathUtils: PathUtils,
        resolvePolicies: resolvePolicies,
        defaultResolvePolicy: defaultResolvePolicy,
        Resolvable: Resolvable,
        NATIVE_INJECTOR_TOKEN: NATIVE_INJECTOR_TOKEN,
        ResolveContext: ResolveContext,
        resolvablesBuilder: resolvablesBuilder,
        StateBuilder: StateBuilder,
        StateObject: StateObject,
        StateMatcher: StateMatcher,
        StateQueueManager: StateQueueManager,
        StateRegistry: StateRegistry,
        StateService: StateService,
        TargetState: TargetState,
        get TransitionHookPhase() {
            return exports.TransitionHookPhase;
        },
        get TransitionHookScope() {
            return exports.TransitionHookScope;
        },
        HookBuilder: HookBuilder,
        matchState: matchState,
        RegisteredHook: RegisteredHook,
        makeEvent: makeEvent,
        get RejectType() {
            return exports.RejectType;
        },
        Rejection: Rejection,
        Transition: Transition,
        TransitionHook: TransitionHook,
        TransitionEventType: TransitionEventType,
        defaultTransOpts: defaultTransOpts,
        TransitionService: TransitionService,
        UrlRules: UrlRules,
        UrlConfig: UrlConfig,
        UrlMatcher: UrlMatcher,
        ParamFactory: ParamFactory,
        UrlMatcherFactory: UrlMatcherFactory,
        UrlRouter: UrlRouter,
        UrlRuleFactory: UrlRuleFactory,
        BaseUrlRule: BaseUrlRule,
        UrlService: UrlService,
        ViewService: ViewService,
        UIRouterGlobals: UIRouterGlobals,
        UIRouter: UIRouter,
        $q: $q,
        $injector: $injector,
        BaseLocationServices: BaseLocationServices,
        HashLocationService: HashLocationService,
        MemoryLocationService: MemoryLocationService,
        PushStateLocationService: PushStateLocationService,
        MemoryLocationConfig: MemoryLocationConfig,
        BrowserLocationConfig: BrowserLocationConfig,
        keyValsToObjectR: keyValsToObjectR,
        getParams: getParams,
        parseUrl: parseUrl$1,
        buildUrl: buildUrl,
        locationPluginFactory: locationPluginFactory,
        servicesPlugin: servicesPlugin,
        hashLocationPlugin: hashLocationPlugin,
        pushStateLocationPlugin: pushStateLocationPlugin,
        memoryLocationPlugin: memoryLocationPlugin,
        UIRouterPluginBase: UIRouterPluginBase
    }), hasAnyKey = function(keys, obj) {
        return keys.reduce(function(acc, key) {
            return acc || isDefined(obj[key]);
        }, !1);
    }, id$1 = 0, Ng1ViewConfig = function() {
        function Ng1ViewConfig(path, viewDecl, factory) {
            var _this = this;
            this.path = path, this.viewDecl = viewDecl, this.factory = factory, this.$id = id$1++, 
            this.loaded = !1, this.getTemplate = function(uiView, context) {
                return _this.component ? _this.factory.makeComponentTemplate(uiView, context, _this.component, _this.viewDecl.bindings) : _this.template;
            };
        }
        return Ng1ViewConfig.prototype.load = function() {
            var _this = this, $q$$1 = services.$q, context = new ResolveContext(this.path), params = this.path.reduce(function(acc, node) {
                return extend(acc, node.paramValues);
            }, {}), promises = {
                template: $q$$1.when(this.factory.fromConfig(this.viewDecl, params, context)),
                controller: $q$$1.when(this.getController(context))
            };
            return $q$$1.all(promises).then(function(results) {
                return trace.traceViewServiceEvent("Loaded", _this), _this.controller = results.controller, 
                extend(_this, results.template), _this;
            });
        }, Ng1ViewConfig.prototype.getController = function(context) {
            var provider = this.viewDecl.controllerProvider;
            if (!isInjectable(provider)) return this.viewDecl.controller;
            var deps = services.$injector.annotate(provider), providerFn = isArray(provider) ? tail(provider) : provider, resolvable = new Resolvable("", providerFn, deps);
            return resolvable.get(context);
        }, Ng1ViewConfig;
    }(), TemplateFactory = function() {
        function TemplateFactory() {
            var _this = this;
            this._useHttp = ng.version.minor < 3, this.$get = [ "$http", "$templateCache", "$injector", function($http, $templateCache, $injector$$1) {
                return _this.$templateRequest = $injector$$1.has && $injector$$1.has("$templateRequest") && $injector$$1.get("$templateRequest"), 
                _this.$http = $http, _this.$templateCache = $templateCache, _this;
            } ];
        }
        return TemplateFactory.prototype.useHttpService = function(value) {
            this._useHttp = value;
        }, TemplateFactory.prototype.fromConfig = function(config, params, context) {
            var defaultTemplate = "<ui-view></ui-view>", asTemplate = function(result) {
                return services.$q.when(result).then(function(str) {
                    return {
                        template: str
                    };
                });
            }, asComponent = function(result) {
                return services.$q.when(result).then(function(str) {
                    return {
                        component: str
                    };
                });
            };
            return isDefined(config.template) ? asTemplate(this.fromString(config.template, params)) : isDefined(config.templateUrl) ? asTemplate(this.fromUrl(config.templateUrl, params)) : isDefined(config.templateProvider) ? asTemplate(this.fromProvider(config.templateProvider, params, context)) : isDefined(config.component) ? asComponent(config.component) : isDefined(config.componentProvider) ? asComponent(this.fromComponentProvider(config.componentProvider, params, context)) : asTemplate(defaultTemplate);
        }, TemplateFactory.prototype.fromString = function(template, params) {
            return isFunction(template) ? template(params) : template;
        }, TemplateFactory.prototype.fromUrl = function(url, params) {
            return isFunction(url) && (url = url(params)), null == url ? null : this._useHttp ? this.$http.get(url, {
                cache: this.$templateCache,
                headers: {
                    Accept: "text/html"
                }
            }).then(function(response) {
                return response.data;
            }) : this.$templateRequest(url);
        }, TemplateFactory.prototype.fromProvider = function(provider, params, context) {
            var deps = services.$injector.annotate(provider), providerFn = isArray(provider) ? tail(provider) : provider, resolvable = new Resolvable("", providerFn, deps);
            return resolvable.get(context);
        }, TemplateFactory.prototype.fromComponentProvider = function(provider, params, context) {
            var deps = services.$injector.annotate(provider), providerFn = isArray(provider) ? tail(provider) : provider, resolvable = new Resolvable("", providerFn, deps);
            return resolvable.get(context);
        }, TemplateFactory.prototype.makeComponentTemplate = function(uiView, context, component, bindings) {
            bindings = bindings || {};
            var prefix = ng.version.minor >= 3 ? "::" : "", kebob = function(camelCase) {
                var kebobed = kebobString(camelCase);
                return /^(x|data)-/.exec(kebobed) ? "x-" + kebobed : kebobed;
            }, attributeTpl = function(input) {
                var name = input.name, type = input.type, attrName = kebob(name);
                if (uiView.attr(attrName) && !bindings[name]) return attrName + "='" + uiView.attr(attrName) + "'";
                var resolveName = bindings[name] || name;
                if ("@" === type) return attrName + "='{{" + prefix + "$resolve." + resolveName + "}}'";
                if ("&" === type) {
                    var res = context.getResolvable(resolveName), fn = res && res.data, args = fn && services.$injector.annotate(fn) || [], arrayIdxStr = isArray(fn) ? "[" + (fn.length - 1) + "]" : "";
                    return attrName + "='$resolve." + resolveName + arrayIdxStr + "(" + args.join(",") + ")'";
                }
                return attrName + "='" + prefix + "$resolve." + resolveName + "'";
            }, attrs = getComponentBindings(component).map(attributeTpl).join(" "), kebobName = kebob(component);
            return "<" + kebobName + " " + attrs + "></" + kebobName + ">";
        }, TemplateFactory;
    }(), getBindings = function(def) {
        return scopeBindings(isObject(def.bindToController) ? def.bindToController : def.scope);
    }, scopeBindings = function(bindingsObj) {
        return Object.keys(bindingsObj || {}).map(function(key) {
            return [ key, /^([=<@&])[?]?(.*)/.exec(bindingsObj[key]) ];
        }).filter(function(tuple) {
            return isDefined(tuple) && isArray(tuple[1]);
        }).map(function(tuple) {
            return {
                name: tuple[1][2] || tuple[0],
                type: tuple[1][1]
            };
        });
    }, StateProvider = function() {
        function StateProvider(stateRegistry, stateService) {
            this.stateRegistry = stateRegistry, this.stateService = stateService, createProxyFunctions(val(StateProvider.prototype), this, val(this));
        }
        return StateProvider.prototype.decorator = function(name, func) {
            return this.stateRegistry.decorator(name, func) || this;
        }, StateProvider.prototype.state = function(name, definition) {
            return isObject(name) ? definition = name : definition.name = name, this.stateRegistry.register(definition), 
            this;
        }, StateProvider.prototype.onInvalid = function(callback) {
            return this.stateService.onInvalid(callback);
        }, StateProvider;
    }(), getStateHookBuilder = function(hookName) {
        return function(stateObject) {
            function decoratedNg1Hook(trans, state) {
                var resolveContext = new ResolveContext(trans.treeChanges(pathname)), subContext = resolveContext.subContext(state.$$state()), locals = extend(getLocals(subContext), {
                    $state$: state,
                    $transition$: trans
                });
                return services.$injector.invoke(hook, this, locals);
            }
            var hook = stateObject[hookName], pathname = "onExit" === hookName ? "from" : "to";
            return hook ? decoratedNg1Hook : void 0;
        };
    }, Ng1LocationServices = function() {
        function Ng1LocationServices($locationProvider) {
            this._urlListeners = [], this.$locationProvider = $locationProvider;
            var _lp = val($locationProvider);
            createProxyFunctions(_lp, this, _lp, [ "hashPrefix" ]);
        }
        return Ng1LocationServices.monkeyPatchPathParameterType = function(router) {
            var pathType = router.urlMatcherFactory.type("path");
            pathType.encode = function(x) {
                return null != x ? x.toString().replace(/(~|\/)/g, function(m) {
                    return {
                        "~": "~~",
                        "/": "~2F"
                    }[m];
                }) : x;
            }, pathType.decode = function(x) {
                return null != x ? x.toString().replace(/(~~|~2F)/g, function(m) {
                    return {
                        "~~": "~",
                        "~2F": "/"
                    }[m];
                }) : x;
            };
        }, Ng1LocationServices.prototype.dispose = function() {}, Ng1LocationServices.prototype.onChange = function(callback) {
            var _this = this;
            return this._urlListeners.push(callback), function() {
                return removeFrom(_this._urlListeners)(callback);
            };
        }, Ng1LocationServices.prototype.html5Mode = function() {
            var html5Mode = this.$locationProvider.html5Mode();
            return html5Mode = isObject(html5Mode) ? html5Mode.enabled : html5Mode, html5Mode && this.$sniffer.history;
        }, Ng1LocationServices.prototype.baseHref = function() {
            return this._baseHref || (this._baseHref = this.$browser.baseHref() || this.$window.location.pathname);
        }, Ng1LocationServices.prototype.url = function(newUrl, replace, state) {
            return void 0 === replace && (replace = !1), isDefined(newUrl) && this.$location.url(newUrl), 
            replace && this.$location.replace(), state && this.$location.state(state), this.$location.url();
        }, Ng1LocationServices.prototype._runtimeServices = function($rootScope, $location, $sniffer, $browser, $window) {
            var _this = this;
            this.$location = $location, this.$sniffer = $sniffer, this.$browser = $browser, 
            this.$window = $window, $rootScope.$on("$locationChangeSuccess", function(evt) {
                return _this._urlListeners.forEach(function(fn) {
                    return fn(evt);
                });
            });
            var _loc = val($location);
            createProxyFunctions(_loc, this, _loc, [ "replace", "path", "search", "hash" ]), 
            createProxyFunctions(_loc, this, _loc, [ "port", "protocol", "host" ]);
        }, Ng1LocationServices;
    }(), UrlRouterProvider = function() {
        function UrlRouterProvider(router) {
            this.router = router;
        }
        return UrlRouterProvider.injectableHandler = function(router, handler) {
            return function(match) {
                return services.$injector.invoke(handler, null, {
                    $match: match,
                    $stateParams: router.globals.params
                });
            };
        }, UrlRouterProvider.prototype.$get = function() {
            var urlService = this.router.urlService;
            return this.router.urlRouter.update(!0), urlService.interceptDeferred || urlService.listen(), 
            this.router.urlRouter;
        }, UrlRouterProvider.prototype.rule = function(ruleFn) {
            var _this = this;
            if (!isFunction(ruleFn)) throw new Error("'rule' must be a function");
            var match = function() {
                return ruleFn(services.$injector, _this.router.locationService);
            }, rule = new BaseUrlRule(match, identity);
            return this.router.urlService.rules.rule(rule), this;
        }, UrlRouterProvider.prototype.otherwise = function(rule) {
            var _this = this, urlRules = this.router.urlService.rules;
            if (isString(rule)) urlRules.otherwise(rule); else {
                if (!isFunction(rule)) throw new Error("'rule' must be a string or function");
                urlRules.otherwise(function() {
                    return rule(services.$injector, _this.router.locationService);
                });
            }
            return this;
        }, UrlRouterProvider.prototype.when = function(what, handler) {
            return (isArray(handler) || isFunction(handler)) && (handler = UrlRouterProvider.injectableHandler(this.router, handler)), 
            this.router.urlService.rules.when(what, handler), this;
        }, UrlRouterProvider.prototype.deferIntercept = function(defer) {
            this.router.urlService.deferIntercept(defer);
        }, UrlRouterProvider;
    }();
    ng.module("ui.router.angular1", []);
    var mod_init = ng.module("ui.router.init", [ "ng" ]), mod_util = ng.module("ui.router.util", [ "ui.router.init" ]), mod_rtr = ng.module("ui.router.router", [ "ui.router.util" ]), mod_state = ng.module("ui.router.state", [ "ui.router.router", "ui.router.util", "ui.router.angular1" ]), mod_main = ng.module("ui.router", [ "ui.router.init", "ui.router.state", "ui.router.angular1" ]), router = (ng.module("ui.router.compat", [ "ui.router" ]), 
    null);
    $uiRouterProvider.$inject = [ "$locationProvider" ];
    var getProviderFor = function(serviceName) {
        return [ "$uiRouterProvider", function($urp) {
            var service = $urp.router[serviceName];
            return service.$get = function() {
                return service;
            }, service;
        } ];
    };
    runBlock.$inject = [ "$injector", "$q", "$uiRouter" ];
    var getUrlRouterProvider = function(uiRouter) {
        return uiRouter.urlRouterProvider = new UrlRouterProvider(uiRouter);
    }, getStateProvider = function() {
        return extend(router.stateProvider, {
            $get: function() {
                return router.stateService;
            }
        });
    };
    watchDigests.$inject = [ "$rootScope" ], mod_init.provider("$uiRouter", $uiRouterProvider), 
    mod_rtr.provider("$urlRouter", [ "$uiRouterProvider", getUrlRouterProvider ]), mod_util.provider("$urlService", getProviderFor("urlService")), 
    mod_util.provider("$urlMatcherFactory", [ "$uiRouterProvider", function() {
        return router.urlMatcherFactory;
    } ]), mod_util.provider("$templateFactory", function() {
        return new TemplateFactory();
    }), mod_state.provider("$stateRegistry", getProviderFor("stateRegistry")), mod_state.provider("$uiRouterGlobals", getProviderFor("globals")), 
    mod_state.provider("$transitions", getProviderFor("transitionService")), mod_state.provider("$state", [ "$uiRouterProvider", getStateProvider ]), 
    mod_state.factory("$stateParams", [ "$uiRouter", function($uiRouter) {
        return $uiRouter.globals.params;
    } ]), mod_main.factory("$view", function() {
        return router.viewService;
    }), mod_main.service("$trace", function() {
        return trace;
    }), mod_main.run(watchDigests), mod_util.run([ "$urlMatcherFactory", function() {} ]), 
    mod_state.run([ "$state", function() {} ]), mod_rtr.run([ "$urlRouter", function() {} ]), 
    mod_init.run(runBlock);
    var uiSrefDirective, getLocals = function(ctx) {
        var tokens = ctx.getTokens().filter(isString), tuples = tokens.map(function(key) {
            var resolvable = ctx.getResolvable(key), waitPolicy = ctx.getPolicy(resolvable).async;
            return [ key, "NOWAIT" === waitPolicy ? resolvable.promise : resolvable.data ];
        });
        return tuples.reduce(applyPairs, {});
    };
    uiSrefDirective = [ "$uiRouter", "$timeout", function($uiRouter, $timeout) {
        var $state = $uiRouter.stateService;
        return {
            restrict: "A",
            require: [ "?^uiSrefActive", "?^uiSrefActiveEq" ],
            link: function(scope, element, attrs, uiSrefActive) {
                function update() {
                    var def = getDef();
                    unlinkInfoFn && unlinkInfoFn(), active && (unlinkInfoFn = active.$$addStateInfo(def.uiState, def.uiStateParams)), 
                    null != def.href && attrs.$set(type.attr, def.href);
                }
                var hookFn, type = getTypeInfo(element), active = uiSrefActive[1] || uiSrefActive[0], unlinkInfoFn = null, rawDef = {}, getDef = function() {
                    return processedDef($state, element, rawDef);
                }, ref = parseStateRef(attrs.uiSref);
                rawDef.uiState = ref.state, rawDef.uiStateOpts = attrs.uiSrefOpts ? scope.$eval(attrs.uiSrefOpts) : {}, 
                ref.paramExpr && (scope.$watch(ref.paramExpr, function(val$$1) {
                    rawDef.uiStateParams = extend({}, val$$1), update();
                }, !0), rawDef.uiStateParams = extend({}, scope.$eval(ref.paramExpr))), update(), 
                scope.$on("$destroy", $uiRouter.stateRegistry.onStatesChanged(update)), scope.$on("$destroy", $uiRouter.transitionService.onSuccess({}, update)), 
                type.clickable && (hookFn = clickHook(element, $state, $timeout, type, getDef), 
                bindEvents(element, scope, hookFn, rawDef.uiStateOpts));
            }
        };
    } ];
    var uiStateDirective;
    uiStateDirective = [ "$uiRouter", "$timeout", function($uiRouter, $timeout) {
        var $state = $uiRouter.stateService;
        return {
            restrict: "A",
            require: [ "?^uiSrefActive", "?^uiSrefActiveEq" ],
            link: function(scope, element, attrs, uiSrefActive) {
                function update() {
                    var def = getDef();
                    unlinkInfoFn && unlinkInfoFn(), active && (unlinkInfoFn = active.$$addStateInfo(def.uiState, def.uiStateParams)), 
                    null != def.href && attrs.$set(type.attr, def.href);
                }
                var hookFn, type = getTypeInfo(element), active = uiSrefActive[1] || uiSrefActive[0], unlinkInfoFn = null, rawDef = {}, getDef = function() {
                    return processedDef($state, element, rawDef);
                }, inputAttrs = [ "uiState", "uiStateParams", "uiStateOpts" ], watchDeregFns = inputAttrs.reduce(function(acc, attr) {
                    return acc[attr] = noop, acc;
                }, {});
                inputAttrs.forEach(function(field) {
                    rawDef[field] = attrs[field] ? scope.$eval(attrs[field]) : null, attrs.$observe(field, function(expr) {
                        watchDeregFns[field](), watchDeregFns[field] = scope.$watch(expr, function(newval) {
                            rawDef[field] = newval, update();
                        }, !0);
                    });
                }), update(), scope.$on("$destroy", $uiRouter.stateRegistry.onStatesChanged(update)), 
                scope.$on("$destroy", $uiRouter.transitionService.onSuccess({}, update)), type.clickable && (hookFn = clickHook(element, $state, $timeout, type, getDef), 
                bindEvents(element, scope, hookFn, rawDef.uiStateOpts));
            }
        };
    } ];
    var uiSrefActiveDirective;
    uiSrefActiveDirective = [ "$state", "$stateParams", "$interpolate", "$uiRouter", function($state, $stateParams, $interpolate, $uiRouter) {
        return {
            restrict: "A",
            controller: [ "$scope", "$element", "$attrs", function($scope, $element, $attrs) {
                function updateAfterTransition(trans) {
                    trans.promise.then(update, noop);
                }
                function setupEventListeners() {
                    var deregisterStatesChangedListener = $uiRouter.stateRegistry.onStatesChanged(handleStatesChanged), deregisterOnStartListener = $uiRouter.transitionService.onStart({}, updateAfterTransition), deregisterStateChangeSuccessListener = $scope.$on("$stateChangeSuccess", update);
                    return function() {
                        deregisterStatesChangedListener(), deregisterOnStartListener(), deregisterStateChangeSuccessListener();
                    };
                }
                function handleStatesChanged() {
                    setStatesFromDefinitionObject(uiSrefActive);
                }
                function setStatesFromDefinitionObject(statesDefinition) {
                    isObject(statesDefinition) && (states = [], forEach(statesDefinition, function(stateOrName, activeClass) {
                        var addStateForClass = function(stateOrName, activeClass) {
                            var ref = parseStateRef(stateOrName);
                            addState(ref.state, $scope.$eval(ref.paramExpr), activeClass);
                        };
                        isString(stateOrName) ? addStateForClass(stateOrName, activeClass) : isArray(stateOrName) && forEach(stateOrName, function(stateOrName) {
                            addStateForClass(stateOrName, activeClass);
                        });
                    }));
                }
                function addState(stateName, stateParams, activeClass) {
                    var state = $state.get(stateName, stateContext($element)), stateInfo = {
                        state: state || {
                            name: stateName
                        },
                        params: stateParams,
                        activeClass: activeClass
                    };
                    return states.push(stateInfo), function() {
                        removeFrom(states)(stateInfo);
                    };
                }
                function update() {
                    var splitClasses = function(str) {
                        return str.split(/\s/).filter(identity);
                    }, getClasses = function(stateList) {
                        return stateList.map(function(x) {
                            return x.activeClass;
                        }).map(splitClasses).reduce(unnestR, []);
                    }, allClasses = getClasses(states).concat(splitClasses(activeEqClass)).reduce(uniqR, []), fuzzyClasses = getClasses(states.filter(function(x) {
                        return $state.includes(x.state.name, x.params);
                    })), exactlyMatchesAny = !!states.filter(function(x) {
                        return $state.is(x.state.name, x.params);
                    }).length, exactClasses = exactlyMatchesAny ? splitClasses(activeEqClass) : [], addClasses = fuzzyClasses.concat(exactClasses).reduce(uniqR, []), removeClasses = allClasses.filter(function(cls) {
                        return !inArray(addClasses, cls);
                    });
                    $scope.$evalAsync(function() {
                        addClasses.forEach(function(className) {
                            return $element.addClass(className);
                        }), removeClasses.forEach(function(className) {
                            return $element.removeClass(className);
                        });
                    });
                }
                var activeEqClass, uiSrefActive, states = [];
                activeEqClass = $interpolate($attrs.uiSrefActiveEq || "", !1)($scope);
                try {
                    uiSrefActive = $scope.$eval($attrs.uiSrefActive);
                } catch (e) {}
                uiSrefActive = uiSrefActive || $interpolate($attrs.uiSrefActive || "", !1)($scope), 
                setStatesFromDefinitionObject(uiSrefActive), this.$$addStateInfo = function(newState, newParams) {
                    if (!(isObject(uiSrefActive) && states.length > 0)) {
                        var deregister = addState(newState, newParams, uiSrefActive);
                        return update(), deregister;
                    }
                }, $scope.$on("$destroy", setupEventListeners()), $uiRouter.globals.transition && updateAfterTransition($uiRouter.globals.transition), 
                update();
            } ]
        };
    } ], ng.module("ui.router.state").directive("uiSref", uiSrefDirective).directive("uiSrefActive", uiSrefActiveDirective).directive("uiSrefActiveEq", uiSrefActiveDirective).directive("uiState", uiStateDirective), 
    $IsStateFilter.$inject = [ "$state" ], $IncludedByStateFilter.$inject = [ "$state" ], 
    ng.module("ui.router.state").filter("isState", $IsStateFilter).filter("includedByState", $IncludedByStateFilter);
    var uiView;
    uiView = [ "$view", "$animate", "$uiViewScroll", "$interpolate", "$q", function($view, $animate, $uiViewScroll, $interpolate, $q$$1) {
        function getRenderer() {
            return {
                enter: function(element, target, cb) {
                    ng.version.minor > 2 ? $animate.enter(element, null, target).then(cb) : $animate.enter(element, null, target, cb);
                },
                leave: function(element, cb) {
                    ng.version.minor > 2 ? $animate.leave(element).then(cb) : $animate.leave(element, cb);
                }
            };
        }
        function configsEqual(config1, config2) {
            return config1 === config2;
        }
        var rootData = {
            $cfg: {
                viewDecl: {
                    $context: $view._pluginapi._rootViewContext()
                }
            },
            $uiView: {}
        }, directive = {
            count: 0,
            restrict: "ECA",
            terminal: !0,
            priority: 400,
            transclude: "element",
            compile: function(tElement, tAttrs, $transclude) {
                return function(scope, $element, attrs) {
                    function configUpdatedCallback(config) {
                        (!config || config instanceof Ng1ViewConfig) && (configsEqual(viewConfig, config) || (trace.traceUIViewConfigUpdated(activeUIView, config && config.viewDecl && config.viewDecl.$context), 
                        viewConfig = config, updateView(config)));
                    }
                    function cleanupLastView() {
                        if (previousEl && (trace.traceUIViewEvent("Removing (previous) el", previousEl.data("$uiView")), 
                        previousEl.remove(), previousEl = null), currentScope && (trace.traceUIViewEvent("Destroying scope", activeUIView), 
                        currentScope.$destroy(), currentScope = null), currentEl) {
                            var _viewData_1 = currentEl.data("$uiViewAnim");
                            trace.traceUIViewEvent("Animate out", _viewData_1), renderer.leave(currentEl, function() {
                                _viewData_1.$$animLeave.resolve(), previousEl = null;
                            }), previousEl = currentEl, currentEl = null;
                        }
                    }
                    function updateView(config) {
                        var newScope = scope.$new(), animEnter = $q$$1.defer(), animLeave = $q$$1.defer(), $uiViewData = {
                            $cfg: config,
                            $uiView: activeUIView
                        }, $uiViewAnim = {
                            $animEnter: animEnter.promise,
                            $animLeave: animLeave.promise,
                            $$animLeave: animLeave
                        };
                        newScope.$emit("$viewContentLoading", name);
                        var cloned = $transclude(newScope, function(clone) {
                            clone.data("$uiViewAnim", $uiViewAnim), clone.data("$uiView", $uiViewData), renderer.enter(clone, $element, function() {
                                animEnter.resolve(), currentScope && currentScope.$emit("$viewContentAnimationEnded"), 
                                (isDefined(autoScrollExp) && !autoScrollExp || scope.$eval(autoScrollExp)) && $uiViewScroll(clone);
                            }), cleanupLastView();
                        });
                        currentEl = cloned, currentScope = newScope, currentScope.$emit("$viewContentLoaded", config || viewConfig), 
                        currentScope.$eval(onloadExp);
                    }
                    var previousEl, currentEl, currentScope, viewConfig, unregister, onloadExp = attrs.onload || "", autoScrollExp = attrs.autoscroll, renderer = getRenderer(attrs, scope), inherited = $element.inheritedData("$uiView") || rootData, name = $interpolate(attrs.uiView || attrs.name || "")(scope) || "$default", activeUIView = {
                        $type: "ng1",
                        id: directive.count++,
                        name: name,
                        fqn: inherited.$uiView.fqn ? inherited.$uiView.fqn + "." + name : name,
                        config: null,
                        configUpdated: configUpdatedCallback,
                        get creationContext() {
                            var fromParentTagConfig = parse("$cfg.viewDecl.$context")(inherited), fromParentTag = parse("$uiView.creationContext")(inherited);
                            return fromParentTagConfig || fromParentTag;
                        }
                    };
                    trace.traceUIViewEvent("Linking", activeUIView), $element.data("$uiView", {
                        $uiView: activeUIView
                    }), updateView(), unregister = $view.registerUIView(activeUIView), scope.$on("$destroy", function() {
                        trace.traceUIViewEvent("Destroying/Unregistering", activeUIView), unregister();
                    });
                };
            }
        };
        return directive;
    } ], $ViewDirectiveFill.$inject = [ "$compile", "$controller", "$transitions", "$view", "$q", "$timeout" ];
    var hasComponentImpl = "function" == typeof ng.module("ui.router").component, _uiCanExitId = 0;
    ng.module("ui.router.state").directive("uiView", uiView), ng.module("ui.router.state").directive("uiView", $ViewDirectiveFill), 
    ng.module("ui.router.state").provider("$uiViewScroll", $ViewScrollProvider);
    var index$1 = "ui.router";
    exports.default = index$1, exports.core = index, exports.watchDigests = watchDigests, 
    exports.getLocals = getLocals, exports.getNg1ViewConfigFactory = getNg1ViewConfigFactory, 
    exports.ng1ViewsBuilder = ng1ViewsBuilder, exports.Ng1ViewConfig = Ng1ViewConfig, 
    exports.StateProvider = StateProvider, exports.UrlRouterProvider = UrlRouterProvider, 
    exports.root = root, exports.fromJson = fromJson, exports.toJson = toJson, exports.forEach = forEach, 
    exports.extend = extend, exports.equals = equals, exports.identity = identity, exports.noop = noop, 
    exports.createProxyFunctions = createProxyFunctions, exports.inherit = inherit, 
    exports.inArray = inArray, exports._inArray = _inArray, exports.removeFrom = removeFrom, 
    exports._removeFrom = _removeFrom, exports.pushTo = pushTo, exports._pushTo = _pushTo, 
    exports.deregAll = deregAll, exports.defaults = defaults, exports.mergeR = mergeR, 
    exports.ancestors = ancestors, exports.pick = pick, exports.omit = omit, exports.pluck = pluck, 
    exports.filter = filter, exports.find = find, exports.mapObj = mapObj, exports.map = map, 
    exports.values = values, exports.allTrueR = allTrueR, exports.anyTrueR = anyTrueR, 
    exports.unnestR = unnestR, exports.flattenR = flattenR, exports.pushR = pushR, exports.uniqR = uniqR, 
    exports.unnest = unnest, exports.flatten = flatten, exports.assertPredicate = assertPredicate, 
    exports.assertMap = assertMap, exports.assertFn = assertFn, exports.pairs = pairs, 
    exports.arrayTuples = arrayTuples, exports.applyPairs = applyPairs, exports.tail = tail, 
    exports.copy = copy, exports._extend = _extend, exports.silenceUncaughtInPromise = silenceUncaughtInPromise, 
    exports.silentRejection = silentRejection, exports.makeStub = makeStub, exports.services = services, 
    exports.Glob = Glob, exports.curry = curry, exports.compose = compose, exports.pipe = pipe, 
    exports.prop = prop, exports.propEq = propEq, exports.parse = parse, exports.not = not, 
    exports.and = and, exports.or = or, exports.all = all, exports.any = any, exports.is = is, 
    exports.eq = eq, exports.val = val, exports.invoke = invoke, exports.pattern = pattern, 
    exports.isUndefined = isUndefined, exports.isDefined = isDefined, exports.isNull = isNull, 
    exports.isNullOrUndefined = isNullOrUndefined, exports.isFunction = isFunction, 
    exports.isNumber = isNumber, exports.isString = isString, exports.isObject = isObject, 
    exports.isArray = isArray, exports.isDate = isDate, exports.isRegExp = isRegExp, 
    exports.isInjectable = isInjectable, exports.isPromise = isPromise, exports.Queue = Queue, 
    exports.maxLength = maxLength, exports.padString = padString, exports.kebobString = kebobString, 
    exports.functionToString = functionToString, exports.fnToString = fnToString, exports.stringify = stringify, 
    exports.beforeAfterSubstr = beforeAfterSubstr, exports.hostRegex = hostRegex, exports.stripLastPathElement = stripLastPathElement, 
    exports.splitHash = splitHash, exports.splitQuery = splitQuery, exports.splitEqual = splitEqual, 
    exports.trimHashVal = trimHashVal, exports.splitOnDelim = splitOnDelim, exports.joinNeighborsR = joinNeighborsR, 
    exports.Trace = Trace, exports.trace = trace, exports.Param = Param, exports.ParamTypes = ParamTypes, 
    exports.StateParams = StateParams, exports.ParamType = ParamType, exports.PathNode = PathNode, 
    exports.PathUtils = PathUtils, exports.resolvePolicies = resolvePolicies, exports.defaultResolvePolicy = defaultResolvePolicy, 
    exports.Resolvable = Resolvable, exports.NATIVE_INJECTOR_TOKEN = NATIVE_INJECTOR_TOKEN, 
    exports.ResolveContext = ResolveContext, exports.resolvablesBuilder = resolvablesBuilder, 
    exports.StateBuilder = StateBuilder, exports.StateObject = StateObject, exports.StateMatcher = StateMatcher, 
    exports.StateQueueManager = StateQueueManager, exports.StateRegistry = StateRegistry, 
    exports.StateService = StateService, exports.TargetState = TargetState, exports.HookBuilder = HookBuilder, 
    exports.matchState = matchState, exports.RegisteredHook = RegisteredHook, exports.makeEvent = makeEvent, 
    exports.Rejection = Rejection, exports.Transition = Transition, exports.TransitionHook = TransitionHook, 
    exports.TransitionEventType = TransitionEventType, exports.defaultTransOpts = defaultTransOpts, 
    exports.TransitionService = TransitionService, exports.UrlRules = UrlRules, exports.UrlConfig = UrlConfig, 
    exports.UrlMatcher = UrlMatcher, exports.ParamFactory = ParamFactory, exports.UrlMatcherFactory = UrlMatcherFactory, 
    exports.UrlRouter = UrlRouter, exports.UrlRuleFactory = UrlRuleFactory, exports.BaseUrlRule = BaseUrlRule, 
    exports.UrlService = UrlService, exports.ViewService = ViewService, exports.UIRouterGlobals = UIRouterGlobals, 
    exports.UIRouter = UIRouter, exports.$q = $q, exports.$injector = $injector, exports.BaseLocationServices = BaseLocationServices, 
    exports.HashLocationService = HashLocationService, exports.MemoryLocationService = MemoryLocationService, 
    exports.PushStateLocationService = PushStateLocationService, exports.MemoryLocationConfig = MemoryLocationConfig, 
    exports.BrowserLocationConfig = BrowserLocationConfig, exports.keyValsToObjectR = keyValsToObjectR, 
    exports.getParams = getParams, exports.parseUrl = parseUrl$1, exports.buildUrl = buildUrl, 
    exports.locationPluginFactory = locationPluginFactory, exports.servicesPlugin = servicesPlugin, 
    exports.hashLocationPlugin = hashLocationPlugin, exports.pushStateLocationPlugin = pushStateLocationPlugin, 
    exports.memoryLocationPlugin = memoryLocationPlugin, exports.UIRouterPluginBase = UIRouterPluginBase, 
    Object.defineProperty(exports, "__esModule", {
        value: !0
    });
}), angular.module("ui.bootstrap", [ "ui.bootstrap.tpls", "ui.bootstrap.collapse", "ui.bootstrap.tabindex", "ui.bootstrap.accordion", "ui.bootstrap.alert", "ui.bootstrap.buttons", "ui.bootstrap.carousel", "ui.bootstrap.dateparser", "ui.bootstrap.isClass", "ui.bootstrap.datepicker", "ui.bootstrap.position", "ui.bootstrap.datepickerPopup", "ui.bootstrap.debounce", "ui.bootstrap.dropdown", "ui.bootstrap.stackedMap", "ui.bootstrap.modal", "ui.bootstrap.paging", "ui.bootstrap.pager", "ui.bootstrap.pagination", "ui.bootstrap.tooltip", "ui.bootstrap.popover", "ui.bootstrap.progressbar", "ui.bootstrap.rating", "ui.bootstrap.tabs", "ui.bootstrap.timepicker", "ui.bootstrap.typeahead" ]), 
angular.module("ui.bootstrap.tpls", [ "uib/template/accordion/accordion-group.html", "uib/template/accordion/accordion.html", "uib/template/alert/alert.html", "uib/template/carousel/carousel.html", "uib/template/carousel/slide.html", "uib/template/datepicker/datepicker.html", "uib/template/datepicker/day.html", "uib/template/datepicker/month.html", "uib/template/datepicker/year.html", "uib/template/datepickerPopup/popup.html", "uib/template/modal/window.html", "uib/template/pager/pager.html", "uib/template/pagination/pagination.html", "uib/template/tooltip/tooltip-html-popup.html", "uib/template/tooltip/tooltip-popup.html", "uib/template/tooltip/tooltip-template-popup.html", "uib/template/popover/popover-html.html", "uib/template/popover/popover-template.html", "uib/template/popover/popover.html", "uib/template/progressbar/bar.html", "uib/template/progressbar/progress.html", "uib/template/progressbar/progressbar.html", "uib/template/rating/rating.html", "uib/template/tabs/tab.html", "uib/template/tabs/tabset.html", "uib/template/timepicker/timepicker.html", "uib/template/typeahead/typeahead-match.html", "uib/template/typeahead/typeahead-popup.html" ]), 
angular.module("ui.bootstrap.collapse", []).directive("uibCollapse", [ "$animate", "$q", "$parse", "$injector", function($animate, $q, $parse, $injector) {
    var $animateCss = $injector.has("$animateCss") ? $injector.get("$animateCss") : null;
    return {
        link: function(scope, element, attrs) {
            function init() {
                horizontal = !!("horizontal" in attrs), horizontal ? (css = {
                    width: ""
                }, cssTo = {
                    width: "0"
                }) : (css = {
                    height: ""
                }, cssTo = {
                    height: "0"
                }), scope.$eval(attrs.uibCollapse) || element.addClass("in").addClass("collapse").attr("aria-expanded", !0).attr("aria-hidden", !1).css(css);
            }
            function getScrollFromElement(element) {
                return horizontal ? {
                    width: element.scrollWidth + "px"
                } : {
                    height: element.scrollHeight + "px"
                };
            }
            function expand() {
                element.hasClass("collapse") && element.hasClass("in") || $q.resolve(expandingExpr(scope)).then(function() {
                    element.removeClass("collapse").addClass("collapsing").attr("aria-expanded", !0).attr("aria-hidden", !1), 
                    $animateCss ? $animateCss(element, {
                        addClass: "in",
                        easing: "ease",
                        css: {
                            overflow: "hidden"
                        },
                        to: getScrollFromElement(element[0])
                    }).start()["finally"](expandDone) : $animate.addClass(element, "in", {
                        css: {
                            overflow: "hidden"
                        },
                        to: getScrollFromElement(element[0])
                    }).then(expandDone);
                });
            }
            function expandDone() {
                element.removeClass("collapsing").addClass("collapse").css(css), expandedExpr(scope);
            }
            function collapse() {
                return element.hasClass("collapse") || element.hasClass("in") ? void $q.resolve(collapsingExpr(scope)).then(function() {
                    element.css(getScrollFromElement(element[0])).removeClass("collapse").addClass("collapsing").attr("aria-expanded", !1).attr("aria-hidden", !0), 
                    $animateCss ? $animateCss(element, {
                        removeClass: "in",
                        to: cssTo
                    }).start()["finally"](collapseDone) : $animate.removeClass(element, "in", {
                        to: cssTo
                    }).then(collapseDone);
                }) : collapseDone();
            }
            function collapseDone() {
                element.css(cssTo), element.removeClass("collapsing").addClass("collapse"), collapsedExpr(scope);
            }
            var expandingExpr = $parse(attrs.expanding), expandedExpr = $parse(attrs.expanded), collapsingExpr = $parse(attrs.collapsing), collapsedExpr = $parse(attrs.collapsed), horizontal = !1, css = {}, cssTo = {};
            init(), scope.$watch(attrs.uibCollapse, function(shouldCollapse) {
                shouldCollapse ? collapse() : expand();
            });
        }
    };
} ]), angular.module("ui.bootstrap.tabindex", []).directive("uibTabindexToggle", function() {
    return {
        restrict: "A",
        link: function(scope, elem, attrs) {
            attrs.$observe("disabled", function(disabled) {
                attrs.$set("tabindex", disabled ? -1 : null);
            });
        }
    };
}), angular.module("ui.bootstrap.accordion", [ "ui.bootstrap.collapse", "ui.bootstrap.tabindex" ]).constant("uibAccordionConfig", {
    closeOthers: !0
}).controller("UibAccordionController", [ "$scope", "$attrs", "uibAccordionConfig", function($scope, $attrs, accordionConfig) {
    this.groups = [], this.closeOthers = function(openGroup) {
        var closeOthers = angular.isDefined($attrs.closeOthers) ? $scope.$eval($attrs.closeOthers) : accordionConfig.closeOthers;
        closeOthers && angular.forEach(this.groups, function(group) {
            group !== openGroup && (group.isOpen = !1);
        });
    }, this.addGroup = function(groupScope) {
        var that = this;
        this.groups.push(groupScope), groupScope.$on("$destroy", function() {
            that.removeGroup(groupScope);
        });
    }, this.removeGroup = function(group) {
        var index = this.groups.indexOf(group);
        -1 !== index && this.groups.splice(index, 1);
    };
} ]).directive("uibAccordion", function() {
    return {
        controller: "UibAccordionController",
        controllerAs: "accordion",
        transclude: !0,
        templateUrl: function(element, attrs) {
            return attrs.templateUrl || "uib/template/accordion/accordion.html";
        }
    };
}).directive("uibAccordionGroup", function() {
    return {
        require: "^uibAccordion",
        transclude: !0,
        restrict: "A",
        templateUrl: function(element, attrs) {
            return attrs.templateUrl || "uib/template/accordion/accordion-group.html";
        },
        scope: {
            heading: "@",
            panelClass: "@?",
            isOpen: "=?",
            isDisabled: "=?"
        },
        controller: function() {
            this.setHeading = function(element) {
                this.heading = element;
            };
        },
        link: function(scope, element, attrs, accordionCtrl) {
            element.addClass("panel"), accordionCtrl.addGroup(scope), scope.openClass = attrs.openClass || "panel-open", 
            scope.panelClass = attrs.panelClass || "panel-default", scope.$watch("isOpen", function(value) {
                element.toggleClass(scope.openClass, !!value), value && accordionCtrl.closeOthers(scope);
            }), scope.toggleOpen = function($event) {
                scope.isDisabled || $event && 32 !== $event.which || (scope.isOpen = !scope.isOpen);
            };
            var id = "accordiongroup-" + scope.$id + "-" + Math.floor(1e4 * Math.random());
            scope.headingId = id + "-tab", scope.panelId = id + "-panel";
        }
    };
}).directive("uibAccordionHeading", function() {
    return {
        transclude: !0,
        template: "",
        replace: !0,
        require: "^uibAccordionGroup",
        link: function(scope, element, attrs, accordionGroupCtrl, transclude) {
            accordionGroupCtrl.setHeading(transclude(scope, angular.noop));
        }
    };
}).directive("uibAccordionTransclude", function() {
    function getHeaderSelectors() {
        return "uib-accordion-header,data-uib-accordion-header,x-uib-accordion-header,uib\\:accordion-header,[uib-accordion-header],[data-uib-accordion-header],[x-uib-accordion-header]";
    }
    return {
        require: "^uibAccordionGroup",
        link: function(scope, element, attrs, controller) {
            scope.$watch(function() {
                return controller[attrs.uibAccordionTransclude];
            }, function(heading) {
                if (heading) {
                    var elem = angular.element(element[0].querySelector(getHeaderSelectors()));
                    elem.html(""), elem.append(heading);
                }
            });
        }
    };
}), angular.module("ui.bootstrap.alert", []).controller("UibAlertController", [ "$scope", "$element", "$attrs", "$interpolate", "$timeout", function($scope, $element, $attrs, $interpolate, $timeout) {
    $scope.closeable = !!$attrs.close, $element.addClass("alert"), $attrs.$set("role", "alert"), 
    $scope.closeable && $element.addClass("alert-dismissible");
    var dismissOnTimeout = angular.isDefined($attrs.dismissOnTimeout) ? $interpolate($attrs.dismissOnTimeout)($scope.$parent) : null;
    dismissOnTimeout && $timeout(function() {
        $scope.close();
    }, parseInt(dismissOnTimeout, 10));
} ]).directive("uibAlert", function() {
    return {
        controller: "UibAlertController",
        controllerAs: "alert",
        restrict: "A",
        templateUrl: function(element, attrs) {
            return attrs.templateUrl || "uib/template/alert/alert.html";
        },
        transclude: !0,
        scope: {
            close: "&"
        }
    };
}), angular.module("ui.bootstrap.buttons", []).constant("uibButtonConfig", {
    activeClass: "active",
    toggleEvent: "click"
}).controller("UibButtonsController", [ "uibButtonConfig", function(buttonConfig) {
    this.activeClass = buttonConfig.activeClass || "active", this.toggleEvent = buttonConfig.toggleEvent || "click";
} ]).directive("uibBtnRadio", [ "$parse", function($parse) {
    return {
        require: [ "uibBtnRadio", "ngModel" ],
        controller: "UibButtonsController",
        controllerAs: "buttons",
        link: function(scope, element, attrs, ctrls) {
            var buttonsCtrl = ctrls[0], ngModelCtrl = ctrls[1], uncheckableExpr = $parse(attrs.uibUncheckable);
            element.find("input").css({
                display: "none"
            }), ngModelCtrl.$render = function() {
                element.toggleClass(buttonsCtrl.activeClass, angular.equals(ngModelCtrl.$modelValue, scope.$eval(attrs.uibBtnRadio)));
            }, element.on(buttonsCtrl.toggleEvent, function() {
                if (!attrs.disabled) {
                    var isActive = element.hasClass(buttonsCtrl.activeClass);
                    (!isActive || angular.isDefined(attrs.uncheckable)) && scope.$apply(function() {
                        ngModelCtrl.$setViewValue(isActive ? null : scope.$eval(attrs.uibBtnRadio)), ngModelCtrl.$render();
                    });
                }
            }), attrs.uibUncheckable && scope.$watch(uncheckableExpr, function(uncheckable) {
                attrs.$set("uncheckable", uncheckable ? "" : void 0);
            });
        }
    };
} ]).directive("uibBtnCheckbox", function() {
    return {
        require: [ "uibBtnCheckbox", "ngModel" ],
        controller: "UibButtonsController",
        controllerAs: "button",
        link: function(scope, element, attrs, ctrls) {
            function getTrueValue() {
                return getCheckboxValue(attrs.btnCheckboxTrue, !0);
            }
            function getFalseValue() {
                return getCheckboxValue(attrs.btnCheckboxFalse, !1);
            }
            function getCheckboxValue(attribute, defaultValue) {
                return angular.isDefined(attribute) ? scope.$eval(attribute) : defaultValue;
            }
            var buttonsCtrl = ctrls[0], ngModelCtrl = ctrls[1];
            element.find("input").css({
                display: "none"
            }), ngModelCtrl.$render = function() {
                element.toggleClass(buttonsCtrl.activeClass, angular.equals(ngModelCtrl.$modelValue, getTrueValue()));
            }, element.on(buttonsCtrl.toggleEvent, function() {
                attrs.disabled || scope.$apply(function() {
                    ngModelCtrl.$setViewValue(element.hasClass(buttonsCtrl.activeClass) ? getFalseValue() : getTrueValue()), 
                    ngModelCtrl.$render();
                });
            });
        }
    };
}), angular.module("ui.bootstrap.carousel", []).controller("UibCarouselController", [ "$scope", "$element", "$interval", "$timeout", "$animate", function($scope, $element, $interval, $timeout, $animate) {
    function clearBufferedTransitions() {
        for (;bufferedTransitions.length; ) bufferedTransitions.shift();
    }
    function setActive(index) {
        for (var i = 0; i < slides.length; i++) slides[i].slide.active = i === index;
    }
    function goNext(slide, index, direction) {
        if (!destroyed) {
            if (angular.extend(slide, {
                direction: direction
            }), angular.extend(slides[currentIndex].slide || {}, {
                direction: direction
            }), $animate.enabled($element) && !$scope.$currentTransition && slides[index].element && self.slides.length > 1) {
                slides[index].element.data(SLIDE_DIRECTION, slide.direction);
                var currentIdx = self.getCurrentIndex();
                angular.isNumber(currentIdx) && slides[currentIdx].element && slides[currentIdx].element.data(SLIDE_DIRECTION, slide.direction), 
                $scope.$currentTransition = !0, $animate.on("addClass", slides[index].element, function(element, phase) {
                    if ("close" === phase && ($scope.$currentTransition = null, $animate.off("addClass", element), 
                    bufferedTransitions.length)) {
                        var nextSlide = bufferedTransitions.pop().slide, nextIndex = nextSlide.index, nextDirection = nextIndex > self.getCurrentIndex() ? "next" : "prev";
                        clearBufferedTransitions(), goNext(nextSlide, nextIndex, nextDirection);
                    }
                });
            }
            $scope.active = slide.index, currentIndex = slide.index, setActive(index), restartTimer();
        }
    }
    function findSlideIndex(slide) {
        for (var i = 0; i < slides.length; i++) if (slides[i].slide === slide) return i;
    }
    function resetTimer() {
        currentInterval && ($interval.cancel(currentInterval), currentInterval = null);
    }
    function resetTransition(slides) {
        slides.length || ($scope.$currentTransition = null, clearBufferedTransitions());
    }
    function restartTimer() {
        resetTimer();
        var interval = +$scope.interval;
        !isNaN(interval) && interval > 0 && (currentInterval = $interval(timerFn, interval));
    }
    function timerFn() {
        var interval = +$scope.interval;
        isPlaying && !isNaN(interval) && interval > 0 && slides.length ? $scope.next() : $scope.pause();
    }
    var currentInterval, isPlaying, self = this, slides = self.slides = $scope.slides = [], SLIDE_DIRECTION = "uib-slideDirection", currentIndex = $scope.active, bufferedTransitions = [], destroyed = !1;
    $element.addClass("carousel"), self.addSlide = function(slide, element) {
        slides.push({
            slide: slide,
            element: element
        }), slides.sort(function(a, b) {
            return +a.slide.index - +b.slide.index;
        }), (slide.index === $scope.active || 1 === slides.length && !angular.isNumber($scope.active)) && ($scope.$currentTransition && ($scope.$currentTransition = null), 
        currentIndex = slide.index, $scope.active = slide.index, setActive(currentIndex), 
        self.select(slides[findSlideIndex(slide)]), 1 === slides.length && $scope.play());
    }, self.getCurrentIndex = function() {
        for (var i = 0; i < slides.length; i++) if (slides[i].slide.index === currentIndex) return i;
    }, self.next = $scope.next = function() {
        var newIndex = (self.getCurrentIndex() + 1) % slides.length;
        return 0 === newIndex && $scope.noWrap() ? void $scope.pause() : self.select(slides[newIndex], "next");
    }, self.prev = $scope.prev = function() {
        var newIndex = self.getCurrentIndex() - 1 < 0 ? slides.length - 1 : self.getCurrentIndex() - 1;
        return $scope.noWrap() && newIndex === slides.length - 1 ? void $scope.pause() : self.select(slides[newIndex], "prev");
    }, self.removeSlide = function(slide) {
        var index = findSlideIndex(slide), bufferedIndex = bufferedTransitions.indexOf(slides[index]);
        -1 !== bufferedIndex && bufferedTransitions.splice(bufferedIndex, 1), slides.splice(index, 1), 
        slides.length > 0 && currentIndex === index ? index >= slides.length ? (currentIndex = slides.length - 1, 
        $scope.active = currentIndex, setActive(currentIndex), self.select(slides[slides.length - 1])) : (currentIndex = index, 
        $scope.active = currentIndex, setActive(currentIndex), self.select(slides[index])) : currentIndex > index && (currentIndex--, 
        $scope.active = currentIndex), 0 === slides.length && (currentIndex = null, $scope.active = null, 
        clearBufferedTransitions());
    }, self.select = $scope.select = function(nextSlide, direction) {
        var nextIndex = findSlideIndex(nextSlide.slide);
        void 0 === direction && (direction = nextIndex > self.getCurrentIndex() ? "next" : "prev"), 
        nextSlide.slide.index === currentIndex || $scope.$currentTransition ? nextSlide && nextSlide.slide.index !== currentIndex && $scope.$currentTransition && bufferedTransitions.push(slides[nextIndex]) : goNext(nextSlide.slide, nextIndex, direction);
    }, $scope.indexOfSlide = function(slide) {
        return +slide.slide.index;
    }, $scope.isActive = function(slide) {
        return $scope.active === slide.slide.index;
    }, $scope.isPrevDisabled = function() {
        return 0 === $scope.active && $scope.noWrap();
    }, $scope.isNextDisabled = function() {
        return $scope.active === slides.length - 1 && $scope.noWrap();
    }, $scope.pause = function() {
        $scope.noPause || (isPlaying = !1, resetTimer());
    }, $scope.play = function() {
        isPlaying || (isPlaying = !0, restartTimer());
    }, $element.on("mouseenter", $scope.pause), $element.on("mouseleave", $scope.play), 
    $scope.$on("$destroy", function() {
        destroyed = !0, resetTimer();
    }), $scope.$watch("noTransition", function(noTransition) {
        $animate.enabled($element, !noTransition);
    }), $scope.$watch("interval", restartTimer), $scope.$watchCollection("slides", resetTransition), 
    $scope.$watch("active", function(index) {
        if (angular.isNumber(index) && currentIndex !== index) {
            for (var i = 0; i < slides.length; i++) if (slides[i].slide.index === index) {
                index = i;
                break;
            }
            var slide = slides[index];
            slide && (setActive(index), self.select(slides[index]), currentIndex = index);
        }
    });
} ]).directive("uibCarousel", function() {
    return {
        transclude: !0,
        controller: "UibCarouselController",
        controllerAs: "carousel",
        restrict: "A",
        templateUrl: function(element, attrs) {
            return attrs.templateUrl || "uib/template/carousel/carousel.html";
        },
        scope: {
            active: "=",
            interval: "=",
            noTransition: "=",
            noPause: "=",
            noWrap: "&"
        }
    };
}).directive("uibSlide", [ "$animate", function($animate) {
    return {
        require: "^uibCarousel",
        restrict: "A",
        transclude: !0,
        templateUrl: function(element, attrs) {
            return attrs.templateUrl || "uib/template/carousel/slide.html";
        },
        scope: {
            actual: "=?",
            index: "=?"
        },
        link: function(scope, element, attrs, carouselCtrl) {
            element.addClass("item"), carouselCtrl.addSlide(scope, element), scope.$on("$destroy", function() {
                carouselCtrl.removeSlide(scope);
            }), scope.$watch("active", function(active) {
                $animate[active ? "addClass" : "removeClass"](element, "active");
            });
        }
    };
} ]).animation(".item", [ "$animateCss", function($animateCss) {
    function removeClass(element, className, callback) {
        element.removeClass(className), callback && callback();
    }
    var SLIDE_DIRECTION = "uib-slideDirection";
    return {
        beforeAddClass: function(element, className, done) {
            if ("active" === className) {
                var stopped = !1, direction = element.data(SLIDE_DIRECTION), directionClass = "next" === direction ? "left" : "right", removeClassFn = removeClass.bind(this, element, directionClass + " " + direction, done);
                return element.addClass(direction), $animateCss(element, {
                    addClass: directionClass
                }).start().done(removeClassFn), function() {
                    stopped = !0;
                };
            }
            done();
        },
        beforeRemoveClass: function(element, className, done) {
            if ("active" === className) {
                var stopped = !1, direction = element.data(SLIDE_DIRECTION), directionClass = "next" === direction ? "left" : "right", removeClassFn = removeClass.bind(this, element, directionClass, done);
                return $animateCss(element, {
                    addClass: directionClass
                }).start().done(removeClassFn), function() {
                    stopped = !0;
                };
            }
            done();
        }
    };
} ]), angular.module("ui.bootstrap.dateparser", []).service("uibDateParser", [ "$log", "$locale", "dateFilter", "orderByFilter", function($log, $locale, dateFilter, orderByFilter) {
    function createParser(format) {
        var map = [], regex = format.split(""), quoteIndex = format.indexOf("'");
        if (quoteIndex > -1) {
            var inLiteral = !1;
            format = format.split("");
            for (var i = quoteIndex; i < format.length; i++) inLiteral ? ("'" === format[i] && (i + 1 < format.length && "'" === format[i + 1] ? (format[i + 1] = "$", 
            regex[i + 1] = "") : (regex[i] = "", inLiteral = !1)), format[i] = "$") : "'" === format[i] && (format[i] = "$", 
            regex[i] = "", inLiteral = !0);
            format = format.join("");
        }
        return angular.forEach(formatCodeToRegex, function(data) {
            var index = format.indexOf(data.key);
            if (index > -1) {
                format = format.split(""), regex[index] = "(" + data.regex + ")", format[index] = "$";
                for (var i = index + 1, n = index + data.key.length; n > i; i++) regex[i] = "", 
                format[i] = "$";
                format = format.join(""), map.push({
                    index: index,
                    key: data.key,
                    apply: data.apply,
                    matcher: data.regex
                });
            }
        }), {
            regex: new RegExp("^" + regex.join("") + "$"),
            map: orderByFilter(map, "index")
        };
    }
    function createFormatter(format) {
        for (var formatter, literalIdx, formatters = [], i = 0; i < format.length; ) if (angular.isNumber(literalIdx)) {
            if ("'" === format.charAt(i)) (i + 1 >= format.length || "'" !== format.charAt(i + 1)) && (formatters.push(constructLiteralFormatter(format, literalIdx, i)), 
            literalIdx = null); else if (i === format.length) for (;literalIdx < format.length; ) formatter = constructFormatterFromIdx(format, literalIdx), 
            formatters.push(formatter), literalIdx = formatter.endIdx;
            i++;
        } else "'" !== format.charAt(i) ? (formatter = constructFormatterFromIdx(format, i), 
        formatters.push(formatter.parser), i = formatter.endIdx) : (literalIdx = i, i++);
        return formatters;
    }
    function constructLiteralFormatter(format, literalIdx, endIdx) {
        return function() {
            return format.substr(literalIdx + 1, endIdx - literalIdx - 1);
        };
    }
    function constructFormatterFromIdx(format, i) {
        for (var currentPosStr = format.substr(i), j = 0; j < formatCodeToRegex.length; j++) if (new RegExp("^" + formatCodeToRegex[j].key).test(currentPosStr)) {
            var data = formatCodeToRegex[j];
            return {
                endIdx: i + data.key.length,
                parser: data.formatter
            };
        }
        return {
            endIdx: i + 1,
            parser: function() {
                return currentPosStr.charAt(0);
            }
        };
    }
    function isValid(year, month, date) {
        return 1 > date ? !1 : 1 === month && date > 28 ? 29 === date && (year % 4 === 0 && year % 100 !== 0 || year % 400 === 0) : 3 === month || 5 === month || 8 === month || 10 === month ? 31 > date : !0;
    }
    function toInt(str) {
        return parseInt(str, 10);
    }
    function toTimezone(date, timezone) {
        return date && timezone ? convertTimezoneToLocal(date, timezone) : date;
    }
    function fromTimezone(date, timezone) {
        return date && timezone ? convertTimezoneToLocal(date, timezone, !0) : date;
    }
    function timezoneToOffset(timezone, fallback) {
        timezone = timezone.replace(/:/g, "");
        var requestedTimezoneOffset = Date.parse("Jan 01, 1970 00:00:00 " + timezone) / 6e4;
        return isNaN(requestedTimezoneOffset) ? fallback : requestedTimezoneOffset;
    }
    function addDateMinutes(date, minutes) {
        return date = new Date(date.getTime()), date.setMinutes(date.getMinutes() + minutes), 
        date;
    }
    function convertTimezoneToLocal(date, timezone, reverse) {
        reverse = reverse ? -1 : 1;
        var dateTimezoneOffset = date.getTimezoneOffset(), timezoneOffset = timezoneToOffset(timezone, dateTimezoneOffset);
        return addDateMinutes(date, reverse * (timezoneOffset - dateTimezoneOffset));
    }
    var localeId, formatCodeToRegex, SPECIAL_CHARACTERS_REGEXP = /[\\\^\$\*\+\?\|\[\]\(\)\.\{\}]/g;
    this.init = function() {
        localeId = $locale.id, this.parsers = {}, this.formatters = {}, formatCodeToRegex = [ {
            key: "yyyy",
            regex: "\\d{4}",
            apply: function(value) {
                this.year = +value;
            },
            formatter: function(date) {
                var _date = new Date();
                return _date.setFullYear(Math.abs(date.getFullYear())), dateFilter(_date, "yyyy");
            }
        }, {
            key: "yy",
            regex: "\\d{2}",
            apply: function(value) {
                value = +value, this.year = 69 > value ? value + 2e3 : value + 1900;
            },
            formatter: function(date) {
                var _date = new Date();
                return _date.setFullYear(Math.abs(date.getFullYear())), dateFilter(_date, "yy");
            }
        }, {
            key: "y",
            regex: "\\d{1,4}",
            apply: function(value) {
                this.year = +value;
            },
            formatter: function(date) {
                var _date = new Date();
                return _date.setFullYear(Math.abs(date.getFullYear())), dateFilter(_date, "y");
            }
        }, {
            key: "M!",
            regex: "0?[1-9]|1[0-2]",
            apply: function(value) {
                this.month = value - 1;
            },
            formatter: function(date) {
                var value = date.getMonth();
                return /^[0-9]$/.test(value) ? dateFilter(date, "MM") : dateFilter(date, "M");
            }
        }, {
            key: "MMMM",
            regex: $locale.DATETIME_FORMATS.MONTH.join("|"),
            apply: function(value) {
                this.month = $locale.DATETIME_FORMATS.MONTH.indexOf(value);
            },
            formatter: function(date) {
                return dateFilter(date, "MMMM");
            }
        }, {
            key: "MMM",
            regex: $locale.DATETIME_FORMATS.SHORTMONTH.join("|"),
            apply: function(value) {
                this.month = $locale.DATETIME_FORMATS.SHORTMONTH.indexOf(value);
            },
            formatter: function(date) {
                return dateFilter(date, "MMM");
            }
        }, {
            key: "MM",
            regex: "0[1-9]|1[0-2]",
            apply: function(value) {
                this.month = value - 1;
            },
            formatter: function(date) {
                return dateFilter(date, "MM");
            }
        }, {
            key: "M",
            regex: "[1-9]|1[0-2]",
            apply: function(value) {
                this.month = value - 1;
            },
            formatter: function(date) {
                return dateFilter(date, "M");
            }
        }, {
            key: "d!",
            regex: "[0-2]?[0-9]{1}|3[0-1]{1}",
            apply: function(value) {
                this.date = +value;
            },
            formatter: function(date) {
                var value = date.getDate();
                return /^[1-9]$/.test(value) ? dateFilter(date, "dd") : dateFilter(date, "d");
            }
        }, {
            key: "dd",
            regex: "[0-2][0-9]{1}|3[0-1]{1}",
            apply: function(value) {
                this.date = +value;
            },
            formatter: function(date) {
                return dateFilter(date, "dd");
            }
        }, {
            key: "d",
            regex: "[1-2]?[0-9]{1}|3[0-1]{1}",
            apply: function(value) {
                this.date = +value;
            },
            formatter: function(date) {
                return dateFilter(date, "d");
            }
        }, {
            key: "EEEE",
            regex: $locale.DATETIME_FORMATS.DAY.join("|"),
            formatter: function(date) {
                return dateFilter(date, "EEEE");
            }
        }, {
            key: "EEE",
            regex: $locale.DATETIME_FORMATS.SHORTDAY.join("|"),
            formatter: function(date) {
                return dateFilter(date, "EEE");
            }
        }, {
            key: "HH",
            regex: "(?:0|1)[0-9]|2[0-3]",
            apply: function(value) {
                this.hours = +value;
            },
            formatter: function(date) {
                return dateFilter(date, "HH");
            }
        }, {
            key: "hh",
            regex: "0[0-9]|1[0-2]",
            apply: function(value) {
                this.hours = +value;
            },
            formatter: function(date) {
                return dateFilter(date, "hh");
            }
        }, {
            key: "H",
            regex: "1?[0-9]|2[0-3]",
            apply: function(value) {
                this.hours = +value;
            },
            formatter: function(date) {
                return dateFilter(date, "H");
            }
        }, {
            key: "h",
            regex: "[0-9]|1[0-2]",
            apply: function(value) {
                this.hours = +value;
            },
            formatter: function(date) {
                return dateFilter(date, "h");
            }
        }, {
            key: "mm",
            regex: "[0-5][0-9]",
            apply: function(value) {
                this.minutes = +value;
            },
            formatter: function(date) {
                return dateFilter(date, "mm");
            }
        }, {
            key: "m",
            regex: "[0-9]|[1-5][0-9]",
            apply: function(value) {
                this.minutes = +value;
            },
            formatter: function(date) {
                return dateFilter(date, "m");
            }
        }, {
            key: "sss",
            regex: "[0-9][0-9][0-9]",
            apply: function(value) {
                this.milliseconds = +value;
            },
            formatter: function(date) {
                return dateFilter(date, "sss");
            }
        }, {
            key: "ss",
            regex: "[0-5][0-9]",
            apply: function(value) {
                this.seconds = +value;
            },
            formatter: function(date) {
                return dateFilter(date, "ss");
            }
        }, {
            key: "s",
            regex: "[0-9]|[1-5][0-9]",
            apply: function(value) {
                this.seconds = +value;
            },
            formatter: function(date) {
                return dateFilter(date, "s");
            }
        }, {
            key: "a",
            regex: $locale.DATETIME_FORMATS.AMPMS.join("|"),
            apply: function(value) {
                12 === this.hours && (this.hours = 0), "PM" === value && (this.hours += 12);
            },
            formatter: function(date) {
                return dateFilter(date, "a");
            }
        }, {
            key: "Z",
            regex: "[+-]\\d{4}",
            apply: function(value) {
                var matches = value.match(/([+-])(\d{2})(\d{2})/), sign = matches[1], hours = matches[2], minutes = matches[3];
                this.hours += toInt(sign + hours), this.minutes += toInt(sign + minutes);
            },
            formatter: function(date) {
                return dateFilter(date, "Z");
            }
        }, {
            key: "ww",
            regex: "[0-4][0-9]|5[0-3]",
            formatter: function(date) {
                return dateFilter(date, "ww");
            }
        }, {
            key: "w",
            regex: "[0-9]|[1-4][0-9]|5[0-3]",
            formatter: function(date) {
                return dateFilter(date, "w");
            }
        }, {
            key: "GGGG",
            regex: $locale.DATETIME_FORMATS.ERANAMES.join("|").replace(/\s/g, "\\s"),
            formatter: function(date) {
                return dateFilter(date, "GGGG");
            }
        }, {
            key: "GGG",
            regex: $locale.DATETIME_FORMATS.ERAS.join("|"),
            formatter: function(date) {
                return dateFilter(date, "GGG");
            }
        }, {
            key: "GG",
            regex: $locale.DATETIME_FORMATS.ERAS.join("|"),
            formatter: function(date) {
                return dateFilter(date, "GG");
            }
        }, {
            key: "G",
            regex: $locale.DATETIME_FORMATS.ERAS.join("|"),
            formatter: function(date) {
                return dateFilter(date, "G");
            }
        } ];
    }, this.init(), this.filter = function(date, format) {
        if (!angular.isDate(date) || isNaN(date) || !format) return "";
        format = $locale.DATETIME_FORMATS[format] || format, $locale.id !== localeId && this.init(), 
        this.formatters[format] || (this.formatters[format] = createFormatter(format));
        var formatters = this.formatters[format];
        return formatters.reduce(function(str, formatter) {
            return str + formatter(date);
        }, "");
    }, this.parse = function(input, format, baseDate) {
        if (!angular.isString(input) || !format) return input;
        format = $locale.DATETIME_FORMATS[format] || format, format = format.replace(SPECIAL_CHARACTERS_REGEXP, "\\$&"), 
        $locale.id !== localeId && this.init(), this.parsers[format] || (this.parsers[format] = createParser(format, "apply"));
        var parser = this.parsers[format], regex = parser.regex, map = parser.map, results = input.match(regex), tzOffset = !1;
        if (results && results.length) {
            var fields, dt;
            angular.isDate(baseDate) && !isNaN(baseDate.getTime()) ? fields = {
                year: baseDate.getFullYear(),
                month: baseDate.getMonth(),
                date: baseDate.getDate(),
                hours: baseDate.getHours(),
                minutes: baseDate.getMinutes(),
                seconds: baseDate.getSeconds(),
                milliseconds: baseDate.getMilliseconds()
            } : (baseDate && $log.warn("dateparser:", "baseDate is not a valid date"), fields = {
                year: 1900,
                month: 0,
                date: 1,
                hours: 0,
                minutes: 0,
                seconds: 0,
                milliseconds: 0
            });
            for (var i = 1, n = results.length; n > i; i++) {
                var mapper = map[i - 1];
                "Z" === mapper.matcher && (tzOffset = !0), mapper.apply && mapper.apply.call(fields, results[i]);
            }
            var datesetter = tzOffset ? Date.prototype.setUTCFullYear : Date.prototype.setFullYear, timesetter = tzOffset ? Date.prototype.setUTCHours : Date.prototype.setHours;
            return isValid(fields.year, fields.month, fields.date) && (!angular.isDate(baseDate) || isNaN(baseDate.getTime()) || tzOffset ? (dt = new Date(0), 
            datesetter.call(dt, fields.year, fields.month, fields.date), timesetter.call(dt, fields.hours || 0, fields.minutes || 0, fields.seconds || 0, fields.milliseconds || 0)) : (dt = new Date(baseDate), 
            datesetter.call(dt, fields.year, fields.month, fields.date), timesetter.call(dt, fields.hours, fields.minutes, fields.seconds, fields.milliseconds))), 
            dt;
        }
    }, this.toTimezone = toTimezone, this.fromTimezone = fromTimezone, this.timezoneToOffset = timezoneToOffset, 
    this.addDateMinutes = addDateMinutes, this.convertTimezoneToLocal = convertTimezoneToLocal;
} ]), angular.module("ui.bootstrap.isClass", []).directive("uibIsClass", [ "$animate", function($animate) {
    var ON_REGEXP = /^\s*([\s\S]+?)\s+on\s+([\s\S]+?)\s*$/, IS_REGEXP = /^\s*([\s\S]+?)\s+for\s+([\s\S]+?)\s*$/;
    return {
        restrict: "A",
        compile: function(tElement, tAttrs) {
            function linkFn(scope, element) {
                linkedScopes.push(scope), instances.push({
                    scope: scope,
                    element: element
                }), exps.forEach(function(exp) {
                    addForExp(exp, scope);
                }), scope.$on("$destroy", removeScope);
            }
            function addForExp(exp, scope) {
                var matches = exp.match(IS_REGEXP), clazz = scope.$eval(matches[1]), compareWithExp = matches[2], data = expToData[exp];
                if (!data) {
                    var watchFn = function(compareWithVal) {
                        var newActivated = null;
                        instances.some(function(instance) {
                            var thisVal = instance.scope.$eval(onExp);
                            return thisVal === compareWithVal ? (newActivated = instance, !0) : void 0;
                        }), data.lastActivated !== newActivated && (data.lastActivated && $animate.removeClass(data.lastActivated.element, clazz), 
                        newActivated && $animate.addClass(newActivated.element, clazz), data.lastActivated = newActivated);
                    };
                    expToData[exp] = data = {
                        lastActivated: null,
                        scope: scope,
                        watchFn: watchFn,
                        compareWithExp: compareWithExp,
                        watcher: scope.$watch(compareWithExp, watchFn)
                    };
                }
                data.watchFn(scope.$eval(compareWithExp));
            }
            function removeScope(e) {
                var removedScope = e.targetScope, index = linkedScopes.indexOf(removedScope);
                if (linkedScopes.splice(index, 1), instances.splice(index, 1), linkedScopes.length) {
                    var newWatchScope = linkedScopes[0];
                    angular.forEach(expToData, function(data) {
                        data.scope === removedScope && (data.watcher = newWatchScope.$watch(data.compareWithExp, data.watchFn), 
                        data.scope = newWatchScope);
                    });
                } else expToData = {};
            }
            var linkedScopes = [], instances = [], expToData = {}, onExpMatches = tAttrs.uibIsClass.match(ON_REGEXP), onExp = onExpMatches[2], expsStr = onExpMatches[1], exps = expsStr.split(",");
            return linkFn;
        }
    };
} ]), angular.module("ui.bootstrap.datepicker", [ "ui.bootstrap.dateparser", "ui.bootstrap.isClass" ]).value("$datepickerSuppressError", !1).value("$datepickerLiteralWarning", !0).constant("uibDatepickerConfig", {
    datepickerMode: "day",
    formatDay: "dd",
    formatMonth: "MMMM",
    formatYear: "yyyy",
    formatDayHeader: "EEE",
    formatDayTitle: "MMMM yyyy",
    formatMonthTitle: "yyyy",
    maxDate: null,
    maxMode: "year",
    minDate: null,
    minMode: "day",
    monthColumns: 3,
    ngModelOptions: {},
    shortcutPropagation: !1,
    showWeeks: !0,
    yearColumns: 5,
    yearRows: 4
}).controller("UibDatepickerController", [ "$scope", "$element", "$attrs", "$parse", "$interpolate", "$locale", "$log", "dateFilter", "uibDatepickerConfig", "$datepickerLiteralWarning", "$datepickerSuppressError", "uibDateParser", function($scope, $element, $attrs, $parse, $interpolate, $locale, $log, dateFilter, datepickerConfig, $datepickerLiteralWarning, $datepickerSuppressError, dateParser) {
    function setMode(mode) {
        $scope.datepickerMode = mode, $scope.datepickerOptions.datepickerMode = mode;
    }
    var self = this, ngModelCtrl = {
        $setViewValue: angular.noop
    }, ngModelOptions = {}, watchListeners = [];
    $element.addClass("uib-datepicker"), $attrs.$set("role", "application"), $scope.datepickerOptions || ($scope.datepickerOptions = {}), 
    this.modes = [ "day", "month", "year" ], [ "customClass", "dateDisabled", "datepickerMode", "formatDay", "formatDayHeader", "formatDayTitle", "formatMonth", "formatMonthTitle", "formatYear", "maxDate", "maxMode", "minDate", "minMode", "monthColumns", "showWeeks", "shortcutPropagation", "startingDay", "yearColumns", "yearRows" ].forEach(function(key) {
        switch (key) {
          case "customClass":
          case "dateDisabled":
            $scope[key] = $scope.datepickerOptions[key] || angular.noop;
            break;

          case "datepickerMode":
            $scope.datepickerMode = angular.isDefined($scope.datepickerOptions.datepickerMode) ? $scope.datepickerOptions.datepickerMode : datepickerConfig.datepickerMode;
            break;

          case "formatDay":
          case "formatDayHeader":
          case "formatDayTitle":
          case "formatMonth":
          case "formatMonthTitle":
          case "formatYear":
            self[key] = angular.isDefined($scope.datepickerOptions[key]) ? $interpolate($scope.datepickerOptions[key])($scope.$parent) : datepickerConfig[key];
            break;

          case "monthColumns":
          case "showWeeks":
          case "shortcutPropagation":
          case "yearColumns":
          case "yearRows":
            self[key] = angular.isDefined($scope.datepickerOptions[key]) ? $scope.datepickerOptions[key] : datepickerConfig[key];
            break;

          case "startingDay":
            self.startingDay = angular.isDefined($scope.datepickerOptions.startingDay) ? $scope.datepickerOptions.startingDay : angular.isNumber(datepickerConfig.startingDay) ? datepickerConfig.startingDay : ($locale.DATETIME_FORMATS.FIRSTDAYOFWEEK + 8) % 7;
            break;

          case "maxDate":
          case "minDate":
            $scope.$watch("datepickerOptions." + key, function(value) {
                value ? angular.isDate(value) ? self[key] = dateParser.fromTimezone(new Date(value), ngModelOptions.timezone) : ($datepickerLiteralWarning && $log.warn("Literal date support has been deprecated, please switch to date object usage"), 
                self[key] = new Date(dateFilter(value, "medium"))) : self[key] = datepickerConfig[key] ? dateParser.fromTimezone(new Date(datepickerConfig[key]), ngModelOptions.timezone) : null, 
                self.refreshView();
            });
            break;

          case "maxMode":
          case "minMode":
            $scope.datepickerOptions[key] ? $scope.$watch(function() {
                return $scope.datepickerOptions[key];
            }, function(value) {
                self[key] = $scope[key] = angular.isDefined(value) ? value : $scope.datepickerOptions[key], 
                ("minMode" === key && self.modes.indexOf($scope.datepickerOptions.datepickerMode) < self.modes.indexOf(self[key]) || "maxMode" === key && self.modes.indexOf($scope.datepickerOptions.datepickerMode) > self.modes.indexOf(self[key])) && ($scope.datepickerMode = self[key], 
                $scope.datepickerOptions.datepickerMode = self[key]);
            }) : self[key] = $scope[key] = datepickerConfig[key] || null;
        }
    }), $scope.uniqueId = "datepicker-" + $scope.$id + "-" + Math.floor(1e4 * Math.random()), 
    $scope.disabled = angular.isDefined($attrs.disabled) || !1, angular.isDefined($attrs.ngDisabled) && watchListeners.push($scope.$parent.$watch($attrs.ngDisabled, function(disabled) {
        $scope.disabled = disabled, self.refreshView();
    })), $scope.isActive = function(dateObject) {
        return 0 === self.compare(dateObject.date, self.activeDate) ? ($scope.activeDateId = dateObject.uid, 
        !0) : !1;
    }, this.init = function(ngModelCtrl_) {
        ngModelCtrl = ngModelCtrl_, ngModelOptions = ngModelCtrl_.$options || $scope.datepickerOptions.ngModelOptions || datepickerConfig.ngModelOptions, 
        $scope.datepickerOptions.initDate ? (self.activeDate = dateParser.fromTimezone($scope.datepickerOptions.initDate, ngModelOptions.timezone) || new Date(), 
        $scope.$watch("datepickerOptions.initDate", function(initDate) {
            initDate && (ngModelCtrl.$isEmpty(ngModelCtrl.$modelValue) || ngModelCtrl.$invalid) && (self.activeDate = dateParser.fromTimezone(initDate, ngModelOptions.timezone), 
            self.refreshView());
        })) : self.activeDate = new Date();
        var date = ngModelCtrl.$modelValue ? new Date(ngModelCtrl.$modelValue) : new Date();
        this.activeDate = isNaN(date) ? dateParser.fromTimezone(new Date(), ngModelOptions.timezone) : dateParser.fromTimezone(date, ngModelOptions.timezone), 
        ngModelCtrl.$render = function() {
            self.render();
        };
    }, this.render = function() {
        if (ngModelCtrl.$viewValue) {
            var date = new Date(ngModelCtrl.$viewValue), isValid = !isNaN(date);
            isValid ? this.activeDate = dateParser.fromTimezone(date, ngModelOptions.timezone) : $datepickerSuppressError || $log.error('Datepicker directive: "ng-model" value must be a Date object');
        }
        this.refreshView();
    }, this.refreshView = function() {
        if (this.element) {
            $scope.selectedDt = null, this._refreshView(), $scope.activeDt && ($scope.activeDateId = $scope.activeDt.uid);
            var date = ngModelCtrl.$viewValue ? new Date(ngModelCtrl.$viewValue) : null;
            date = dateParser.fromTimezone(date, ngModelOptions.timezone), ngModelCtrl.$setValidity("dateDisabled", !date || this.element && !this.isDisabled(date));
        }
    }, this.createDateObject = function(date, format) {
        var model = ngModelCtrl.$viewValue ? new Date(ngModelCtrl.$viewValue) : null;
        model = dateParser.fromTimezone(model, ngModelOptions.timezone);
        var today = new Date();
        today = dateParser.fromTimezone(today, ngModelOptions.timezone);
        var time = this.compare(date, today), dt = {
            date: date,
            label: dateParser.filter(date, format),
            selected: model && 0 === this.compare(date, model),
            disabled: this.isDisabled(date),
            past: 0 > time,
            current: 0 === time,
            future: time > 0,
            customClass: this.customClass(date) || null
        };
        return model && 0 === this.compare(date, model) && ($scope.selectedDt = dt), self.activeDate && 0 === this.compare(dt.date, self.activeDate) && ($scope.activeDt = dt), 
        dt;
    }, this.isDisabled = function(date) {
        return $scope.disabled || this.minDate && this.compare(date, this.minDate) < 0 || this.maxDate && this.compare(date, this.maxDate) > 0 || $scope.dateDisabled && $scope.dateDisabled({
            date: date,
            mode: $scope.datepickerMode
        });
    }, this.customClass = function(date) {
        return $scope.customClass({
            date: date,
            mode: $scope.datepickerMode
        });
    }, this.split = function(arr, size) {
        for (var arrays = []; arr.length > 0; ) arrays.push(arr.splice(0, size));
        return arrays;
    }, $scope.select = function(date) {
        if ($scope.datepickerMode === self.minMode) {
            var dt = ngModelCtrl.$viewValue ? dateParser.fromTimezone(new Date(ngModelCtrl.$viewValue), ngModelOptions.timezone) : new Date(0, 0, 0, 0, 0, 0, 0);
            dt.setFullYear(date.getFullYear(), date.getMonth(), date.getDate()), dt = dateParser.toTimezone(dt, ngModelOptions.timezone), 
            ngModelCtrl.$setViewValue(dt), ngModelCtrl.$render();
        } else self.activeDate = date, setMode(self.modes[self.modes.indexOf($scope.datepickerMode) - 1]), 
        $scope.$emit("uib:datepicker.mode");
        $scope.$broadcast("uib:datepicker.focus");
    }, $scope.move = function(direction) {
        var year = self.activeDate.getFullYear() + direction * (self.step.years || 0), month = self.activeDate.getMonth() + direction * (self.step.months || 0);
        self.activeDate.setFullYear(year, month, 1), self.refreshView();
    }, $scope.toggleMode = function(direction) {
        direction = direction || 1, $scope.datepickerMode === self.maxMode && 1 === direction || $scope.datepickerMode === self.minMode && -1 === direction || (setMode(self.modes[self.modes.indexOf($scope.datepickerMode) + direction]), 
        $scope.$emit("uib:datepicker.mode"));
    }, $scope.keys = {
        13: "enter",
        32: "space",
        33: "pageup",
        34: "pagedown",
        35: "end",
        36: "home",
        37: "left",
        38: "up",
        39: "right",
        40: "down"
    };
    var focusElement = function() {
        self.element[0].focus();
    };
    $scope.$on("uib:datepicker.focus", focusElement), $scope.keydown = function(evt) {
        var key = $scope.keys[evt.which];
        if (key && !evt.shiftKey && !evt.altKey && !$scope.disabled) if (evt.preventDefault(), 
        self.shortcutPropagation || evt.stopPropagation(), "enter" === key || "space" === key) {
            if (self.isDisabled(self.activeDate)) return;
            $scope.select(self.activeDate);
        } else !evt.ctrlKey || "up" !== key && "down" !== key ? (self.handleKeyDown(key, evt), 
        self.refreshView()) : $scope.toggleMode("up" === key ? 1 : -1);
    }, $element.on("keydown", function(evt) {
        $scope.$apply(function() {
            $scope.keydown(evt);
        });
    }), $scope.$on("$destroy", function() {
        for (;watchListeners.length; ) watchListeners.shift()();
    });
} ]).controller("UibDaypickerController", [ "$scope", "$element", "dateFilter", function(scope, $element, dateFilter) {
    function getDaysInMonth(year, month) {
        return 1 !== month || year % 4 !== 0 || year % 100 === 0 && year % 400 !== 0 ? DAYS_IN_MONTH[month] : 29;
    }
    function getISO8601WeekNumber(date) {
        var checkDate = new Date(date);
        checkDate.setDate(checkDate.getDate() + 4 - (checkDate.getDay() || 7));
        var time = checkDate.getTime();
        return checkDate.setMonth(0), checkDate.setDate(1), Math.floor(Math.round((time - checkDate) / 864e5) / 7) + 1;
    }
    var DAYS_IN_MONTH = [ 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 ];
    this.step = {
        months: 1
    }, this.element = $element, this.init = function(ctrl) {
        angular.extend(ctrl, this), scope.showWeeks = ctrl.showWeeks, ctrl.refreshView();
    }, this.getDates = function(startDate, n) {
        for (var date, dates = new Array(n), current = new Date(startDate), i = 0; n > i; ) date = new Date(current), 
        dates[i++] = date, current.setDate(current.getDate() + 1);
        return dates;
    }, this._refreshView = function() {
        var year = this.activeDate.getFullYear(), month = this.activeDate.getMonth(), firstDayOfMonth = new Date(this.activeDate);
        firstDayOfMonth.setFullYear(year, month, 1);
        var difference = this.startingDay - firstDayOfMonth.getDay(), numDisplayedFromPreviousMonth = difference > 0 ? 7 - difference : -difference, firstDate = new Date(firstDayOfMonth);
        numDisplayedFromPreviousMonth > 0 && firstDate.setDate(-numDisplayedFromPreviousMonth + 1);
        for (var days = this.getDates(firstDate, 42), i = 0; 42 > i; i++) days[i] = angular.extend(this.createDateObject(days[i], this.formatDay), {
            secondary: days[i].getMonth() !== month,
            uid: scope.uniqueId + "-" + i
        });
        scope.labels = new Array(7);
        for (var j = 0; 7 > j; j++) scope.labels[j] = {
            abbr: dateFilter(days[j].date, this.formatDayHeader),
            full: dateFilter(days[j].date, "EEEE")
        };
        if (scope.title = dateFilter(this.activeDate, this.formatDayTitle), scope.rows = this.split(days, 7), 
        scope.showWeeks) {
            scope.weekNumbers = [];
            for (var thursdayIndex = (11 - this.startingDay) % 7, numWeeks = scope.rows.length, curWeek = 0; numWeeks > curWeek; curWeek++) scope.weekNumbers.push(getISO8601WeekNumber(scope.rows[curWeek][thursdayIndex].date));
        }
    }, this.compare = function(date1, date2) {
        var _date1 = new Date(date1.getFullYear(), date1.getMonth(), date1.getDate()), _date2 = new Date(date2.getFullYear(), date2.getMonth(), date2.getDate());
        return _date1.setFullYear(date1.getFullYear()), _date2.setFullYear(date2.getFullYear()), 
        _date1 - _date2;
    }, this.handleKeyDown = function(key) {
        var date = this.activeDate.getDate();
        if ("left" === key) date -= 1; else if ("up" === key) date -= 7; else if ("right" === key) date += 1; else if ("down" === key) date += 7; else if ("pageup" === key || "pagedown" === key) {
            var month = this.activeDate.getMonth() + ("pageup" === key ? -1 : 1);
            this.activeDate.setMonth(month, 1), date = Math.min(getDaysInMonth(this.activeDate.getFullYear(), this.activeDate.getMonth()), date);
        } else "home" === key ? date = 1 : "end" === key && (date = getDaysInMonth(this.activeDate.getFullYear(), this.activeDate.getMonth()));
        this.activeDate.setDate(date);
    };
} ]).controller("UibMonthpickerController", [ "$scope", "$element", "dateFilter", function(scope, $element, dateFilter) {
    this.step = {
        years: 1
    }, this.element = $element, this.init = function(ctrl) {
        angular.extend(ctrl, this), ctrl.refreshView();
    }, this._refreshView = function() {
        for (var date, months = new Array(12), year = this.activeDate.getFullYear(), i = 0; 12 > i; i++) date = new Date(this.activeDate), 
        date.setFullYear(year, i, 1), months[i] = angular.extend(this.createDateObject(date, this.formatMonth), {
            uid: scope.uniqueId + "-" + i
        });
        scope.title = dateFilter(this.activeDate, this.formatMonthTitle), scope.rows = this.split(months, this.monthColumns), 
        scope.yearHeaderColspan = this.monthColumns > 3 ? this.monthColumns - 2 : 1;
    }, this.compare = function(date1, date2) {
        var _date1 = new Date(date1.getFullYear(), date1.getMonth()), _date2 = new Date(date2.getFullYear(), date2.getMonth());
        return _date1.setFullYear(date1.getFullYear()), _date2.setFullYear(date2.getFullYear()), 
        _date1 - _date2;
    }, this.handleKeyDown = function(key) {
        var date = this.activeDate.getMonth();
        if ("left" === key) date -= 1; else if ("up" === key) date -= this.monthColumns; else if ("right" === key) date += 1; else if ("down" === key) date += this.monthColumns; else if ("pageup" === key || "pagedown" === key) {
            var year = this.activeDate.getFullYear() + ("pageup" === key ? -1 : 1);
            this.activeDate.setFullYear(year);
        } else "home" === key ? date = 0 : "end" === key && (date = 11);
        this.activeDate.setMonth(date);
    };
} ]).controller("UibYearpickerController", [ "$scope", "$element", "dateFilter", function(scope, $element) {
    function getStartingYear(year) {
        return parseInt((year - 1) / range, 10) * range + 1;
    }
    var columns, range;
    this.element = $element, this.yearpickerInit = function() {
        columns = this.yearColumns, range = this.yearRows * columns, this.step = {
            years: range
        };
    }, this._refreshView = function() {
        for (var date, years = new Array(range), i = 0, start = getStartingYear(this.activeDate.getFullYear()); range > i; i++) date = new Date(this.activeDate), 
        date.setFullYear(start + i, 0, 1), years[i] = angular.extend(this.createDateObject(date, this.formatYear), {
            uid: scope.uniqueId + "-" + i
        });
        scope.title = [ years[0].label, years[range - 1].label ].join(" - "), scope.rows = this.split(years, columns), 
        scope.columns = columns;
    }, this.compare = function(date1, date2) {
        return date1.getFullYear() - date2.getFullYear();
    }, this.handleKeyDown = function(key) {
        var date = this.activeDate.getFullYear();
        "left" === key ? date -= 1 : "up" === key ? date -= columns : "right" === key ? date += 1 : "down" === key ? date += columns : "pageup" === key || "pagedown" === key ? date += ("pageup" === key ? -1 : 1) * range : "home" === key ? date = getStartingYear(this.activeDate.getFullYear()) : "end" === key && (date = getStartingYear(this.activeDate.getFullYear()) + range - 1), 
        this.activeDate.setFullYear(date);
    };
} ]).directive("uibDatepicker", function() {
    return {
        templateUrl: function(element, attrs) {
            return attrs.templateUrl || "uib/template/datepicker/datepicker.html";
        },
        scope: {
            datepickerOptions: "=?"
        },
        require: [ "uibDatepicker", "^ngModel" ],
        restrict: "A",
        controller: "UibDatepickerController",
        controllerAs: "datepicker",
        link: function(scope, element, attrs, ctrls) {
            var datepickerCtrl = ctrls[0], ngModelCtrl = ctrls[1];
            datepickerCtrl.init(ngModelCtrl);
        }
    };
}).directive("uibDaypicker", function() {
    return {
        templateUrl: function(element, attrs) {
            return attrs.templateUrl || "uib/template/datepicker/day.html";
        },
        require: [ "^uibDatepicker", "uibDaypicker" ],
        restrict: "A",
        controller: "UibDaypickerController",
        link: function(scope, element, attrs, ctrls) {
            var datepickerCtrl = ctrls[0], daypickerCtrl = ctrls[1];
            daypickerCtrl.init(datepickerCtrl);
        }
    };
}).directive("uibMonthpicker", function() {
    return {
        templateUrl: function(element, attrs) {
            return attrs.templateUrl || "uib/template/datepicker/month.html";
        },
        require: [ "^uibDatepicker", "uibMonthpicker" ],
        restrict: "A",
        controller: "UibMonthpickerController",
        link: function(scope, element, attrs, ctrls) {
            var datepickerCtrl = ctrls[0], monthpickerCtrl = ctrls[1];
            monthpickerCtrl.init(datepickerCtrl);
        }
    };
}).directive("uibYearpicker", function() {
    return {
        templateUrl: function(element, attrs) {
            return attrs.templateUrl || "uib/template/datepicker/year.html";
        },
        require: [ "^uibDatepicker", "uibYearpicker" ],
        restrict: "A",
        controller: "UibYearpickerController",
        link: function(scope, element, attrs, ctrls) {
            var ctrl = ctrls[0];
            angular.extend(ctrl, ctrls[1]), ctrl.yearpickerInit(), ctrl.refreshView();
        }
    };
}), angular.module("ui.bootstrap.position", []).factory("$uibPosition", [ "$document", "$window", function($document, $window) {
    var SCROLLBAR_WIDTH, BODY_SCROLLBAR_WIDTH, OVERFLOW_REGEX = {
        normal: /(auto|scroll)/,
        hidden: /(auto|scroll|hidden)/
    }, PLACEMENT_REGEX = {
        auto: /\s?auto?\s?/i,
        primary: /^(top|bottom|left|right)$/,
        secondary: /^(top|bottom|left|right|center)$/,
        vertical: /^(top|bottom)$/
    }, BODY_REGEX = /(HTML|BODY)/;
    return {
        getRawNode: function(elem) {
            return elem.nodeName ? elem : elem[0] || elem;
        },
        parseStyle: function(value) {
            return value = parseFloat(value), isFinite(value) ? value : 0;
        },
        offsetParent: function(elem) {
            function isStaticPositioned(el) {
                return "static" === ($window.getComputedStyle(el).position || "static");
            }
            elem = this.getRawNode(elem);
            for (var offsetParent = elem.offsetParent || $document[0].documentElement; offsetParent && offsetParent !== $document[0].documentElement && isStaticPositioned(offsetParent); ) offsetParent = offsetParent.offsetParent;
            return offsetParent || $document[0].documentElement;
        },
        scrollbarWidth: function(isBody) {
            if (isBody) {
                if (angular.isUndefined(BODY_SCROLLBAR_WIDTH)) {
                    var bodyElem = $document.find("body");
                    bodyElem.addClass("uib-position-body-scrollbar-measure"), BODY_SCROLLBAR_WIDTH = $window.innerWidth - bodyElem[0].clientWidth, 
                    BODY_SCROLLBAR_WIDTH = isFinite(BODY_SCROLLBAR_WIDTH) ? BODY_SCROLLBAR_WIDTH : 0, 
                    bodyElem.removeClass("uib-position-body-scrollbar-measure");
                }
                return BODY_SCROLLBAR_WIDTH;
            }
            if (angular.isUndefined(SCROLLBAR_WIDTH)) {
                var scrollElem = angular.element('<div class="uib-position-scrollbar-measure"></div>');
                $document.find("body").append(scrollElem), SCROLLBAR_WIDTH = scrollElem[0].offsetWidth - scrollElem[0].clientWidth, 
                SCROLLBAR_WIDTH = isFinite(SCROLLBAR_WIDTH) ? SCROLLBAR_WIDTH : 0, scrollElem.remove();
            }
            return SCROLLBAR_WIDTH;
        },
        scrollbarPadding: function(elem) {
            elem = this.getRawNode(elem);
            var elemStyle = $window.getComputedStyle(elem), paddingRight = this.parseStyle(elemStyle.paddingRight), paddingBottom = this.parseStyle(elemStyle.paddingBottom), scrollParent = this.scrollParent(elem, !1, !0), scrollbarWidth = this.scrollbarWidth(scrollParent, BODY_REGEX.test(scrollParent.tagName));
            return {
                scrollbarWidth: scrollbarWidth,
                widthOverflow: scrollParent.scrollWidth > scrollParent.clientWidth,
                right: paddingRight + scrollbarWidth,
                originalRight: paddingRight,
                heightOverflow: scrollParent.scrollHeight > scrollParent.clientHeight,
                bottom: paddingBottom + scrollbarWidth,
                originalBottom: paddingBottom
            };
        },
        isScrollable: function(elem, includeHidden) {
            elem = this.getRawNode(elem);
            var overflowRegex = includeHidden ? OVERFLOW_REGEX.hidden : OVERFLOW_REGEX.normal, elemStyle = $window.getComputedStyle(elem);
            return overflowRegex.test(elemStyle.overflow + elemStyle.overflowY + elemStyle.overflowX);
        },
        scrollParent: function(elem, includeHidden, includeSelf) {
            elem = this.getRawNode(elem);
            var overflowRegex = includeHidden ? OVERFLOW_REGEX.hidden : OVERFLOW_REGEX.normal, documentEl = $document[0].documentElement, elemStyle = $window.getComputedStyle(elem);
            if (includeSelf && overflowRegex.test(elemStyle.overflow + elemStyle.overflowY + elemStyle.overflowX)) return elem;
            var excludeStatic = "absolute" === elemStyle.position, scrollParent = elem.parentElement || documentEl;
            if (scrollParent === documentEl || "fixed" === elemStyle.position) return documentEl;
            for (;scrollParent.parentElement && scrollParent !== documentEl; ) {
                var spStyle = $window.getComputedStyle(scrollParent);
                if (excludeStatic && "static" !== spStyle.position && (excludeStatic = !1), !excludeStatic && overflowRegex.test(spStyle.overflow + spStyle.overflowY + spStyle.overflowX)) break;
                scrollParent = scrollParent.parentElement;
            }
            return scrollParent;
        },
        position: function(elem, includeMagins) {
            elem = this.getRawNode(elem);
            var elemOffset = this.offset(elem);
            if (includeMagins) {
                var elemStyle = $window.getComputedStyle(elem);
                elemOffset.top -= this.parseStyle(elemStyle.marginTop), elemOffset.left -= this.parseStyle(elemStyle.marginLeft);
            }
            var parent = this.offsetParent(elem), parentOffset = {
                top: 0,
                left: 0
            };
            return parent !== $document[0].documentElement && (parentOffset = this.offset(parent), 
            parentOffset.top += parent.clientTop - parent.scrollTop, parentOffset.left += parent.clientLeft - parent.scrollLeft), 
            {
                width: Math.round(angular.isNumber(elemOffset.width) ? elemOffset.width : elem.offsetWidth),
                height: Math.round(angular.isNumber(elemOffset.height) ? elemOffset.height : elem.offsetHeight),
                top: Math.round(elemOffset.top - parentOffset.top),
                left: Math.round(elemOffset.left - parentOffset.left)
            };
        },
        offset: function(elem) {
            elem = this.getRawNode(elem);
            var elemBCR = elem.getBoundingClientRect();
            return {
                width: Math.round(angular.isNumber(elemBCR.width) ? elemBCR.width : elem.offsetWidth),
                height: Math.round(angular.isNumber(elemBCR.height) ? elemBCR.height : elem.offsetHeight),
                top: Math.round(elemBCR.top + ($window.pageYOffset || $document[0].documentElement.scrollTop)),
                left: Math.round(elemBCR.left + ($window.pageXOffset || $document[0].documentElement.scrollLeft))
            };
        },
        viewportOffset: function(elem, useDocument, includePadding) {
            elem = this.getRawNode(elem), includePadding = includePadding !== !1 ? !0 : !1;
            var elemBCR = elem.getBoundingClientRect(), offsetBCR = {
                top: 0,
                left: 0,
                bottom: 0,
                right: 0
            }, offsetParent = useDocument ? $document[0].documentElement : this.scrollParent(elem), offsetParentBCR = offsetParent.getBoundingClientRect();
            if (offsetBCR.top = offsetParentBCR.top + offsetParent.clientTop, offsetBCR.left = offsetParentBCR.left + offsetParent.clientLeft, 
            offsetParent === $document[0].documentElement && (offsetBCR.top += $window.pageYOffset, 
            offsetBCR.left += $window.pageXOffset), offsetBCR.bottom = offsetBCR.top + offsetParent.clientHeight, 
            offsetBCR.right = offsetBCR.left + offsetParent.clientWidth, includePadding) {
                var offsetParentStyle = $window.getComputedStyle(offsetParent);
                offsetBCR.top += this.parseStyle(offsetParentStyle.paddingTop), offsetBCR.bottom -= this.parseStyle(offsetParentStyle.paddingBottom), 
                offsetBCR.left += this.parseStyle(offsetParentStyle.paddingLeft), offsetBCR.right -= this.parseStyle(offsetParentStyle.paddingRight);
            }
            return {
                top: Math.round(elemBCR.top - offsetBCR.top),
                bottom: Math.round(offsetBCR.bottom - elemBCR.bottom),
                left: Math.round(elemBCR.left - offsetBCR.left),
                right: Math.round(offsetBCR.right - elemBCR.right)
            };
        },
        parsePlacement: function(placement) {
            var autoPlace = PLACEMENT_REGEX.auto.test(placement);
            return autoPlace && (placement = placement.replace(PLACEMENT_REGEX.auto, "")), placement = placement.split("-"), 
            placement[0] = placement[0] || "top", PLACEMENT_REGEX.primary.test(placement[0]) || (placement[0] = "top"), 
            placement[1] = placement[1] || "center", PLACEMENT_REGEX.secondary.test(placement[1]) || (placement[1] = "center"), 
            placement[2] = autoPlace ? !0 : !1, placement;
        },
        positionElements: function(hostElem, targetElem, placement, appendToBody) {
            hostElem = this.getRawNode(hostElem), targetElem = this.getRawNode(targetElem);
            var targetWidth = angular.isDefined(targetElem.offsetWidth) ? targetElem.offsetWidth : targetElem.prop("offsetWidth"), targetHeight = angular.isDefined(targetElem.offsetHeight) ? targetElem.offsetHeight : targetElem.prop("offsetHeight");
            placement = this.parsePlacement(placement);
            var hostElemPos = appendToBody ? this.offset(hostElem) : this.position(hostElem), targetElemPos = {
                top: 0,
                left: 0,
                placement: ""
            };
            if (placement[2]) {
                var viewportOffset = this.viewportOffset(hostElem, appendToBody), targetElemStyle = $window.getComputedStyle(targetElem), adjustedSize = {
                    width: targetWidth + Math.round(Math.abs(this.parseStyle(targetElemStyle.marginLeft) + this.parseStyle(targetElemStyle.marginRight))),
                    height: targetHeight + Math.round(Math.abs(this.parseStyle(targetElemStyle.marginTop) + this.parseStyle(targetElemStyle.marginBottom)))
                };
                if (placement[0] = "top" === placement[0] && adjustedSize.height > viewportOffset.top && adjustedSize.height <= viewportOffset.bottom ? "bottom" : "bottom" === placement[0] && adjustedSize.height > viewportOffset.bottom && adjustedSize.height <= viewportOffset.top ? "top" : "left" === placement[0] && adjustedSize.width > viewportOffset.left && adjustedSize.width <= viewportOffset.right ? "right" : "right" === placement[0] && adjustedSize.width > viewportOffset.right && adjustedSize.width <= viewportOffset.left ? "left" : placement[0], 
                placement[1] = "top" === placement[1] && adjustedSize.height - hostElemPos.height > viewportOffset.bottom && adjustedSize.height - hostElemPos.height <= viewportOffset.top ? "bottom" : "bottom" === placement[1] && adjustedSize.height - hostElemPos.height > viewportOffset.top && adjustedSize.height - hostElemPos.height <= viewportOffset.bottom ? "top" : "left" === placement[1] && adjustedSize.width - hostElemPos.width > viewportOffset.right && adjustedSize.width - hostElemPos.width <= viewportOffset.left ? "right" : "right" === placement[1] && adjustedSize.width - hostElemPos.width > viewportOffset.left && adjustedSize.width - hostElemPos.width <= viewportOffset.right ? "left" : placement[1], 
                "center" === placement[1]) if (PLACEMENT_REGEX.vertical.test(placement[0])) {
                    var xOverflow = hostElemPos.width / 2 - targetWidth / 2;
                    viewportOffset.left + xOverflow < 0 && adjustedSize.width - hostElemPos.width <= viewportOffset.right ? placement[1] = "left" : viewportOffset.right + xOverflow < 0 && adjustedSize.width - hostElemPos.width <= viewportOffset.left && (placement[1] = "right");
                } else {
                    var yOverflow = hostElemPos.height / 2 - adjustedSize.height / 2;
                    viewportOffset.top + yOverflow < 0 && adjustedSize.height - hostElemPos.height <= viewportOffset.bottom ? placement[1] = "top" : viewportOffset.bottom + yOverflow < 0 && adjustedSize.height - hostElemPos.height <= viewportOffset.top && (placement[1] = "bottom");
                }
            }
            switch (placement[0]) {
              case "top":
                targetElemPos.top = hostElemPos.top - targetHeight;
                break;

              case "bottom":
                targetElemPos.top = hostElemPos.top + hostElemPos.height;
                break;

              case "left":
                targetElemPos.left = hostElemPos.left - targetWidth;
                break;

              case "right":
                targetElemPos.left = hostElemPos.left + hostElemPos.width;
            }
            switch (placement[1]) {
              case "top":
                targetElemPos.top = hostElemPos.top;
                break;

              case "bottom":
                targetElemPos.top = hostElemPos.top + hostElemPos.height - targetHeight;
                break;

              case "left":
                targetElemPos.left = hostElemPos.left;
                break;

              case "right":
                targetElemPos.left = hostElemPos.left + hostElemPos.width - targetWidth;
                break;

              case "center":
                PLACEMENT_REGEX.vertical.test(placement[0]) ? targetElemPos.left = hostElemPos.left + hostElemPos.width / 2 - targetWidth / 2 : targetElemPos.top = hostElemPos.top + hostElemPos.height / 2 - targetHeight / 2;
            }
            return targetElemPos.top = Math.round(targetElemPos.top), targetElemPos.left = Math.round(targetElemPos.left), 
            targetElemPos.placement = "center" === placement[1] ? placement[0] : placement[0] + "-" + placement[1], 
            targetElemPos;
        },
        adjustTop: function(placementClasses, containerPosition, initialHeight, currentHeight) {
            return -1 !== placementClasses.indexOf("top") && initialHeight !== currentHeight ? {
                top: containerPosition.top - currentHeight + "px"
            } : void 0;
        },
        positionArrow: function(elem, placement) {
            elem = this.getRawNode(elem);
            var innerElem = elem.querySelector(".tooltip-inner, .popover-inner");
            if (innerElem) {
                var isTooltip = angular.element(innerElem).hasClass("tooltip-inner"), arrowElem = elem.querySelector(isTooltip ? ".tooltip-arrow" : ".arrow");
                if (arrowElem) {
                    var arrowCss = {
                        top: "",
                        bottom: "",
                        left: "",
                        right: ""
                    };
                    if (placement = this.parsePlacement(placement), "center" === placement[1]) return void angular.element(arrowElem).css(arrowCss);
                    var borderProp = "border-" + placement[0] + "-width", borderWidth = $window.getComputedStyle(arrowElem)[borderProp], borderRadiusProp = "border-";
                    borderRadiusProp += PLACEMENT_REGEX.vertical.test(placement[0]) ? placement[0] + "-" + placement[1] : placement[1] + "-" + placement[0], 
                    borderRadiusProp += "-radius";
                    var borderRadius = $window.getComputedStyle(isTooltip ? innerElem : elem)[borderRadiusProp];
                    switch (placement[0]) {
                      case "top":
                        arrowCss.bottom = isTooltip ? "0" : "-" + borderWidth;
                        break;

                      case "bottom":
                        arrowCss.top = isTooltip ? "0" : "-" + borderWidth;
                        break;

                      case "left":
                        arrowCss.right = isTooltip ? "0" : "-" + borderWidth;
                        break;

                      case "right":
                        arrowCss.left = isTooltip ? "0" : "-" + borderWidth;
                    }
                    arrowCss[placement[1]] = borderRadius, angular.element(arrowElem).css(arrowCss);
                }
            }
        }
    };
} ]), angular.module("ui.bootstrap.datepickerPopup", [ "ui.bootstrap.datepicker", "ui.bootstrap.position" ]).value("$datepickerPopupLiteralWarning", !0).constant("uibDatepickerPopupConfig", {
    altInputFormats: [],
    appendToBody: !1,
    clearText: "Clear",
    closeOnDateSelection: !0,
    closeText: "Done",
    currentText: "Today",
    datepickerPopup: "yyyy-MM-dd",
    datepickerPopupTemplateUrl: "uib/template/datepickerPopup/popup.html",
    datepickerTemplateUrl: "uib/template/datepicker/datepicker.html",
    html5Types: {
        date: "yyyy-MM-dd",
        "datetime-local": "yyyy-MM-ddTHH:mm:ss.sss",
        month: "yyyy-MM"
    },
    onOpenFocus: !0,
    showButtonBar: !0,
    placement: "auto bottom-left"
}).controller("UibDatepickerPopupController", [ "$scope", "$element", "$attrs", "$compile", "$log", "$parse", "$window", "$document", "$rootScope", "$uibPosition", "dateFilter", "uibDateParser", "uibDatepickerPopupConfig", "$timeout", "uibDatepickerConfig", "$datepickerPopupLiteralWarning", function($scope, $element, $attrs, $compile, $log, $parse, $window, $document, $rootScope, $position, dateFilter, dateParser, datepickerPopupConfig, $timeout, datepickerConfig, $datepickerPopupLiteralWarning) {
    function parseDateString(viewValue) {
        var date = dateParser.parse(viewValue, dateFormat, $scope.date);
        if (isNaN(date)) for (var i = 0; i < altInputFormats.length; i++) if (date = dateParser.parse(viewValue, altInputFormats[i], $scope.date), 
        !isNaN(date)) return date;
        return date;
    }
    function parseDate(viewValue) {
        if (angular.isNumber(viewValue) && (viewValue = new Date(viewValue)), !viewValue) return null;
        if (angular.isDate(viewValue) && !isNaN(viewValue)) return viewValue;
        if (angular.isString(viewValue)) {
            var date = parseDateString(viewValue);
            if (!isNaN(date)) return dateParser.fromTimezone(date, ngModelOptions.timezone);
        }
        return ngModel.$options && ngModel.$options.allowInvalid ? viewValue : void 0;
    }
    function validator(modelValue, viewValue) {
        var value = modelValue || viewValue;
        return $attrs.ngRequired || value ? (angular.isNumber(value) && (value = new Date(value)), 
        value ? angular.isDate(value) && !isNaN(value) ? !0 : angular.isString(value) ? !isNaN(parseDateString(value)) : !1 : !0) : !0;
    }
    function documentClickBind(event) {
        if ($scope.isOpen || !$scope.disabled) {
            var popup = $popup[0], dpContainsTarget = $element[0].contains(event.target), popupContainsTarget = void 0 !== popup.contains && popup.contains(event.target);
            !$scope.isOpen || dpContainsTarget || popupContainsTarget || $scope.$apply(function() {
                $scope.isOpen = !1;
            });
        }
    }
    function inputKeydownBind(evt) {
        27 === evt.which && $scope.isOpen ? (evt.preventDefault(), evt.stopPropagation(), 
        $scope.$apply(function() {
            $scope.isOpen = !1;
        }), $element[0].focus()) : 40 !== evt.which || $scope.isOpen || (evt.preventDefault(), 
        evt.stopPropagation(), $scope.$apply(function() {
            $scope.isOpen = !0;
        }));
    }
    function positionPopup() {
        if ($scope.isOpen) {
            var dpElement = angular.element($popup[0].querySelector(".uib-datepicker-popup")), placement = $attrs.popupPlacement ? $attrs.popupPlacement : datepickerPopupConfig.placement, position = $position.positionElements($element, dpElement, placement, appendToBody);
            dpElement.css({
                top: position.top + "px",
                left: position.left + "px"
            }), dpElement.hasClass("uib-position-measure") && dpElement.removeClass("uib-position-measure");
        }
    }
    var dateFormat, closeOnDateSelection, appendToBody, onOpenFocus, datepickerPopupTemplateUrl, datepickerTemplateUrl, popupEl, datepickerEl, scrollParentEl, ngModel, ngModelOptions, $popup, altInputFormats, isHtml5DateInput = !1, watchListeners = [];
    this.init = function(_ngModel_) {
        if (ngModel = _ngModel_, ngModelOptions = angular.isObject(_ngModel_.$options) ? _ngModel_.$options : {
            timezone: null
        }, closeOnDateSelection = angular.isDefined($attrs.closeOnDateSelection) ? $scope.$parent.$eval($attrs.closeOnDateSelection) : datepickerPopupConfig.closeOnDateSelection, 
        appendToBody = angular.isDefined($attrs.datepickerAppendToBody) ? $scope.$parent.$eval($attrs.datepickerAppendToBody) : datepickerPopupConfig.appendToBody, 
        onOpenFocus = angular.isDefined($attrs.onOpenFocus) ? $scope.$parent.$eval($attrs.onOpenFocus) : datepickerPopupConfig.onOpenFocus, 
        datepickerPopupTemplateUrl = angular.isDefined($attrs.datepickerPopupTemplateUrl) ? $attrs.datepickerPopupTemplateUrl : datepickerPopupConfig.datepickerPopupTemplateUrl, 
        datepickerTemplateUrl = angular.isDefined($attrs.datepickerTemplateUrl) ? $attrs.datepickerTemplateUrl : datepickerPopupConfig.datepickerTemplateUrl, 
        altInputFormats = angular.isDefined($attrs.altInputFormats) ? $scope.$parent.$eval($attrs.altInputFormats) : datepickerPopupConfig.altInputFormats, 
        $scope.showButtonBar = angular.isDefined($attrs.showButtonBar) ? $scope.$parent.$eval($attrs.showButtonBar) : datepickerPopupConfig.showButtonBar, 
        datepickerPopupConfig.html5Types[$attrs.type] ? (dateFormat = datepickerPopupConfig.html5Types[$attrs.type], 
        isHtml5DateInput = !0) : (dateFormat = $attrs.uibDatepickerPopup || datepickerPopupConfig.datepickerPopup, 
        $attrs.$observe("uibDatepickerPopup", function(value) {
            var newDateFormat = value || datepickerPopupConfig.datepickerPopup;
            if (newDateFormat !== dateFormat && (dateFormat = newDateFormat, ngModel.$modelValue = null, 
            !dateFormat)) throw new Error("uibDatepickerPopup must have a date format specified.");
        })), !dateFormat) throw new Error("uibDatepickerPopup must have a date format specified.");
        if (isHtml5DateInput && $attrs.uibDatepickerPopup) throw new Error("HTML5 date input types do not support custom formats.");
        popupEl = angular.element("<div uib-datepicker-popup-wrap><div uib-datepicker></div></div>"), 
        popupEl.attr({
            "ng-model": "date",
            "ng-change": "dateSelection(date)",
            "template-url": datepickerPopupTemplateUrl
        }), datepickerEl = angular.element(popupEl.children()[0]), datepickerEl.attr("template-url", datepickerTemplateUrl), 
        $scope.datepickerOptions || ($scope.datepickerOptions = {}), isHtml5DateInput && "month" === $attrs.type && ($scope.datepickerOptions.datepickerMode = "month", 
        $scope.datepickerOptions.minMode = "month"), datepickerEl.attr("datepicker-options", "datepickerOptions"), 
        isHtml5DateInput ? ngModel.$formatters.push(function(value) {
            return $scope.date = dateParser.fromTimezone(value, ngModelOptions.timezone), value;
        }) : (ngModel.$$parserName = "date", ngModel.$validators.date = validator, ngModel.$parsers.unshift(parseDate), 
        ngModel.$formatters.push(function(value) {
            return ngModel.$isEmpty(value) ? ($scope.date = value, value) : (angular.isNumber(value) && (value = new Date(value)), 
            $scope.date = dateParser.fromTimezone(value, ngModelOptions.timezone), dateParser.filter($scope.date, dateFormat));
        })), ngModel.$viewChangeListeners.push(function() {
            $scope.date = parseDateString(ngModel.$viewValue);
        }), $element.on("keydown", inputKeydownBind), $popup = $compile(popupEl)($scope), 
        popupEl.remove(), appendToBody ? $document.find("body").append($popup) : $element.after($popup), 
        $scope.$on("$destroy", function() {
            for ($scope.isOpen === !0 && ($rootScope.$$phase || $scope.$apply(function() {
                $scope.isOpen = !1;
            })), $popup.remove(), $element.off("keydown", inputKeydownBind), $document.off("click", documentClickBind), 
            scrollParentEl && scrollParentEl.off("scroll", positionPopup), angular.element($window).off("resize", positionPopup); watchListeners.length; ) watchListeners.shift()();
        });
    }, $scope.getText = function(key) {
        return $scope[key + "Text"] || datepickerPopupConfig[key + "Text"];
    }, $scope.isDisabled = function(date) {
        "today" === date && (date = dateParser.fromTimezone(new Date(), ngModelOptions.timezone));
        var dates = {};
        return angular.forEach([ "minDate", "maxDate" ], function(key) {
            $scope.datepickerOptions[key] ? angular.isDate($scope.datepickerOptions[key]) ? dates[key] = new Date($scope.datepickerOptions[key]) : ($datepickerPopupLiteralWarning && $log.warn("Literal date support has been deprecated, please switch to date object usage"), 
            dates[key] = new Date(dateFilter($scope.datepickerOptions[key], "medium"))) : dates[key] = null;
        }), $scope.datepickerOptions && dates.minDate && $scope.compare(date, dates.minDate) < 0 || dates.maxDate && $scope.compare(date, dates.maxDate) > 0;
    }, $scope.compare = function(date1, date2) {
        return new Date(date1.getFullYear(), date1.getMonth(), date1.getDate()) - new Date(date2.getFullYear(), date2.getMonth(), date2.getDate());
    }, $scope.dateSelection = function(dt) {
        $scope.date = dt;
        var date = $scope.date ? dateParser.filter($scope.date, dateFormat) : null;
        $element.val(date), ngModel.$setViewValue(date), closeOnDateSelection && ($scope.isOpen = !1, 
        $element[0].focus());
    }, $scope.keydown = function(evt) {
        27 === evt.which && (evt.stopPropagation(), $scope.isOpen = !1, $element[0].focus());
    }, $scope.select = function(date, evt) {
        if (evt.stopPropagation(), "today" === date) {
            var today = new Date();
            angular.isDate($scope.date) ? (date = new Date($scope.date), date.setFullYear(today.getFullYear(), today.getMonth(), today.getDate())) : (date = dateParser.fromTimezone(today, ngModelOptions.timezone), 
            date.setHours(0, 0, 0, 0));
        }
        $scope.dateSelection(date);
    }, $scope.close = function(evt) {
        evt.stopPropagation(), $scope.isOpen = !1, $element[0].focus();
    }, $scope.disabled = angular.isDefined($attrs.disabled) || !1, $attrs.ngDisabled && watchListeners.push($scope.$parent.$watch($parse($attrs.ngDisabled), function(disabled) {
        $scope.disabled = disabled;
    })), $scope.$watch("isOpen", function(value) {
        value ? $scope.disabled ? $scope.isOpen = !1 : $timeout(function() {
            positionPopup(), onOpenFocus && $scope.$broadcast("uib:datepicker.focus"), $document.on("click", documentClickBind);
            var placement = $attrs.popupPlacement ? $attrs.popupPlacement : datepickerPopupConfig.placement;
            appendToBody || $position.parsePlacement(placement)[2] ? (scrollParentEl = scrollParentEl || angular.element($position.scrollParent($element)), 
            scrollParentEl && scrollParentEl.on("scroll", positionPopup)) : scrollParentEl = null, 
            angular.element($window).on("resize", positionPopup);
        }, 0, !1) : ($document.off("click", documentClickBind), scrollParentEl && scrollParentEl.off("scroll", positionPopup), 
        angular.element($window).off("resize", positionPopup));
    }), $scope.$on("uib:datepicker.mode", function() {
        $timeout(positionPopup, 0, !1);
    });
} ]).directive("uibDatepickerPopup", function() {
    return {
        require: [ "ngModel", "uibDatepickerPopup" ],
        controller: "UibDatepickerPopupController",
        scope: {
            datepickerOptions: "=?",
            isOpen: "=?",
            currentText: "@",
            clearText: "@",
            closeText: "@"
        },
        link: function(scope, element, attrs, ctrls) {
            var ngModel = ctrls[0], ctrl = ctrls[1];
            ctrl.init(ngModel);
        }
    };
}).directive("uibDatepickerPopupWrap", function() {
    return {
        restrict: "A",
        transclude: !0,
        templateUrl: function(element, attrs) {
            return attrs.templateUrl || "uib/template/datepickerPopup/popup.html";
        }
    };
}), angular.module("ui.bootstrap.debounce", []).factory("$$debounce", [ "$timeout", function($timeout) {
    return function(callback, debounceTime) {
        var timeoutPromise;
        return function() {
            var self = this, args = Array.prototype.slice.call(arguments);
            timeoutPromise && $timeout.cancel(timeoutPromise), timeoutPromise = $timeout(function() {
                callback.apply(self, args);
            }, debounceTime);
        };
    };
} ]), angular.module("ui.bootstrap.dropdown", [ "ui.bootstrap.position" ]).constant("uibDropdownConfig", {
    appendToOpenClass: "uib-dropdown-open",
    openClass: "open"
}).service("uibDropdownService", [ "$document", "$rootScope", function($document, $rootScope) {
    var openScope = null;
    this.open = function(dropdownScope) {
        openScope || $document.on("click", closeDropdown), openScope && openScope !== dropdownScope && (openScope.isOpen = !1), 
        openScope = dropdownScope;
    }, this.close = function(dropdownScope) {
        openScope === dropdownScope && (openScope = null, $document.off("click", closeDropdown), 
        $document.off("keydown", this.keybindFilter));
    };
    var closeDropdown = function(evt) {
        if (openScope && !(evt && "disabled" === openScope.getAutoClose() || evt && 3 === evt.which)) {
            var toggleElement = openScope.getToggleElement();
            if (!(evt && toggleElement && toggleElement[0].contains(evt.target))) {
                var dropdownElement = openScope.getDropdownElement();
                evt && "outsideClick" === openScope.getAutoClose() && dropdownElement && dropdownElement[0].contains(evt.target) || (openScope.isOpen = !1, 
                openScope.focusToggleElement(), $rootScope.$$phase || openScope.$apply());
            }
        }
    };
    this.keybindFilter = function(evt) {
        var dropdownElement = openScope.getDropdownElement(), toggleElement = openScope.getToggleElement(), dropdownElementTargeted = dropdownElement && dropdownElement[0].contains(evt.target), toggleElementTargeted = toggleElement && toggleElement[0].contains(evt.target);
        27 === evt.which ? (evt.stopPropagation(), openScope.focusToggleElement(), closeDropdown()) : openScope.isKeynavEnabled() && -1 !== [ 38, 40 ].indexOf(evt.which) && openScope.isOpen && (dropdownElementTargeted || toggleElementTargeted) && (evt.preventDefault(), 
        evt.stopPropagation(), openScope.focusDropdownEntry(evt.which));
    };
} ]).controller("UibDropdownController", [ "$scope", "$element", "$attrs", "$parse", "uibDropdownConfig", "uibDropdownService", "$animate", "$uibPosition", "$document", "$compile", "$templateRequest", function($scope, $element, $attrs, $parse, dropdownConfig, uibDropdownService, $animate, $position, $document, $compile, $templateRequest) {
    var templateScope, getIsOpen, self = this, scope = $scope.$new(), appendToOpenClass = dropdownConfig.appendToOpenClass, openClass = dropdownConfig.openClass, setIsOpen = angular.noop, toggleInvoker = $attrs.onToggle ? $parse($attrs.onToggle) : angular.noop, appendToBody = !1, appendTo = null, keynavEnabled = !1, body = $document.find("body");
    $element.addClass("dropdown"), this.init = function() {
        if ($attrs.isOpen && (getIsOpen = $parse($attrs.isOpen), setIsOpen = getIsOpen.assign, 
        $scope.$watch(getIsOpen, function(value) {
            scope.isOpen = !!value;
        })), angular.isDefined($attrs.dropdownAppendTo)) {
            var appendToEl = $parse($attrs.dropdownAppendTo)(scope);
            appendToEl && (appendTo = angular.element(appendToEl));
        }
        appendToBody = angular.isDefined($attrs.dropdownAppendToBody), keynavEnabled = angular.isDefined($attrs.keyboardNav), 
        appendToBody && !appendTo && (appendTo = body), appendTo && self.dropdownMenu && (appendTo.append(self.dropdownMenu), 
        $element.on("$destroy", function() {
            self.dropdownMenu.remove();
        }));
    }, this.toggle = function(open) {
        return scope.isOpen = arguments.length ? !!open : !scope.isOpen, angular.isFunction(setIsOpen) && setIsOpen(scope, scope.isOpen), 
        scope.isOpen;
    }, this.isOpen = function() {
        return scope.isOpen;
    }, scope.getToggleElement = function() {
        return self.toggleElement;
    }, scope.getAutoClose = function() {
        return $attrs.autoClose || "always";
    }, scope.getElement = function() {
        return $element;
    }, scope.isKeynavEnabled = function() {
        return keynavEnabled;
    }, scope.focusDropdownEntry = function(keyCode) {
        var elems = self.dropdownMenu ? angular.element(self.dropdownMenu).find("a") : $element.find("ul").eq(0).find("a");
        switch (keyCode) {
          case 40:
            self.selectedOption = angular.isNumber(self.selectedOption) ? self.selectedOption === elems.length - 1 ? self.selectedOption : self.selectedOption + 1 : 0;
            break;

          case 38:
            self.selectedOption = angular.isNumber(self.selectedOption) ? 0 === self.selectedOption ? 0 : self.selectedOption - 1 : elems.length - 1;
        }
        elems[self.selectedOption].focus();
    }, scope.getDropdownElement = function() {
        return self.dropdownMenu;
    }, scope.focusToggleElement = function() {
        self.toggleElement && self.toggleElement[0].focus();
    }, scope.$watch("isOpen", function(isOpen, wasOpen) {
        if (appendTo && self.dropdownMenu) {
            var css, rightalign, scrollbarPadding, pos = $position.positionElements($element, self.dropdownMenu, "bottom-left", !0), scrollbarWidth = 0;
            if (css = {
                top: pos.top + "px",
                display: isOpen ? "block" : "none"
            }, rightalign = self.dropdownMenu.hasClass("dropdown-menu-right"), rightalign ? (css.left = "auto", 
            scrollbarPadding = $position.scrollbarPadding(appendTo), scrollbarPadding.heightOverflow && scrollbarPadding.scrollbarWidth && (scrollbarWidth = scrollbarPadding.scrollbarWidth), 
            css.right = window.innerWidth - scrollbarWidth - (pos.left + $element.prop("offsetWidth")) + "px") : (css.left = pos.left + "px", 
            css.right = "auto"), !appendToBody) {
                var appendOffset = $position.offset(appendTo);
                css.top = pos.top - appendOffset.top + "px", rightalign ? css.right = window.innerWidth - (pos.left - appendOffset.left + $element.prop("offsetWidth")) + "px" : css.left = pos.left - appendOffset.left + "px";
            }
            self.dropdownMenu.css(css);
        }
        var openContainer = appendTo ? appendTo : $element, hasOpenClass = openContainer.hasClass(appendTo ? appendToOpenClass : openClass);
        if (hasOpenClass === !isOpen && $animate[isOpen ? "addClass" : "removeClass"](openContainer, appendTo ? appendToOpenClass : openClass).then(function() {
            angular.isDefined(isOpen) && isOpen !== wasOpen && toggleInvoker($scope, {
                open: !!isOpen
            });
        }), isOpen) self.dropdownMenuTemplateUrl ? $templateRequest(self.dropdownMenuTemplateUrl).then(function(tplContent) {
            templateScope = scope.$new(), $compile(tplContent.trim())(templateScope, function(dropdownElement) {
                var newEl = dropdownElement;
                self.dropdownMenu.replaceWith(newEl), self.dropdownMenu = newEl, $document.on("keydown", uibDropdownService.keybindFilter);
            });
        }) : $document.on("keydown", uibDropdownService.keybindFilter), scope.focusToggleElement(), 
        uibDropdownService.open(scope, $element); else {
            if (uibDropdownService.close(scope, $element), self.dropdownMenuTemplateUrl) {
                templateScope && templateScope.$destroy();
                var newEl = angular.element('<ul class="dropdown-menu"></ul>');
                self.dropdownMenu.replaceWith(newEl), self.dropdownMenu = newEl;
            }
            self.selectedOption = null;
        }
        angular.isFunction(setIsOpen) && setIsOpen($scope, isOpen);
    });
} ]).directive("uibDropdown", function() {
    return {
        controller: "UibDropdownController",
        link: function(scope, element, attrs, dropdownCtrl) {
            dropdownCtrl.init();
        }
    };
}).directive("uibDropdownMenu", function() {
    return {
        restrict: "A",
        require: "?^uibDropdown",
        link: function(scope, element, attrs, dropdownCtrl) {
            if (dropdownCtrl && !angular.isDefined(attrs.dropdownNested)) {
                element.addClass("dropdown-menu");
                var tplUrl = attrs.templateUrl;
                tplUrl && (dropdownCtrl.dropdownMenuTemplateUrl = tplUrl), dropdownCtrl.dropdownMenu || (dropdownCtrl.dropdownMenu = element);
            }
        }
    };
}).directive("uibDropdownToggle", function() {
    return {
        require: "?^uibDropdown",
        link: function(scope, element, attrs, dropdownCtrl) {
            if (dropdownCtrl) {
                element.addClass("dropdown-toggle"), dropdownCtrl.toggleElement = element;
                var toggleDropdown = function(event) {
                    event.preventDefault(), element.hasClass("disabled") || attrs.disabled || scope.$apply(function() {
                        dropdownCtrl.toggle();
                    });
                };
                element.bind("click", toggleDropdown), element.attr({
                    "aria-haspopup": !0,
                    "aria-expanded": !1
                }), scope.$watch(dropdownCtrl.isOpen, function(isOpen) {
                    element.attr("aria-expanded", !!isOpen);
                }), scope.$on("$destroy", function() {
                    element.unbind("click", toggleDropdown);
                });
            }
        }
    };
}), angular.module("ui.bootstrap.stackedMap", []).factory("$$stackedMap", function() {
    return {
        createNew: function() {
            var stack = [];
            return {
                add: function(key, value) {
                    stack.push({
                        key: key,
                        value: value
                    });
                },
                get: function(key) {
                    for (var i = 0; i < stack.length; i++) if (key === stack[i].key) return stack[i];
                },
                keys: function() {
                    for (var keys = [], i = 0; i < stack.length; i++) keys.push(stack[i].key);
                    return keys;
                },
                top: function() {
                    return stack[stack.length - 1];
                },
                remove: function(key) {
                    for (var idx = -1, i = 0; i < stack.length; i++) if (key === stack[i].key) {
                        idx = i;
                        break;
                    }
                    return stack.splice(idx, 1)[0];
                },
                removeTop: function() {
                    return stack.pop();
                },
                length: function() {
                    return stack.length;
                }
            };
        }
    };
}), angular.module("ui.bootstrap.modal", [ "ui.bootstrap.stackedMap", "ui.bootstrap.position" ]).factory("$$multiMap", function() {
    return {
        createNew: function() {
            var map = {};
            return {
                entries: function() {
                    return Object.keys(map).map(function(key) {
                        return {
                            key: key,
                            value: map[key]
                        };
                    });
                },
                get: function(key) {
                    return map[key];
                },
                hasKey: function(key) {
                    return !!map[key];
                },
                keys: function() {
                    return Object.keys(map);
                },
                put: function(key, value) {
                    map[key] || (map[key] = []), map[key].push(value);
                },
                remove: function(key, value) {
                    var values = map[key];
                    if (values) {
                        var idx = values.indexOf(value);
                        -1 !== idx && values.splice(idx, 1), values.length || delete map[key];
                    }
                }
            };
        }
    };
}).provider("$uibResolve", function() {
    var resolve = this;
    this.resolver = null, this.setResolver = function(resolver) {
        this.resolver = resolver;
    }, this.$get = [ "$injector", "$q", function($injector, $q) {
        var resolver = resolve.resolver ? $injector.get(resolve.resolver) : null;
        return {
            resolve: function(invocables, locals, parent, self) {
                if (resolver) return resolver.resolve(invocables, locals, parent, self);
                var promises = [];
                return angular.forEach(invocables, function(value) {
                    promises.push(angular.isFunction(value) || angular.isArray(value) ? $q.resolve($injector.invoke(value)) : angular.isString(value) ? $q.resolve($injector.get(value)) : $q.resolve(value));
                }), $q.all(promises).then(function(resolves) {
                    var resolveObj = {}, resolveIter = 0;
                    return angular.forEach(invocables, function(value, key) {
                        resolveObj[key] = resolves[resolveIter++];
                    }), resolveObj;
                });
            }
        };
    } ];
}).directive("uibModalBackdrop", [ "$animate", "$injector", "$uibModalStack", function($animate, $injector, $modalStack) {
    function linkFn(scope, element, attrs) {
        attrs.modalInClass && ($animate.addClass(element, attrs.modalInClass), scope.$on($modalStack.NOW_CLOSING_EVENT, function(e, setIsAsync) {
            var done = setIsAsync();
            scope.modalOptions.animation ? $animate.removeClass(element, attrs.modalInClass).then(done) : done();
        }));
    }
    return {
        restrict: "A",
        compile: function(tElement, tAttrs) {
            return tElement.addClass(tAttrs.backdropClass), linkFn;
        }
    };
} ]).directive("uibModalWindow", [ "$uibModalStack", "$q", "$animateCss", "$document", function($modalStack, $q, $animateCss, $document) {
    return {
        scope: {
            index: "@"
        },
        restrict: "A",
        transclude: !0,
        templateUrl: function(tElement, tAttrs) {
            return tAttrs.templateUrl || "uib/template/modal/window.html";
        },
        link: function(scope, element, attrs) {
            element.addClass(attrs.windowTopClass || ""), scope.size = attrs.size, scope.close = function(evt) {
                var modal = $modalStack.getTop();
                modal && modal.value.backdrop && "static" !== modal.value.backdrop && evt.target === evt.currentTarget && (evt.preventDefault(), 
                evt.stopPropagation(), $modalStack.dismiss(modal.key, "backdrop click"));
            }, element.on("click", scope.close), scope.$isRendered = !0;
            var modalRenderDeferObj = $q.defer();
            scope.$$postDigest(function() {
                modalRenderDeferObj.resolve();
            }), modalRenderDeferObj.promise.then(function() {
                var animationPromise = null;
                attrs.modalInClass && (animationPromise = $animateCss(element, {
                    addClass: attrs.modalInClass
                }).start(), scope.$on($modalStack.NOW_CLOSING_EVENT, function(e, setIsAsync) {
                    var done = setIsAsync();
                    $animateCss(element, {
                        removeClass: attrs.modalInClass
                    }).start().then(done);
                })), $q.when(animationPromise).then(function() {
                    var modal = $modalStack.getTop();
                    if (modal && $modalStack.modalRendered(modal.key), !$document[0].activeElement || !element[0].contains($document[0].activeElement)) {
                        var inputWithAutofocus = element[0].querySelector("[autofocus]");
                        inputWithAutofocus ? inputWithAutofocus.focus() : element[0].focus();
                    }
                });
            });
        }
    };
} ]).directive("uibModalAnimationClass", function() {
    return {
        compile: function(tElement, tAttrs) {
            tAttrs.modalAnimation && tElement.addClass(tAttrs.uibModalAnimationClass);
        }
    };
}).directive("uibModalTransclude", [ "$animate", function($animate) {
    return {
        link: function(scope, element, attrs, controller, transclude) {
            transclude(scope.$parent, function(clone) {
                element.empty(), $animate.enter(clone, element);
            });
        }
    };
} ]).factory("$uibModalStack", [ "$animate", "$animateCss", "$document", "$compile", "$rootScope", "$q", "$$multiMap", "$$stackedMap", "$uibPosition", function($animate, $animateCss, $document, $compile, $rootScope, $q, $$multiMap, $$stackedMap, $uibPosition) {
    function snake_case(name) {
        var separator = "-";
        return name.replace(SNAKE_CASE_REGEXP, function(letter, pos) {
            return (pos ? separator : "") + letter.toLowerCase();
        });
    }
    function isVisible(element) {
        return !!(element.offsetWidth || element.offsetHeight || element.getClientRects().length);
    }
    function backdropIndex() {
        for (var topBackdropIndex = -1, opened = openedWindows.keys(), i = 0; i < opened.length; i++) openedWindows.get(opened[i]).value.backdrop && (topBackdropIndex = i);
        return topBackdropIndex > -1 && topModalIndex > topBackdropIndex && (topBackdropIndex = topModalIndex), 
        topBackdropIndex;
    }
    function removeModalWindow(modalInstance, elementToReceiveFocus) {
        var modalWindow = openedWindows.get(modalInstance).value, appendToElement = modalWindow.appendTo;
        openedWindows.remove(modalInstance), previousTopOpenedModal = openedWindows.top(), 
        previousTopOpenedModal && (topModalIndex = parseInt(previousTopOpenedModal.value.modalDomEl.attr("index"), 10)), 
        removeAfterAnimate(modalWindow.modalDomEl, modalWindow.modalScope, function() {
            var modalBodyClass = modalWindow.openedClass || OPENED_MODAL_CLASS;
            openedClasses.remove(modalBodyClass, modalInstance);
            var areAnyOpen = openedClasses.hasKey(modalBodyClass);
            appendToElement.toggleClass(modalBodyClass, areAnyOpen), !areAnyOpen && scrollbarPadding && scrollbarPadding.heightOverflow && scrollbarPadding.scrollbarWidth && (appendToElement.css(scrollbarPadding.originalRight ? {
                paddingRight: scrollbarPadding.originalRight + "px"
            } : {
                paddingRight: ""
            }), scrollbarPadding = null), toggleTopWindowClass(!0);
        }, modalWindow.closedDeferred), checkRemoveBackdrop(), elementToReceiveFocus && elementToReceiveFocus.focus ? elementToReceiveFocus.focus() : appendToElement.focus && appendToElement.focus();
    }
    function toggleTopWindowClass(toggleSwitch) {
        var modalWindow;
        openedWindows.length() > 0 && (modalWindow = openedWindows.top().value, modalWindow.modalDomEl.toggleClass(modalWindow.windowTopClass || "", toggleSwitch));
    }
    function checkRemoveBackdrop() {
        if (backdropDomEl && -1 === backdropIndex()) {
            var backdropScopeRef = backdropScope;
            removeAfterAnimate(backdropDomEl, backdropScope, function() {
                backdropScopeRef = null;
            }), backdropDomEl = void 0, backdropScope = void 0;
        }
    }
    function removeAfterAnimate(domEl, scope, done, closedDeferred) {
        function afterAnimating() {
            afterAnimating.done || (afterAnimating.done = !0, $animate.leave(domEl).then(function() {
                done && done(), domEl.remove(), closedDeferred && closedDeferred.resolve();
            }), scope.$destroy());
        }
        var asyncDeferred, asyncPromise = null, setIsAsync = function() {
            return asyncDeferred || (asyncDeferred = $q.defer(), asyncPromise = asyncDeferred.promise), 
            function() {
                asyncDeferred.resolve();
            };
        };
        return scope.$broadcast($modalStack.NOW_CLOSING_EVENT, setIsAsync), $q.when(asyncPromise).then(afterAnimating);
    }
    function keydownListener(evt) {
        if (evt.isDefaultPrevented()) return evt;
        var modal = openedWindows.top();
        if (modal) switch (evt.which) {
          case 27:
            modal.value.keyboard && (evt.preventDefault(), $rootScope.$apply(function() {
                $modalStack.dismiss(modal.key, "escape key press");
            }));
            break;

          case 9:
            var list = $modalStack.loadFocusElementList(modal), focusChanged = !1;
            evt.shiftKey ? ($modalStack.isFocusInFirstItem(evt, list) || $modalStack.isModalFocused(evt, modal)) && (focusChanged = $modalStack.focusLastFocusableElement(list)) : $modalStack.isFocusInLastItem(evt, list) && (focusChanged = $modalStack.focusFirstFocusableElement(list)), 
            focusChanged && (evt.preventDefault(), evt.stopPropagation());
        }
    }
    function broadcastClosing(modalWindow, resultOrReason, closing) {
        return !modalWindow.value.modalScope.$broadcast("modal.closing", resultOrReason, closing).defaultPrevented;
    }
    var backdropDomEl, backdropScope, scrollbarPadding, OPENED_MODAL_CLASS = "modal-open", openedWindows = $$stackedMap.createNew(), openedClasses = $$multiMap.createNew(), $modalStack = {
        NOW_CLOSING_EVENT: "modal.stack.now-closing"
    }, topModalIndex = 0, previousTopOpenedModal = null, tabbableSelector = "a[href], area[href], input:not([disabled]):not([tabindex='-1']), button:not([disabled]):not([tabindex='-1']),select:not([disabled]):not([tabindex='-1']), textarea:not([disabled]):not([tabindex='-1']), iframe, object, embed, *[tabindex]:not([tabindex='-1']), *[contenteditable=true]", SNAKE_CASE_REGEXP = /[A-Z]/g;
    return $rootScope.$watch(backdropIndex, function(newBackdropIndex) {
        backdropScope && (backdropScope.index = newBackdropIndex);
    }), $document.on("keydown", keydownListener), $rootScope.$on("$destroy", function() {
        $document.off("keydown", keydownListener);
    }), $modalStack.open = function(modalInstance, modal) {
        var modalOpener = $document[0].activeElement, modalBodyClass = modal.openedClass || OPENED_MODAL_CLASS;
        toggleTopWindowClass(!1), previousTopOpenedModal = openedWindows.top(), openedWindows.add(modalInstance, {
            deferred: modal.deferred,
            renderDeferred: modal.renderDeferred,
            closedDeferred: modal.closedDeferred,
            modalScope: modal.scope,
            backdrop: modal.backdrop,
            keyboard: modal.keyboard,
            openedClass: modal.openedClass,
            windowTopClass: modal.windowTopClass,
            animation: modal.animation,
            appendTo: modal.appendTo
        }), openedClasses.put(modalBodyClass, modalInstance);
        var appendToElement = modal.appendTo, currBackdropIndex = backdropIndex();
        if (!appendToElement.length) throw new Error("appendTo element not found. Make sure that the element passed is in DOM.");
        currBackdropIndex >= 0 && !backdropDomEl && (backdropScope = $rootScope.$new(!0), 
        backdropScope.modalOptions = modal, backdropScope.index = currBackdropIndex, backdropDomEl = angular.element('<div uib-modal-backdrop="modal-backdrop"></div>'), 
        backdropDomEl.attr({
            "class": "modal-backdrop",
            "ng-style": "{'z-index': 1040 + (index && 1 || 0) + index*10}",
            "uib-modal-animation-class": "fade",
            "modal-in-class": "in"
        }), modal.backdropClass && backdropDomEl.addClass(modal.backdropClass), modal.animation && backdropDomEl.attr("modal-animation", "true"), 
        $compile(backdropDomEl)(backdropScope), $animate.enter(backdropDomEl, appendToElement), 
        $uibPosition.isScrollable(appendToElement) && (scrollbarPadding = $uibPosition.scrollbarPadding(appendToElement), 
        scrollbarPadding.heightOverflow && scrollbarPadding.scrollbarWidth && appendToElement.css({
            paddingRight: scrollbarPadding.right + "px"
        })));
        var content;
        modal.component ? (content = document.createElement(snake_case(modal.component.name)), 
        content = angular.element(content), content.attr({
            resolve: "$resolve",
            "modal-instance": "$uibModalInstance",
            close: "$close($value)",
            dismiss: "$dismiss($value)"
        }), content = $compile(content)(modal.scope)) : content = modal.content, topModalIndex = previousTopOpenedModal ? parseInt(previousTopOpenedModal.value.modalDomEl.attr("index"), 10) + 1 : 0;
        var angularDomEl = angular.element('<div uib-modal-window="modal-window"></div>');
        angularDomEl.attr({
            "class": "modal",
            "template-url": modal.windowTemplateUrl,
            "window-top-class": modal.windowTopClass,
            role: "dialog",
            "aria-labelledby": modal.ariaLabelledBy,
            "aria-describedby": modal.ariaDescribedBy,
            size: modal.size,
            index: topModalIndex,
            animate: "animate",
            "ng-style": "{'z-index': 1050 + $$topModalIndex*10, display: 'block'}",
            tabindex: -1,
            "uib-modal-animation-class": "fade",
            "modal-in-class": "in"
        }).append(content), modal.windowClass && angularDomEl.addClass(modal.windowClass), 
        modal.animation && angularDomEl.attr("modal-animation", "true"), appendToElement.addClass(modalBodyClass), 
        modal.scope && (modal.scope.$$topModalIndex = topModalIndex), $animate.enter($compile(angularDomEl)(modal.scope), appendToElement), 
        openedWindows.top().value.modalDomEl = angularDomEl, openedWindows.top().value.modalOpener = modalOpener;
    }, $modalStack.close = function(modalInstance, result) {
        var modalWindow = openedWindows.get(modalInstance);
        return modalWindow && broadcastClosing(modalWindow, result, !0) ? (modalWindow.value.modalScope.$$uibDestructionScheduled = !0, 
        modalWindow.value.deferred.resolve(result), removeModalWindow(modalInstance, modalWindow.value.modalOpener), 
        !0) : !modalWindow;
    }, $modalStack.dismiss = function(modalInstance, reason) {
        var modalWindow = openedWindows.get(modalInstance);
        return modalWindow && broadcastClosing(modalWindow, reason, !1) ? (modalWindow.value.modalScope.$$uibDestructionScheduled = !0, 
        modalWindow.value.deferred.reject(reason), removeModalWindow(modalInstance, modalWindow.value.modalOpener), 
        !0) : !modalWindow;
    }, $modalStack.dismissAll = function(reason) {
        for (var topModal = this.getTop(); topModal && this.dismiss(topModal.key, reason); ) topModal = this.getTop();
    }, $modalStack.getTop = function() {
        return openedWindows.top();
    }, $modalStack.modalRendered = function(modalInstance) {
        var modalWindow = openedWindows.get(modalInstance);
        modalWindow && modalWindow.value.renderDeferred.resolve();
    }, $modalStack.focusFirstFocusableElement = function(list) {
        return list.length > 0 ? (list[0].focus(), !0) : !1;
    }, $modalStack.focusLastFocusableElement = function(list) {
        return list.length > 0 ? (list[list.length - 1].focus(), !0) : !1;
    }, $modalStack.isModalFocused = function(evt, modalWindow) {
        if (evt && modalWindow) {
            var modalDomEl = modalWindow.value.modalDomEl;
            if (modalDomEl && modalDomEl.length) return (evt.target || evt.srcElement) === modalDomEl[0];
        }
        return !1;
    }, $modalStack.isFocusInFirstItem = function(evt, list) {
        return list.length > 0 ? (evt.target || evt.srcElement) === list[0] : !1;
    }, $modalStack.isFocusInLastItem = function(evt, list) {
        return list.length > 0 ? (evt.target || evt.srcElement) === list[list.length - 1] : !1;
    }, $modalStack.loadFocusElementList = function(modalWindow) {
        if (modalWindow) {
            var modalDomE1 = modalWindow.value.modalDomEl;
            if (modalDomE1 && modalDomE1.length) {
                var elements = modalDomE1[0].querySelectorAll(tabbableSelector);
                return elements ? Array.prototype.filter.call(elements, function(element) {
                    return isVisible(element);
                }) : elements;
            }
        }
    }, $modalStack;
} ]).provider("$uibModal", function() {
    var $modalProvider = {
        options: {
            animation: !0,
            backdrop: !0,
            keyboard: !0
        },
        $get: [ "$rootScope", "$q", "$document", "$templateRequest", "$controller", "$uibResolve", "$uibModalStack", function($rootScope, $q, $document, $templateRequest, $controller, $uibResolve, $modalStack) {
            function getTemplatePromise(options) {
                return options.template ? $q.when(options.template) : $templateRequest(angular.isFunction(options.templateUrl) ? options.templateUrl() : options.templateUrl);
            }
            var $modal = {}, promiseChain = null;
            return $modal.getPromiseChain = function() {
                return promiseChain;
            }, $modal.open = function(modalOptions) {
                function resolveWithTemplate() {
                    return templateAndResolvePromise;
                }
                var modalResultDeferred = $q.defer(), modalOpenedDeferred = $q.defer(), modalClosedDeferred = $q.defer(), modalRenderDeferred = $q.defer(), modalInstance = {
                    result: modalResultDeferred.promise,
                    opened: modalOpenedDeferred.promise,
                    closed: modalClosedDeferred.promise,
                    rendered: modalRenderDeferred.promise,
                    close: function(result) {
                        return $modalStack.close(modalInstance, result);
                    },
                    dismiss: function(reason) {
                        return $modalStack.dismiss(modalInstance, reason);
                    }
                };
                if (modalOptions = angular.extend({}, $modalProvider.options, modalOptions), modalOptions.resolve = modalOptions.resolve || {}, 
                modalOptions.appendTo = modalOptions.appendTo || $document.find("body").eq(0), !modalOptions.component && !modalOptions.template && !modalOptions.templateUrl) throw new Error("One of component or template or templateUrl options is required.");
                var templateAndResolvePromise;
                templateAndResolvePromise = modalOptions.component ? $q.when($uibResolve.resolve(modalOptions.resolve, {}, null, null)) : $q.all([ getTemplatePromise(modalOptions), $uibResolve.resolve(modalOptions.resolve, {}, null, null) ]);
                var samePromise;
                return samePromise = promiseChain = $q.all([ promiseChain ]).then(resolveWithTemplate, resolveWithTemplate).then(function(tplAndVars) {
                    function constructLocals(obj, template, instanceOnScope, injectable) {
                        obj.$scope = modalScope, obj.$scope.$resolve = {}, instanceOnScope ? obj.$scope.$uibModalInstance = modalInstance : obj.$uibModalInstance = modalInstance;
                        var resolves = template ? tplAndVars[1] : tplAndVars;
                        angular.forEach(resolves, function(value, key) {
                            injectable && (obj[key] = value), obj.$scope.$resolve[key] = value;
                        });
                    }
                    var providedScope = modalOptions.scope || $rootScope, modalScope = providedScope.$new();
                    modalScope.$close = modalInstance.close, modalScope.$dismiss = modalInstance.dismiss, 
                    modalScope.$on("$destroy", function() {
                        modalScope.$$uibDestructionScheduled || modalScope.$dismiss("$uibUnscheduledDestruction");
                    });
                    var ctrlInstance, ctrlInstantiate, modal = {
                        scope: modalScope,
                        deferred: modalResultDeferred,
                        renderDeferred: modalRenderDeferred,
                        closedDeferred: modalClosedDeferred,
                        animation: modalOptions.animation,
                        backdrop: modalOptions.backdrop,
                        keyboard: modalOptions.keyboard,
                        backdropClass: modalOptions.backdropClass,
                        windowTopClass: modalOptions.windowTopClass,
                        windowClass: modalOptions.windowClass,
                        windowTemplateUrl: modalOptions.windowTemplateUrl,
                        ariaLabelledBy: modalOptions.ariaLabelledBy,
                        ariaDescribedBy: modalOptions.ariaDescribedBy,
                        size: modalOptions.size,
                        openedClass: modalOptions.openedClass,
                        appendTo: modalOptions.appendTo
                    }, component = {}, ctrlLocals = {};
                    modalOptions.component ? (constructLocals(component, !1, !0, !1), component.name = modalOptions.component, 
                    modal.component = component) : modalOptions.controller && (constructLocals(ctrlLocals, !0, !1, !0), 
                    ctrlInstantiate = $controller(modalOptions.controller, ctrlLocals, !0, modalOptions.controllerAs), 
                    modalOptions.controllerAs && modalOptions.bindToController && (ctrlInstance = ctrlInstantiate.instance, 
                    ctrlInstance.$close = modalScope.$close, ctrlInstance.$dismiss = modalScope.$dismiss, 
                    angular.extend(ctrlInstance, {
                        $resolve: ctrlLocals.$scope.$resolve
                    }, providedScope)), ctrlInstance = ctrlInstantiate(), angular.isFunction(ctrlInstance.$onInit) && ctrlInstance.$onInit()), 
                    modalOptions.component || (modal.content = tplAndVars[0]), $modalStack.open(modalInstance, modal), 
                    modalOpenedDeferred.resolve(!0);
                }, function(reason) {
                    modalOpenedDeferred.reject(reason), modalResultDeferred.reject(reason);
                })["finally"](function() {
                    promiseChain === samePromise && (promiseChain = null);
                }), modalInstance;
            }, $modal;
        } ]
    };
    return $modalProvider;
}), angular.module("ui.bootstrap.paging", []).factory("uibPaging", [ "$parse", function($parse) {
    return {
        create: function(ctrl, $scope, $attrs) {
            ctrl.setNumPages = $attrs.numPages ? $parse($attrs.numPages).assign : angular.noop, 
            ctrl.ngModelCtrl = {
                $setViewValue: angular.noop
            }, ctrl._watchers = [], ctrl.init = function(ngModelCtrl, config) {
                ctrl.ngModelCtrl = ngModelCtrl, ctrl.config = config, ngModelCtrl.$render = function() {
                    ctrl.render();
                }, $attrs.itemsPerPage ? ctrl._watchers.push($scope.$parent.$watch($attrs.itemsPerPage, function(value) {
                    ctrl.itemsPerPage = parseInt(value, 10), $scope.totalPages = ctrl.calculateTotalPages(), 
                    ctrl.updatePage();
                })) : ctrl.itemsPerPage = config.itemsPerPage, $scope.$watch("totalItems", function(newTotal, oldTotal) {
                    (angular.isDefined(newTotal) || newTotal !== oldTotal) && ($scope.totalPages = ctrl.calculateTotalPages(), 
                    ctrl.updatePage());
                });
            }, ctrl.calculateTotalPages = function() {
                var totalPages = ctrl.itemsPerPage < 1 ? 1 : Math.ceil($scope.totalItems / ctrl.itemsPerPage);
                return Math.max(totalPages || 0, 1);
            }, ctrl.render = function() {
                $scope.page = parseInt(ctrl.ngModelCtrl.$viewValue, 10) || 1;
            }, $scope.selectPage = function(page, evt) {
                evt && evt.preventDefault();
                var clickAllowed = !$scope.ngDisabled || !evt;
                clickAllowed && $scope.page !== page && page > 0 && page <= $scope.totalPages && (evt && evt.target && evt.target.blur(), 
                ctrl.ngModelCtrl.$setViewValue(page), ctrl.ngModelCtrl.$render());
            }, $scope.getText = function(key) {
                return $scope[key + "Text"] || ctrl.config[key + "Text"];
            }, $scope.noPrevious = function() {
                return 1 === $scope.page;
            }, $scope.noNext = function() {
                return $scope.page === $scope.totalPages;
            }, ctrl.updatePage = function() {
                ctrl.setNumPages($scope.$parent, $scope.totalPages), $scope.page > $scope.totalPages ? $scope.selectPage($scope.totalPages) : ctrl.ngModelCtrl.$render();
            }, $scope.$on("$destroy", function() {
                for (;ctrl._watchers.length; ) ctrl._watchers.shift()();
            });
        }
    };
} ]), angular.module("ui.bootstrap.pager", [ "ui.bootstrap.paging", "ui.bootstrap.tabindex" ]).controller("UibPagerController", [ "$scope", "$attrs", "uibPaging", "uibPagerConfig", function($scope, $attrs, uibPaging, uibPagerConfig) {
    $scope.align = angular.isDefined($attrs.align) ? $scope.$parent.$eval($attrs.align) : uibPagerConfig.align, 
    uibPaging.create(this, $scope, $attrs);
} ]).constant("uibPagerConfig", {
    itemsPerPage: 10,
    previousText: " Previous",
    nextText: "Next ",
    align: !0
}).directive("uibPager", [ "uibPagerConfig", function(uibPagerConfig) {
    return {
        scope: {
            totalItems: "=",
            previousText: "@",
            nextText: "@",
            ngDisabled: "="
        },
        require: [ "uibPager", "?ngModel" ],
        restrict: "A",
        controller: "UibPagerController",
        controllerAs: "pager",
        templateUrl: function(element, attrs) {
            return attrs.templateUrl || "uib/template/pager/pager.html";
        },
        link: function(scope, element, attrs, ctrls) {
            element.addClass("pager");
            var paginationCtrl = ctrls[0], ngModelCtrl = ctrls[1];
            ngModelCtrl && paginationCtrl.init(ngModelCtrl, uibPagerConfig);
        }
    };
} ]), angular.module("ui.bootstrap.pagination", [ "ui.bootstrap.paging", "ui.bootstrap.tabindex" ]).controller("UibPaginationController", [ "$scope", "$attrs", "$parse", "uibPaging", "uibPaginationConfig", function($scope, $attrs, $parse, uibPaging, uibPaginationConfig) {
    function makePage(number, text, isActive) {
        return {
            number: number,
            text: text,
            active: isActive
        };
    }
    function getPages(currentPage, totalPages) {
        var pages = [], startPage = 1, endPage = totalPages, isMaxSized = angular.isDefined(maxSize) && totalPages > maxSize;
        isMaxSized && (rotate ? (startPage = Math.max(currentPage - Math.floor(maxSize / 2), 1), 
        endPage = startPage + maxSize - 1, endPage > totalPages && (endPage = totalPages, 
        startPage = endPage - maxSize + 1)) : (startPage = (Math.ceil(currentPage / maxSize) - 1) * maxSize + 1, 
        endPage = Math.min(startPage + maxSize - 1, totalPages)));
        for (var number = startPage; endPage >= number; number++) {
            var page = makePage(number, pageLabel(number), number === currentPage);
            pages.push(page);
        }
        if (isMaxSized && maxSize > 0 && (!rotate || forceEllipses || boundaryLinkNumbers)) {
            if (startPage > 1) {
                if (!boundaryLinkNumbers || startPage > 3) {
                    var previousPageSet = makePage(startPage - 1, "...", !1);
                    pages.unshift(previousPageSet);
                }
                if (boundaryLinkNumbers) {
                    if (3 === startPage) {
                        var secondPageLink = makePage(2, "2", !1);
                        pages.unshift(secondPageLink);
                    }
                    var firstPageLink = makePage(1, "1", !1);
                    pages.unshift(firstPageLink);
                }
            }
            if (totalPages > endPage) {
                if (!boundaryLinkNumbers || totalPages - 2 > endPage) {
                    var nextPageSet = makePage(endPage + 1, "...", !1);
                    pages.push(nextPageSet);
                }
                if (boundaryLinkNumbers) {
                    if (endPage === totalPages - 2) {
                        var secondToLastPageLink = makePage(totalPages - 1, totalPages - 1, !1);
                        pages.push(secondToLastPageLink);
                    }
                    var lastPageLink = makePage(totalPages, totalPages, !1);
                    pages.push(lastPageLink);
                }
            }
        }
        return pages;
    }
    var ctrl = this, maxSize = angular.isDefined($attrs.maxSize) ? $scope.$parent.$eval($attrs.maxSize) : uibPaginationConfig.maxSize, rotate = angular.isDefined($attrs.rotate) ? $scope.$parent.$eval($attrs.rotate) : uibPaginationConfig.rotate, forceEllipses = angular.isDefined($attrs.forceEllipses) ? $scope.$parent.$eval($attrs.forceEllipses) : uibPaginationConfig.forceEllipses, boundaryLinkNumbers = angular.isDefined($attrs.boundaryLinkNumbers) ? $scope.$parent.$eval($attrs.boundaryLinkNumbers) : uibPaginationConfig.boundaryLinkNumbers, pageLabel = angular.isDefined($attrs.pageLabel) ? function(idx) {
        return $scope.$parent.$eval($attrs.pageLabel, {
            $page: idx
        });
    } : angular.identity;
    $scope.boundaryLinks = angular.isDefined($attrs.boundaryLinks) ? $scope.$parent.$eval($attrs.boundaryLinks) : uibPaginationConfig.boundaryLinks, 
    $scope.directionLinks = angular.isDefined($attrs.directionLinks) ? $scope.$parent.$eval($attrs.directionLinks) : uibPaginationConfig.directionLinks, 
    uibPaging.create(this, $scope, $attrs), $attrs.maxSize && ctrl._watchers.push($scope.$parent.$watch($parse($attrs.maxSize), function(value) {
        maxSize = parseInt(value, 10), ctrl.render();
    }));
    var originalRender = this.render;
    this.render = function() {
        originalRender(), $scope.page > 0 && $scope.page <= $scope.totalPages && ($scope.pages = getPages($scope.page, $scope.totalPages));
    };
} ]).constant("uibPaginationConfig", {
    itemsPerPage: 10,
    boundaryLinks: !1,
    boundaryLinkNumbers: !1,
    directionLinks: !0,
    firstText: "First",
    previousText: "Previous",
    nextText: "Next",
    lastText: "Last",
    rotate: !0,
    forceEllipses: !1
}).directive("uibPagination", [ "$parse", "uibPaginationConfig", function($parse, uibPaginationConfig) {
    return {
        scope: {
            totalItems: "=",
            firstText: "@",
            previousText: "@",
            nextText: "@",
            lastText: "@",
            ngDisabled: "="
        },
        require: [ "uibPagination", "?ngModel" ],
        restrict: "A",
        controller: "UibPaginationController",
        controllerAs: "pagination",
        templateUrl: function(element, attrs) {
            return attrs.templateUrl || "uib/template/pagination/pagination.html";
        },
        link: function(scope, element, attrs, ctrls) {
            element.addClass("pagination");
            var paginationCtrl = ctrls[0], ngModelCtrl = ctrls[1];
            ngModelCtrl && paginationCtrl.init(ngModelCtrl, uibPaginationConfig);
        }
    };
} ]), angular.module("ui.bootstrap.tooltip", [ "ui.bootstrap.position", "ui.bootstrap.stackedMap" ]).provider("$uibTooltip", function() {
    function snake_case(name) {
        var regexp = /[A-Z]/g, separator = "-";
        return name.replace(regexp, function(letter, pos) {
            return (pos ? separator : "") + letter.toLowerCase();
        });
    }
    var defaultOptions = {
        placement: "top",
        placementClassPrefix: "",
        animation: !0,
        popupDelay: 0,
        popupCloseDelay: 0,
        useContentExp: !1
    }, triggerMap = {
        mouseenter: "mouseleave",
        click: "click",
        outsideClick: "outsideClick",
        focus: "blur",
        none: ""
    }, globalOptions = {};
    this.options = function(value) {
        angular.extend(globalOptions, value);
    }, this.setTriggers = function(triggers) {
        angular.extend(triggerMap, triggers);
    }, this.$get = [ "$window", "$compile", "$timeout", "$document", "$uibPosition", "$interpolate", "$rootScope", "$parse", "$$stackedMap", function($window, $compile, $timeout, $document, $position, $interpolate, $rootScope, $parse, $$stackedMap) {
        function keypressListener(e) {
            if (27 === e.which) {
                var last = openedTooltips.top();
                last && (last.value.close(), last = null);
            }
        }
        var openedTooltips = $$stackedMap.createNew();
        return $document.on("keyup", keypressListener), $rootScope.$on("$destroy", function() {
            $document.off("keyup", keypressListener);
        }), function(ttType, prefix, defaultTriggerShow, options) {
            function getTriggers(trigger) {
                var show = (trigger || options.trigger || defaultTriggerShow).split(" "), hide = show.map(function(trigger) {
                    return triggerMap[trigger] || trigger;
                });
                return {
                    show: show,
                    hide: hide
                };
            }
            options = angular.extend({}, defaultOptions, globalOptions, options);
            var directiveName = snake_case(ttType), startSym = $interpolate.startSymbol(), endSym = $interpolate.endSymbol(), template = "<div " + directiveName + '-popup uib-title="' + startSym + "title" + endSym + '" ' + (options.useContentExp ? 'content-exp="contentExp()" ' : 'content="' + startSym + "content" + endSym + '" ') + 'origin-scope="origScope" class="uib-position-measure ' + prefix + '" tooltip-animation-class="fade"uib-tooltip-classes ng-class="{ in: isOpen }" ></div>';
            return {
                compile: function() {
                    var tooltipLinker = $compile(template);
                    return function(scope, element, attrs) {
                        function toggleTooltipBind() {
                            ttScope.isOpen ? hideTooltipBind() : showTooltipBind();
                        }
                        function showTooltipBind() {
                            (!hasEnableExp || scope.$eval(attrs[prefix + "Enable"])) && (cancelHide(), prepareTooltip(), 
                            ttScope.popupDelay ? showTimeout || (showTimeout = $timeout(show, ttScope.popupDelay, !1)) : show());
                        }
                        function hideTooltipBind() {
                            cancelShow(), ttScope.popupCloseDelay ? hideTimeout || (hideTimeout = $timeout(hide, ttScope.popupCloseDelay, !1)) : hide();
                        }
                        function show() {
                            return cancelShow(), cancelHide(), ttScope.content ? (createTooltip(), void ttScope.$evalAsync(function() {
                                ttScope.isOpen = !0, assignIsOpen(!0), positionTooltip();
                            })) : angular.noop;
                        }
                        function cancelShow() {
                            showTimeout && ($timeout.cancel(showTimeout), showTimeout = null), positionTimeout && ($timeout.cancel(positionTimeout), 
                            positionTimeout = null);
                        }
                        function hide() {
                            ttScope && ttScope.$evalAsync(function() {
                                ttScope && (ttScope.isOpen = !1, assignIsOpen(!1), ttScope.animation ? transitionTimeout || (transitionTimeout = $timeout(removeTooltip, 150, !1)) : removeTooltip());
                            });
                        }
                        function cancelHide() {
                            hideTimeout && ($timeout.cancel(hideTimeout), hideTimeout = null), transitionTimeout && ($timeout.cancel(transitionTimeout), 
                            transitionTimeout = null);
                        }
                        function createTooltip() {
                            tooltip || (tooltipLinkedScope = ttScope.$new(), tooltip = tooltipLinker(tooltipLinkedScope, function(tooltip) {
                                appendToBody ? $document.find("body").append(tooltip) : element.after(tooltip);
                            }), openedTooltips.add(ttScope, {
                                close: hide
                            }), prepObservers());
                        }
                        function removeTooltip() {
                            cancelShow(), cancelHide(), unregisterObservers(), tooltip && (tooltip.remove(), 
                            tooltip = null), openedTooltips.remove(ttScope), tooltipLinkedScope && (tooltipLinkedScope.$destroy(), 
                            tooltipLinkedScope = null);
                        }
                        function prepareTooltip() {
                            ttScope.title = attrs[prefix + "Title"], ttScope.content = contentParse ? contentParse(scope) : attrs[ttType], 
                            ttScope.popupClass = attrs[prefix + "Class"], ttScope.placement = angular.isDefined(attrs[prefix + "Placement"]) ? attrs[prefix + "Placement"] : options.placement;
                            var placement = $position.parsePlacement(ttScope.placement);
                            lastPlacement = placement[1] ? placement[0] + "-" + placement[1] : placement[0];
                            var delay = parseInt(attrs[prefix + "PopupDelay"], 10), closeDelay = parseInt(attrs[prefix + "PopupCloseDelay"], 10);
                            ttScope.popupDelay = isNaN(delay) ? options.popupDelay : delay, ttScope.popupCloseDelay = isNaN(closeDelay) ? options.popupCloseDelay : closeDelay;
                        }
                        function assignIsOpen(isOpen) {
                            isOpenParse && angular.isFunction(isOpenParse.assign) && isOpenParse.assign(scope, isOpen);
                        }
                        function prepObservers() {
                            observers.length = 0, contentParse ? (observers.push(scope.$watch(contentParse, function(val) {
                                ttScope.content = val, !val && ttScope.isOpen && hide();
                            })), observers.push(tooltipLinkedScope.$watch(function() {
                                repositionScheduled || (repositionScheduled = !0, tooltipLinkedScope.$$postDigest(function() {
                                    repositionScheduled = !1, ttScope && ttScope.isOpen && positionTooltip();
                                }));
                            }))) : observers.push(attrs.$observe(ttType, function(val) {
                                ttScope.content = val, !val && ttScope.isOpen ? hide() : positionTooltip();
                            })), observers.push(attrs.$observe(prefix + "Title", function(val) {
                                ttScope.title = val, ttScope.isOpen && positionTooltip();
                            })), observers.push(attrs.$observe(prefix + "Placement", function(val) {
                                ttScope.placement = val ? val : options.placement, ttScope.isOpen && positionTooltip();
                            }));
                        }
                        function unregisterObservers() {
                            observers.length && (angular.forEach(observers, function(observer) {
                                observer();
                            }), observers.length = 0);
                        }
                        function bodyHideTooltipBind(e) {
                            ttScope && ttScope.isOpen && tooltip && (element[0].contains(e.target) || tooltip[0].contains(e.target) || hideTooltipBind());
                        }
                        function prepTriggers() {
                            var showTriggers = [], hideTriggers = [], val = scope.$eval(attrs[prefix + "Trigger"]);
                            unregisterTriggers(), angular.isObject(val) ? (Object.keys(val).forEach(function(key) {
                                showTriggers.push(key), hideTriggers.push(val[key]);
                            }), triggers = {
                                show: showTriggers,
                                hide: hideTriggers
                            }) : triggers = getTriggers(val), "none" !== triggers.show && triggers.show.forEach(function(trigger, idx) {
                                "outsideClick" === trigger ? (element.on("click", toggleTooltipBind), $document.on("click", bodyHideTooltipBind)) : trigger === triggers.hide[idx] ? element.on(trigger, toggleTooltipBind) : trigger && (element.on(trigger, showTooltipBind), 
                                element.on(triggers.hide[idx], hideTooltipBind)), element.on("keypress", function(e) {
                                    27 === e.which && hideTooltipBind();
                                });
                            });
                        }
                        var tooltip, tooltipLinkedScope, transitionTimeout, showTimeout, hideTimeout, positionTimeout, lastPlacement, appendToBody = angular.isDefined(options.appendToBody) ? options.appendToBody : !1, triggers = getTriggers(void 0), hasEnableExp = angular.isDefined(attrs[prefix + "Enable"]), ttScope = scope.$new(!0), repositionScheduled = !1, isOpenParse = angular.isDefined(attrs[prefix + "IsOpen"]) ? $parse(attrs[prefix + "IsOpen"]) : !1, contentParse = options.useContentExp ? $parse(attrs[ttType]) : !1, observers = [], positionTooltip = function() {
                            tooltip && tooltip.html() && (positionTimeout || (positionTimeout = $timeout(function() {
                                var ttPosition = $position.positionElements(element, tooltip, ttScope.placement, appendToBody), initialHeight = angular.isDefined(tooltip.offsetHeight) ? tooltip.offsetHeight : tooltip.prop("offsetHeight"), elementPos = appendToBody ? $position.offset(element) : $position.position(element);
                                tooltip.css({
                                    top: ttPosition.top + "px",
                                    left: ttPosition.left + "px"
                                });
                                var placementClasses = ttPosition.placement.split("-");
                                tooltip.hasClass(placementClasses[0]) || (tooltip.removeClass(lastPlacement.split("-")[0]), 
                                tooltip.addClass(placementClasses[0])), tooltip.hasClass(options.placementClassPrefix + ttPosition.placement) || (tooltip.removeClass(options.placementClassPrefix + lastPlacement), 
                                tooltip.addClass(options.placementClassPrefix + ttPosition.placement)), $timeout(function() {
                                    var currentHeight = angular.isDefined(tooltip.offsetHeight) ? tooltip.offsetHeight : tooltip.prop("offsetHeight"), adjustment = $position.adjustTop(placementClasses, elementPos, initialHeight, currentHeight);
                                    adjustment && tooltip.css(adjustment);
                                }, 0, !1), tooltip.hasClass("uib-position-measure") ? ($position.positionArrow(tooltip, ttPosition.placement), 
                                tooltip.removeClass("uib-position-measure")) : lastPlacement !== ttPosition.placement && $position.positionArrow(tooltip, ttPosition.placement), 
                                lastPlacement = ttPosition.placement, positionTimeout = null;
                            }, 0, !1)));
                        };
                        ttScope.origScope = scope, ttScope.isOpen = !1, ttScope.contentExp = function() {
                            return ttScope.content;
                        }, attrs.$observe("disabled", function(val) {
                            val && cancelShow(), val && ttScope.isOpen && hide();
                        }), isOpenParse && scope.$watch(isOpenParse, function(val) {
                            ttScope && !val === ttScope.isOpen && toggleTooltipBind();
                        });
                        var unregisterTriggers = function() {
                            triggers.show.forEach(function(trigger) {
                                "outsideClick" === trigger ? element.off("click", toggleTooltipBind) : (element.off(trigger, showTooltipBind), 
                                element.off(trigger, toggleTooltipBind));
                            }), triggers.hide.forEach(function(trigger) {
                                "outsideClick" === trigger ? $document.off("click", bodyHideTooltipBind) : element.off(trigger, hideTooltipBind);
                            });
                        };
                        prepTriggers();
                        var animation = scope.$eval(attrs[prefix + "Animation"]);
                        ttScope.animation = angular.isDefined(animation) ? !!animation : options.animation;
                        var appendToBodyVal, appendKey = prefix + "AppendToBody";
                        appendToBodyVal = appendKey in attrs && void 0 === attrs[appendKey] ? !0 : scope.$eval(attrs[appendKey]), 
                        appendToBody = angular.isDefined(appendToBodyVal) ? appendToBodyVal : appendToBody, 
                        scope.$on("$destroy", function() {
                            unregisterTriggers(), removeTooltip(), ttScope = null;
                        });
                    };
                }
            };
        };
    } ];
}).directive("uibTooltipTemplateTransclude", [ "$animate", "$sce", "$compile", "$templateRequest", function($animate, $sce, $compile, $templateRequest) {
    return {
        link: function(scope, elem, attrs) {
            var currentScope, previousElement, currentElement, origScope = scope.$eval(attrs.tooltipTemplateTranscludeScope), changeCounter = 0, cleanupLastIncludeContent = function() {
                previousElement && (previousElement.remove(), previousElement = null), currentScope && (currentScope.$destroy(), 
                currentScope = null), currentElement && ($animate.leave(currentElement).then(function() {
                    previousElement = null;
                }), previousElement = currentElement, currentElement = null);
            };
            scope.$watch($sce.parseAsResourceUrl(attrs.uibTooltipTemplateTransclude), function(src) {
                var thisChangeId = ++changeCounter;
                src ? ($templateRequest(src, !0).then(function(response) {
                    if (thisChangeId === changeCounter) {
                        var newScope = origScope.$new(), template = response, clone = $compile(template)(newScope, function(clone) {
                            cleanupLastIncludeContent(), $animate.enter(clone, elem);
                        });
                        currentScope = newScope, currentElement = clone, currentScope.$emit("$includeContentLoaded", src);
                    }
                }, function() {
                    thisChangeId === changeCounter && (cleanupLastIncludeContent(), scope.$emit("$includeContentError", src));
                }), scope.$emit("$includeContentRequested", src)) : cleanupLastIncludeContent();
            }), scope.$on("$destroy", cleanupLastIncludeContent);
        }
    };
} ]).directive("uibTooltipClasses", [ "$uibPosition", function($uibPosition) {
    return {
        restrict: "A",
        link: function(scope, element, attrs) {
            if (scope.placement) {
                var position = $uibPosition.parsePlacement(scope.placement);
                element.addClass(position[0]);
            }
            scope.popupClass && element.addClass(scope.popupClass), scope.animation && element.addClass(attrs.tooltipAnimationClass);
        }
    };
} ]).directive("uibTooltipPopup", function() {
    return {
        restrict: "A",
        scope: {
            content: "@"
        },
        templateUrl: "uib/template/tooltip/tooltip-popup.html"
    };
}).directive("uibTooltip", [ "$uibTooltip", function($uibTooltip) {
    return $uibTooltip("uibTooltip", "tooltip", "mouseenter");
} ]).directive("uibTooltipTemplatePopup", function() {
    return {
        restrict: "A",
        scope: {
            contentExp: "&",
            originScope: "&"
        },
        templateUrl: "uib/template/tooltip/tooltip-template-popup.html"
    };
}).directive("uibTooltipTemplate", [ "$uibTooltip", function($uibTooltip) {
    return $uibTooltip("uibTooltipTemplate", "tooltip", "mouseenter", {
        useContentExp: !0
    });
} ]).directive("uibTooltipHtmlPopup", function() {
    return {
        restrict: "A",
        scope: {
            contentExp: "&"
        },
        templateUrl: "uib/template/tooltip/tooltip-html-popup.html"
    };
}).directive("uibTooltipHtml", [ "$uibTooltip", function($uibTooltip) {
    return $uibTooltip("uibTooltipHtml", "tooltip", "mouseenter", {
        useContentExp: !0
    });
} ]), angular.module("ui.bootstrap.popover", [ "ui.bootstrap.tooltip" ]).directive("uibPopoverTemplatePopup", function() {
    return {
        restrict: "A",
        scope: {
            uibTitle: "@",
            contentExp: "&",
            originScope: "&"
        },
        templateUrl: "uib/template/popover/popover-template.html"
    };
}).directive("uibPopoverTemplate", [ "$uibTooltip", function($uibTooltip) {
    return $uibTooltip("uibPopoverTemplate", "popover", "click", {
        useContentExp: !0
    });
} ]).directive("uibPopoverHtmlPopup", function() {
    return {
        restrict: "A",
        scope: {
            contentExp: "&",
            uibTitle: "@"
        },
        templateUrl: "uib/template/popover/popover-html.html"
    };
}).directive("uibPopoverHtml", [ "$uibTooltip", function($uibTooltip) {
    return $uibTooltip("uibPopoverHtml", "popover", "click", {
        useContentExp: !0
    });
} ]).directive("uibPopoverPopup", function() {
    return {
        restrict: "A",
        scope: {
            uibTitle: "@",
            content: "@"
        },
        templateUrl: "uib/template/popover/popover.html"
    };
}).directive("uibPopover", [ "$uibTooltip", function($uibTooltip) {
    return $uibTooltip("uibPopover", "popover", "click");
} ]), angular.module("ui.bootstrap.progressbar", []).constant("uibProgressConfig", {
    animate: !0,
    max: 100
}).controller("UibProgressController", [ "$scope", "$attrs", "uibProgressConfig", function($scope, $attrs, progressConfig) {
    function getMaxOrDefault() {
        return angular.isDefined($scope.maxParam) ? $scope.maxParam : progressConfig.max;
    }
    var self = this, animate = angular.isDefined($attrs.animate) ? $scope.$parent.$eval($attrs.animate) : progressConfig.animate;
    this.bars = [], $scope.max = getMaxOrDefault(), this.addBar = function(bar, element, attrs) {
        animate || element.css({
            transition: "none"
        }), this.bars.push(bar), bar.max = getMaxOrDefault(), bar.title = attrs && angular.isDefined(attrs.title) ? attrs.title : "progressbar", 
        bar.$watch("value", function() {
            bar.recalculatePercentage();
        }), bar.recalculatePercentage = function() {
            var totalPercentage = self.bars.reduce(function(total, bar) {
                return bar.percent = +(100 * bar.value / bar.max).toFixed(2), total + bar.percent;
            }, 0);
            totalPercentage > 100 && (bar.percent -= totalPercentage - 100);
        }, bar.$on("$destroy", function() {
            element = null, self.removeBar(bar);
        });
    }, this.removeBar = function(bar) {
        this.bars.splice(this.bars.indexOf(bar), 1), this.bars.forEach(function(bar) {
            bar.recalculatePercentage();
        });
    }, $scope.$watch("maxParam", function() {
        self.bars.forEach(function(bar) {
            bar.max = getMaxOrDefault(), bar.recalculatePercentage();
        });
    });
} ]).directive("uibProgress", function() {
    return {
        replace: !0,
        transclude: !0,
        controller: "UibProgressController",
        require: "uibProgress",
        scope: {
            maxParam: "=?max"
        },
        templateUrl: "uib/template/progressbar/progress.html"
    };
}).directive("uibBar", function() {
    return {
        replace: !0,
        transclude: !0,
        require: "^uibProgress",
        scope: {
            value: "=",
            type: "@"
        },
        templateUrl: "uib/template/progressbar/bar.html",
        link: function(scope, element, attrs, progressCtrl) {
            progressCtrl.addBar(scope, element, attrs);
        }
    };
}).directive("uibProgressbar", function() {
    return {
        replace: !0,
        transclude: !0,
        controller: "UibProgressController",
        scope: {
            value: "=",
            maxParam: "=?max",
            type: "@"
        },
        templateUrl: "uib/template/progressbar/progressbar.html",
        link: function(scope, element, attrs, progressCtrl) {
            progressCtrl.addBar(scope, angular.element(element.children()[0]), {
                title: attrs.title
            });
        }
    };
}), angular.module("ui.bootstrap.rating", []).constant("uibRatingConfig", {
    max: 5,
    stateOn: null,
    stateOff: null,
    enableReset: !0,
    titles: [ "one", "two", "three", "four", "five" ]
}).controller("UibRatingController", [ "$scope", "$attrs", "uibRatingConfig", function($scope, $attrs, ratingConfig) {
    var ngModelCtrl = {
        $setViewValue: angular.noop
    }, self = this;
    this.init = function(ngModelCtrl_) {
        ngModelCtrl = ngModelCtrl_, ngModelCtrl.$render = this.render, ngModelCtrl.$formatters.push(function(value) {
            return angular.isNumber(value) && value << 0 !== value && (value = Math.round(value)), 
            value;
        }), this.stateOn = angular.isDefined($attrs.stateOn) ? $scope.$parent.$eval($attrs.stateOn) : ratingConfig.stateOn, 
        this.stateOff = angular.isDefined($attrs.stateOff) ? $scope.$parent.$eval($attrs.stateOff) : ratingConfig.stateOff, 
        this.enableReset = angular.isDefined($attrs.enableReset) ? $scope.$parent.$eval($attrs.enableReset) : ratingConfig.enableReset;
        var tmpTitles = angular.isDefined($attrs.titles) ? $scope.$parent.$eval($attrs.titles) : ratingConfig.titles;
        this.titles = angular.isArray(tmpTitles) && tmpTitles.length > 0 ? tmpTitles : ratingConfig.titles;
        var ratingStates = angular.isDefined($attrs.ratingStates) ? $scope.$parent.$eval($attrs.ratingStates) : new Array(angular.isDefined($attrs.max) ? $scope.$parent.$eval($attrs.max) : ratingConfig.max);
        $scope.range = this.buildTemplateObjects(ratingStates);
    }, this.buildTemplateObjects = function(states) {
        for (var i = 0, n = states.length; n > i; i++) states[i] = angular.extend({
            index: i
        }, {
            stateOn: this.stateOn,
            stateOff: this.stateOff,
            title: this.getTitle(i)
        }, states[i]);
        return states;
    }, this.getTitle = function(index) {
        return index >= this.titles.length ? index + 1 : this.titles[index];
    }, $scope.rate = function(value) {
        if (!$scope.readonly && value >= 0 && value <= $scope.range.length) {
            var newViewValue = self.enableReset && ngModelCtrl.$viewValue === value ? 0 : value;
            ngModelCtrl.$setViewValue(newViewValue), ngModelCtrl.$render();
        }
    }, $scope.enter = function(value) {
        $scope.readonly || ($scope.value = value), $scope.onHover({
            value: value
        });
    }, $scope.reset = function() {
        $scope.value = ngModelCtrl.$viewValue, $scope.onLeave();
    }, $scope.onKeydown = function(evt) {
        /(37|38|39|40)/.test(evt.which) && (evt.preventDefault(), evt.stopPropagation(), 
        $scope.rate($scope.value + (38 === evt.which || 39 === evt.which ? 1 : -1)));
    }, this.render = function() {
        $scope.value = ngModelCtrl.$viewValue, $scope.title = self.getTitle($scope.value - 1);
    };
} ]).directive("uibRating", function() {
    return {
        require: [ "uibRating", "ngModel" ],
        restrict: "A",
        scope: {
            readonly: "=?readOnly",
            onHover: "&",
            onLeave: "&"
        },
        controller: "UibRatingController",
        templateUrl: "uib/template/rating/rating.html",
        link: function(scope, element, attrs, ctrls) {
            var ratingCtrl = ctrls[0], ngModelCtrl = ctrls[1];
            ratingCtrl.init(ngModelCtrl);
        }
    };
}), angular.module("ui.bootstrap.tabs", []).controller("UibTabsetController", [ "$scope", function($scope) {
    function findTabIndex(index) {
        for (var i = 0; i < ctrl.tabs.length; i++) if (ctrl.tabs[i].index === index) return i;
    }
    var oldIndex, ctrl = this;
    ctrl.tabs = [], ctrl.select = function(index, evt) {
        if (!destroyed) {
            var previousIndex = findTabIndex(oldIndex), previousSelected = ctrl.tabs[previousIndex];
            if (previousSelected) {
                if (previousSelected.tab.onDeselect({
                    $event: evt,
                    $selectedIndex: index
                }), evt && evt.isDefaultPrevented()) return;
                previousSelected.tab.active = !1;
            }
            var selected = ctrl.tabs[index];
            selected ? (selected.tab.onSelect({
                $event: evt
            }), selected.tab.active = !0, ctrl.active = selected.index, oldIndex = selected.index) : !selected && angular.isDefined(oldIndex) && (ctrl.active = null, 
            oldIndex = null);
        }
    }, ctrl.addTab = function(tab) {
        if (ctrl.tabs.push({
            tab: tab,
            index: tab.index
        }), ctrl.tabs.sort(function(t1, t2) {
            return t1.index > t2.index ? 1 : t1.index < t2.index ? -1 : 0;
        }), tab.index === ctrl.active || !angular.isDefined(ctrl.active) && 1 === ctrl.tabs.length) {
            var newActiveIndex = findTabIndex(tab.index);
            ctrl.select(newActiveIndex);
        }
    }, ctrl.removeTab = function(tab) {
        for (var index, i = 0; i < ctrl.tabs.length; i++) if (ctrl.tabs[i].tab === tab) {
            index = i;
            break;
        }
        if (ctrl.tabs[index].index === ctrl.active) {
            var newActiveTabIndex = index === ctrl.tabs.length - 1 ? index - 1 : index + 1 % ctrl.tabs.length;
            ctrl.select(newActiveTabIndex);
        }
        ctrl.tabs.splice(index, 1);
    }, $scope.$watch("tabset.active", function(val) {
        angular.isDefined(val) && val !== oldIndex && ctrl.select(findTabIndex(val));
    });
    var destroyed;
    $scope.$on("$destroy", function() {
        destroyed = !0;
    });
} ]).directive("uibTabset", function() {
    return {
        transclude: !0,
        replace: !0,
        scope: {},
        bindToController: {
            active: "=?",
            type: "@"
        },
        controller: "UibTabsetController",
        controllerAs: "tabset",
        templateUrl: function(element, attrs) {
            return attrs.templateUrl || "uib/template/tabs/tabset.html";
        },
        link: function(scope, element, attrs) {
            scope.vertical = angular.isDefined(attrs.vertical) ? scope.$parent.$eval(attrs.vertical) : !1, 
            scope.justified = angular.isDefined(attrs.justified) ? scope.$parent.$eval(attrs.justified) : !1;
        }
    };
}).directive("uibTab", [ "$parse", function($parse) {
    return {
        require: "^uibTabset",
        replace: !0,
        templateUrl: function(element, attrs) {
            return attrs.templateUrl || "uib/template/tabs/tab.html";
        },
        transclude: !0,
        scope: {
            heading: "@",
            index: "=?",
            classes: "@?",
            onSelect: "&select",
            onDeselect: "&deselect"
        },
        controller: function() {},
        controllerAs: "tab",
        link: function(scope, elm, attrs, tabsetCtrl, transclude) {
            scope.disabled = !1, attrs.disable && scope.$parent.$watch($parse(attrs.disable), function(value) {
                scope.disabled = !!value;
            }), angular.isUndefined(attrs.index) && (scope.index = tabsetCtrl.tabs && tabsetCtrl.tabs.length ? Math.max.apply(null, tabsetCtrl.tabs.map(function(t) {
                return t.index;
            })) + 1 : 0), angular.isUndefined(attrs.classes) && (scope.classes = ""), scope.select = function(evt) {
                if (!scope.disabled) {
                    for (var index, i = 0; i < tabsetCtrl.tabs.length; i++) if (tabsetCtrl.tabs[i].tab === scope) {
                        index = i;
                        break;
                    }
                    tabsetCtrl.select(index, evt);
                }
            }, tabsetCtrl.addTab(scope), scope.$on("$destroy", function() {
                tabsetCtrl.removeTab(scope);
            }), scope.$transcludeFn = transclude;
        }
    };
} ]).directive("uibTabHeadingTransclude", function() {
    return {
        restrict: "A",
        require: "^uibTab",
        link: function(scope, elm) {
            scope.$watch("headingElement", function(heading) {
                heading && (elm.html(""), elm.append(heading));
            });
        }
    };
}).directive("uibTabContentTransclude", function() {
    function isTabHeading(node) {
        return node.tagName && (node.hasAttribute("uib-tab-heading") || node.hasAttribute("data-uib-tab-heading") || node.hasAttribute("x-uib-tab-heading") || "uib-tab-heading" === node.tagName.toLowerCase() || "data-uib-tab-heading" === node.tagName.toLowerCase() || "x-uib-tab-heading" === node.tagName.toLowerCase() || "uib:tab-heading" === node.tagName.toLowerCase());
    }
    return {
        restrict: "A",
        require: "^uibTabset",
        link: function(scope, elm, attrs) {
            var tab = scope.$eval(attrs.uibTabContentTransclude).tab;
            tab.$transcludeFn(tab.$parent, function(contents) {
                angular.forEach(contents, function(node) {
                    isTabHeading(node) ? tab.headingElement = node : elm.append(node);
                });
            });
        }
    };
}), angular.module("ui.bootstrap.timepicker", []).constant("uibTimepickerConfig", {
    hourStep: 1,
    minuteStep: 1,
    secondStep: 1,
    showMeridian: !0,
    showSeconds: !1,
    meridians: null,
    readonlyInput: !1,
    mousewheel: !0,
    arrowkeys: !0,
    showSpinners: !0,
    templateUrl: "uib/template/timepicker/timepicker.html"
}).controller("UibTimepickerController", [ "$scope", "$element", "$attrs", "$parse", "$log", "$locale", "uibTimepickerConfig", function($scope, $element, $attrs, $parse, $log, $locale, timepickerConfig) {
    function getHoursFromTemplate() {
        var hours = +$scope.hours, valid = $scope.showMeridian ? hours > 0 && 13 > hours : hours >= 0 && 24 > hours;
        return valid && "" !== $scope.hours ? ($scope.showMeridian && (12 === hours && (hours = 0), 
        $scope.meridian === meridians[1] && (hours += 12)), hours) : void 0;
    }
    function getMinutesFromTemplate() {
        var minutes = +$scope.minutes, valid = minutes >= 0 && 60 > minutes;
        return valid && "" !== $scope.minutes ? minutes : void 0;
    }
    function getSecondsFromTemplate() {
        var seconds = +$scope.seconds;
        return seconds >= 0 && 60 > seconds ? seconds : void 0;
    }
    function pad(value, noPad) {
        return null === value ? "" : angular.isDefined(value) && value.toString().length < 2 && !noPad ? "0" + value : value.toString();
    }
    function refresh(keyboardChange) {
        makeValid(), ngModelCtrl.$setViewValue(new Date(selected)), updateTemplate(keyboardChange);
    }
    function makeValid() {
        ngModelCtrl.$setValidity("time", !0), $scope.invalidHours = !1, $scope.invalidMinutes = !1, 
        $scope.invalidSeconds = !1;
    }
    function updateTemplate(keyboardChange) {
        if (ngModelCtrl.$modelValue) {
            var hours = selected.getHours(), minutes = selected.getMinutes(), seconds = selected.getSeconds();
            $scope.showMeridian && (hours = 0 === hours || 12 === hours ? 12 : hours % 12), 
            $scope.hours = "h" === keyboardChange ? hours : pad(hours, !padHours), "m" !== keyboardChange && ($scope.minutes = pad(minutes)), 
            $scope.meridian = selected.getHours() < 12 ? meridians[0] : meridians[1], "s" !== keyboardChange && ($scope.seconds = pad(seconds)), 
            $scope.meridian = selected.getHours() < 12 ? meridians[0] : meridians[1];
        } else $scope.hours = null, $scope.minutes = null, $scope.seconds = null, $scope.meridian = meridians[0];
    }
    function addSecondsToSelected(seconds) {
        selected = addSeconds(selected, seconds), refresh();
    }
    function addMinutes(selected, minutes) {
        return addSeconds(selected, 60 * minutes);
    }
    function addSeconds(date, seconds) {
        var dt = new Date(date.getTime() + 1e3 * seconds), newDate = new Date(date);
        return newDate.setHours(dt.getHours(), dt.getMinutes(), dt.getSeconds()), newDate;
    }
    function modelIsEmpty() {
        return !(null !== $scope.hours && "" !== $scope.hours || null !== $scope.minutes && "" !== $scope.minutes || $scope.showSeconds && (!$scope.showSeconds || null !== $scope.seconds && "" !== $scope.seconds));
    }
    var selected = new Date(), watchers = [], ngModelCtrl = {
        $setViewValue: angular.noop
    }, meridians = angular.isDefined($attrs.meridians) ? $scope.$parent.$eval($attrs.meridians) : timepickerConfig.meridians || $locale.DATETIME_FORMATS.AMPMS, padHours = angular.isDefined($attrs.padHours) ? $scope.$parent.$eval($attrs.padHours) : !0;
    $scope.tabindex = angular.isDefined($attrs.tabindex) ? $attrs.tabindex : 0, $element.removeAttr("tabindex"), 
    this.init = function(ngModelCtrl_, inputs) {
        ngModelCtrl = ngModelCtrl_, ngModelCtrl.$render = this.render, ngModelCtrl.$formatters.unshift(function(modelValue) {
            return modelValue ? new Date(modelValue) : null;
        });
        var hoursInputEl = inputs.eq(0), minutesInputEl = inputs.eq(1), secondsInputEl = inputs.eq(2), mousewheel = angular.isDefined($attrs.mousewheel) ? $scope.$parent.$eval($attrs.mousewheel) : timepickerConfig.mousewheel;
        mousewheel && this.setupMousewheelEvents(hoursInputEl, minutesInputEl, secondsInputEl);
        var arrowkeys = angular.isDefined($attrs.arrowkeys) ? $scope.$parent.$eval($attrs.arrowkeys) : timepickerConfig.arrowkeys;
        arrowkeys && this.setupArrowkeyEvents(hoursInputEl, minutesInputEl, secondsInputEl), 
        $scope.readonlyInput = angular.isDefined($attrs.readonlyInput) ? $scope.$parent.$eval($attrs.readonlyInput) : timepickerConfig.readonlyInput, 
        this.setupInputEvents(hoursInputEl, minutesInputEl, secondsInputEl);
    };
    var hourStep = timepickerConfig.hourStep;
    $attrs.hourStep && watchers.push($scope.$parent.$watch($parse($attrs.hourStep), function(value) {
        hourStep = +value;
    }));
    var minuteStep = timepickerConfig.minuteStep;
    $attrs.minuteStep && watchers.push($scope.$parent.$watch($parse($attrs.minuteStep), function(value) {
        minuteStep = +value;
    }));
    var min;
    watchers.push($scope.$parent.$watch($parse($attrs.min), function(value) {
        var dt = new Date(value);
        min = isNaN(dt) ? void 0 : dt;
    }));
    var max;
    watchers.push($scope.$parent.$watch($parse($attrs.max), function(value) {
        var dt = new Date(value);
        max = isNaN(dt) ? void 0 : dt;
    }));
    var disabled = !1;
    $attrs.ngDisabled && watchers.push($scope.$parent.$watch($parse($attrs.ngDisabled), function(value) {
        disabled = value;
    })), $scope.noIncrementHours = function() {
        var incrementedSelected = addMinutes(selected, 60 * hourStep);
        return disabled || incrementedSelected > max || selected > incrementedSelected && min > incrementedSelected;
    }, $scope.noDecrementHours = function() {
        var decrementedSelected = addMinutes(selected, 60 * -hourStep);
        return disabled || min > decrementedSelected || decrementedSelected > selected && decrementedSelected > max;
    }, $scope.noIncrementMinutes = function() {
        var incrementedSelected = addMinutes(selected, minuteStep);
        return disabled || incrementedSelected > max || selected > incrementedSelected && min > incrementedSelected;
    }, $scope.noDecrementMinutes = function() {
        var decrementedSelected = addMinutes(selected, -minuteStep);
        return disabled || min > decrementedSelected || decrementedSelected > selected && decrementedSelected > max;
    }, $scope.noIncrementSeconds = function() {
        var incrementedSelected = addSeconds(selected, secondStep);
        return disabled || incrementedSelected > max || selected > incrementedSelected && min > incrementedSelected;
    }, $scope.noDecrementSeconds = function() {
        var decrementedSelected = addSeconds(selected, -secondStep);
        return disabled || min > decrementedSelected || decrementedSelected > selected && decrementedSelected > max;
    }, $scope.noToggleMeridian = function() {
        return selected.getHours() < 12 ? disabled || addMinutes(selected, 720) > max : disabled || addMinutes(selected, -720) < min;
    };
    var secondStep = timepickerConfig.secondStep;
    $attrs.secondStep && watchers.push($scope.$parent.$watch($parse($attrs.secondStep), function(value) {
        secondStep = +value;
    })), $scope.showSeconds = timepickerConfig.showSeconds, $attrs.showSeconds && watchers.push($scope.$parent.$watch($parse($attrs.showSeconds), function(value) {
        $scope.showSeconds = !!value;
    })), $scope.showMeridian = timepickerConfig.showMeridian, $attrs.showMeridian && watchers.push($scope.$parent.$watch($parse($attrs.showMeridian), function(value) {
        if ($scope.showMeridian = !!value, ngModelCtrl.$error.time) {
            var hours = getHoursFromTemplate(), minutes = getMinutesFromTemplate();
            angular.isDefined(hours) && angular.isDefined(minutes) && (selected.setHours(hours), 
            refresh());
        } else updateTemplate();
    })), this.setupMousewheelEvents = function(hoursInputEl, minutesInputEl, secondsInputEl) {
        var isScrollingUp = function(e) {
            e.originalEvent && (e = e.originalEvent);
            var delta = e.wheelDelta ? e.wheelDelta : -e.deltaY;
            return e.detail || delta > 0;
        };
        hoursInputEl.bind("mousewheel wheel", function(e) {
            disabled || $scope.$apply(isScrollingUp(e) ? $scope.incrementHours() : $scope.decrementHours()), 
            e.preventDefault();
        }), minutesInputEl.bind("mousewheel wheel", function(e) {
            disabled || $scope.$apply(isScrollingUp(e) ? $scope.incrementMinutes() : $scope.decrementMinutes()), 
            e.preventDefault();
        }), secondsInputEl.bind("mousewheel wheel", function(e) {
            disabled || $scope.$apply(isScrollingUp(e) ? $scope.incrementSeconds() : $scope.decrementSeconds()), 
            e.preventDefault();
        });
    }, this.setupArrowkeyEvents = function(hoursInputEl, minutesInputEl, secondsInputEl) {
        hoursInputEl.bind("keydown", function(e) {
            disabled || (38 === e.which ? (e.preventDefault(), $scope.incrementHours(), $scope.$apply()) : 40 === e.which && (e.preventDefault(), 
            $scope.decrementHours(), $scope.$apply()));
        }), minutesInputEl.bind("keydown", function(e) {
            disabled || (38 === e.which ? (e.preventDefault(), $scope.incrementMinutes(), $scope.$apply()) : 40 === e.which && (e.preventDefault(), 
            $scope.decrementMinutes(), $scope.$apply()));
        }), secondsInputEl.bind("keydown", function(e) {
            disabled || (38 === e.which ? (e.preventDefault(), $scope.incrementSeconds(), $scope.$apply()) : 40 === e.which && (e.preventDefault(), 
            $scope.decrementSeconds(), $scope.$apply()));
        });
    }, this.setupInputEvents = function(hoursInputEl, minutesInputEl, secondsInputEl) {
        if ($scope.readonlyInput) return $scope.updateHours = angular.noop, $scope.updateMinutes = angular.noop, 
        void ($scope.updateSeconds = angular.noop);
        var invalidate = function(invalidHours, invalidMinutes, invalidSeconds) {
            ngModelCtrl.$setViewValue(null), ngModelCtrl.$setValidity("time", !1), angular.isDefined(invalidHours) && ($scope.invalidHours = invalidHours), 
            angular.isDefined(invalidMinutes) && ($scope.invalidMinutes = invalidMinutes), angular.isDefined(invalidSeconds) && ($scope.invalidSeconds = invalidSeconds);
        };
        $scope.updateHours = function() {
            var hours = getHoursFromTemplate(), minutes = getMinutesFromTemplate();
            ngModelCtrl.$setDirty(), angular.isDefined(hours) && angular.isDefined(minutes) ? (selected.setHours(hours), 
            selected.setMinutes(minutes), min > selected || selected > max ? invalidate(!0) : refresh("h")) : invalidate(!0);
        }, hoursInputEl.bind("blur", function() {
            ngModelCtrl.$setTouched(), modelIsEmpty() ? makeValid() : null === $scope.hours || "" === $scope.hours ? invalidate(!0) : !$scope.invalidHours && $scope.hours < 10 && $scope.$apply(function() {
                $scope.hours = pad($scope.hours, !padHours);
            });
        }), $scope.updateMinutes = function() {
            var minutes = getMinutesFromTemplate(), hours = getHoursFromTemplate();
            ngModelCtrl.$setDirty(), angular.isDefined(minutes) && angular.isDefined(hours) ? (selected.setHours(hours), 
            selected.setMinutes(minutes), min > selected || selected > max ? invalidate(void 0, !0) : refresh("m")) : invalidate(void 0, !0);
        }, minutesInputEl.bind("blur", function() {
            ngModelCtrl.$setTouched(), modelIsEmpty() ? makeValid() : null === $scope.minutes ? invalidate(void 0, !0) : !$scope.invalidMinutes && $scope.minutes < 10 && $scope.$apply(function() {
                $scope.minutes = pad($scope.minutes);
            });
        }), $scope.updateSeconds = function() {
            var seconds = getSecondsFromTemplate();
            ngModelCtrl.$setDirty(), angular.isDefined(seconds) ? (selected.setSeconds(seconds), 
            refresh("s")) : invalidate(void 0, void 0, !0);
        }, secondsInputEl.bind("blur", function() {
            modelIsEmpty() ? makeValid() : !$scope.invalidSeconds && $scope.seconds < 10 && $scope.$apply(function() {
                $scope.seconds = pad($scope.seconds);
            });
        });
    }, this.render = function() {
        var date = ngModelCtrl.$viewValue;
        isNaN(date) ? (ngModelCtrl.$setValidity("time", !1), $log.error('Timepicker directive: "ng-model" value must be a Date object, a number of milliseconds since 01.01.1970 or a string representing an RFC2822 or ISO 8601 date.')) : (date && (selected = date), 
        min > selected || selected > max ? (ngModelCtrl.$setValidity("time", !1), $scope.invalidHours = !0, 
        $scope.invalidMinutes = !0) : makeValid(), updateTemplate());
    }, $scope.showSpinners = angular.isDefined($attrs.showSpinners) ? $scope.$parent.$eval($attrs.showSpinners) : timepickerConfig.showSpinners, 
    $scope.incrementHours = function() {
        $scope.noIncrementHours() || addSecondsToSelected(60 * hourStep * 60);
    }, $scope.decrementHours = function() {
        $scope.noDecrementHours() || addSecondsToSelected(60 * -hourStep * 60);
    }, $scope.incrementMinutes = function() {
        $scope.noIncrementMinutes() || addSecondsToSelected(60 * minuteStep);
    }, $scope.decrementMinutes = function() {
        $scope.noDecrementMinutes() || addSecondsToSelected(60 * -minuteStep);
    }, $scope.incrementSeconds = function() {
        $scope.noIncrementSeconds() || addSecondsToSelected(secondStep);
    }, $scope.decrementSeconds = function() {
        $scope.noDecrementSeconds() || addSecondsToSelected(-secondStep);
    }, $scope.toggleMeridian = function() {
        var minutes = getMinutesFromTemplate(), hours = getHoursFromTemplate();
        $scope.noToggleMeridian() || (angular.isDefined(minutes) && angular.isDefined(hours) ? addSecondsToSelected(720 * (selected.getHours() < 12 ? 60 : -60)) : $scope.meridian = $scope.meridian === meridians[0] ? meridians[1] : meridians[0]);
    }, $scope.blur = function() {
        ngModelCtrl.$setTouched();
    }, $scope.$on("$destroy", function() {
        for (;watchers.length; ) watchers.shift()();
    });
} ]).directive("uibTimepicker", [ "uibTimepickerConfig", function(uibTimepickerConfig) {
    return {
        require: [ "uibTimepicker", "?^ngModel" ],
        restrict: "A",
        controller: "UibTimepickerController",
        controllerAs: "timepicker",
        scope: {},
        templateUrl: function(element, attrs) {
            return attrs.templateUrl || uibTimepickerConfig.templateUrl;
        },
        link: function(scope, element, attrs, ctrls) {
            var timepickerCtrl = ctrls[0], ngModelCtrl = ctrls[1];
            ngModelCtrl && timepickerCtrl.init(ngModelCtrl, element.find("input"));
        }
    };
} ]), angular.module("ui.bootstrap.typeahead", [ "ui.bootstrap.debounce", "ui.bootstrap.position" ]).factory("uibTypeaheadParser", [ "$parse", function($parse) {
    var TYPEAHEAD_REGEXP = /^\s*([\s\S]+?)(?:\s+as\s+([\s\S]+?))?\s+for\s+(?:([\$\w][\$\w\d]*))\s+in\s+([\s\S]+?)$/;
    return {
        parse: function(input) {
            var match = input.match(TYPEAHEAD_REGEXP);
            if (!match) throw new Error('Expected typeahead specification in form of "_modelValue_ (as _label_)? for _item_ in _collection_" but got "' + input + '".');
            return {
                itemName: match[3],
                source: $parse(match[4]),
                viewMapper: $parse(match[2] || match[1]),
                modelMapper: $parse(match[1])
            };
        }
    };
} ]).controller("UibTypeaheadController", [ "$scope", "$element", "$attrs", "$compile", "$parse", "$q", "$timeout", "$document", "$window", "$rootScope", "$$debounce", "$uibPosition", "uibTypeaheadParser", function(originalScope, element, attrs, $compile, $parse, $q, $timeout, $document, $window, $rootScope, $$debounce, $position, typeaheadParser) {
    function fireRecalculating() {
        scope.moveInProgress || (scope.moveInProgress = !0, scope.$digest()), debouncedRecalculate();
    }
    function recalculatePosition() {
        scope.position = appendToBody ? $position.offset(element) : $position.position(element), 
        scope.position.top += element.prop("offsetHeight");
    }
    var modelCtrl, ngModelOptions, HOT_KEYS = [ 9, 13, 27, 38, 40 ], eventDebounceTime = 200, minLength = originalScope.$eval(attrs.typeaheadMinLength);
    minLength || 0 === minLength || (minLength = 1), originalScope.$watch(attrs.typeaheadMinLength, function(newVal) {
        minLength = newVal || 0 === newVal ? newVal : 1;
    });
    var waitTime = originalScope.$eval(attrs.typeaheadWaitMs) || 0, isEditable = originalScope.$eval(attrs.typeaheadEditable) !== !1;
    originalScope.$watch(attrs.typeaheadEditable, function(newVal) {
        isEditable = newVal !== !1;
    });
    var hasFocus, selected, isLoadingSetter = $parse(attrs.typeaheadLoading).assign || angular.noop, isSelectEvent = attrs.typeaheadShouldSelect ? $parse(attrs.typeaheadShouldSelect) : function(scope, vals) {
        var evt = vals.$event;
        return 13 === evt.which || 9 === evt.which;
    }, onSelectCallback = $parse(attrs.typeaheadOnSelect), isSelectOnBlur = angular.isDefined(attrs.typeaheadSelectOnBlur) ? originalScope.$eval(attrs.typeaheadSelectOnBlur) : !1, isNoResultsSetter = $parse(attrs.typeaheadNoResults).assign || angular.noop, inputFormatter = attrs.typeaheadInputFormatter ? $parse(attrs.typeaheadInputFormatter) : void 0, appendToBody = attrs.typeaheadAppendToBody ? originalScope.$eval(attrs.typeaheadAppendToBody) : !1, appendTo = attrs.typeaheadAppendTo ? originalScope.$eval(attrs.typeaheadAppendTo) : null, focusFirst = originalScope.$eval(attrs.typeaheadFocusFirst) !== !1, selectOnExact = attrs.typeaheadSelectOnExact ? originalScope.$eval(attrs.typeaheadSelectOnExact) : !1, isOpenSetter = $parse(attrs.typeaheadIsOpen).assign || angular.noop, showHint = originalScope.$eval(attrs.typeaheadShowHint) || !1, parsedModel = $parse(attrs.ngModel), invokeModelSetter = $parse(attrs.ngModel + "($$$p)"), $setModelValue = function(scope, newValue) {
        return angular.isFunction(parsedModel(originalScope)) && ngModelOptions && ngModelOptions.$options && ngModelOptions.$options.getterSetter ? invokeModelSetter(scope, {
            $$$p: newValue
        }) : parsedModel.assign(scope, newValue);
    }, parserResult = typeaheadParser.parse(attrs.uibTypeahead), scope = originalScope.$new(), offDestroy = originalScope.$on("$destroy", function() {
        scope.$destroy();
    });
    scope.$on("$destroy", offDestroy);
    var popupId = "typeahead-" + scope.$id + "-" + Math.floor(1e4 * Math.random());
    element.attr({
        "aria-autocomplete": "list",
        "aria-expanded": !1,
        "aria-owns": popupId
    });
    var inputsContainer, hintInputElem;
    showHint && (inputsContainer = angular.element("<div></div>"), inputsContainer.css("position", "relative"), 
    element.after(inputsContainer), hintInputElem = element.clone(), hintInputElem.attr("placeholder", ""), 
    hintInputElem.attr("tabindex", "-1"), hintInputElem.val(""), hintInputElem.css({
        position: "absolute",
        top: "0px",
        left: "0px",
        "border-color": "transparent",
        "box-shadow": "none",
        opacity: 1,
        background: "none 0% 0% / auto repeat scroll padding-box border-box rgb(255, 255, 255)",
        color: "#999"
    }), element.css({
        position: "relative",
        "vertical-align": "top",
        "background-color": "transparent"
    }), hintInputElem.attr("id") && hintInputElem.removeAttr("id"), inputsContainer.append(hintInputElem), 
    hintInputElem.after(element));
    var popUpEl = angular.element("<div uib-typeahead-popup></div>");
    popUpEl.attr({
        id: popupId,
        matches: "matches",
        active: "activeIdx",
        select: "select(activeIdx, evt)",
        "move-in-progress": "moveInProgress",
        query: "query",
        position: "position",
        "assign-is-open": "assignIsOpen(isOpen)",
        debounce: "debounceUpdate"
    }), angular.isDefined(attrs.typeaheadTemplateUrl) && popUpEl.attr("template-url", attrs.typeaheadTemplateUrl), 
    angular.isDefined(attrs.typeaheadPopupTemplateUrl) && popUpEl.attr("popup-template-url", attrs.typeaheadPopupTemplateUrl);
    var resetHint = function() {
        showHint && hintInputElem.val("");
    }, resetMatches = function() {
        scope.matches = [], scope.activeIdx = -1, element.attr("aria-expanded", !1), resetHint();
    }, getMatchId = function(index) {
        return popupId + "-option-" + index;
    };
    scope.$watch("activeIdx", function(index) {
        0 > index ? element.removeAttr("aria-activedescendant") : element.attr("aria-activedescendant", getMatchId(index));
    });
    var inputIsExactMatch = function(inputValue, index) {
        return scope.matches.length > index && inputValue ? inputValue.toUpperCase() === scope.matches[index].label.toUpperCase() : !1;
    }, getMatchesAsync = function(inputValue, evt) {
        var locals = {
            $viewValue: inputValue
        };
        isLoadingSetter(originalScope, !0), isNoResultsSetter(originalScope, !1), $q.when(parserResult.source(originalScope, locals)).then(function(matches) {
            var onCurrentRequest = inputValue === modelCtrl.$viewValue;
            if (onCurrentRequest && hasFocus) if (matches && matches.length > 0) {
                scope.activeIdx = focusFirst ? 0 : -1, isNoResultsSetter(originalScope, !1), scope.matches.length = 0;
                for (var i = 0; i < matches.length; i++) locals[parserResult.itemName] = matches[i], 
                scope.matches.push({
                    id: getMatchId(i),
                    label: parserResult.viewMapper(scope, locals),
                    model: matches[i]
                });
                if (scope.query = inputValue, recalculatePosition(), element.attr("aria-expanded", !0), 
                selectOnExact && 1 === scope.matches.length && inputIsExactMatch(inputValue, 0) && (angular.isNumber(scope.debounceUpdate) || angular.isObject(scope.debounceUpdate) ? $$debounce(function() {
                    scope.select(0, evt);
                }, angular.isNumber(scope.debounceUpdate) ? scope.debounceUpdate : scope.debounceUpdate["default"]) : scope.select(0, evt)), 
                showHint) {
                    var firstLabel = scope.matches[0].label;
                    hintInputElem.val(angular.isString(inputValue) && inputValue.length > 0 && firstLabel.slice(0, inputValue.length).toUpperCase() === inputValue.toUpperCase() ? inputValue + firstLabel.slice(inputValue.length) : "");
                }
            } else resetMatches(), isNoResultsSetter(originalScope, !0);
            onCurrentRequest && isLoadingSetter(originalScope, !1);
        }, function() {
            resetMatches(), isLoadingSetter(originalScope, !1), isNoResultsSetter(originalScope, !0);
        });
    };
    appendToBody && (angular.element($window).on("resize", fireRecalculating), $document.find("body").on("scroll", fireRecalculating));
    var debouncedRecalculate = $$debounce(function() {
        scope.matches.length && recalculatePosition(), scope.moveInProgress = !1;
    }, eventDebounceTime);
    scope.moveInProgress = !1, scope.query = void 0;
    var timeoutPromise, scheduleSearchWithTimeout = function(inputValue) {
        timeoutPromise = $timeout(function() {
            getMatchesAsync(inputValue);
        }, waitTime);
    }, cancelPreviousTimeout = function() {
        timeoutPromise && $timeout.cancel(timeoutPromise);
    };
    resetMatches(), scope.assignIsOpen = function(isOpen) {
        isOpenSetter(originalScope, isOpen);
    }, scope.select = function(activeIdx, evt) {
        var model, item, locals = {};
        selected = !0, locals[parserResult.itemName] = item = scope.matches[activeIdx].model, 
        model = parserResult.modelMapper(originalScope, locals), $setModelValue(originalScope, model), 
        modelCtrl.$setValidity("editable", !0), modelCtrl.$setValidity("parse", !0), onSelectCallback(originalScope, {
            $item: item,
            $model: model,
            $label: parserResult.viewMapper(originalScope, locals),
            $event: evt
        }), resetMatches(), scope.$eval(attrs.typeaheadFocusOnSelect) !== !1 && $timeout(function() {
            element[0].focus();
        }, 0, !1);
    }, element.on("keydown", function(evt) {
        if (0 !== scope.matches.length && -1 !== HOT_KEYS.indexOf(evt.which)) {
            var shouldSelect = isSelectEvent(originalScope, {
                $event: evt
            });
            if (-1 === scope.activeIdx && shouldSelect || 9 === evt.which && evt.shiftKey) return resetMatches(), 
            void scope.$digest();
            evt.preventDefault();
            var target;
            switch (evt.which) {
              case 27:
                evt.stopPropagation(), resetMatches(), originalScope.$digest();
                break;

              case 38:
                scope.activeIdx = (scope.activeIdx > 0 ? scope.activeIdx : scope.matches.length) - 1, 
                scope.$digest(), target = popUpEl[0].querySelectorAll(".uib-typeahead-match")[scope.activeIdx], 
                target.parentNode.scrollTop = target.offsetTop;
                break;

              case 40:
                scope.activeIdx = (scope.activeIdx + 1) % scope.matches.length, scope.$digest(), 
                target = popUpEl[0].querySelectorAll(".uib-typeahead-match")[scope.activeIdx], target.parentNode.scrollTop = target.offsetTop;
                break;

              default:
                shouldSelect && scope.$apply(function() {
                    angular.isNumber(scope.debounceUpdate) || angular.isObject(scope.debounceUpdate) ? $$debounce(function() {
                        scope.select(scope.activeIdx, evt);
                    }, angular.isNumber(scope.debounceUpdate) ? scope.debounceUpdate : scope.debounceUpdate["default"]) : scope.select(scope.activeIdx, evt);
                });
            }
        }
    }), element.bind("focus", function(evt) {
        hasFocus = !0, 0 !== minLength || modelCtrl.$viewValue || $timeout(function() {
            getMatchesAsync(modelCtrl.$viewValue, evt);
        }, 0);
    }), element.bind("blur", function(evt) {
        isSelectOnBlur && scope.matches.length && -1 !== scope.activeIdx && !selected && (selected = !0, 
        scope.$apply(function() {
            angular.isObject(scope.debounceUpdate) && angular.isNumber(scope.debounceUpdate.blur) ? $$debounce(function() {
                scope.select(scope.activeIdx, evt);
            }, scope.debounceUpdate.blur) : scope.select(scope.activeIdx, evt);
        })), !isEditable && modelCtrl.$error.editable && (modelCtrl.$setViewValue(), scope.$apply(function() {
            modelCtrl.$setValidity("editable", !0), modelCtrl.$setValidity("parse", !0);
        }), element.val("")), hasFocus = !1, selected = !1;
    });
    var dismissClickHandler = function(evt) {
        element[0] !== evt.target && 3 !== evt.which && 0 !== scope.matches.length && (resetMatches(), 
        $rootScope.$$phase || originalScope.$digest());
    };
    $document.on("click", dismissClickHandler), originalScope.$on("$destroy", function() {
        $document.off("click", dismissClickHandler), (appendToBody || appendTo) && $popup.remove(), 
        appendToBody && (angular.element($window).off("resize", fireRecalculating), $document.find("body").off("scroll", fireRecalculating)), 
        popUpEl.remove(), showHint && inputsContainer.remove();
    });
    var $popup = $compile(popUpEl)(scope);
    appendToBody ? $document.find("body").append($popup) : appendTo ? angular.element(appendTo).eq(0).append($popup) : element.after($popup), 
    this.init = function(_modelCtrl, _ngModelOptions) {
        modelCtrl = _modelCtrl, ngModelOptions = _ngModelOptions, scope.debounceUpdate = modelCtrl.$options && $parse(modelCtrl.$options.debounce)(originalScope), 
        modelCtrl.$parsers.unshift(function(inputValue) {
            return hasFocus = !0, 0 === minLength || inputValue && inputValue.length >= minLength ? waitTime > 0 ? (cancelPreviousTimeout(), 
            scheduleSearchWithTimeout(inputValue)) : getMatchesAsync(inputValue) : (isLoadingSetter(originalScope, !1), 
            cancelPreviousTimeout(), resetMatches()), isEditable ? inputValue : inputValue ? void modelCtrl.$setValidity("editable", !1) : (modelCtrl.$setValidity("editable", !0), 
            null);
        }), modelCtrl.$formatters.push(function(modelValue) {
            var candidateViewValue, emptyViewValue, locals = {};
            return isEditable || modelCtrl.$setValidity("editable", !0), inputFormatter ? (locals.$model = modelValue, 
            inputFormatter(originalScope, locals)) : (locals[parserResult.itemName] = modelValue, 
            candidateViewValue = parserResult.viewMapper(originalScope, locals), locals[parserResult.itemName] = void 0, 
            emptyViewValue = parserResult.viewMapper(originalScope, locals), candidateViewValue !== emptyViewValue ? candidateViewValue : modelValue);
        });
    };
} ]).directive("uibTypeahead", function() {
    return {
        controller: "UibTypeaheadController",
        require: [ "ngModel", "^?ngModelOptions", "uibTypeahead" ],
        link: function(originalScope, element, attrs, ctrls) {
            ctrls[2].init(ctrls[0], ctrls[1]);
        }
    };
}).directive("uibTypeaheadPopup", [ "$$debounce", function($$debounce) {
    return {
        scope: {
            matches: "=",
            query: "=",
            active: "=",
            position: "&",
            moveInProgress: "=",
            select: "&",
            assignIsOpen: "&",
            debounce: "&"
        },
        replace: !0,
        templateUrl: function(element, attrs) {
            return attrs.popupTemplateUrl || "uib/template/typeahead/typeahead-popup.html";
        },
        link: function(scope, element, attrs) {
            scope.templateUrl = attrs.templateUrl, scope.isOpen = function() {
                var isDropdownOpen = scope.matches.length > 0;
                return scope.assignIsOpen({
                    isOpen: isDropdownOpen
                }), isDropdownOpen;
            }, scope.isActive = function(matchIdx) {
                return scope.active === matchIdx;
            }, scope.selectActive = function(matchIdx) {
                scope.active = matchIdx;
            }, scope.selectMatch = function(activeIdx, evt) {
                var debounce = scope.debounce();
                angular.isNumber(debounce) || angular.isObject(debounce) ? $$debounce(function() {
                    scope.select({
                        activeIdx: activeIdx,
                        evt: evt
                    });
                }, angular.isNumber(debounce) ? debounce : debounce["default"]) : scope.select({
                    activeIdx: activeIdx,
                    evt: evt
                });
            };
        }
    };
} ]).directive("uibTypeaheadMatch", [ "$templateRequest", "$compile", "$parse", function($templateRequest, $compile, $parse) {
    return {
        scope: {
            index: "=",
            match: "=",
            query: "="
        },
        link: function(scope, element, attrs) {
            var tplUrl = $parse(attrs.templateUrl)(scope.$parent) || "uib/template/typeahead/typeahead-match.html";
            $templateRequest(tplUrl).then(function(tplContent) {
                var tplEl = angular.element(tplContent.trim());
                element.replaceWith(tplEl), $compile(tplEl)(scope);
            });
        }
    };
} ]).filter("uibTypeaheadHighlight", [ "$sce", "$injector", "$log", function($sce, $injector, $log) {
    function escapeRegexp(queryToEscape) {
        return queryToEscape.replace(/([.?*+^$[\]\\(){}|-])/g, "\\$1");
    }
    function containsHtml(matchItem) {
        return /<.*>/g.test(matchItem);
    }
    var isSanitizePresent;
    return isSanitizePresent = $injector.has("$sanitize"), function(matchItem, query) {
        return !isSanitizePresent && containsHtml(matchItem) && $log.warn("Unsafe use of typeahead please use ngSanitize"), 
        matchItem = query ? ("" + matchItem).replace(new RegExp(escapeRegexp(query), "gi"), "<strong>$&</strong>") : matchItem, 
        isSanitizePresent || (matchItem = $sce.trustAsHtml(matchItem)), matchItem;
    };
} ]), angular.module("uib/template/accordion/accordion-group.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("uib/template/accordion/accordion-group.html", '<div role="tab" id="{{::headingId}}" aria-selected="{{isOpen}}" class="panel-heading" ng-keypress="toggleOpen($event)">\n  <h4 class="panel-title">\n    <a role="button" data-toggle="collapse" href aria-expanded="{{isOpen}}" aria-controls="{{::panelId}}" tabindex="0" class="accordion-toggle" ng-click="toggleOpen()" uib-accordion-transclude="heading" ng-disabled="isDisabled" uib-tabindex-toggle><span uib-accordion-header ng-class="{\'text-muted\': isDisabled}">{{heading}}</span></a>\n  </h4>\n</div>\n<div id="{{::panelId}}" aria-labelledby="{{::headingId}}" aria-hidden="{{!isOpen}}" role="tabpanel" class="panel-collapse collapse" uib-collapse="!isOpen">\n  <div class="panel-body" ng-transclude></div>\n</div>\n');
} ]), angular.module("uib/template/accordion/accordion.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("uib/template/accordion/accordion.html", '<div role="tablist" class="panel-group" ng-transclude></div>');
} ]), angular.module("uib/template/alert/alert.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("uib/template/alert/alert.html", '<button ng-show="closeable" type="button" class="close" ng-click="close({$event: $event})">\n  <span aria-hidden="true">&times;</span>\n  <span class="sr-only">Close</span>\n</button>\n<div ng-transclude></div>\n');
} ]), angular.module("uib/template/carousel/carousel.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("uib/template/carousel/carousel.html", '<div class="carousel-inner" ng-transclude></div>\n<a role="button" href class="left carousel-control" ng-click="prev()" ng-class="{ disabled: isPrevDisabled() }" ng-show="slides.length > 1">\n  <span aria-hidden="true" class="glyphicon glyphicon-chevron-left"></span>\n  <span class="sr-only">previous</span>\n</a>\n<a role="button" href class="right carousel-control" ng-click="next()" ng-class="{ disabled: isNextDisabled() }" ng-show="slides.length > 1">\n  <span aria-hidden="true" class="glyphicon glyphicon-chevron-right"></span>\n  <span class="sr-only">next</span>\n</a>\n<ol class="carousel-indicators" ng-show="slides.length > 1">\n  <li ng-repeat="slide in slides | orderBy:indexOfSlide track by $index" ng-class="{ active: isActive(slide) }" ng-click="select(slide)">\n    <span class="sr-only">slide {{ $index + 1 }} of {{ slides.length }}<span ng-if="isActive(slide)">, currently active</span></span>\n  </li>\n</ol>\n');
} ]), angular.module("uib/template/carousel/slide.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("uib/template/carousel/slide.html", '<div class="text-center" ng-transclude></div>\n');
} ]), angular.module("uib/template/datepicker/datepicker.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("uib/template/datepicker/datepicker.html", '<div ng-switch="datepickerMode">\n  <div uib-daypicker ng-switch-when="day" tabindex="0" class="uib-daypicker"></div>\n  <div uib-monthpicker ng-switch-when="month" tabindex="0" class="uib-monthpicker"></div>\n  <div uib-yearpicker ng-switch-when="year" tabindex="0" class="uib-yearpicker"></div>\n</div>\n');
} ]), angular.module("uib/template/datepicker/day.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("uib/template/datepicker/day.html", '<table role="grid" aria-labelledby="{{::uniqueId}}-title" aria-activedescendant="{{activeDateId}}">\n  <thead>\n    <tr>\n      <th><button type="button" class="btn btn-default btn-sm pull-left uib-left" ng-click="move(-1)" tabindex="-1"><i class="glyphicon glyphicon-chevron-left"></i></button></th>\n      <th colspan="{{::5 + showWeeks}}"><button id="{{::uniqueId}}-title" role="heading" aria-live="assertive" aria-atomic="true" type="button" class="btn btn-default btn-sm uib-title" ng-click="toggleMode()" ng-disabled="datepickerMode === maxMode" tabindex="-1"><strong>{{title}}</strong></button></th>\n      <th><button type="button" class="btn btn-default btn-sm pull-right uib-right" ng-click="move(1)" tabindex="-1"><i class="glyphicon glyphicon-chevron-right"></i></button></th>\n    </tr>\n    <tr>\n      <th ng-if="showWeeks" class="text-center"></th>\n      <th ng-repeat="label in ::labels track by $index" class="text-center"><small aria-label="{{::label.full}}">{{::label.abbr}}</small></th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr class="uib-weeks" ng-repeat="row in rows track by $index" role="row">\n      <td ng-if="showWeeks" class="text-center h6"><em>{{ weekNumbers[$index] }}</em></td>\n      <td ng-repeat="dt in row" class="uib-day text-center" role="gridcell"\n        id="{{::dt.uid}}"\n        ng-class="::dt.customClass">\n        <button type="button" class="btn btn-default btn-sm"\n          uib-is-class="\n            \'btn-info\' for selectedDt,\n            \'active\' for activeDt\n            on dt"\n          ng-click="select(dt.date)"\n          ng-disabled="::dt.disabled"\n          tabindex="-1"><span ng-class="::{\'text-muted\': dt.secondary, \'text-info\': dt.current}">{{::dt.label}}</span></button>\n      </td>\n    </tr>\n  </tbody>\n</table>\n');
} ]), angular.module("uib/template/datepicker/month.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("uib/template/datepicker/month.html", '<table role="grid" aria-labelledby="{{::uniqueId}}-title" aria-activedescendant="{{activeDateId}}">\n  <thead>\n    <tr>\n      <th><button type="button" class="btn btn-default btn-sm pull-left uib-left" ng-click="move(-1)" tabindex="-1"><i class="glyphicon glyphicon-chevron-left"></i></button></th>\n      <th colspan="{{::yearHeaderColspan}}"><button id="{{::uniqueId}}-title" role="heading" aria-live="assertive" aria-atomic="true" type="button" class="btn btn-default btn-sm uib-title" ng-click="toggleMode()" ng-disabled="datepickerMode === maxMode" tabindex="-1"><strong>{{title}}</strong></button></th>\n      <th><button type="button" class="btn btn-default btn-sm pull-right uib-right" ng-click="move(1)" tabindex="-1"><i class="glyphicon glyphicon-chevron-right"></i></button></th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr class="uib-months" ng-repeat="row in rows track by $index" role="row">\n      <td ng-repeat="dt in row" class="uib-month text-center" role="gridcell"\n        id="{{::dt.uid}}"\n        ng-class="::dt.customClass">\n        <button type="button" class="btn btn-default"\n          uib-is-class="\n            \'btn-info\' for selectedDt,\n            \'active\' for activeDt\n            on dt"\n          ng-click="select(dt.date)"\n          ng-disabled="::dt.disabled"\n          tabindex="-1"><span ng-class="::{\'text-info\': dt.current}">{{::dt.label}}</span></button>\n      </td>\n    </tr>\n  </tbody>\n</table>\n');
} ]), angular.module("uib/template/datepicker/year.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("uib/template/datepicker/year.html", '<table role="grid" aria-labelledby="{{::uniqueId}}-title" aria-activedescendant="{{activeDateId}}">\n  <thead>\n    <tr>\n      <th><button type="button" class="btn btn-default btn-sm pull-left uib-left" ng-click="move(-1)" tabindex="-1"><i class="glyphicon glyphicon-chevron-left"></i></button></th>\n      <th colspan="{{::columns - 2}}"><button id="{{::uniqueId}}-title" role="heading" aria-live="assertive" aria-atomic="true" type="button" class="btn btn-default btn-sm uib-title" ng-click="toggleMode()" ng-disabled="datepickerMode === maxMode" tabindex="-1"><strong>{{title}}</strong></button></th>\n      <th><button type="button" class="btn btn-default btn-sm pull-right uib-right" ng-click="move(1)" tabindex="-1"><i class="glyphicon glyphicon-chevron-right"></i></button></th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr class="uib-years" ng-repeat="row in rows track by $index" role="row">\n      <td ng-repeat="dt in row" class="uib-year text-center" role="gridcell"\n        id="{{::dt.uid}}"\n        ng-class="::dt.customClass">\n        <button type="button" class="btn btn-default"\n          uib-is-class="\n            \'btn-info\' for selectedDt,\n            \'active\' for activeDt\n            on dt"\n          ng-click="select(dt.date)"\n          ng-disabled="::dt.disabled"\n          tabindex="-1"><span ng-class="::{\'text-info\': dt.current}">{{::dt.label}}</span></button>\n      </td>\n    </tr>\n  </tbody>\n</table>\n');
} ]), angular.module("uib/template/datepickerPopup/popup.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("uib/template/datepickerPopup/popup.html", '<ul class="uib-datepicker-popup dropdown-menu uib-position-measure" dropdown-nested ng-if="isOpen" ng-keydown="keydown($event)" ng-click="$event.stopPropagation()">\n  <li ng-transclude></li>\n  <li ng-if="showButtonBar" class="uib-button-bar">\n    <span class="btn-group pull-left">\n      <button type="button" class="btn btn-sm btn-info uib-datepicker-current" ng-click="select(\'today\', $event)" ng-disabled="isDisabled(\'today\')">{{ getText(\'current\') }}</button>\n      <button type="button" class="btn btn-sm btn-danger uib-clear" ng-click="select(null, $event)">{{ getText(\'clear\') }}</button>\n    </span>\n    <button type="button" class="btn btn-sm btn-success pull-right uib-close" ng-click="close($event)">{{ getText(\'close\') }}</button>\n  </li>\n</ul>\n');
} ]), angular.module("uib/template/modal/window.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("uib/template/modal/window.html", "<div class=\"modal-dialog {{size ? 'modal-' + size : ''}}\"><div class=\"modal-content\" uib-modal-transclude></div></div>\n");
} ]), angular.module("uib/template/pager/pager.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("uib/template/pager/pager.html", '<li ng-class="{disabled: noPrevious()||ngDisabled, previous: align}"><a href ng-click="selectPage(page - 1, $event)" ng-disabled="noPrevious()||ngDisabled" uib-tabindex-toggle>{{::getText(\'previous\')}}</a></li>\n<li ng-class="{disabled: noNext()||ngDisabled, next: align}"><a href ng-click="selectPage(page + 1, $event)" ng-disabled="noNext()||ngDisabled" uib-tabindex-toggle>{{::getText(\'next\')}}</a></li>\n');
} ]), angular.module("uib/template/pagination/pagination.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("uib/template/pagination/pagination.html", '<li ng-if="::boundaryLinks" ng-class="{disabled: noPrevious()||ngDisabled}" class="pagination-first"><a href ng-click="selectPage(1, $event)" ng-disabled="noPrevious()||ngDisabled" uib-tabindex-toggle>{{::getText(\'first\')}}</a></li>\n<li ng-if="::directionLinks" ng-class="{disabled: noPrevious()||ngDisabled}" class="pagination-prev"><a href ng-click="selectPage(page - 1, $event)" ng-disabled="noPrevious()||ngDisabled" uib-tabindex-toggle>{{::getText(\'previous\')}}</a></li>\n<li ng-repeat="page in pages track by $index" ng-class="{active: page.active,disabled: ngDisabled&&!page.active}" class="pagination-page"><a href ng-click="selectPage(page.number, $event)" ng-disabled="ngDisabled&&!page.active" uib-tabindex-toggle>{{page.text}}</a></li>\n<li ng-if="::directionLinks" ng-class="{disabled: noNext()||ngDisabled}" class="pagination-next"><a href ng-click="selectPage(page + 1, $event)" ng-disabled="noNext()||ngDisabled" uib-tabindex-toggle>{{::getText(\'next\')}}</a></li>\n<li ng-if="::boundaryLinks" ng-class="{disabled: noNext()||ngDisabled}" class="pagination-last"><a href ng-click="selectPage(totalPages, $event)" ng-disabled="noNext()||ngDisabled" uib-tabindex-toggle>{{::getText(\'last\')}}</a></li>\n');
} ]), angular.module("uib/template/tooltip/tooltip-html-popup.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("uib/template/tooltip/tooltip-html-popup.html", '<div class="tooltip-arrow"></div>\n<div class="tooltip-inner" ng-bind-html="contentExp()"></div>\n');
} ]), angular.module("uib/template/tooltip/tooltip-popup.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("uib/template/tooltip/tooltip-popup.html", '<div class="tooltip-arrow"></div>\n<div class="tooltip-inner" ng-bind="content"></div>\n');
} ]), angular.module("uib/template/tooltip/tooltip-template-popup.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("uib/template/tooltip/tooltip-template-popup.html", '<div class="tooltip-arrow"></div>\n<div class="tooltip-inner"\n  uib-tooltip-template-transclude="contentExp()"\n  tooltip-template-transclude-scope="originScope()"></div>\n');
} ]), angular.module("uib/template/popover/popover-html.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("uib/template/popover/popover-html.html", '<div class="arrow"></div>\n\n<div class="popover-inner">\n    <h3 class="popover-title" ng-bind="uibTitle" ng-if="uibTitle"></h3>\n    <div class="popover-content" ng-bind-html="contentExp()"></div>\n</div>\n');
} ]), angular.module("uib/template/popover/popover-template.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("uib/template/popover/popover-template.html", '<div class="arrow"></div>\n\n<div class="popover-inner">\n    <h3 class="popover-title" ng-bind="uibTitle" ng-if="uibTitle"></h3>\n    <div class="popover-content"\n      uib-tooltip-template-transclude="contentExp()"\n      tooltip-template-transclude-scope="originScope()"></div>\n</div>\n');
} ]), angular.module("uib/template/popover/popover.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("uib/template/popover/popover.html", '<div class="arrow"></div>\n\n<div class="popover-inner">\n    <h3 class="popover-title" ng-bind="uibTitle" ng-if="uibTitle"></h3>\n    <div class="popover-content" ng-bind="content"></div>\n</div>\n');
} ]), angular.module("uib/template/progressbar/bar.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("uib/template/progressbar/bar.html", '<div class="progress-bar" ng-class="type && \'progress-bar-\' + type" role="progressbar" aria-valuenow="{{value}}" aria-valuemin="0" aria-valuemax="{{max}}" ng-style="{width: (percent < 100 ? percent : 100) + \'%\'}" aria-valuetext="{{percent | number:0}}%" aria-labelledby="{{::title}}" ng-transclude></div>\n');
} ]), angular.module("uib/template/progressbar/progress.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("uib/template/progressbar/progress.html", '<div class="progress" ng-transclude aria-labelledby="{{::title}}"></div>');
} ]), angular.module("uib/template/progressbar/progressbar.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("uib/template/progressbar/progressbar.html", '<div class="progress">\n  <div class="progress-bar" ng-class="type && \'progress-bar-\' + type" role="progressbar" aria-valuenow="{{value}}" aria-valuemin="0" aria-valuemax="{{max}}" ng-style="{width: (percent < 100 ? percent : 100) + \'%\'}" aria-valuetext="{{percent | number:0}}%" aria-labelledby="{{::title}}" ng-transclude></div>\n</div>\n');
} ]), angular.module("uib/template/rating/rating.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("uib/template/rating/rating.html", '<span ng-mouseleave="reset()" ng-keydown="onKeydown($event)" tabindex="0" role="slider" aria-valuemin="0" aria-valuemax="{{range.length}}" aria-valuenow="{{value}}" aria-valuetext="{{title}}">\n    <span ng-repeat-start="r in range track by $index" class="sr-only">({{ $index < value ? \'*\' : \' \' }})</span>\n    <i ng-repeat-end ng-mouseenter="enter($index + 1)" ng-click="rate($index + 1)" class="glyphicon" ng-class="$index < value && (r.stateOn || \'glyphicon-star\') || (r.stateOff || \'glyphicon-star-empty\')" ng-attr-title="{{r.title}}"></i>\n</span>\n');
} ]), angular.module("uib/template/tabs/tab.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("uib/template/tabs/tab.html", '<li ng-class="[{active: active, disabled: disabled}, classes]" class="uib-tab nav-item">\n  <a href ng-click="select($event)" class="nav-link" uib-tab-heading-transclude>{{heading}}</a>\n</li>\n');
} ]), angular.module("uib/template/tabs/tabset.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("uib/template/tabs/tabset.html", '<div>\n  <ul class="nav nav-{{tabset.type || \'tabs\'}}" ng-class="{\'nav-stacked\': vertical, \'nav-justified\': justified}" ng-transclude></ul>\n  <div class="tab-content">\n    <div class="tab-pane"\n         ng-repeat="tab in tabset.tabs"\n         ng-class="{active: tabset.active === tab.index}"\n         uib-tab-content-transclude="tab">\n    </div>\n  </div>\n</div>\n');
} ]), angular.module("uib/template/timepicker/timepicker.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("uib/template/timepicker/timepicker.html", '<table class="uib-timepicker">\n  <tbody>\n    <tr class="text-center" ng-show="::showSpinners">\n      <td class="uib-increment hours"><a ng-click="incrementHours()" ng-class="{disabled: noIncrementHours()}" class="btn btn-link" ng-disabled="noIncrementHours()" tabindex="-1"><span class="glyphicon glyphicon-chevron-up"></span></a></td>\n      <td>&nbsp;</td>\n      <td class="uib-increment minutes"><a ng-click="incrementMinutes()" ng-class="{disabled: noIncrementMinutes()}" class="btn btn-link" ng-disabled="noIncrementMinutes()" tabindex="-1"><span class="glyphicon glyphicon-chevron-up"></span></a></td>\n      <td ng-show="showSeconds">&nbsp;</td>\n      <td ng-show="showSeconds" class="uib-increment seconds"><a ng-click="incrementSeconds()" ng-class="{disabled: noIncrementSeconds()}" class="btn btn-link" ng-disabled="noIncrementSeconds()" tabindex="-1"><span class="glyphicon glyphicon-chevron-up"></span></a></td>\n      <td ng-show="showMeridian"></td>\n    </tr>\n    <tr>\n      <td class="form-group uib-time hours" ng-class="{\'has-error\': invalidHours}">\n        <input type="text" placeholder="HH" ng-model="hours" ng-change="updateHours()" class="form-control text-center" ng-readonly="::readonlyInput" maxlength="2" tabindex="{{::tabindex}}" ng-disabled="noIncrementHours()" ng-blur="blur()">\n      </td>\n      <td class="uib-separator">:</td>\n      <td class="form-group uib-time minutes" ng-class="{\'has-error\': invalidMinutes}">\n        <input type="text" placeholder="MM" ng-model="minutes" ng-change="updateMinutes()" class="form-control text-center" ng-readonly="::readonlyInput" maxlength="2" tabindex="{{::tabindex}}" ng-disabled="noIncrementMinutes()" ng-blur="blur()">\n      </td>\n      <td ng-show="showSeconds" class="uib-separator">:</td>\n      <td class="form-group uib-time seconds" ng-class="{\'has-error\': invalidSeconds}" ng-show="showSeconds">\n        <input type="text" placeholder="SS" ng-model="seconds" ng-change="updateSeconds()" class="form-control text-center" ng-readonly="readonlyInput" maxlength="2" tabindex="{{::tabindex}}" ng-disabled="noIncrementSeconds()" ng-blur="blur()">\n      </td>\n      <td ng-show="showMeridian" class="uib-time am-pm"><button type="button" ng-class="{disabled: noToggleMeridian()}" class="btn btn-default text-center" ng-click="toggleMeridian()" ng-disabled="noToggleMeridian()" tabindex="{{::tabindex}}">{{meridian}}</button></td>\n    </tr>\n    <tr class="text-center" ng-show="::showSpinners">\n      <td class="uib-decrement hours"><a ng-click="decrementHours()" ng-class="{disabled: noDecrementHours()}" class="btn btn-link" ng-disabled="noDecrementHours()" tabindex="-1"><span class="glyphicon glyphicon-chevron-down"></span></a></td>\n      <td>&nbsp;</td>\n      <td class="uib-decrement minutes"><a ng-click="decrementMinutes()" ng-class="{disabled: noDecrementMinutes()}" class="btn btn-link" ng-disabled="noDecrementMinutes()" tabindex="-1"><span class="glyphicon glyphicon-chevron-down"></span></a></td>\n      <td ng-show="showSeconds">&nbsp;</td>\n      <td ng-show="showSeconds" class="uib-decrement seconds"><a ng-click="decrementSeconds()" ng-class="{disabled: noDecrementSeconds()}" class="btn btn-link" ng-disabled="noDecrementSeconds()" tabindex="-1"><span class="glyphicon glyphicon-chevron-down"></span></a></td>\n      <td ng-show="showMeridian"></td>\n    </tr>\n  </tbody>\n</table>\n');
} ]), angular.module("uib/template/typeahead/typeahead-match.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("uib/template/typeahead/typeahead-match.html", '<a href\n   tabindex="-1"\n   ng-bind-html="match.label | uibTypeaheadHighlight:query"\n   ng-attr-title="{{match.label}}"></a>\n');
} ]), angular.module("uib/template/typeahead/typeahead-popup.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("uib/template/typeahead/typeahead-popup.html", '<ul class="dropdown-menu" ng-show="isOpen() && !moveInProgress" ng-style="{top: position().top+\'px\', left: position().left+\'px\'}" role="listbox" aria-hidden="{{!isOpen()}}">\n    <li class="uib-typeahead-match" ng-repeat="match in matches track by $index" ng-class="{active: isActive($index) }" ng-mouseenter="selectActive($index)" ng-click="selectMatch($index, $event)" role="option" id="{{::match.id}}">\n        <div uib-typeahead-match index="$index" match="match" query="query" template-url="templateUrl"></div>\n    </li>\n</ul>\n');
} ]), angular.module("ui.bootstrap.carousel").run(function() {
    !angular.$$csp().noInlineStyle && !angular.$$uibCarouselCss && angular.element(document).find("head").prepend('<style type="text/css">.ng-animate.item:not(.left):not(.right){-webkit-transition:0s ease-in-out left;transition:0s ease-in-out left}</style>'), 
    angular.$$uibCarouselCss = !0;
}), angular.module("ui.bootstrap.datepicker").run(function() {
    !angular.$$csp().noInlineStyle && !angular.$$uibDatepickerCss && angular.element(document).find("head").prepend('<style type="text/css">.uib-datepicker .uib-title{width:100%;}.uib-day button,.uib-month button,.uib-year button{min-width:100%;}.uib-left,.uib-right{width:100%}</style>'), 
    angular.$$uibDatepickerCss = !0;
}), angular.module("ui.bootstrap.position").run(function() {
    !angular.$$csp().noInlineStyle && !angular.$$uibPositionCss && angular.element(document).find("head").prepend('<style type="text/css">.uib-position-measure{display:block !important;visibility:hidden !important;position:absolute !important;top:-9999px !important;left:-9999px !important;}.uib-position-scrollbar-measure{position:absolute !important;top:-9999px !important;width:50px !important;height:50px !important;overflow:scroll !important;}.uib-position-body-scrollbar-measure{overflow:scroll !important;}</style>'), 
    angular.$$uibPositionCss = !0;
}), angular.module("ui.bootstrap.datepickerPopup").run(function() {
    !angular.$$csp().noInlineStyle && !angular.$$uibDatepickerpopupCss && angular.element(document).find("head").prepend('<style type="text/css">.uib-datepicker-popup.dropdown-menu{display:block;float:none;margin:0;}.uib-button-bar{padding:10px 9px 2px;}</style>'), 
    angular.$$uibDatepickerpopupCss = !0;
}), angular.module("ui.bootstrap.tooltip").run(function() {
    !angular.$$csp().noInlineStyle && !angular.$$uibTooltipCss && angular.element(document).find("head").prepend('<style type="text/css">[uib-tooltip-popup].tooltip.top-left > .tooltip-arrow,[uib-tooltip-popup].tooltip.top-right > .tooltip-arrow,[uib-tooltip-popup].tooltip.bottom-left > .tooltip-arrow,[uib-tooltip-popup].tooltip.bottom-right > .tooltip-arrow,[uib-tooltip-popup].tooltip.left-top > .tooltip-arrow,[uib-tooltip-popup].tooltip.left-bottom > .tooltip-arrow,[uib-tooltip-popup].tooltip.right-top > .tooltip-arrow,[uib-tooltip-popup].tooltip.right-bottom > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.top-left > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.top-right > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.bottom-left > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.bottom-right > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.left-top > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.left-bottom > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.right-top > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.right-bottom > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.top-left > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.top-right > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.bottom-left > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.bottom-right > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.left-top > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.left-bottom > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.right-top > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.right-bottom > .tooltip-arrow,[uib-popover-popup].popover.top-left > .arrow,[uib-popover-popup].popover.top-right > .arrow,[uib-popover-popup].popover.bottom-left > .arrow,[uib-popover-popup].popover.bottom-right > .arrow,[uib-popover-popup].popover.left-top > .arrow,[uib-popover-popup].popover.left-bottom > .arrow,[uib-popover-popup].popover.right-top > .arrow,[uib-popover-popup].popover.right-bottom > .arrow,[uib-popover-html-popup].popover.top-left > .arrow,[uib-popover-html-popup].popover.top-right > .arrow,[uib-popover-html-popup].popover.bottom-left > .arrow,[uib-popover-html-popup].popover.bottom-right > .arrow,[uib-popover-html-popup].popover.left-top > .arrow,[uib-popover-html-popup].popover.left-bottom > .arrow,[uib-popover-html-popup].popover.right-top > .arrow,[uib-popover-html-popup].popover.right-bottom > .arrow,[uib-popover-template-popup].popover.top-left > .arrow,[uib-popover-template-popup].popover.top-right > .arrow,[uib-popover-template-popup].popover.bottom-left > .arrow,[uib-popover-template-popup].popover.bottom-right > .arrow,[uib-popover-template-popup].popover.left-top > .arrow,[uib-popover-template-popup].popover.left-bottom > .arrow,[uib-popover-template-popup].popover.right-top > .arrow,[uib-popover-template-popup].popover.right-bottom > .arrow{top:auto;bottom:auto;left:auto;right:auto;margin:0;}[uib-popover-popup].popover,[uib-popover-html-popup].popover,[uib-popover-template-popup].popover{display:block !important;}</style>'), 
    angular.$$uibTooltipCss = !0;
}), angular.module("ui.bootstrap.timepicker").run(function() {
    !angular.$$csp().noInlineStyle && !angular.$$uibTimepickerCss && angular.element(document).find("head").prepend('<style type="text/css">.uib-time input{width:50px;}</style>'), 
    angular.$$uibTimepickerCss = !0;
}), angular.module("ui.bootstrap.typeahead").run(function() {
    !angular.$$csp().noInlineStyle && !angular.$$uibTypeaheadCss && angular.element(document).find("head").prepend('<style type="text/css">[uib-typeahead-popup].dropdown-menu{display:block;}</style>'), 
    angular.$$uibTypeaheadCss = !0;
}), define("ngdir/angular-ui-bootstrap", [ "angular" ], function() {}), angular.module("lr.upload", [ "lr.upload.formdata", "lr.upload.iframe", "lr.upload.directives" ]), 
angular.module("lr.upload.directives", []), angular.module("lr.upload.directives").directive("uploadButton", [ "upload", function(upload) {
    return {
        restrict: "EA",
        scope: {
            data: "=?data",
            url: "@",
            id: "@",
            param: "@",
            method: "@",
            onUpload: "&",
            onSuccess: "&",
            onError: "&",
            onComplete: "&"
        },
        link: function(scope, element, attr) {
            var el = angular.element(element), fileInput = angular.element('<input id="' + scope.id + '" type="file" />');
            if (el.append(fileInput), fileInput.on("change", function() {
                var fileInput = angular.element(this);
                if (!fileInput[0].files || 0 !== fileInput[0].files.length) {
                    var options = {
                        url: scope.url,
                        method: scope.method || "POST",
                        forceIFrameUpload: scope.$eval(attr.forceIframeUpload) || !1,
                        data: scope.data || {}
                    };
                    options.data[scope.param || "file"] = fileInput, scope.$apply(function() {
                        scope.onUpload({
                            files: fileInput[0].files
                        });
                    }), upload(options).then(function(response) {
                        scope.onSuccess({
                            response: response
                        }), scope.onComplete({
                            response: response
                        });
                    }, function(response) {
                        scope.onError({
                            response: response
                        }), scope.onComplete({
                            response: response
                        });
                    });
                }
            }), "required" in attr && attr.$observe("required", function(value) {
                var required = "" === value ? !0 : scope.$eval(value);
                fileInput.attr("required", required), element.toggleClass("ng-valid", !required), 
                element.toggleClass("ng-invalid ng-invalid-required", required);
            }), "accept" in attr && attr.$observe("accept", function(value) {
                fileInput.attr("accept", value);
            }), upload.support.formData) {
                var uploadButtonMultipleObserve = function() {
                    fileInput.attr("multiple", !(!scope.$eval(attr.multiple) || scope.$eval(attr.forceIframeUpload)));
                };
                attr.$observe("multiple", uploadButtonMultipleObserve), attr.$observe("forceIframeUpload", uploadButtonMultipleObserve);
            }
        }
    };
} ]), angular.module("lr.upload.formdata", []).factory("formDataTransform", function() {
    return function(data) {
        var formData = new FormData();
        return angular.forEach(data, function(value, key) {
            if (angular.isElement(value)) {
                var files = [];
                angular.forEach(value, function(el) {
                    angular.forEach(el.files, function(file) {
                        files.push(file);
                    }), el.value = "";
                }), 0 !== files.length && (files.length > 1 ? angular.forEach(files, function(file, index) {
                    formData.append(key + "[" + index + "]", file);
                }) : formData.append(key, files[0]));
            } else formData.append(key, value);
        }), formData;
    };
}).factory("formDataUpload", [ "$http", "formDataTransform", function($http, formDataTransform) {
    return function(config) {
        return config.transformRequest = formDataTransform, config.method = config.method || "POST", 
        config.headers = angular.extend(config.headers || {}, {
            "Content-Type": void 0,
            "Content-Transfer-Encoding": "utf-8"
        }), $http(config);
    };
} ]), angular.module("lr.upload.iframe", []).factory("iFrameUpload", [ "$q", "$http", "$document", "$rootScope", function($q, $http, $document, $rootScope) {
    function indexOf(array, obj) {
        if (array.indexOf) return array.indexOf(obj);
        for (var i = 0; i < array.length; i++) if (obj === array[i]) return i;
        return -1;
    }
    function iFrameUpload(config) {
        var files = [], deferred = $q.defer(), promise = deferred.promise;
        angular.forEach(config.data || {}, function(value, key) {
            angular.isElement(value) && (delete config.data[key], value.attr("name", key), files.push(value));
        });
        var addParamChar = /\?/.test(config.url) ? "&" : "?";
        "DELETE" === config.method ? (config.url = config.url + addParamChar + "_method=DELETE", 
        config.method = "POST") : "PUT" === config.method ? (config.url = config.url + addParamChar + "_method=PUT", 
        config.method = "POST") : "PATCH" === config.method && (config.url = config.url + addParamChar + "_method=PATCH", 
        config.method = "POST");
        var body = angular.element($document[0].body), uniqueScope = $rootScope.$new(), uniqueName = "iframe-transport-" + uniqueScope.$id;
        uniqueScope.$destroy();
        var form = angular.element("<form></form>");
        form.attr("target", uniqueName), form.attr("action", config.url), form.attr("method", config.method || "POST"), 
        form.css("display", "none"), files.length && (form.attr("enctype", "multipart/form-data"), 
        form.attr("encoding", "multipart/form-data"));
        var iframe = angular.element('<iframe name="' + uniqueName + '" src="javascript:false;"></iframe>');
        return iframe.on("load", function() {
            function transformData(data, fns) {
                var headers = [];
                return angular.isFunction(fns) ? fns(data, headers) : (angular.forEach(fns, function(fn) {
                    data = fn(data, headers);
                }), data);
            }
            function removePendingReq() {
                var idx = indexOf($http.pendingRequests, config);
                -1 !== idx && ($http.pendingRequests.splice(idx, 1), config.$iframeTransportForm.remove(), 
                delete config.$iframeTransportForm);
            }
            iframe.off("load").on("load", function() {
                var response;
                try {
                    var doc = this.contentWindow ? this.contentWindow.document : this.contentDocument;
                    if (response = angular.element(doc.body).text(), !response.length) throw new Error();
                } catch (e) {}
                form.append(angular.element('<iframe src="javascript:false;"></iframe>'));
                try {
                    response = transformData(response, $http.defaults.transformResponse);
                } catch (e) {}
                deferred.resolve({
                    data: response,
                    status: 200,
                    headers: [],
                    config: config
                });
            }), angular.forEach(config.data, function(value, name) {
                var input = angular.element('<input type="hidden" />');
                input.attr("name", name), input.val(value), form.append(input);
            }), angular.forEach(files, function(input) {
                var clone = input.clone(!0);
                input.after(clone), form.append(input);
            }), config.$iframeTransportForm = form, $http.pendingRequests.push(config), form[0].submit(), 
            promise.then(removePendingReq, removePendingReq);
        }), form.append(iframe), body.append(form), promise;
    }
    return iFrameUpload;
} ]), angular.module("lr.upload").factory("upload", [ "$window", "formDataUpload", "iFrameUpload", function($window, formDataUpload, iFrameUpload) {
    function upload(config) {
        return support.formData && !config.forceIFrameUpload ? formDataUpload(config) : iFrameUpload(config);
    }
    var support = {
        fileInput: !(new RegExp("(Android (1\\.[0156]|2\\.[01]))|(Windows Phone (OS 7|8\\.0))|(XBLWP)|(ZuneWP)|(WPDesktop)|(w(eb)?OSBrowser)|(webOS)|(Kindle/(1\\.0|2\\.[05]|3\\.0))").test($window.navigator.userAgent) || angular.element('<input type="file">').prop("disabled")),
        fileUpload: !(!$window.XMLHttpRequestUpload || !$window.FileReader),
        formData: !!$window.FormData
    };
    return upload.support = support, upload;
} ]), define("ngdir/angular-upload", [ "angular" ], function() {}), angular.module("angular-google-analytics", []).provider("Analytics", function() {
    var accountId, displayFeatures, domainName, removeRegExp, experimentId, crossLinkDomains, created = !1, trackRoutes = !0, trackPrefix = "", analyticsJS = !1, pageEvent = "$routeChangeSuccess", cookieConfig = "auto", ecommerce = !1, enhancedEcommerce = !1, enhancedLinkAttribution = !1, ignoreFirstPageLoad = !1, crossDomainLinker = !1, linkerConfig = {
        allowLinker: !0
    };
    this._logs = [], this.setAccount = function(id) {
        return accountId = id, !0;
    }, this.trackPages = function(doTrack) {
        return trackRoutes = doTrack, !0;
    }, this.trackPrefix = function(prefix) {
        return trackPrefix = prefix, !0;
    }, this.setDomainName = function(domain) {
        return domainName = domain, !0;
    }, this.useDisplayFeatures = function(val) {
        return displayFeatures = !!val, !0;
    }, this.useAnalytics = function(val) {
        return analyticsJS = !!val, !0;
    }, this.useEnhancedLinkAttribution = function(val) {
        return enhancedLinkAttribution = !!val, !0;
    }, this.useCrossDomainLinker = function(val) {
        return crossDomainLinker = !!val, !0;
    }, this.setCrossLinkDomains = function(domains) {
        return crossLinkDomains = domains, !0;
    }, this.setPageEvent = function(name) {
        return pageEvent = name, !0;
    }, this.setCookieConfig = function(config) {
        return cookieConfig = config, !0;
    }, this.useECommerce = function(val, enhanced) {
        return ecommerce = !!val, enhancedEcommerce = !!enhanced, !0;
    }, this.setRemoveRegExp = function(regex) {
        return regex instanceof RegExp ? (removeRegExp = regex, !0) : !1;
    }, this.setExperimentId = function(id) {
        return experimentId = id, !0;
    }, this.ignoreFirstPageLoad = function(val) {
        ignoreFirstPageLoad = !!val;
    }, this.$get = [ "$document", "$rootScope", "$location", "$window", function($document, $rootScope, $location, $window) {
        function _createScriptTag() {
            if (accountId) {
                $window._gaq = [], $window._gaq.push([ "_setAccount", accountId ]), domainName && $window._gaq.push([ "_setDomainName", domainName ]), 
                enhancedLinkAttribution && $window._gaq.push([ "_require", "inpage_linkid", "//www.google-analytics.com/plugins/ga/inpage_linkid.js" ]), 
                trackRoutes && !ignoreFirstPageLoad && $window._gaq.push(removeRegExp ? [ "_trackPageview", getUrl() ] : [ "_trackPageview" ]);
                var gaSrc;
                gaSrc = displayFeatures ? ("https:" === document.location.protocol ? "https://" : "http://") + "stats.g.doubleclick.net/dc.js" : ("https:" === document.location.protocol ? "https://ssl" : "http://www") + ".google-analytics.com/ga.js", 
                function() {
                    var document = $document[0], ga = document.createElement("script");
                    ga.type = "text/javascript", ga.async = !0, ga.src = gaSrc;
                    var s = document.getElementsByTagName("script")[0];
                    s.parentNode.insertBefore(ga, s);
                }(gaSrc), created = !0;
            }
        }
        function _createAnalyticsScriptTag() {
            if (!accountId) return console.warn("No account id set for Analytics.js");
            if (function(i, s, o, g, r, a, m) {
                i.GoogleAnalyticsObject = r, i[r] = i[r] || function() {
                    (i[r].q = i[r].q || []).push(arguments);
                }, i[r].l = 1 * new Date(), a = s.createElement(o), m = s.getElementsByTagName(o)[0], 
                a.async = 1, a.src = g, m.parentNode.insertBefore(a, m);
            }(window, document, "script", "//www.google-analytics.com/analytics.js", "ga"), 
            angular.isArray(accountId) ? accountId.forEach(function(trackerObj) {
                $window.ga("create", trackerObj.tracker, cookieConfig, {
                    name: trackerObj.name
                });
            }) : crossDomainLinker ? ($window.ga("create", accountId, cookieConfig, linkerConfig), 
            $window.ga("require", "linker"), crossLinkDomains && $window.ga("linker:autoLink", crossLinkDomains)) : $window.ga("create", accountId, cookieConfig), 
            displayFeatures && $window.ga("require", "displayfeatures"), trackRoutes && !ignoreFirstPageLoad && $window.ga("send", "pageview", getUrl()), 
            $window.ga && (ecommerce && (enhancedEcommerce ? $window.ga("require", "ec", "ec.js") : $window.ga("require", "ecommerce", "ecommerce.js")), 
            enhancedLinkAttribution && $window.ga("require", "linkid", "linkid.js"), experimentId)) {
                var expScript = document.createElement("script"), s = document.getElementsByTagName("script")[0];
                expScript.src = "//www.google-analytics.com/cx/api.js?experiment=" + experimentId, 
                s.parentNode.insertBefore(expScript, s);
            }
        }
        var getUrl = function() {
            var url = $location.path();
            return removeRegExp ? url.replace(removeRegExp, "") : url;
        };
        this._log = function() {
            this._logs.push(arguments);
        }, this._trackPage = function(url, title) {
            title = title ? title : $document[0].title, trackRoutes && !analyticsJS && $window._gaq ? ($window._gaq.push([ "_set", "title", title ]), 
            $window._gaq.push([ "_trackPageview", trackPrefix + url ]), this._log("_trackPageview", arguments)) : trackRoutes && analyticsJS && $window.ga && (angular.isArray(accountId) ? accountId.forEach(function(trackerObj) {
                $window.ga(trackerObj.name + ".send", "pageview", {
                    page: trackPrefix + url,
                    title: title
                });
            }) : $window.ga("send", "pageview", {
                page: trackPrefix + url,
                title: title
            }), this._log("pageview", arguments));
        }, this._trackEvent = function(category, action, label, value) {
            !analyticsJS && $window._gaq ? ($window._gaq.push([ "_trackEvent", category, action, label, value ]), 
            this._log("trackEvent", arguments)) : $window.ga && ($window.ga("send", "event", category, action, label, value), 
            this._log("event", arguments));
        }, this._addTrans = function(transactionId, affiliation, total, tax, shipping, city, state, country, currency) {
            !analyticsJS && $window._gaq ? ($window._gaq.push([ "_addTrans", transactionId, affiliation, total, tax, shipping, city, state, country ]), 
            this._log("_addTrans", arguments)) : $window.ga && (ecommerce ? enhancedEcommerce ? console.warn("Enhanced ecommerce plugin is enabled. Only one plugin(ecommerce/ec) can be used at a time. Use AnalyticsProvider.setECommerce(true,false);") : ($window.ga("ecommerce:addTransaction", {
                id: transactionId,
                affiliation: affiliation,
                revenue: total,
                tax: tax,
                shipping: shipping,
                currency: currency || "USD"
            }), this._log("ecommerce:addTransaction", arguments)) : console.warn("ecommerce no set. Use AnalyticsProvider.setECommerce(true,false);"));
        }, this._addItem = function(transactionId, sku, name, category, price, quantity) {
            !analyticsJS && $window._gaq ? ($window._gaq.push([ "_addItem", transactionId, sku, name, category, price, quantity ]), 
            this._log("_addItem", arguments)) : $window.ga && (ecommerce ? enhancedEcommerce ? console.warn("Enhanced ecommerce plugin is enabled. Only one plugin(ecommerce/ec) can be used at a time. Use AnalyticsProvider.setECommerce(true,false);") : ($window.ga("ecommerce:addItem", {
                id: transactionId,
                name: name,
                sku: sku,
                category: category,
                price: price,
                quantity: quantity
            }), this._log("ecommerce:addItem", arguments)) : console.warn("ecommerce no set. Use AnalyticsProvider.setECommerce(true,false);"));
        }, this._trackTrans = function() {
            !analyticsJS && $window._gaq ? ($window._gaq.push([ "_trackTrans" ]), this._log("_trackTrans", arguments)) : $window.ga && (ecommerce ? enhancedEcommerce ? console.warn("Enhanced ecommerce plugin is enabled. Only one plugin(ecommerce/ec) can be used at a time. Use AnalyticsProvider.setECommerce(true,false);") : ($window.ga("ecommerce:send"), 
            this._log("ecommerce:send", arguments)) : console.warn("ecommerce no set. Use AnalyticsProvider.setECommerce(true,false);"));
        }, this._clearTrans = function() {
            $window.ga && (ecommerce ? enhancedEcommerce ? console.warn("Enhanced ecommerce plugin is enabled. Only one plugin(ecommerce/ec) can be used at a time. Use AnalyticsProvider.setECommerce(true,false);") : ($window.ga("ecommerce:clear"), 
            this._log("ecommerce:clear", arguments)) : console.warn("ecommerce no set. Use AnalyticsProvider.setECommerce(true,false);"));
        }, this._addProduct = function(productId, name, category, brand, variant, price, quantity, coupon, position) {
            !analyticsJS && $window._gaq ? ($window._gaq.push([ "_addProduct", productId, name, category, brand, variant, price, quantity, coupon, position ]), 
            this._log("_addProduct", arguments)) : $window.ga && (ecommerce ? enhancedEcommerce ? ($window.ga("ec:addProduct", {
                id: productId,
                name: name,
                category: category,
                brand: brand,
                variant: variant,
                price: price,
                quantity: quantity,
                coupon: coupon,
                position: position
            }), this._log("ec:addProduct", arguments)) : console.warn("Enhanced ecommerce plugin is disabled. Use AnalyticsProvider.setECommerce(true,true);") : console.warn("ecommerce not set. Use AnalyticsProvider.setECommerce(true,true);"));
        }, this._addImpression = function(id, name, list, brand, category, variant, position, price) {
            !analyticsJS && $window._gaq ? ($window._gaq.push([ "_addImpression", id, name, list, brand, category, variant, position, price ]), 
            this._log("_addImpression", arguments)) : $window.ga && (ecommerce ? enhancedEcommerce ? $window.ga("ec:addImpression", {
                id: id,
                name: name,
                category: category,
                brand: brand,
                variant: variant,
                list: list,
                position: position,
                price: price
            }) : console.warn("Enhanced ecommerce plugin is disabled. Use AnalyticsProvider.setECommerce(true,true);") : console.warn("ecommerce not set. Use AnalyticsProvider.setECommerce(true,true);"), 
            this._log("ec:addImpression", arguments));
        }, this._addPromo = function(productId, name, creative, position) {
            !analyticsJS && $window._gaq ? ($window._gaq.push([ "_addPromo", productId, name, creative, position ]), 
            this._log("_addPromo", arguments)) : $window.ga && (ecommerce ? enhancedEcommerce ? ($window.ga("ec:addPromo", {
                id: productId,
                name: name,
                creative: creative,
                position: position
            }), this._log("ec:addPromo", arguments)) : console.warn("Enhanced ecommerce plugin is disabled. Use AnalyticsProvider.setECommerce(true,true);") : console.warn("ecommerce not set. Use AnalyticsProvider.setECommerce(true,true);"));
        }, this._getActionFieldObject = function(id, affiliation, revenue, tax, shipping, coupon, list, step, option) {
            var obj = {};
            return id && (obj.id = id), affiliation && (obj.affiliation = affiliation), revenue && (obj.revenue = revenue), 
            tax && (obj.tax = tax), shipping && (obj.shipping = shipping), coupon && (obj.coupon = coupon), 
            list && (obj.list = list), step && (obj.step = step), option && (obj.option = option), 
            obj;
        }, this._setAction = function(action, obj) {
            !analyticsJS && $window._gaq ? ($window._gaq.push([ "_setAction", action, obj ]), 
            this._log("__setAction", arguments)) : $window.ga && (ecommerce ? enhancedEcommerce ? ($window.ga("ec:setAction", action, obj), 
            this._log("ec:setAction", arguments)) : console.warn("Enhanced ecommerce plugin is disabled. Use AnalyticsProvider.setECommerce(true,true);") : console.warn("ecommerce not set. Use AnalyticsProvider.setECommerce(true,true);"));
        }, this._trackTransaction = function(transactionId, affiliation, revenue, tax, shipping, coupon, list, step, option) {
            this._setAction("purchase", this._getActionFieldObject(transactionId, affiliation, revenue, tax, shipping, coupon, list, step, option)), 
            this._pageView();
        }, this._trackRefund = function(transactionId) {
            this._setAction("refund", this._getActionFieldObject(transactionId)), this._pageView();
        }, this._trackCheckOut = function(step, option) {
            this._setAction("checkout", this._getActionFieldObject(null, null, null, null, null, null, null, step, option)), 
            this._pageView();
        }, this._trackCart = function(action) {
            -1 !== [ "add", "remove" ].indexOf(action) && (this._setAction(action), this._send("event", "UX", "click", action + "to cart"));
        }, this._promoClick = function(promotionName) {
            this._setAction("promo_click"), this._send("event", "Internal Promotions", "click", promotionName);
        }, this._productClick = function(listName) {
            this._setAction("click", this._getActionFieldObject(null, null, null, null, null, null, listName, null, null)), 
            this._send("event", "UX", "click", listName);
        }, this._send = function(obj) {
            $window.ga && ($window.ga("send", obj), this._log("send", obj));
        }, this._pageView = function() {
            this._send("pageview");
        }, this._set = function(name, value) {
            $window.ga && ($window.ga("set", name, value), this._log("set", name, value));
        }, analyticsJS ? _createAnalyticsScriptTag() : _createScriptTag();
        var me = this;
        return trackRoutes && $rootScope.$on(pageEvent, function() {
            me._trackPage(getUrl());
        }), {
            _logs: me._logs,
            cookieConfig: cookieConfig,
            displayFeatures: displayFeatures,
            ecommerce: ecommerce,
            enhancedEcommerce: enhancedEcommerce,
            enhancedLinkAttribution: enhancedLinkAttribution,
            getUrl: getUrl,
            experimentId: experimentId,
            ignoreFirstPageLoad: ignoreFirstPageLoad,
            trackPage: function(url, title) {
                me._trackPage(url, title);
            },
            trackEvent: function(category, action, label, value) {
                me._trackEvent(category, action, label, value);
            },
            addTrans: function(transactionId, affiliation, total, tax, shipping, city, state, country, currency) {
                me._addTrans(transactionId, affiliation, total, tax, shipping, city, state, country, currency);
            },
            addItem: function(transactionId, sku, name, category, price, quantity) {
                me._addItem(transactionId, sku, name, category, price, quantity);
            },
            trackTrans: function() {
                me._trackTrans();
            },
            clearTrans: function() {
                me._clearTrans();
            },
            addProduct: function(productId, name, category, brand, variant, price, quantity, coupon, position) {
                me._addProduct(productId, name, category, brand, variant, price, quantity, coupon, position);
            },
            addPromo: function(productId, name, creative, position) {
                me._addPromo(productId, name, creative, position);
            },
            addImpression: function(productId, name, list, brand, category, variant, position, price) {
                me._addImpression(productId, name, list, brand, category, variant, position, price);
            },
            productClick: function(listName) {
                me._productClick(listName);
            },
            promoClick: function(promotionName) {
                me._promoClick(promotionName);
            },
            trackDetail: function() {
                me._setAction("detail"), me._pageView();
            },
            trackCart: function(action) {
                me._trackCart(action);
            },
            trackCheckout: function(step, option) {
                me._trackCheckOut(step, option);
            },
            trackTransaction: function(transactionId, affiliation, revenue, tax, shipping, coupon, list, step, option) {
                me._trackTransaction(transactionId, affiliation, revenue, tax, shipping, coupon, list, step, option);
            },
            setAction: function(action, obj) {
                me._setAction(action, obj);
            },
            send: function(obj) {
                me._send(obj);
            },
            pageView: function() {
                me._pageView();
            },
            set: function(name, value) {
                me._set(name, value);
            }
        };
    } ];
}), define("ngdir/angular-google-analytics", [ "angular" ], function() {}), function(window, angular, undefined) {
    function $$CookieWriter($document, $log, $browser) {
        function buildCookieString(name, value, options) {
            var path, expires;
            options = options || {}, expires = options.expires, path = angular.isDefined(options.path) ? options.path : cookiePath, 
            angular.isUndefined(value) && (expires = "Thu, 01 Jan 1970 00:00:00 GMT", value = ""), 
            angular.isString(expires) && (expires = new Date(expires));
            var str = encodeURIComponent(name) + "=" + encodeURIComponent(value);
            str += path ? ";path=" + path : "", str += options.domain ? ";domain=" + options.domain : "", 
            str += expires ? ";expires=" + expires.toUTCString() : "", str += options.secure ? ";secure" : "";
            var cookieLength = str.length + 1;
            return cookieLength > 4096 && $log.warn("Cookie '" + name + "' possibly not set or overflowed because it was too large (" + cookieLength + " > 4096 bytes)!"), 
            str;
        }
        var cookiePath = $browser.baseHref(), rawDocument = $document[0];
        return function(name, value, options) {
            rawDocument.cookie = buildCookieString(name, value, options);
        };
    }
    angular.module("ngCookies", [ "ng" ]).provider("$cookies", [ function() {
        function calcOptions(options) {
            return options ? angular.extend({}, defaults, options) : defaults;
        }
        var defaults = this.defaults = {};
        this.$get = [ "$$cookieReader", "$$cookieWriter", function($$cookieReader, $$cookieWriter) {
            return {
                get: function(key) {
                    return $$cookieReader()[key];
                },
                getObject: function(key) {
                    var value = this.get(key);
                    return value ? angular.fromJson(value) : value;
                },
                getAll: function() {
                    return $$cookieReader();
                },
                put: function(key, value, options) {
                    $$cookieWriter(key, value, calcOptions(options));
                },
                putObject: function(key, value, options) {
                    this.put(key, angular.toJson(value), options);
                },
                remove: function(key, options) {
                    $$cookieWriter(key, undefined, calcOptions(options));
                }
            };
        } ];
    } ]), angular.module("ngCookies").factory("$cookieStore", [ "$cookies", function($cookies) {
        return {
            get: function(key) {
                return $cookies.getObject(key);
            },
            put: function(key, value) {
                $cookies.putObject(key, value);
            },
            remove: function(key) {
                $cookies.remove(key);
            }
        };
    } ]), $$CookieWriter.$inject = [ "$document", "$log", "$browser" ], angular.module("ngCookies").provider("$$cookieWriter", function() {
        this.$get = $$CookieWriter;
    });
}(window, window.angular), define("ngdir/angular-ng-cookies", [ "angular" ], function() {}), 
define("common/js/modules/strings/stringsModule", [ "angular" ], function(ng) {
    return ng.module("commonModules.strings", []);
}), define("common/js/modules/strings/stringsService", [ "./stringsModule" ], function(module) {
    module.factory("StringsService", function(FormConstants) {
        function trim(str) {
            return str.replace(/^\s+|\s+$/g, "");
        }
        function trimToWord(str, len) {
            if (null == str || 0 >= len) return "";
            var chopped = str;
            return len && str.length > len && (chopped = chopped.substr(0, len - 4), chopped = chopped.replace(/[\s\,]+[^\s\,]*$/, ""), 
            chopped += " ..."), chopped;
        }
        function trimToSentence(str, len) {
            if (null == str || 0 >= len) return "";
            if (!len || len >= str.length) return str;
            var trimmed = "", parts = str.split(/[\,\.\;]/);
            if (0 == parts.length) return str;
            for (var senetenceEndInd = 0, i = 0; i < parts.length; i++) {
                var part = parts[i];
                if (!(trimmed.length + part.length < len)) break;
                trimmed += part, senetenceEndInd += part.length + 1, trimmed += str.charAt(senetenceEndInd - 1);
            }
            return trimmed ? trimmed.replace(/[\,\;]$/, "") : trimToWord(str, len);
        }
        function shortFileName(str) {
            return null == str ? "" : str.length < 25 ? str : str.substr(0, 10) + "..." + str.substr(str.length - 8);
        }
        function isBlank(str) {
            return null == str ? !0 : stripTags(str + "").match(/^[\s|\n]*$/) ? !0 : !1;
        }
        function stripTag(str, tag) {
            var div = document.createElement("div");
            div.innerHTML = str;
            for (var tags = div.getElementsByTagName(tag), i = tags.length; i--; ) tags[i].parentNode.removeChild(tags[i]);
            return div.innerHTML;
        }
        function stripDangerousTags(str) {
            var stripped = stripTag(str, "script");
            return stripped = stripTag(stripped, "embed"), stripped = stripTag(stripped, "base"), 
            stripped = stripTag(stripped, "applet");
        }
        function capitalize(text) {
            return text ? (text += "", text.substr(0, 1).toUpperCase() + text.substr(1)) : "";
        }
        function camelCaseToUpUnderscore(fieldName) {
            return fieldName ? fieldName.replace(/([A-Z])/g, "_$1").toUpperCase() : "";
        }
        function upUnderscoreTocamelCase(fieldName) {
            if (!fieldName) return "";
            for (var words = fieldName.toLowerCase().split("_"), ret = "", i = 0; i < words.length; i++) {
                var word = words[i];
                i > 0 && (word = capitalize(word)), ret += word;
            }
            return ret;
        }
        function underscoreToHuman(fieldName) {
            if (!fieldName) return "";
            fieldName += "";
            for (var words = fieldName.toLowerCase().split("_"), ret = "", i = 0; i < words.length; i++) ret += " " + words[i];
            return capitalize(ret.substr(1));
        }
        function camelCaseToHuman(fieldName) {
            return underscoreToHuman(camelCaseToUpUnderscore(fieldName));
        }
        function underscoreToDashed(fieldName) {
            return fieldName ? fieldName.toLowerCase().replace(/\_/g, "-") : "";
        }
        function stripTags(str) {
            return str ? trim(str.replace(/<(div|br.?.?|p)>/gi, "\n").replace(/<[^>]*>/g, "").replace(/\&nbsp\;/g, " ").replace(/\&quot\;/g, '"').replace(/\&lt\;/g, "<").replace(/\&gt\;/g, ">").replace(/\&amp;\;/g, "&").replace(/\n[\n\s]*/g, "\n")) : "";
        }
        function brLines(str) {
            return str.replace(/\n/g, "<br>");
        }
        function pad(str, len, c) {
            for (var paddedStr = str.toString(); paddedStr.length < len; ) paddedStr = c + paddedStr;
            return paddedStr;
        }
        function mask(str) {
            var len = str.length;
            return 2 > len ? "**" : str.substring(0, 1) + pad("", len - 2, "*") + str.substring(len - 2, len - 1);
        }
        function compare(str1, str2) {
            return str1 > str2 ? 1 : str2 > str1 ? -1 : 0;
        }
        function randomString(len) {
            return Math.random().toString(36).substring(2, len + 2);
        }
        function isHebChar(char) {
            return char >= "" && "" >= char;
        }
        function guessDirection(text) {
            if (text) {
                var c = text.charAt(0);
                if (isHebChar(c)) return "rtl";
            }
            return "ltr";
        }
        function isValidEmailAddress(emailAddress) {
            return FormConstants.validationPatterns.email.test(emailAddress);
        }
        function readableNumber(number) {
            if (null == number) return "";
            var numberStr = trim(number + ""), readable = "";
            0 > number && (numberStr = numberStr.substr(1));
            var numberParts = numberStr.split("."), fraction = "";
            numberParts.length > 1 && (numberStr = numberParts[0], fraction = "." + numberParts[1], 
            fraction = fraction.substr(0, 3));
            for (var numberLength = numberStr.length, i = 0; numberLength > i; i++) readable = numberStr.charAt(numberLength - i - 1) + readable, 
            i != numberLength - 1 && i % 3 == 2 && (readable = "," + readable);
            return 0 > number && (readable = "-" + readable), readable + fraction;
        }
        function escapeHtml(str) {
            var entityMap = {
                "&": "&amp;",
                "<": "&lt;",
                ">": "&gt;",
                '"': "&quot;",
                "'": "&#39;",
                "/": "&#x2F;"
            };
            return String(str).replace(/[&<>"'\/]/g, function(s) {
                return entityMap[s];
            });
        }
        function stripNonLetters(str) {
            return str ? str.replace(/[^\u00C0-\u1FFF\u2C00-\uD7FF\w]+/g, " ").trim().replace(/ +/g, "-") : "";
        }
        function fileNameFromUrl(url) {
            return url ? url.split("/").pop().split("#")[0].split("?")[0] : "";
        }
        function isImage(url) {
            return url ? null != url.match(/\.(jpeg|jpg|gif|png)$/) : !1;
        }
        return {
            isBlank: isBlank,
            trim: trim,
            trimToWord: trimToWord,
            trimToSentence: trimToSentence,
            shortFileName: shortFileName,
            stripTags: stripTags,
            stripTag: stripTag,
            stripDangerousTags: stripDangerousTags,
            escapeHtml: escapeHtml,
            brLines: brLines,
            stripNonLetters: stripNonLetters,
            pad: pad,
            randomString: randomString,
            compare: compare,
            readableNumber: readableNumber,
            capitalize: capitalize,
            camelCaseToHuman: camelCaseToHuman,
            camelCaseToUpUnderscore: camelCaseToUpUnderscore,
            upUnderscoreTocamelCase: upUnderscoreTocamelCase,
            underscoreToHuman: underscoreToHuman,
            underscoreToDashed: underscoreToDashed,
            mask: mask,
            isHebChar: isHebChar,
            guessDirection: guessDirection,
            isValidEmailAddress: isValidEmailAddress,
            fileNameFromUrl: fileNameFromUrl,
            isImage: isImage
        };
    });
}), define("common/js/modules/strings/stringsFilters", [ "./stringsModule" ], function(module) {
    return module.filter("capitalize", [ "StringsService", function(StringsService) {
        return function(text) {
            return StringsService.capitalize(text);
        };
    } ]).filter("trim", [ "StringsService", function(StringsService) {
        return function(text, length) {
            return StringsService.trimToWord(text, length);
        };
    } ]).filter("shortFileName", [ "StringsService", function(StringsService) {
        return function(text, length) {
            return StringsService.shortFileName(text, length);
        };
    } ]).filter("stripTags", [ "StringsService", function(StringsService) {
        return function(text) {
            return StringsService.stripTags(text);
        };
    } ]).filter("brLines", [ "StringsService", function(StringsService) {
        return function(text) {
            return StringsService.brLines(text);
        };
    } ]).filter("strArr", [ "ArraysService", function(ArraysService) {
        return function(arr, separator) {
            return ArraysService.toString(arr, separator || ", ");
        };
    } ]).filter("percent", [ "ArraysService", function() {
        return function(value) {
            return Math.round(100 * value) + "%";
        };
    } ]).filter("guessDirection", [ "StringsService", function(StringsService) {
        return function(text) {
            return StringsService.guessDirection(text);
        };
    } ]).filter("camelCaseToUpUnderscore", [ "StringsService", function(StringsService) {
        return function(text) {
            return StringsService.camelCaseToUpUnderscore(text);
        };
    } ]).filter("underscoreToHuman", [ "StringsService", function(StringsService) {
        return function(text) {
            return StringsService.underscoreToHuman(text);
        };
    } ]).filter("underscoreToDashed", [ "StringsService", function(StringsService) {
        return function(text) {
            return StringsService.underscoreToDashed(text);
        };
    } ]).filter("readableNumber", [ "StringsService", function(StringsService) {
        return function(text) {
            return StringsService.readableNumber(text);
        };
    } ]).filter("isImage", [ "StringsService", function(StringsService) {
        return function(url) {
            return StringsService.isImage(url);
        };
    } ]).filter("fileNameFromUrl", [ "StringsService", function(StringsService) {
        return function(url) {
            return StringsService.fileNameFromUrl(url);
        };
    } ]).filter("camelToHuman", [ "StringsService", function(StringsService) {
        return function(text) {
            return StringsService.camelCaseToHuman(text);
        };
    } ]);
}), define("common/js/modules/strings/diffService", [ "./stringsModule" ], function(module) {
    module.factory("DiffService", function() {
        function getChangeInds(str1, str2) {
            if (!str1 || !str2 || str1 == str2) return null;
            var fromStart = findFirstChangeFromStart(str1, str2), fromEnd = findFirstChangeFromEnd(str1, str2, fromStart);
            return {
                fromStart: fromStart,
                fromEnd: fromEnd
            };
        }
        function findFirstChangeFromStart(str1, str2) {
            for (var str1Length = str1.length, str2Length = str2.length, i = 0; str1Length > i && str2Length > i; i++) {
                var c1 = str1.charAt(i), c2 = str2.charAt(i);
                if (c1 != c2) return i;
            }
            return Math.min(str1Length, str2Length);
        }
        function findFirstChangeFromEnd(str1, str2, changeStartInd) {
            for (var str1Length = str1.length, str2Length = str2.length, i = 0; str1Length > i && str2Length > i; i++) {
                var str1Ind = str1Length - 1 - i, str2Ind = str2Length - 1 - i;
                if (changeStartInd >= str1Ind || changeStartInd >= str1Ind) return i - 1;
                var c1 = str1.charAt(str1Ind), c2 = str2.charAt(str2Ind);
                if (c1 != c2) return i;
            }
            return Math.min(str1Length, str2Length);
        }
        return {
            getChangeInds: getChangeInds
        };
    });
}), define("common/js/modules/strings/index", [ "./stringsModule", "./stringsService", "./stringsFilters", "./diffService" ], function() {}), 
define("common/js/modules/utils/utilsModule", [ "angular" ], function(ng) {
    return ng.module("commonModules.utils", []);
}), define("common/js/modules/utils/externalHrefDirective", [ "./utilsModule" ], function(module) {
    module.directive("bsExternalHref", function() {
        return {
            restrict: "A",
            scope: {},
            link: function(scope, elem, attrs) {
                function update(urlAttr) {
                    if (urlAttr) {
                        var url = urlAttr;
                        0 == !url.indexOf("http") && (url = "http://" + url), elem.attr("href", url), elem.removeClass("inactive");
                    } else elem.attr("href", "javascript:{}"), elem.addClass("inactive");
                }
                attrs.$observe("bsExternalHref", function(urlAttr) {
                    update(urlAttr);
                });
            }
        };
    });
}), define("common/js/modules/utils/arraysService", [ "./utilsModule" ], function(module) {
    module.factory("ArraysService", function() {
        function getInd(list, value) {
            if (!list) return null;
            for (var i = 0; i < list.length; i++) if (list[i] == value) return i;
            return null;
        }
        function contains(list, value) {
            var ind = getInd(list, value);
            return null == ind ? !1 : !0;
        }
        function remove(list, value) {
            var ind = getInd(list, value);
            return null != ind && list.splice(ind, 1), ind;
        }
        function containsByKey(list, key, value) {
            var ind = getIndByKey(list, key, value);
            return null == ind ? !1 : !0;
        }
        function filteredByNonEmpty(list, key) {
            return filterByNotInValuesList(list, key, [ null, "" ]);
        }
        function filteredByEmpty(list, key) {
            return filterByValuesList(list, key, [ null, "" ]);
        }
        function filteredBy(list, key, val) {
            return getFilteredList(list, key, !0, val);
        }
        function filteredByNot(list, key, val) {
            return getFilteredList(list, key, !1, val);
        }
        function getFilteredList(list, key, equals, value) {
            return filterWithFunction(list, function(item) {
                var matches = item[key] == value;
                return equals && matches || !equals && !matches;
            });
        }
        function filterByValuesList(list, key, values, matchCondtion) {
            return filterWithFunction(list, function(item) {
                var value = item[key], inList = contains(values, value);
                switch (matchCondtion) {
                  case "matchIfNotInList":
                    return !inList;

                  default:
                    return inList;
                }
            });
        }
        function filterByNotInValuesList(list, key, values) {
            return filterByValuesList(list, key, values, "matchIfNotInList");
        }
        function filterWithFunction(list, fn) {
            if (!list) return [];
            for (var filtered = [], i = 0; i < list.length; i++) {
                var item = list[i];
                fn(item) && filtered.push(item);
            }
            return filtered;
        }
        function getByKey(list, key, value) {
            var ind = getIndByKey(list, key, value);
            return null == ind ? null : list[ind];
        }
        function getIndByKey(list, key, value) {
            if (!list) return null;
            for (var i = 0; i < list.length; i++) {
                var item = list[i];
                if (item) {
                    var itemVal = eval("item." + key);
                    if (itemVal == value) return i;
                }
            }
            return null;
        }
        function getNotNullKey(list, key) {
            if (!list) return null;
            for (var i = 0; i < list.length; i++) if (null != list[i][key]) return list[i];
            return null;
        }
        function getById(list, id) {
            return getByKey(list, "id", id);
        }
        function getIndById(list, id) {
            return getIndByKey(list, "id", id);
        }
        function removeById(list, id) {
            return removeByKey(list, "id", id);
        }
        function addOrReplace(list, obj) {
            var ind = remove(list, obj);
            insert(list, ind, obj);
        }
        function addIfNotExists(list, obj) {
            contains(list, obj) || list.push(obj);
        }
        function insert(list, ind, obj) {
            null != ind ? list.splice(ind, 0, obj) : list.push(obj);
        }
        function addOrReplaceById(list, obj) {
            addOrReplaceByKey(list, "id", obj);
        }
        function addOrReplaceByKey(list, key, obj) {
            var ind = removeByKey(list, key, obj[key]);
            insert(list, ind, obj);
        }
        function removeByKey(list, key, val) {
            if (!list) return null;
            for (var objToRemoveInd = null, removedObj = null, i = 0; i < list.length; i++) if (list[i][key] && list[i][key] == val) {
                objToRemoveInd = i, removedObj = list[i];
                break;
            }
            return removedObj && list.splice(objToRemoveInd, 1), objToRemoveInd;
        }
        function chop(list, size) {
            return list.length > size ? list.slice(0, size) : list;
        }
        function sort(list, key, desc, emptyBehaviour) {
            var keyParts = key.split(","), mainKey = keyParts[0], subKey = keyParts[1];
            return list.sort(function(a, b) {
                var aVal = eval("a." + mainKey), bVal = eval("b." + mainKey);
                if (aVal == bVal) {
                    if (!subKey) return 0;
                    aVal = eval("a." + subKey), bVal = eval("b." + subKey);
                }
                if (null != aVal && null != bVal || !emptyBehaviour) {
                    var greater = bVal > aVal ? -1 : 1;
                    return greater * (desc ? -1 : 1);
                }
                return "emptyFirst" == emptyBehaviour ? null == bVal ? 1 : -1 : "emptyLast" == emptyBehaviour ? null == bVal ? -1 : 1 : void 0;
            });
        }
        function shuffle(list) {
            for (var tempList = []; list.length > 0; ) tempList.push(popRandom(list));
            for (;tempList.length > 0; ) list.push(tempList.pop());
            return list;
        }
        function toString(list, separator) {
            if (!list || 0 == list.length) return "";
            var listStr = "";
            separator || (separator = ",");
            for (var i = 0; i < list.length; i++) listStr += separator + list[i];
            return listStr.substring(separator.length);
        }
        function toFieldsString(list, field, separator) {
            return toString(getAttributesList(list, field, separator));
        }
        function getMaxByKey(list, key) {
            if (!list) return null;
            var maxObj = null;
            for (var i in list) (null == maxObj || list[i][key] && list[i][key] > maxObj[key]) && (maxObj = list[i]);
            return maxObj;
        }
        function getMaxesByKey(list, key) {
            if (!list) return null;
            for (var maxesList = [], maxObj = null, i = 0; i < list.length; i++) null == maxObj || list[i][key] > maxObj[key] ? (maxObj = list[i], 
            maxesList = [ maxObj ]) : list[i][key] == maxObj[key] && maxesList.push(list[i][key]);
            return maxesList;
        }
        function popRandom(list) {
            var obj = getRandom(list);
            return remove(list, obj), obj;
        }
        function getRandom(list) {
            var randomInd = Math.floor(Math.random() * list.length), obj = list[randomInd];
            return obj;
        }
        function inverse(list) {
            for (var listCopy = []; list.length > 0; ) listCopy.push(list.pop());
            for (var i = 0; i < listCopy.length; i++) list.push(listCopy[i]);
        }
        function average(list, key) {
            return list ? sum(list, key) / list.length : null;
        }
        function sum(list, key) {
            if (!list) return null;
            for (var total = 0, i = 0; i < list.length; i++) {
                var elem = list[i];
                total += key ? elem[key] : elem;
            }
            return total;
        }
        function getAttributesList(list, key) {
            var attrList = [];
            if (!list) return [];
            for (var i = 0; i < list.length; i++) attrList.push(list[i][key]);
            return attrList;
        }
        function getIdsList(list) {
            return getAttributesList(list, "id");
        }
        function hasCommonElement(list1, list2) {
            if (!list1 || !list2 || 0 == list1.length || 0 == list2.length) return !1;
            for (var i = 0; i < list1.length; i++) for (var j = 0; j < list2.length; j++) if (list1[i] == list2[j]) return !0;
            return !1;
        }
        function replaceContent(oldList, newList) {
            var newListClone = newList ? newList.slice(0) : [];
            oldList.length = 0, Array.prototype.push.apply(oldList, newListClone);
        }
        function listToMap(list, key) {
            var map = {};
            if (list) for (var i = 0; i < list.length; i++) {
                var item = list[i];
                map[item[key]] = item;
            }
            return map;
        }
        function listToMapById(list) {
            return listToMap(list, "id");
        }
        function setPropertyFromMap(list, property, map, key, detaultVal) {
            if (list) for (var i = 0; i < list.length; i++) {
                var item = list[i];
                item[property] = map[item[key]] || detaultVal;
            }
        }
        function setPropertyFromMapById(list, property, map) {
            setPropertyFromMap(list, property, map, "id");
        }
        function setPropertyFromList(list, property, propertiesList, listKey, propertyKey, detaultVal) {
            if (list && propertiesList) for (var map = listToMap(propertiesList, propertyKey), i = 0; i < list.length; i++) {
                var item = list[i], itemKey = item[listKey];
                item[property] = map[itemKey] || detaultVal;
            }
        }
        function addOrReplaceAllByKey(oldList, newList, key) {
            for (var i = 0; i < newList.length; i++) {
                var newItem = newList[i];
                addOrReplaceByKey(oldList, newItem, key), newItem.existsInNewList = !0;
            }
        }
        return {
            shuffle: shuffle,
            sort: sort,
            inverse: inverse,
            chop: chop,
            insert: insert,
            addOrReplaceByKey: addOrReplaceByKey,
            addOrReplaceById: addOrReplaceById,
            addOrReplace: addOrReplace,
            addIfNotExists: addIfNotExists,
            replaceContent: replaceContent,
            addOrReplaceAllByKey: addOrReplaceAllByKey,
            getIndById: getIndById,
            getById: getById,
            getNotNullKey: getNotNullKey,
            getIndByKey: getIndByKey,
            getByKey: getByKey,
            getInd: getInd,
            removeByKey: removeByKey,
            removeById: removeById,
            remove: remove,
            sum: sum,
            average: average,
            getMaxesByKey: getMaxesByKey,
            getMaxByKey: getMaxByKey,
            filterByValuesList: filterByValuesList,
            filterWithFunction: filterWithFunction,
            getFilteredList: getFilteredList,
            filteredByNonEmpty: filteredByNonEmpty,
            filteredByEmpty: filteredByEmpty,
            filteredByNot: filteredByNot,
            filteredBy: filteredBy,
            containsByKey: containsByKey,
            contains: contains,
            hasCommonElement: hasCommonElement,
            getRandom: getRandom,
            popRandom: popRandom,
            listToMap: listToMap,
            listToMapById: listToMapById,
            setPropertyFromMap: setPropertyFromMap,
            setPropertyFromMapById: setPropertyFromMapById,
            setPropertyFromList: setPropertyFromList,
            getIdsList: getIdsList,
            getAttributesList: getAttributesList,
            toFieldsString: toFieldsString,
            toString: toString
        };
    });
}), Array.prototype.indexOf || (Array.prototype.indexOf = function(obj, start) {
    for (var i = start || 0, j = this.length; j > i; i++) if (this[i] === obj) return i;
    return -1;
}), define("common/js/modules/utils/dateUtilsService", [ "./utilsModule" ], function(module) {
    module.factory("DateUtilsService", function($q, $filter, StringsService) {
        function formatToServerDate(date, withTime) {
            var format = "yyyy-MM-dd";
            return withTime && (format += " HH:mm:ss"), $filter("date")(date, format);
        }
        function parseServerDate(dateStr) {
            var dateComponenets = dateStr.split(" "), dateParts = dateComponenets[0].split("-"), date = new Date(dateParts[0], dateParts[1] - 1, dateParts[2]);
            if (dateComponenets.length > 1) {
                var timeParts = dateComponenets[1].split(":");
                2 == timeParts.length && timeParts.push("00"), date = new Date(dateParts[0], dateParts[1] - 1, dateParts[2], timeParts[0], timeParts[1], timeParts[2]);
            }
            return date;
        }
        function parseDuration(millisLeft) {
            var delta = Math.floor(millisLeft / 1e3), days = Math.floor(delta / 86400);
            delta -= 86400 * days;
            var hours = Math.floor(delta / 3600) % 24;
            delta -= 3600 * hours;
            var minutes = Math.floor(delta / 60) % 60;
            delta -= 60 * minutes;
            var seconds = Math.floor(delta % 60);
            return {
                days: days,
                hours: hours,
                minutes: minutes,
                seconds: seconds
            };
        }
        function isToday(serverDate) {
            return formatToServerDate(new Date()) == serverDate;
        }
        function getFormattedDuration(millisLeft) {
            var parsed = parseDuration(millisLeft), formatted = "";
            return parsed.days && (formatted += parsed.days + "d, "), (parsed.hours || parsed.days) && (formatted += StringsService.pad(parsed.hours, 2, "0") + ":"), 
            formatted += StringsService.pad(parsed.minutes, 2, "0") + ":", formatted += StringsService.pad(Math.max(parsed.seconds, 1), 2, "0");
        }
        return {
            formatToServerDate: formatToServerDate,
            isToday: isToday,
            parseServerDate: parseServerDate,
            parseDuration: parseDuration,
            getFormattedDuration: getFormattedDuration
        };
    });
}), define("common/js/modules/utils/utilFilters", [ "./utilsModule" ], function(module) {
    return module.filter("duration", [ "DateUtilsService", function(DateUtilsService) {
        return function(duration) {
            return DateUtilsService.getFormattedDuration(duration);
        };
    } ]);
}), define("common/js/modules/utils/index", [ "./utilsModule", "./externalHrefDirective", "./arraysService", "./dateUtilsService", "./utilFilters" ], function() {}), 
define("common/js/modules/domUtils/domUtilsModule", [ "angular" ], function(ng) {
    return ng.module("commonModules.domUtils", []);
}), window.getAngularService = function(serviceName) {
    return angular.element(document.body).injector().get(serviceName);
}, !function(name, definition) {
    "function" == typeof define ? define("morpheus", definition) : "undefined" != typeof module ? module.exports = definition() : this[name] = definition();
}("morpheus", function() {
    function has(array, elem, i) {
        if (Array.prototype.indexOf) return array.indexOf(elem);
        for (i = 0; i < array.length; ++i) if (array[i] === elem) return i;
    }
    function render(timestamp) {
        var i, count = children.length;
        for (fixTs && (timestamp = now()), i = count; i--; ) children[i](timestamp);
        children.length && frame(render);
    }
    function live(f) {
        1 === children.push(f) && frame(render);
    }
    function die(f) {
        var rest, index = has(children, f);
        index >= 0 && (rest = children.slice(index + 1), children.length = index, children = children.concat(rest));
    }
    function parseTransform(style, base) {
        var m, values = {};
        return (m = style.match(rotate)) && (values.rotate = by(m[1], base ? base.rotate : null)), 
        (m = style.match(scale)) && (values.scale = by(m[1], base ? base.scale : null)), 
        (m = style.match(skew)) && (values.skewx = by(m[1], base ? base.skewx : null), values.skewy = by(m[3], base ? base.skewy : null)), 
        (m = style.match(translate)) && (values.translatex = by(m[1], base ? base.translatex : null), 
        values.translatey = by(m[3], base ? base.translatey : null)), values;
    }
    function formatTransform(v) {
        var s = "";
        return "rotate" in v && (s += "rotate(" + v.rotate + "deg) "), "scale" in v && (s += "scale(" + v.scale + ") "), 
        "translatex" in v && (s += "translate(" + v.translatex + "px," + v.translatey + "px) "), 
        "skewx" in v && (s += "skew(" + v.skewx + "deg," + v.skewy + "deg)"), s;
    }
    function rgb(r, g, b) {
        return "#" + (1 << 24 | r << 16 | g << 8 | b).toString(16).slice(1);
    }
    function toHex(c) {
        var m = c.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/);
        return (m ? rgb(m[1], m[2], m[3]) : c).replace(/#(\w)(\w)(\w)$/, "#$1$1$2$2$3$3");
    }
    function camelize(s) {
        return s.replace(/-(.)/g, function(m, m1) {
            return m1.toUpperCase();
        });
    }
    function fun(f) {
        return "function" == typeof f;
    }
    function nativeTween(t) {
        return Math.sin(t * Math.PI / 2);
    }
    function tween(duration, fn, done, ease, from, to) {
        function run(t) {
            var delta = t - start;
            return delta > time || stop ? (to = isFinite(to) ? to : 1, stop ? end && fn(to) : fn(to), 
            die(run), done && done.apply(self)) : void fn(isFinite(to) ? diff * ease(delta / time) + from : ease(delta / time));
        }
        ease = fun(ease) ? ease : morpheus.easings[ease] || nativeTween;
        var time = duration || thousand, self = this, diff = to - from, start = now(), stop = 0, end = 0;
        return live(run), {
            stop: function(jump) {
                stop = 1, end = jump, jump || (done = null);
            }
        };
    }
    function bezier(points, pos) {
        var i, j, n = points.length, r = [];
        for (i = 0; n > i; ++i) r[i] = [ points[i][0], points[i][1] ];
        for (j = 1; n > j; ++j) for (i = 0; n - j > i; ++i) r[i][0] = (1 - pos) * r[i][0] + pos * r[parseInt(i + 1, 10)][0], 
        r[i][1] = (1 - pos) * r[i][1] + pos * r[parseInt(i + 1, 10)][1];
        return [ r[0][0], r[0][1] ];
    }
    function nextColor(pos, start, finish) {
        var i, e, from, to, r = [];
        for (i = 0; 6 > i; i++) from = Math.min(15, parseInt(start.charAt(i), 16)), to = Math.min(15, parseInt(finish.charAt(i), 16)), 
        e = Math.floor((to - from) * pos + from), e = e > 15 ? 15 : 0 > e ? 0 : e, r[i] = e.toString(16);
        return "#" + r.join("");
    }
    function getTweenVal(pos, units, begin, end, k, i, v) {
        if ("transform" == k) {
            v = {};
            for (var t in begin[i][k]) v[t] = t in end[i][k] ? Math.round(((end[i][k][t] - begin[i][k][t]) * pos + begin[i][k][t]) * thousand) / thousand : begin[i][k][t];
            return v;
        }
        return "string" == typeof begin[i][k] ? nextColor(pos, begin[i][k], end[i][k]) : (v = Math.round(((end[i][k] - begin[i][k]) * pos + begin[i][k]) * thousand) / thousand, 
        k in unitless || (v += units[i][k] || "px"), v);
    }
    function by(val, start, m, r, i) {
        return (m = relVal.exec(val)) ? (i = parseFloat(m[2])) && start + ("+" == m[1] ? 1 : -1) * i : parseFloat(val);
    }
    function morpheus(elements, options) {
        var i, originalLeft, originalTop, els = elements ? els = isFinite(elements.length) ? elements : [ elements ] : [], complete = options.complete, duration = options.duration, ease = options.easing, points = options.bezier, begin = [], end = [], units = [], bez = [];
        for (points && (originalLeft = options.left, originalTop = options.top, delete options.right, 
        delete options.bottom, delete options.left, delete options.top), i = els.length; i--; ) {
            if (begin[i] = {}, end[i] = {}, units[i] = {}, points) {
                var left = getStyle(els[i], "left"), top = getStyle(els[i], "top"), xy = [ by(fun(originalLeft) ? originalLeft(els[i]) : originalLeft || 0, parseFloat(left)), by(fun(originalTop) ? originalTop(els[i]) : originalTop || 0, parseFloat(top)) ];
                bez[i] = fun(points) ? points(els[i], xy) : points, bez[i].push(xy), bez[i].unshift([ parseInt(left, 10), parseInt(top, 10) ]);
            }
            for (var k in options) {
                switch (k) {
                  case "complete":
                  case "duration":
                  case "easing":
                  case "bezier":
                    continue;
                }
                var unit, v = getStyle(els[i], k), tmp = fun(options[k]) ? options[k](els[i]) : options[k];
                "string" != typeof tmp || !rgbOhex.test(tmp) || rgbOhex.test(v) ? (begin[i][k] = "transform" == k ? parseTransform(v) : "string" == typeof tmp && rgbOhex.test(tmp) ? toHex(v).slice(1) : parseFloat(v), 
                end[i][k] = "transform" == k ? parseTransform(tmp, begin[i][k]) : "string" == typeof tmp && "#" == tmp.charAt(0) ? toHex(tmp).slice(1) : by(tmp, parseFloat(v)), 
                "string" == typeof tmp && (unit = tmp.match(numUnit)) && (units[i][k] = unit[1])) : delete options[k];
            }
        }
        return tween.apply(els, [ duration, function(pos, v, xy) {
            for (i = els.length; i--; ) {
                points && (xy = bezier(bez[i], pos), els[i].style.left = xy[0] + "px", els[i].style.top = xy[1] + "px");
                for (var k in options) v = getTweenVal(pos, units, begin, end, k, i), "transform" == k ? els[i].style[transform] = formatTransform(v) : "opacity" != k || opasity ? els[i].style[camelize(k)] = v : els[i].style.filter = "alpha(opacity=" + 100 * v + ")";
            }
        }, complete, ease ]);
    }
    var doc = document, win = window, perf = win.performance, perfNow = perf && (perf.now || perf.webkitNow || perf.msNow || perf.mozNow), now = perfNow ? function() {
        return perfNow.call(perf);
    } : function() {
        return +new Date();
    }, fixTs = !1, html = doc.documentElement, thousand = 1e3, rgbOhex = /^rgb\(|#/, relVal = /^([+\-])=([\d\.]+)/, numUnit = /^(?:[\+\-]=?)?\d+(?:\.\d+)?(%|in|cm|mm|em|ex|pt|pc|px)$/, rotate = /rotate\(((?:[+\-]=)?([\-\d\.]+))deg\)/, scale = /scale\(((?:[+\-]=)?([\d\.]+))\)/, skew = /skew\(((?:[+\-]=)?([\-\d\.]+))deg, ?((?:[+\-]=)?([\-\d\.]+))deg\)/, translate = /translate\(((?:[+\-]=)?([\-\d\.]+))px, ?((?:[+\-]=)?([\-\d\.]+))px\)/, unitless = {
        lineHeight: 1,
        zoom: 1,
        zIndex: 1,
        opacity: 1,
        transform: 1
    }, transform = function() {
        var i, styles = doc.createElement("a").style, props = [ "webkitTransform", "MozTransform", "OTransform", "msTransform", "Transform" ];
        for (i = 0; i < props.length; i++) if (props[i] in styles) return props[i];
    }(), opasity = function() {
        return "undefined" != typeof doc.createElement("a").style.opacity;
    }(), getStyle = doc.defaultView && doc.defaultView.getComputedStyle ? function(el, property) {
        property = "transform" == property ? transform : property, property = camelize(property);
        var value = null, computed = doc.defaultView.getComputedStyle(el, "");
        return computed && (value = computed[property]), el.style[property] || value;
    } : html.currentStyle ? function(el, property) {
        if (property = camelize(property), "opacity" == property) {
            var val = 100;
            try {
                val = el.filters["DXImageTransform.Microsoft.Alpha"].opacity;
            } catch (e1) {
                try {
                    val = el.filters("alpha").opacity;
                } catch (e2) {}
            }
            return val / 100;
        }
        var value = el.currentStyle ? el.currentStyle[property] : null;
        return el.style[property] || value;
    } : function(el, property) {
        return el.style[camelize(property)];
    }, frame = function() {
        return win.requestAnimationFrame || win.webkitRequestAnimationFrame || win.mozRequestAnimationFrame || win.msRequestAnimationFrame || win.oRequestAnimationFrame || function(callback) {
            win.setTimeout(function() {
                callback(+new Date());
            }, 17);
        };
    }();
    frame(function(timestamp) {
        fixTs = timestamp > 1e12 != now() > 1e12;
    });
    var children = [];
    return morpheus.tween = tween, morpheus.getStyle = getStyle, morpheus.bezier = bezier, 
    morpheus.transform = transform, morpheus.parseTransform = parseTransform, morpheus.formatTransform = formatTransform, 
    morpheus.animationFrame = frame, morpheus.easings = {}, morpheus;
}), define("common/js/modules/domUtils/domUtilsService", [ "./domUtilsModule", "morpheus" ], function(module, morpheus) {
    module.factory("DomUtilsService", function($q, $window, $timeout, I18nService, OsInfoService) {
        function getParentElement(element, tagName, attribute, value) {
            for (var elem = element, result = null; null == result && "body" != elem[0].tagName.toLowerCase(); ) elem = elem.parent(), 
            elem[0].tagName.toLowerCase() != tagName.toLowerCase() || attribute && elem.attr(attribute) != value || (result = elem);
            return result;
        }
        function insertBefore(existingElement, elementToAdd) {
            existingElement.parent()[0].insertBefore(elementToAdd[0], existingElement[0]);
        }
        function findAny(parent, selectors) {
            for (var elements = [], i = 0; i < selectors.length; i++) for (var selectedElements = parent.find(selectors[i]), j = 0; j < selectedElements.length; j++) elements.push(angular.element(selectedElements[i]));
            return elements;
        }
        function findInputByName(parent, inputName) {
            for (var inputs = findAny(parent, [ "input", "select", "textarea" ]), i = 0; i < inputs.length; i++) {
                var input = inputs[i];
                if (input.attr("name") == inputName) return input;
            }
            return null;
        }
        function loadImage(src, delay, retries) {
            var deferred = $q.defer(), image = angular.element(new Image());
            return image.bind("load", function() {
                deferred.resolve({
                    size: {
                        width: image[0].naturalWidth,
                        height: image[0].naturalHeight
                    },
                    src: src
                });
            }), image.bind("error", function() {
                retries > 0 ? loadImage(src, delay, retries - 1).then(function(imageInfo) {
                    deferred.resolve(imageInfo);
                }, function() {
                    deferred.reject();
                }) : deferred.reject();
            }), $timeout(function() {
                image.attr("src", src);
            }, delay || 10), deferred.promise;
        }
        function isTextInputFocused() {
            var activeElement = document.activeElement;
            return !activeElement || "input" != activeElement.tagName.toLowerCase() && "textarea" != activeElement.tagName.toLowerCase() ? !1 : !0;
        }
        function getWindowScroll() {
            var doc = document.documentElement, left = ($window.pageXOffset || doc.scrollLeft) - (doc.clientLeft || 0), top = ($window.pageYOffset || doc.scrollTop) - (doc.clientTop || 0);
            return {
                left: left,
                top: top
            };
        }
        function link(href, text, target) {
            var targetStr = target ? "target='" + target + "'" : "";
            return "<a dir='ltr' href='" + href + "' " + targetStr + ">" + text + "</a>";
        }
        function noWrap(text, dir) {
            return text ? "<span " + (dir ? "dir='" + dir : "") + "' style='white-space:nowrap'>" + text + "</span>" : "";
        }
        function getDirection(lang) {
            switch (lang || I18nService.getCurrentLang()) {
              case "he":
                return "rtl";

              default:
                return "ltr";
            }
        }
        function getTag(tagName, attributeName, attributeValue) {
            for (var tags = document.getElementsByTagName(tagName), i = 0; i < tags.length; i++) {
                var tag = tags[i];
                if (tag.getAttribute(attributeName) == attributeValue) return tag;
            }
        }
        function setTagProp(tagName, attributeName, attributeValue, propName, propValue) {
            var tag = getTag(tagName, attributeName, attributeValue);
            tag || (tag = document.createElement(tagName), tag.setAttribute(attributeName, attributeValue), 
            document.getElementsByTagName("head")[0].appendChild(tag)), tag.setAttribute(propName, propValue);
        }
        function removeTag(tagName, attributeName, attributeValue) {
            var tag = getTag(tagName, attributeName, attributeValue);
            tag && tag.parentNode.removeChild(tag);
        }
        function setMetaTag(attributeName, attributeValue, content) {
            content ? setTagProp("meta", attributeName, attributeValue, "content", content) : removeMetaTag(attributeName, attributeValue);
        }
        function removeMetaTag(attributeName, attributeValue) {
            removeTag("meta", attributeName, attributeValue);
        }
        function getBoundingRect(element) {
            var rect = element[0].getBoundingClientRect(), bodyZoom = document.body.style.zoom;
            if (bodyZoom) {
                var scale = 1 * bodyZoom.replace("%", "") / 100;
                return {
                    top: rect.top * scale,
                    left: rect.left * scale,
                    width: rect.width * scale,
                    height: rect.height * scale
                };
            }
            return rect;
        }
        function scrollToElementTop(element, offset) {
            var scrollOffset = getBoundingRect(element).top;
            scrollOffset += $window.pageYOffset - document.documentElement.clientTop, OsInfoService.isAndroid() && GlobalConfig.isMobileApp && (scrollOffset += 24), 
            offset && (scrollOffset += offset), scrollOffset > 0 && $timeout(function() {
                window.scrollTo(0, scrollOffset);
            }, 10);
        }
        function scrollToElementBottom(element, offset) {
            scrollToElementTop(element, getBoundingRect(element).height + (offset || 0));
        }
        function addCssClassTemporarily(element, cssClass, time, delay) {
            var angularElement = angular.element(element);
            $timeout(function() {
                angularElement.addClass(cssClass), $timeout(function() {
                    angularElement.removeClass(cssClass);
                }, time);
            }, delay || 10);
        }
        function blink(element, time, delay) {
            addCssClassTemporarily(element, "blink", time, delay);
        }
        function displayToast(options) {
            var element = options.element;
            options.selector && (element = angular.element(element[0].querySelectorAll(options.selector)));
            var toastTimerId = element.attr("_toast_id");
            toastTimerId || (toastTimerId = mToastsTimers.runningId++, element.attr("_toast_id", toastTimerId));
            var timer = mToastsTimers.timers[toastTimerId];
            timer && $timeout.cancel(timer), element.css({
                opacity: 0
            });
            var message = options.messageKey ? I18nService.getText(options.messageKey) : options.message;
            message && (element.html(message), morpheus(element, {
                opacity: 1
            }, 500), timer = $timeout(function() {
                morpheus(element, {
                    opacity: 0
                }, 500);
            }, options.delay || 5e3)), mToastsTimers.timers[toastTimerId] = timer;
        }
        function setSubElementText(element, selector, text) {
            var subElement = angular.element(element[0].querySelectorAll(selector));
            subElement.html(text);
        }
        function setFavIcon(url) {
            var link = document.querySelector("link[rel*='icon']") || document.createElement("link");
            link.type = "image/x-icon", link.rel = "shortcut icon", link.href = url, document.getElementsByTagName("head")[0].appendChild(link);
        }
        function copyToClipboard(text) {
            var textArea = document.createElement("textarea");
            textArea.style.position = "fixed", textArea.style.top = 0, textArea.style.left = 0, 
            textArea.style.width = "2em", textArea.style.height = "2em", textArea.style.padding = 0, 
            textArea.style.border = "none", textArea.style.outline = "none", textArea.style.boxShadow = "none", 
            textArea.style.background = "transparent", textArea.value = text, document.body.appendChild(textArea), 
            textArea.select();
            try {
                {
                    document.execCommand("copy");
                }
            } catch (err) {}
            document.body.removeChild(textArea);
        }
        var mToastsTimers = {
            timers: {},
            runningId: 0
        };
        return {
            getParentElement: getParentElement,
            insertBefore: insertBefore,
            setTagProp: setTagProp,
            setMetaTag: setMetaTag,
            removeMetaTag: removeMetaTag,
            findInputByName: findInputByName,
            isTextInputFocused: isTextInputFocused,
            getWindowScroll: getWindowScroll,
            getBoundingRect: getBoundingRect,
            scrollToElementTop: scrollToElementTop,
            scrollToElementBottom: scrollToElementBottom,
            getDirection: getDirection,
            loadImage: loadImage,
            addCssClassTemporarily: addCssClassTemporarily,
            blink: blink,
            displayToast: displayToast,
            setSubElementText: setSubElementText,
            link: link,
            noWrap: noWrap,
            setFavIcon: setFavIcon,
            copyToClipboard: copyToClipboard
        };
    });
}), define("common/js/modules/domUtils/enterKeyActionDirective", [ "./domUtilsModule" ], function(module) {
    module.directive("bsEnterKeyAction", function(PathsService, $parse, $timeout) {
        return {
            restrict: "A",
            scope: {
                action: "&bsEnterKeyAction"
            },
            link: function(scope, element) {
                element.bind("keydown keypress", function(event) {
                    13 === event.which && (scope.action(), $timeout(function() {
                        scope.$apply();
                    }, 30), event.preventDefault());
                });
            }
        };
    });
}), define("common/js/modules/domUtils/viewPortService", [ "./domUtilsModule" ], function(module) {
    module.factory("ViewPortService", function($rootScope, $timeout, DomUtilsService, OsInfoService) {
        function onResize() {
            if (!DomUtilsService.isTextInputFocused() && !$rootScope.resizeBloced) {
                $timeout.cancel(mResizeTriggerTimer);
                {
                    document.activeElement;
                }
                mResizeTriggerTimer = $timeout(function() {
                    DomUtilsService.isTextInputFocused() || (adjustViewPortAccordingToOrientation(), 
                    mViewPortInfo.orientation && mViewPortInfo.orientation != getOrientation(), updateViewportInfo());
                }, 300);
            }
        }
        function updateViewportInfo() {
            mViewPortInfo.innerWidth = window.innerWidth, mViewPortInfo.innerHeight = window.innerHeight, 
            window.innerWidth < 1200 && (mViewPortInfo.mobileMedia = !0, mViewPortInfo.pcMedia = !1), 
            window.innerWidth >= 1200 && (mViewPortInfo.pcMedia = !0, mViewPortInfo.mobileMedia = !1), 
            mViewPortInfo.isWideDevice = isWideDevice(), mViewPortInfo.orientation = getOrientation(), 
            mViewPortInfo.clientWidth = getClientWidth(), mViewPortInfo.contentWidth = Math.min(mViewPortInfo.clientWidth, 1024), 
            mViewPortInfo.clientHeight = getClientHeight(), mViewPortInfo.maxWidth = getMaxWidth(), 
            $rootScope.viewPort = mViewPortInfo, mDebugInfo.viewPort = mViewPortInfo;
        }
        function adjustViewPortAccordingToOrientation() {
            var width;
            width = isLandscapeOrientation() ? 900 : mViewPortInfo.minInitialDimenstion < 400 ? 500 : 900;
            var viewportChanged = !1;
            if (OsInfoService.isAndroid() && GlobalConfig.isMobileApp) {
                var initialWidth = isLandscapeOrientation() ? mInitialHeight : mInitialWidth, newZoom = Math.round(1e4 * initialWidth / width) / 100 + "%";
                (newZoom != document.body.style.zoom || width != mViewPortWidth) && (document.body.style.zoom = newZoom, 
                document.body.style.width = width + "px", viewportChanged = !0);
            } else if (OsInfoService.isIos()) {
                var prevWidth = mViewPortWidth || window.innerWidth, scale = Math.round(100 * prevWidth / width) / 100;
                scale = Math.max(.5, scale);
                var viewPortWidthContent = "width=" + width;
                mViewPortWidth && mViewPortInfo.orientation == getOrientation() || (viewPortWidthContent += ", initial-scale=" + scale + ", maximum-scale=" + scale), 
                GlobalConfig.isMobileApp && (viewPortWidthContent += ", user-scalable=no, viewport-fit=cover"), 
                mViewPortElement.setAttribute("content", viewPortWidthContent), viewportChanged = !0;
            } else width != mViewPortWidth && (mViewPortElement.setAttribute("content", "width=" + width), 
            viewportChanged = !0);
            mViewPortWidth = width, $rootScope.viewPort.viewPortWidth = mViewPortWidth;
        }
        function bindViewPortSizeToWindowWidth() {
            mViewPortInfo.minInitialDimenstion = Math.min(window.innerWidth, window.innerHeight), 
            mInitialWidth = Math.min(window.innerWidth, window.innerHeight), mInitialHeight = Math.max(window.innerWidth, window.innerHeight), 
            mViewPortElement = document.querySelector('meta[name="viewport"]'), $rootScope.viewPortDebugInfo = mDebugInfo, 
            window.addEventListener("resize", onResize), updateViewportInfo(), onResize(), $timeout(updateViewportInfo, 1e3);
        }
        function getWindowScroll() {
            var doc = document.documentElement, left = (window.pageXOffset || doc.scrollLeft) - (doc.clientLeft || 0), top = (window.pageYOffset || doc.scrollTop) - (doc.clientTop || 0);
            return {
                left: left,
                top: top
            };
        }
        function getClientWidth() {
            return GlobalConfig.isMobileApp && mViewPortWidth ? mViewPortWidth : window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth;
        }
        function getMaxWidth() {
            return Math.max(Math.max(window.innerWidth, mViewPortWidth), document.getElementById("mainView").offsetWidth);
        }
        function getViewPortWidth() {
            return mViewPortWidth || getClientWidth();
        }
        function getClientHeight() {
            return OsInfoService.isAndroid() && GlobalConfig.isMobileApp ? window.innerHeight * mViewPortWidth / window.innerWidth : window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;
        }
        function isWideDevice() {
            return $rootScope.searchAgentRequest ? !0 : getClientWidth() < 500 ? !1 : OsInfoService.isMobile() ? !1 : !0;
        }
        function isLandscapeOrientation() {
            return window.innerWidth > window.innerHeight ? !0 : !1;
        }
        function getOrientation() {
            return isLandscapeOrientation() ? "landscape" : "portrait";
        }
        var mViewPortWidth, mInitialWidth, mInitialHeight, mViewPortElement = null, mDebugInfo = {
            resizeCount: 0
        }, mViewPortInfo = {}, mResizeTriggerTimer = null;
        return {
            bindViewPortSizeToWindowWidth: bindViewPortSizeToWindowWidth,
            clientHeight: getClientHeight,
            clientWidth: getClientWidth,
            updateViewportInfo: updateViewportInfo,
            getMaxWidth: getMaxWidth,
            getViewPortWidth: getViewPortWidth,
            getWindowScroll: getWindowScroll,
            isWideDevice: isWideDevice
        };
    });
}), define("common/js/modules/domUtils/slideToggleDirective", [ "./domUtilsModule" ], function(module) {
    module.directive("slideable", function() {
        return {
            restrict: "C",
            compile: function(element, attr) {
                var contents = element.html();
                return element.html('<div class="slideable_content" style="margin:0 !important; padding:0 !important" >' + contents + "</div>"), 
                function(scope, element, attrs) {
                    "true" != attr.slideDisabled && (attrs.duration = attrs.duration ? attrs.duration : "1s", 
                    attrs.easing = attrs.easing ? attrs.easing : "ease-in-out", element.css({
                        overflow: "hidden",
                        height: "0px",
                        transitionProperty: "height",
                        transitionDuration: attrs.duration,
                        transitionTimingFunction: attrs.easing
                    }), element[0].addEventListener("webkitTransitionEnd", function() {
                        "0px" != element[0].style.height && setTimeout(function() {
                            element.css({
                                transitionProperty: "none",
                                height: ""
                            });
                        }, 10);
                    }, !1));
                };
            }
        };
    }).directive("slideToggle", function(DomUtilsService, $timeout, $rootScope) {
        return {
            restrict: "A",
            link: function(scope, element, attrs) {
                function init() {
                    attrs.expanded = !1, target = document.querySelector(attrs.slideToggle), content = target.querySelector(".slideable_content");
                }
                function slideUp() {
                    target.style.height = content.clientHeight + "px", setTimeout(function() {
                        angular.element(target).css({
                            transitionProperty: "height",
                            height: "0px"
                        }), content.classList.remove("expanded"), element.removeClass("expanded"), attrs.expanded = !1;
                    }, 10);
                }
                function slideDown() {
                    init(), content.style.border = "1px solid rgba(0,0,0,0)";
                    var y = content.clientHeight;
                    content.style.border = 0, target.style.height = y + "px", content.classList.add("expanded"), 
                    element.addClass("expanded"), attrs.expanded = !0;
                }
                if ("true" != attrs.slideDisabled) {
                    var target, content;
                    element.bind("click", function() {
                        attrs.expanded ? slideUp() : slideDown();
                    }), element.bind("slideUp", slideUp), $rootScope.$on("dom.slideMenu", function(event, arg) {
                        "#" + arg.name == attrs.slideToggle && ("up" == arg.direction ? slideUp() : slideDown());
                    });
                }
            }
        };
    });
}), define("common/js/modules/domUtils/autoFontSizeDirective", [ "./domUtilsModule" ], function(module) {
    module.directive("bsAutoFontSize", function($window) {
        return {
            template: '<div data-role="inner"  style="display:inline-block" ng-transclude></div>',
            transclude: !0,
            link: {
                post: function(scope, elem, attrs) {
                    function shrinkOrGrow() {
                        var i = 0;
                        if (adjustLineHeightAndInlineImages(), fontTooBig() && options.shrink) for (;fontTooBig() && 100 > i && fontSizeI() >= options.minSize; ) setFontSize(fontSizeI() - 1), 
                        i += 1; else {
                            if (!fontTooSmall() || !options.grow) return;
                            for (;fontTooSmall() && 100 > i; ) setFontSize(fontSizeI() + 1), i += 1;
                        }
                        scope.$emit("auto-font-size:resized", {
                            fontSize: fontSizeI(),
                            elem: elem
                        });
                    }
                    function css(el, prop) {
                        return $window.getComputedStyle ? $window.getComputedStyle(el[0]).getPropertyValue(prop) : void 0;
                    }
                    function fontSizeI() {
                        var fontSize = css(inner, "font-size");
                        return Number(fontSize.match(/\d+/)[0]);
                    }
                    function setFontSize(size) {
                        inner[0].style.fontSize = size + "px", adjustLineHeightAndInlineImages();
                    }
                    function adjustLineHeightAndInlineImages() {
                        if (fontSizeAdjusted()) {
                            var size = fontSizeI();
                            inner[0].style.lineHeight = size + 2 + "px";
                            var images = inner[0].querySelectorAll("img");
                            angular.forEach(images, function(img) {
                                img.style.height(size + 2 + "px");
                            });
                        }
                    }
                    function fontSizeAdjusted() {
                        return !!inner[0].style.fontSize;
                    }
                    function fontTooBig() {
                        return inner[0].offsetWidth > options.maxWidth || inner[0].offsetWidth > elem[0].offsetWidth || inner[0].offsetHeight > elem[0].offsetHeight;
                    }
                    function fontTooSmall() {
                        return inner[0].offsetWidth < elem[0].offsetWidth || inner[0].offsetHeight < elem[0].offsetHeight;
                    }
                    var providedOptions = scope.$eval(attrs.bsAutoFontSize) || {};
                    if (providedOptions.maxWidth) {
                        var options = angular.extend({
                            shrink: !0,
                            grow: !0,
                            minSize: 1,
                            maxWidth: null
                        }, providedOptions), inner = angular.element(elem[0].querySelector("div[data-role]"));
                        scope.$watch(shrinkOrGrow);
                    }
                }
            }
        };
    });
}), define("common/js/modules/domUtils/textDirectionDirective", [ "./domUtilsModule" ], function(module) {
    module.directive("bsTextDirection", function($rootScope, DomUtilsService) {
        return {
            restrict: "A",
            link: function(scope, element, attrs) {
                function setDirection() {
                    var direction = DomUtilsService.getDirection(lang || $rootScope.currentLang);
                    element.attr("dir", direction);
                }
                var lang = attrs.lang;
                scope.$on("i18n.languageChanged", setDirection), setDirection();
            }
        };
    });
}), define("common/js/modules/domUtils/scrollOnDirective", [ "./domUtilsModule" ], function(module) {
    module.directive("bsScrollOn", function($state, $timeout, $rootScope, PathsService, OsInfoService, DomUtilsService) {
        return {
            restrict: "A",
            scope: {
                bsScrollOn: "=",
                scrollToParent: "=",
                watchedValue: "=",
                offset: "=",
                delay: "="
            },
            link: function(scope, element) {
                function scrollIfConditionMet() {
                    if (window.location.hash == originalHash && (1 == scope.watchedValue || scope.bsScrollOn)) {
                        var elementToScroll = scope.scrollToParent ? element.parent : element;
                        DomUtilsService.scrollToElementTop(elementToScroll, scope.offset || -100);
                    }
                }
                var originalHash = window.location.hash;
                $timeout(scrollIfConditionMet, 50 | scope.delay), null != scope.watchedValue && scope.$watch("watchedValue", scrollIfConditionMet);
            }
        };
    });
}), define("common/js/modules/domUtils/backButtonDirective", [ "./domUtilsModule" ], function(module) {
    module.directive("bsBackButton", function($rootScope, $window) {
        return {
            restrict: "A",
            link: function(scope, elem) {
                elem.bind("click", function() {
                    $window.history.back();
                });
            }
        };
    });
}), define("common/js/modules/domUtils/bsWidthLimitDirective", [ "./domUtilsModule" ], function(module) {
    module.directive("bsWidthLimit", function($parse, $timeout, ViewPortService) {
        return {
            restrict: "A",
            scope: {
                params: "=bsWidthLimit"
            },
            link: function(scope, element) {
                if (scope.params.lessThen) {
                    var parts = scope.params.lessThen.split(" "), what = parts[0], maxWitdh = 0;
                    "screenWidth" == what && (maxWitdh = ViewPortService.clientWidth());
                    var operand = parts[1], offset = parts[2];
                    switch (operand) {
                      case "+":
                        maxWitdh += offset;
                        break;

                      case "-":
                        maxWitdh -= offset;
                    }
                    element.css({
                        maxWidth: maxWitdh + "px"
                    });
                }
            }
        };
    });
}), define("common/js/modules/domUtils/focusOnDirective", [ "./domUtilsModule" ], function(module) {
    module.directive("bsFocusOn", function(PathsService, $parse, $timeout) {
        return {
            restrict: "A",
            scope: {
                bsFocusOn: "="
            },
            link: function(scope, element) {
                function focusIfConditionMet() {
                    scope.bsFocusOn && (element[0].focus(), $timeout(function() {
                        element[0].focus();
                    }, 20));
                }
                scope.$watch("bsFocusOn", focusIfConditionMet);
            }
        };
    });
}), define("common/js/modules/domUtils/linkableTextDirective", [ "./domUtilsModule" ], function(module) {
    module.directive("bsLinkableText", function($rootScope, I18nService) {
        return {
            restrict: "E",
            scope: {
                options: "="
            },
            link: function(scope, elem) {
                function display() {
                    elem.html(I18nService.getText(scope.options.textKey, scope.options.textParams));
                    for (var links = elem.find("a"), i = 0; i < links.length; i++) !function(link) {
                        link.bind("mouseup", function(event) {
                            event.preventDefault();
                        }), link.bind("click", function(event) {
                            return scope.options.onLinkClick(link.attr("code")), event.stopPropagation(), event.preventDefault(), 
                            !1;
                        });
                    }(angular.element(links[i]));
                }
                display();
            }
        };
    });
}), define("common/js/modules/domUtils/scrollToTop", [ "./domUtilsModule" ], function(module) {
    module.directive("bsScrollToTop", function(PathsService, $parse, $timeout) {
        return {
            restrict: "A",
            link: function() {
                window.scrollTo(0, 0), $timeout(function() {
                    window.scrollTo(0, 0);
                }, 10);
            }
        };
    });
}), define("common/js/modules/domUtils/paginationDirective", [ "./domUtilsModule" ], function(module) {
    module.directive("bsPagination", function($timeout, $rootScope, $stateParams, PathsService) {
        return {
            restrict: "E",
            replace: !0,
            scope: {
                pagesData: "=",
                hrefPages: "=",
                availableWidth: "=",
                onCurrentPageChange: "&"
            },
            link: function(scope, element) {
                function updateDisplay() {
                    scope.currentLang = $rootScope.currentLang, rebuildNavigationBar(), scope.shouldShow = scope.pagesData.itemsCount > scope.pagesData.itemsPerPage;
                }
                function setBaseHref() {
                    var uiHref = PathsService.getCurrentUiHref();
                    scope.baseHref = $stateParams.page ? uiHref.substr(0, uiHref.lastIndexOf("/")) + "/" : uiHref;
                }
                function getMaxButtonsNumber() {
                    var parent = element.parent()[0];
                    if (parent) {
                        var buttonWidth = $rootScope.viewPort.mobileMedia ? 60 : 50, availableWidth = scope.availableWidth || Math.min(800, parent.offsetWidth), maxButtons = Math.floor(availableWidth / buttonWidth) - 2;
                        return 3 > maxButtons && (maxButtons = 3), maxButtons;
                    }
                }
                function getPageNavigationInfo(totalItems, itemsPerPage, currentPage, maxDisplayedPages) {
                    var firstPage = 1, totalPages = Math.ceil(totalItems / itemsPerPage);
                    maxDisplayedPages >= totalPages ? lastPage = totalPages : maxDisplayedPages / 2 > currentPage ? lastPage = maxDisplayedPages : currentPage > totalPages - maxDisplayedPages / 2 ? (lastPage = totalPages, 
                    firstPage = lastPage - maxDisplayedPages + 1) : (lastPage = currentPage + Math.floor(maxDisplayedPages / 2), 
                    firstPage = lastPage - maxDisplayedPages + 1);
                    var startInd = (currentPage - 1) * itemsPerPage, endInd = Math.min(startInd + itemsPerPage - 1, totalItems - 1);
                    return {
                        firstPage: firstPage,
                        lastPage: lastPage,
                        totalPages: totalPages,
                        currentPageFirstInd: startInd,
                        currentPageLastInd: endInd,
                        currentPage: currentPage,
                        prevPage: 1 == currentPage ? null : currentPage - 1,
                        nextPage: currentPage == totalPages ? null : currentPage + 1
                    };
                }
                function rebuildNavigationBar() {
                    scope.links = [];
                    var pagesData = scope.pagesData, maxButtons = getMaxButtonsNumber(), navPageInfo = getPageNavigationInfo(pagesData.itemsCount, pagesData.itemsPerPage, 1 * pagesData.currentPage, maxButtons);
                    if (navPageInfo.totalPages > 1) {
                        scope.links.push({
                            page: navPageInfo.prevPage,
                            isPrev: !0,
                            html: "&nbsp;"
                        });
                        for (var i = navPageInfo.firstPage; i <= navPageInfo.lastPage; i++) scope.links.push({
                            page: i,
                            isCurrent: i == pagesData.currentPage,
                            html: i
                        });
                        if (maxButtons > 4) {
                            1 != scope.links[1].page && (scope.links[1].page = 1, scope.links[1].html = 1, scope.links[2].html = "...");
                            var lastLinkInd = scope.links.length - 1;
                            scope.links[lastLinkInd].page != navPageInfo.totalPages && (scope.links[lastLinkInd].page = navPageInfo.totalPages, 
                            scope.links[lastLinkInd].html = navPageInfo.totalPages, scope.links[lastLinkInd - 1].html = "...");
                        }
                        scope.links.push({
                            page: navPageInfo.nextPage,
                            isNext: !0,
                            html: "&nbsp;"
                        });
                    }
                }
                function onDataChange(newValue, oldValue) {
                    oldValue && oldValue.itemsPerPage != newValue.itemsPerPage && (scope.pagesData.currentPage = 1), 
                    scope.baseHref && $stateParams.page && scope.pagesData.currentPage != $stateParams.page && (window.location.href = scope.baseHref + scope.pagesData.currentPage), 
                    updateDisplay();
                }
                scope.onLinkClick = function(link) {
                    !scope.hrefPages && link.page && (scope.pagesData.currentPage = link.page), scope.onCurrentPageChange && scope.onCurrentPageChange();
                }, scope.hrefPages && $timeout(setBaseHref, 100), scope.$watchCollection("pagesData", onDataChange), 
                updateDisplay();
            },
            templateUrl: PathsService.commonTemplatePath("elements/pagination")
        };
    });
}), define("common/js/modules/domUtils/touchedClassDirective", [ "./domUtilsModule" ], function(module) {
    module.directive("bsTouchedClass", function($timeout) {
        return {
            restrict: "A",
            scope: {
                touchedClassName: "=bsTouchedClass"
            },
            link: function(scope, element) {
                function addTouchedClass() {
                    $timeout.cancel(timer), element.addClass(scope.touchedClassName);
                }
                function removeTouchedClass() {
                    $timeout.cancel(timer), timer = $timeout(function() {
                        element.removeClass(scope.touchedClassName);
                    }, 300);
                }
                var timer;
                element.bind("touchstart", addTouchedClass), element.bind("touchend", removeTouchedClass), 
                element.bind("touchcancel", removeTouchedClass);
            }
        };
    });
}), define("common/js/modules/domUtils/clicksLockerService", [ "./domUtilsModule" ], function(module) {
    module.factory("ClicksLockerService", function() {
        function lockClicks(elementId) {
            mLockedElements[elementId] = !0;
        }
        function unlockClicks(elementId) {
            delete mLockedElements[elementId];
        }
        function isClicksLocked(elementId) {
            return mLockedElements[elementId];
        }
        function setClicskLocked(elementId, isLocked) {
            isLocked ? lockClicks(elementId) : unlockClicks(elementId);
        }
        var mLockedElements = {};
        return {
            lockClicks: lockClicks,
            unlockClicks: unlockClicks,
            isClicksLocked: isClicksLocked,
            setClicskLocked: setClicskLocked
        };
    });
}), define("common/js/modules/domUtils/bsRightClickDirective", [ "./domUtilsModule" ], function(module) {
    module.directive("bsRightClick", function($parse) {
        return function(scope, element, attrs) {
            var fn = $parse(attrs.bsRightClick);
            element.bind("contextmenu", function(event) {
                scope.$apply(function() {
                    event.preventDefault(), fn(scope, {
                        $event: event
                    });
                });
            });
        };
    });
}), define("common/js/modules/domUtils/stopEventDirective", [ "./domUtilsModule" ], function(module) {
    module.directive("stopEvent", function() {
        return {
            restrict: "A",
            link: function(scope, element, attr) {
                element.on(attr.stopEvent, function(e) {
                    e.stopPropagation();
                });
            }
        };
    });
}), define("common/js/modules/domUtils/draggableDirective", [ "./domUtilsModule" ], function(module) {
    module.directive("bsDraggable", [ "$document", function($document) {
        return {
            link: function(scope, element, attr) {
                function mousemove(event) {
                    y = event.pageY - startY, x = event.pageX - startX, draggbleElement.css({
                        top: y + "px",
                        left: x + "px"
                    });
                }
                function mouseup() {
                    $document.off("mousemove", mousemove), $document.off("mouseup", mouseup);
                }
                var startX = 0, startY = 0, x = 0, y = 0, draggbleElement = element;
                if (attr.parents) for (var i = 0; i < 1 * attr.parents; i++) draggbleElement = draggbleElement.parent();
                element.css({
                    cursor: "pointer"
                }), element.on("mousedown", function(event) {
                    event.preventDefault(), startX = event.pageX - x, startY = event.pageY - y, $document.on("mousemove", mousemove), 
                    $document.on("mouseup", mouseup);
                });
            }
        };
    } ]);
}), define("common/js/modules/domUtils/toastDirective", [ "./domUtilsModule" ], function(module) {
    module.directive("bsToast", function(DomUtilsService) {
        return {
            restrict: "A",
            scope: {
                bsToast: "="
            },
            link: function(scope, element) {
                function showToastIfNotEmpty() {
                    scope.bsToast && DomUtilsService.displayToast({
                        element: element,
                        message: scope.bsToast
                    }), scope.bsToast = "";
                }
                scope.$watch("bsToast", showToastIfNotEmpty);
            }
        };
    });
}), define("common/js/modules/domUtils/index", [ "./domUtilsModule", "./domUtilsService", "./enterKeyActionDirective", "./viewPortService", "./slideToggleDirective", "./autoFontSizeDirective", "./textDirectionDirective", "./scrollOnDirective", "./backButtonDirective", "./bsWidthLimitDirective", "./focusOnDirective", "./linkableTextDirective", "./scrollToTop", "./paginationDirective", "./touchedClassDirective", "./clicksLockerService", "./bsRightClickDirective", "./stopEventDirective", "./draggableDirective", "./toastDirective" ], function() {}), 
define("common/js/modules/api/apiModule", [ "angular", "../utils/index" ], function(ng) {
    return ng.module("commonModules.api", [ "commonModules.utils" ]);
}), define("common/js/modules/api/apiInterceptor", [ "./apiModule", "angular" ], function(module) {
    module.factory("ApiInterceptor", [ "$q", "$location", "$log", "$rootScope", function($q, $location, $log, $rootScope) {
        function isApiRequest(config) {
            return -1 == config.url.indexOf(GlobalConfig.apiBase) ? !1 : -1 != config.url.split("?")[0].indexOf(".properties") ? !1 : !0;
        }
        return {
            response: function(response) {
                if (isApiRequest(response.config)) {
                    if (response.data && !angular.isObject(response.data)) return $log.warn("Bad resopnse:" + response.data), 
                    response.data = {
                        errorType: "INVALID_RESPONSE",
                        message: "Invalid response from server"
                    }, $q.reject(response);
                    if (response.data && response.data.errorType) {
                        switch ($log.warn("Error while invoking api. " + response.data.message), response.data.errorType) {
                          case "SESSION_ENDED":
                            $rootScope.$broadcast("sessionEnded");
                            break;

                          case "NOT_ALLOWED":
                            $rootScope.$broadcast("notAllowed");
                        }
                        return $q.reject(response);
                    }
                }
                return response;
            }
        };
    } ]);
}), define("common/js/modules/api/apiService", [ "./apiModule" ], function(module) {
    module.factory("ApiService", function($http, $log, SessionInfo) {
        function callApi(param1, param2, param3) {
            return angular.isObject(param1) ? callApiWithOptions(param1) : callApiWithParams(param1, param2, param3);
        }
        function callApiWithParams(api, data, method) {
            return callApiWithOptions({
                api: api,
                method: method,
                data: data
            });
        }
        function callApiWithOptions(options) {
            var method = options.method;
            method || (method = "GET");
            var data = angular.copy(options.data);
            data || (data = {});
            var params = {};
            if ("GET" == method && (params = data, data = null, "object" != typeof params)) return void $log.warn("Bad request: must send object to a get request, but found " + typeof params + " (" + params + ")");
            SessionInfo.sessionId && !options.useCdnCache && (params.sessionId = SessionInfo.sessionId);
            var isOldIe = -1 != navigator.appVersion.indexOf("MSIE"), apiBase = options.useCdnCache && !isOldIe ? GlobalConfig.cachedApiBase : GlobalConfig.apiBase, apiPath = options.api;
            "/" == apiPath.charAt(0) && "/" == apiBase.charAt(apiBase.length - 1) && (apiPath = apiPath.substring(1));
            var url = apiBase + apiPath, request = {
                method: method,
                url: url,
                data: data,
                params: params
            };
            "postForm" == options.method && (request.headers = {
                "Content-Type": "application/x-www-form-urlencoded"
            }, request.method = "POST", request.data = serializeData(request.data));
            var promise = $http(request);
            return promise.success = function(callback) {
                return promise.then(function(response) {
                    callback(response.data);
                }), promise;
            }, promise.error = function(callback) {
                return promise.then(null, function(response) {
                    callback(response.data);
                }), promise;
            }, promise;
        }
        function serializeData(data) {
            if (!angular.isObject(data)) return null == data ? "" : data.toString();
            var buffer = [];
            for (var name in data) if (data.hasOwnProperty(name)) {
                var value = data[name];
                buffer.push(encodeURIComponent(name) + "=" + encodeURIComponent(null == value ? "" : value));
            }
            var source = buffer.join("&").replace(/%20/g, "+");
            return source;
        }
        return {
            callApi: callApi
        };
    });
}), define("common/js/modules/api/cachedApiService", [ "./apiModule" ], function(module) {
    module.factory("CachedApiService", function($q, ApiService, ArraysService) {
        function setEntityApisOptions(entityName, apisMap) {
            mEntityApisOptions[entityName] = apisMap;
        }
        function setEntityApiUrl(entityName, apiName, url) {
            mEntityApisOptions[entityName][apiName] != url && (clearEntitiyCache(entityName), 
            mEntityApisOptions[entityName][apiName] = url);
        }
        function cachedPromiseWrap(cachedData) {
            var promise = {};
            return promise.success = function(fn) {
                return fn(cachedData), promise;
            }, promise.then = function(fn) {
                return fn(cachedData), promise;
            }, promise.error = function(fn) {
                return fn(), promise;
            }, promise;
        }
        function getListName(entityName) {
            return entityName + "List";
        }
        function getCachedEntitiesList(entityName) {
            return mCache[getListName(entityName)];
        }
        function getList(entityName, reload) {
            return reload && clearEntitiyCache(entityName), callCachableApi(getListName(entityName), mEntityApisOptions[entityName].getListUrl);
        }
        function getCachedEntity(entityName, entityId) {
            var list = getCachedEntitiesList(entityName);
            return list ? ArraysService.getById(list, entityId) : null;
        }
        function addHttpPromiseHandlers(deferred) {
            deferred.promise.success = function(fn) {
                deferred._bsData ? fn(deferred._bsData) : deferred._bsSuccessFn = fn;
            }, deferred.promise.then(function(response) {
                deferred._bsSuccessFn ? deferred._bsSuccessFn(response.data) : deferred._bsData = response.data;
            });
        }
        function getEntityFromList(entityName, entityId) {
            var deferred = $q.defer();
            return getList(entityName).then(function() {
                deferred.resolve({
                    data: getCachedEntity(entityName, entityId)
                });
            }), addHttpPromiseHandlers(deferred), deferred.promise;
        }
        function saveEntity(entityName, entity) {
            var promise = ApiService.callApi(mEntityApisOptions[entityName].saveUrl, entity, "post");
            return promise.success(function(updatedEntity) {
                updateCachedEntity(entityName, entity.id, updatedEntity);
            }), promise;
        }
        function updateCachedEntity(entityName, entityId, entity) {
            var list = getCachedEntitiesList(entityName);
            list && (entityId ? angular.copy(entity, getCachedEntity(entityName, entityId)) : list.push(entity));
        }
        function removeEntity(entityName, entityId) {
            var apiOptions = mEntityApisOptions[entityName], removeOptions = {
                api: apiOptions.removeUrl,
                data: {}
            }, idKey = apiOptions.idKey;
            return idKey || (idKey = "id"), removeOptions.data[idKey] = entityId, ApiService.callApi(removeOptions).success(function() {
                removeEntityFromCache(entityName, entityId);
            });
        }
        function removeEntityFromCache(entityName, entityId) {
            var list = getCachedEntitiesList(entityName);
            list && ArraysService.removeById(list, entityId);
        }
        function clearEntitiyCache(entityName) {
            delete mCache[getListName(entityName)];
        }
        function touchEntity(entityName, entityId) {
            var entity = getCachedEntity(entityName, entityId);
            entity && (entity.lastTouch = new Date().getTime());
        }
        function callCachableApi(cacheKey, param1, param2, param3) {
            var data = mCache[cacheKey];
            if (data) return cachedPromiseWrap(data);
            var promise = ApiService.callApi(param1, param2, param3);
            return promise.success(function(response) {
                mCache[cacheKey] = response;
            }), promise;
        }
        var mCache = {}, mEntityApisOptions = {};
        return {
            setEntityApisOptions: setEntityApisOptions,
            setEntityApiUrl: setEntityApiUrl,
            getList: getList,
            clearEntitiyCache: clearEntitiyCache,
            getEntityFromList: getEntityFromList,
            getCachedEntity: getCachedEntity,
            getCachedEntitiesList: getCachedEntitiesList,
            saveEntity: saveEntity,
            updateCachedEntity: updateCachedEntity,
            removeEntity: removeEntity,
            touchEntity: touchEntity,
            callCachableApi: callCachableApi,
            cachedPromiseWrap: cachedPromiseWrap,
            _cache: mCache
        };
    });
}), define("common/js/modules/api/index", [ "./apiInterceptor", "./apiModule", "./apiService", "./cachedApiService" ], function() {}), 
define("common/js/modules/system/systemModule", [ "angular", "../utils/index" ], function(ng) {
    return ng.module("commonModules.system", []);
}), define("common/js/modules/system/localStorageService", [ "./systemModule" ], function(module) {
    module.factory("LocalStorageService", function($rootScope, LogService, StringsService) {
        function init() {
            try {
                localStorage.dummy = "dummy", "dummy" == localStorage.dummy ? (delete localStorage.dummy, 
                storageIsWorking = !0) : storageIsWorking = !1;
            } catch (e) {
                LogService.logError("storage is not working", e), storageIsWorking = !1;
            }
        }
        function storageAllowed() {
            return $rootScope.searchAgentRequest ? !1 : !0;
        }
        function checkStorageEnabled() {
            return storageIsWorking && storageAllowed();
        }
        function storeLocal(key, value) {
            try {
                if (storageIsWorking && storageAllowed()) return localStorage[appKey(key)] = value, 
                !0;
            } catch (e) {}
            return !1;
        }
        function deleteLocal(key) {
            try {
                storageIsWorking && storageAllowed() && delete localStorage[appKey(key)];
            } catch (e) {}
        }
        function appKey(key) {
            return GlobalConfig.appName + "_" + key;
        }
        function loadLocal(key) {
            try {
                if (storageIsWorking && storageAllowed()) {
                    var val = localStorage[appKey(key)];
                    return "undefined" == typeof val && (val = ""), val;
                }
            } catch (e) {}
            return null;
        }
        function storeLocalObject(key, obj) {
            return storeLocal(key, JSON.stringify(obj));
        }
        function loadLocalObject(key) {
            var objStr = loadLocal(key);
            return objStr ? JSON.parse(objStr) : null;
        }
        function clear() {
            try {
                localStorage.clear();
            } catch (e) {}
        }
        function getDebugInfo() {
            var debugInfo = {
                data: {},
                storageAllowed: storageAllowed(),
                storageIsWorking: storageIsWorking
            };
            try {
                for (var i = 0, len = localStorage.length; len > i; i++) {
                    var key = localStorage.key(i);
                    debugInfo.data[key] = StringsService.trimToWord(localStorage[key], 100);
                }
            } catch (e) {
                debugInfo.error = LogService.exceptionMessage(e);
            }
            return debugInfo;
        }
        function clearByPrefix(prefix) {
            var keysToClear = [], prefixOfApp = appKey(prefix);
            try {
                for (var i = 0; i < localStorage.length; i++) 0 == localStorage.key(i).indexOf(prefixOfApp) && keysToClear.push(localStorage.key(i));
                for (var i = 0; i < keysToClear.length; i++) localStorage.removeItem(keysToClear[i]);
            } catch (e) {
                LogService.logError("Failed to clear keys with prefix " + prefix, e);
            }
        }
        var storageIsWorking;
        return init(), {
            isEnabled: checkStorageEnabled,
            load: loadLocal,
            store: storeLocal,
            storeObject: storeLocalObject,
            loadObject: loadLocalObject,
            remove: deleteLocal,
            clear: clear,
            clearByPrefix: clearByPrefix,
            getDebugInfo: getDebugInfo
        };
    });
}), define("common/js/modules/system/cssLoaderService", [ "./systemModule" ], function(module) {
    module.factory("CssLoaderService", function($rootScope, $q, LocalStorageService, PortalMobileUtils, PathsService) {
        function getCssPastLoadInfo() {
            var cssPastLoadInfoStr = LocalStorageService.load("cssPastLoadInfo");
            return cssPastLoadInfoStr ? JSON.parse(cssPastLoadInfoStr) : {
                cacheVersion: GlobalConfig.cssCacheVersion,
                loadVersion: 1,
                status: "init"
            };
        }
        function createCssLinkElement(cssPath) {
            $rootScope.debug("createing theme link " + cssPath);
            var fileref = document.createElement("link");
            fileref.setAttribute("rel", "stylesheet"), fileref.setAttribute("type", "text/css"), 
            fileref.setAttribute("href", cssPath), document.getElementsByTagName("head")[0].appendChild(fileref);
        }
        function createCssStyleElement(content) {
            $rootScope.debug("loaded theme with element. theme size:" + content.length);
            var style = document.createElement("style");
            style.appendChild(document.createTextNode(content)), document.getElementsByTagName("head")[0].appendChild(style);
        }
        function loadCss(cssPath) {
            return mPastLoadInfo = getCssPastLoadInfo(), $rootScope.debug("loading css from:" + cssPath), 
            $rootScope.debug("past load info:" + JSON.stringify(mPastLoadInfo)), mCssLoadStart = new Date().getTime(), 
            GlobalConfig.isMobileApp ? BidspiritLoader.localContentLoaded ? BidspiritLoader.readFile("app/theme." + GlobalConfig.appVersion, function(themeContent) {
                themeContent ? createCssStyleElement(themeContent) : createCssLinkElement(cssPath);
            }, function() {
                createCssLinkElement(cssPath);
            }) : createCssLinkElement(cssPath) : createCssLinkElement(cssPath + "?v=" + GlobalConfig.cssCacheVersion + "&load=" + getCssLoadVersion()), 
            waitForCssLoad(), mDeferred.promise;
        }
        function isCssLoaded() {
            var pagePreLoader = document.getElementById("pagePreLoader");
            if (!pagePreLoader) return !0;
            var preLoaderStyle;
            return preLoaderStyle = angular.isDefined(window.getComputedStyle) ? window.getComputedStyle(pagePreLoader) : pagePreLoader.currentStyle, 
            "hidden" === preLoaderStyle.visibility ? (pagePreLoader.parentElement.removeChild(pagePreLoader), 
            !0) : !1;
        }
        function checkLoadTimeout() {
            if (mEnableLoadRetries) {
                var timeSinceLoadState = new Date().getTime() - mCssLoadStart;
                if (timeSinceLoadState > mPastLoadInfo.loadVersion * CSS_LOAD_INCREMENTS) return mPastLoadInfo.status = "failed", 
                storeLoadInfo(), GlobalConfig.isMobileApp && BidspiritLoader.displayDebugIfDev("Failed to load css"), 
                PathsService.reloadWindow("Css failed to load", 10), !0;
            }
            return !1;
        }
        function waitForCssLoad() {
            isCssLoaded() ? ($rootScope.debug("css loaded."), mPastLoadInfo.status = "success", 
            storeLoadInfo(), mDeferred.resolve(mPastLoadInfo)) : checkLoadTimeout() || setTimeout(waitForCssLoad, 50);
        }
        function getCssLoadVersion() {
            return mPastLoadInfo.cacheVersion == GlobalConfig.cssCacheVersion ? "failed" == mPastLoadInfo.status && mPastLoadInfo.loadVersion++ : (mPastLoadInfo.cacheVersion = GlobalConfig.cssCacheVersion, 
            mPastLoadInfo.loadVersion = 1), mPastLoadInfo.status = "init", storeLoadInfo(), 
            mPastLoadInfo.loadVersion;
        }
        function storeLoadInfo() {
            LocalStorageService.store("cssPastLoadInfo", JSON.stringify(mPastLoadInfo));
        }
        var CSS_LOAD_INCREMENTS = 2e4, mCssLoadStart = null, mEnableLoadRetries = !0, mPastLoadInfo = null, mDeferred = $q.defer();
        return {
            loadCss: loadCss,
            isCssLoaded: isCssLoaded
        };
    });
}), define("common/js/modules/system/settingsService", [ "./systemModule" ], function(module) {
    module.factory("SettingsService", function($rootScope, LocalStorageService) {
        function init(settings) {
            mSettings = settings, $rootScope.env = settings.envName, settings.serverTime ? (mServerTimeGap = new Date().getTime() - settings.serverTime, 
            LocalStorageService.store("lastServerTimeGap", mServerTimeGap)) : mServerTimeGap = LocalStorageService.load("lastServerTimeGap") || 0;
        }
        function getAllSettings() {
            return mSettings;
        }
        function getByKey(key, defaultValue) {
            var val = mSettings[key];
            return null != val ? val : defaultValue;
        }
        function updateSetting(key, val) {
            mSettings[key] = val;
        }
        function getRealServerTimeGap() {
            return mRealServerTimeGap;
        }
        function getServerTimeGap() {
            return mServerTimeGap;
        }
        function getCacheVersion(cacheKey) {
            return mSettings.cacheVersions[cacheKey];
        }
        function timeUntil(time) {
            return time - (new Date().getTime() - mServerTimeGap);
        }
        function timeSince(time) {
            return new Date().getTime() - mServerTimeGap - time;
        }
        function isIgnoredSearchToken(token) {
            if (!mSettings.ignoredSearchPhrases || !token) return !1;
            for (var lowerToken = token.toLowerCase(), i = 0; i < mSettings.ignoredSearchPhrases.length; i++) {
                var phrase = mSettings.ignoredSearchPhrases[i];
                if (-1 != lowerToken.indexOf(phrase) || -1 != phrase.indexOf(lowerToken)) return !0;
            }
            return !1;
        }
        var mSettings = null, mServerTimeGap = null;
        return {
            init: init,
            getAll: getAllSettings,
            get: getByKey,
            update: updateSetting,
            timeUntil: timeUntil,
            timeSince: timeSince,
            isIgnoredSearchToken: isIgnoredSearchToken,
            getCacheVersion: getCacheVersion,
            getServerTimeGap: getServerTimeGap,
            getRealServerTimeGap: getRealServerTimeGap
        };
    });
}), define("common/js/modules/system/sessionsService", [ "./systemModule" ], function(module) {
    module.value("SessionInfo", {}), module.factory("SessionsService", function($location, $rootScope, $cookies, $timeout, ApiService, LogService, AnalyticsService, LocalStorageService, SettingsService, PathsService, SessionInfo, OsInfoService) {
        function getSessionUser() {
            return mSessionUser;
        }
        function setSessionUser(user, remember) {
            mSessionUser = user;
            var oldUser = $rootScope.currentUser;
            $rootScope.currentUser = user, userChanged(oldUser, user) && ($rootScope.$broadcast("auth.newSessionUser"), 
            user && (LogService.logEvent({
                userSession: user.email
            }), AnalyticsService.trackDailyUniqueEvent("authAction", "login", "user login " + user.email), 
            AnalyticsService.trackUserId(user.email), handleDevUsers(user))), user ? (remember ? LocalStorageService.store("persistentSession", "true") : LocalStorageService.remove("persistentSession"), 
            LocalStorageService.store("lastLogin", new Date().getTime()), handleMobileAppVersionUpdate(user)) : LocalStorageService.remove("persistent");
        }
        function userChanged(oldUser, newUser) {
            return !oldUser && newUser ? !0 : oldUser && !newUser ? !0 : oldUser || newUser ? oldUser.id != newUser.id ? !0 : oldUser.email != newUser.email ? !0 : oldUser.registrationStage != newUser.registrationStage ? !0 : !1 : !1;
        }
        function handleDevUsers(user) {
            var email = user.email;
            (-1 != email.indexOf("@bidmood.com") || -1 != email.indexOf("@bidspirit.com") || -1 != email.indexOf("liothedog") || -1 != email.indexOf("alexander.kislevsky")) && LocalStorageService.store("bidspiritEmployee", "true"), 
            -1 != email.indexOf("@bidspirit.com") && "dev" != GlobalConfig.envName && ($rootScope.devMode = !0);
        }
        function handleMobileAppVersionUpdate(user) {
            GlobalConfig.isMobileApp && user.mobileAppVersion != GlobalConfig.appVersion && $timeout(function() {
                user && ApiService.callApi("/users/updateMobileAppVersion", {
                    mobileAppVersion: GlobalConfig.appVersion
                });
            }, 5e3);
        }
        function getRegion() {
            return mClientRegion;
        }
        function setSessionId(sessionId) {
            LocalStorageService.isEnabled() && LocalStorageService.store("sessionId", sessionId), 
            SessionInfo.sessionId = sessionId;
        }
        function loadPreviousSessionId() {
            var sessionId, querySessionId = PathsService.getQueryParam("sessionId");
            if (sessionId = LocalStorageService.load("sessionId"), (querySessionId || "43a48ac7719b49b1af6f7800053d42f3" == sessionId) && (window.location = PathsService.getLocationWithoutParam("sessionId"), 
            LocalStorageService.remove("sessionId"), !$rootScope.searchAgentRequest)) throw new Error("Session id is no longer allowed as paramter.");
            "portal" == GlobalConfig.appName && $cookies.get("initialSessionId") && (sessionId = $cookies.get("initialSessionId")), 
            sessionId && setSessionId(sessionId);
        }
        function setSessionInfo(sessionInfo) {
            setSessionId(sessionInfo.sessionId), OsInfoService.setOsInfo(sessionInfo.osInfo), 
            mClientRegion = sessionInfo.region, -1 == sessionInfo.settings.regions.indexOf(mClientRegion) && (mClientRegion = "ALL"), 
            SettingsService.init(sessionInfo.settings), setSessionUser(sessionInfo.user, hasPersistentSession());
        }
        function hasPersistentSession() {
            return "true" == LocalStorageService.load("persistentSession");
        }
        function init() {
            return loadPreviousSessionId(), ApiService.callApi("/auth/initSession", {
                persistentSession: hasPersistentSession()
            }).success(setSessionInfo);
        }
        function logout() {
            var promise = ApiService.callApi("/auth/logout");
            return promise.success(function() {
                mSessionUser = null;
            }), LogService.logMessage("logout"), promise;
        }
        function refreshCurrentSession() {
            return ApiService.callApi("/auth/getCurrentSessionInfo").success(function(sessionInfo) {
                setSessionInfo(sessionInfo);
            });
        }
        var mSessionUser = null, mClientRegion = null;
        return $rootScope.$on("sessionEnded", function() {
            setSessionUser(null);
        }), {
            init: init,
            loadPreviousSessionId: loadPreviousSessionId,
            getSessionUser: getSessionUser,
            setSessionUser: setSessionUser,
            setSessionInfo: setSessionInfo,
            hasPersistentSession: hasPersistentSession,
            refreshCurrentSession: refreshCurrentSession,
            getRegion: getRegion,
            logout: logout
        };
    });
}), define("common/js/modules/system/osInfoService", [ "./systemModule" ], function(module) {
    module.factory("OsInfoService", function() {
        function isMobile() {
            return GlobalConfig.isMobileApp ? !0 : isIphone() || isIpad() || isAndroid() ? !0 : mOsInfo && mOsInfo.isMobile ? !0 : !1;
        }
        function isIe9() {
            return mOsInfo ? isIe() && parseInt(mOsInfo.version) < 10 : /MSIE\s/.test(navigator.userAgent) && parseFloat(navigator.appVersion.split("MSIE")[1]) < 10;
        }
        function checkUserAgentMatch(textToSearch) {
            return -1 != userAgent.indexOf(textToSearch);
        }
        function isIphone() {
            return checkUserAgentMatch("iphone");
        }
        function isIpad() {
            return checkUserAgentMatch("ipad");
        }
        function isAndroid() {
            return checkUserAgentMatch("android");
        }
        function isIos() {
            return isIphone() || isIpad();
        }
        function isOldIe() {
            return -1 != navigator.appVersion.indexOf("MSIE");
        }
        function isAppSupportedOnPlatform() {
            return isIos() || isAndroid();
        }
        function isIe() {
            return mOsInfo ? "IE" == mOsInfo.browser : void 0;
        }
        function isMobileAppDebug() {
            return GlobalConfig.isMobileApp && (-1 != window.location.href.indexOf("-dev-") || -1 != window.location.href.indexOf("192"));
        }
        function getOsInfo() {
            return mOsInfo;
        }
        function getOsInfoString() {
            return mOsInfo.os + " " + mOsInfo.browser + " " + mOsInfo.version;
        }
        function setOsInfo(osInfo) {
            mOsInfo = osInfo;
        }
        function osName() {
            return isAndroid() ? "android" : isIos() ? "ios" : mOsInfo.os.split(" ")[0];
        }
        function getAndroidVersion(ua) {
            if (!navigator.userAgent) return 0;
            ua = (ua || navigator.userAgent).toLowerCase();
            var match = ua.match(/android\s([0-9\.]*)/);
            return match ? 1 * match[1].split(".")[0] : 0;
        }
        var mOsInfo = null, userAgent = navigator.userAgent ? navigator.userAgent.toLowerCase() : "unknown";
        return {
            isIe9: isIe9,
            isOldIe: isOldIe,
            isIe: isIe,
            isMobile: isMobile,
            isAndroid: isAndroid,
            isIphone: isIphone,
            isIpad: isIpad,
            isIos: isIos,
            isMobileAppDebug: isMobileAppDebug,
            getOsInfo: getOsInfo,
            getOsInfoString: getOsInfoString,
            setOsInfo: setOsInfo,
            getAndroidVersion: getAndroidVersion,
            osName: osName,
            isAppSupportedOnPlatform: isAppSupportedOnPlatform
        };
    });
}), define("common/js/modules/system/index", [ "./systemModule", "./localStorageService", "./cssLoaderService", "./settingsService", "./sessionsService", "./osInfoService" ], function() {}), 
define("common/js/modules/paths/pathsModule", [ "angular" ], function(ng) {
    return ng.module("commonModules.paths", []);
}), define("common/js/modules/paths/pathsService", [ "./pathsModule" ], function(module) {
    module.factory("PathsService", function($rootScope, LogService, $uibModal, $state, $timeout, $transitions, $location, SessionInfo, SettingsService, OsInfoService, LocalStorageService) {
        function templatePath(templateName, pathType) {
            var baseName = "null";
            switch (pathType) {
              case "app":
                baseName = GlobalConfig.appName;
                break;

              case "common":
                baseName = "common";
                break;

              default:
                return LogService.logError("Unknown path type: " + pathType), "";
            }
            return GlobalConfig.templatesBase + baseName + "/templates/" + templateName + ".html?" + GlobalConfig.templatesCacheVersion;
        }
        function commonTemplatePath(templateName) {
            return templatePath(templateName, "common");
        }
        function commonImagePath(imageName) {
            return $rootScope.serverFilesBase + "common/images/" + imageName;
        }
        function appImagePath(imageName) {
            return $rootScope.serverFilesBase + "/" + GlobalConfig.appName + "/images/" + imageName;
        }
        function appTemplatePath(templateName) {
            return templatePath(templateName, "app");
        }
        function state(name, options) {
            var params = options.params || {};
            if (options.optionalParams) {
                for (var i = 0; i < options.optionalParams.length; i++) params[options.optionalParams[i]] = {
                    squash: !0,
                    value: null
                };
                delete options.optionalParams;
            }
            return options.params = params, mStatesProvider = mStatesProvider.state(name, options);
        }
        function childSubviewTemplateState(parentName, childName, template, options) {
            var _options = angular.copy(options);
            _options.views = {}, _options.views["@" + parentName] = {
                templateUrl: appTemplatePath(template)
            }, appTemplateState(parentName + "." + childName, null, _options);
        }
        function appTemplateState(name, template, options) {
            var _options = angular.copy(options);
            _options.templateUrl = appTemplatePath(template), _options.views && delete _options.templateUrl, 
            state(name, _options);
        }
        function appModalState(name, template, options, size) {
            var _options = angular.copy(options), modal = null;
            _options.onEnter = function($uibModal) {
                $rootScope.$stateParams = $state.transition._targetState._params, modal = $uibModal.open({
                    templateUrl: appTemplatePath(template),
                    size: size || "lg",
                    backdrop: "static"
                }).result.finally(angular.noop).then(angular.noop, angular.noop);
            };
            var closeModal = function() {
                modal && (modal.close(), modal = null);
            };
            $rootScope.$on("notAllowed", closeModal), $rootScope.$on("sessionEnded", closeModal), 
            state(name, _options);
        }
        function currentStateSuffix() {
            var stateParts = $state.current.name.split(".");
            return stateParts[stateParts.length - 1];
        }
        function simpleChildStates(parentState, childStates) {
            angular.forEach(childStates, function(childState) {
                state(parentState + "." + childState, {
                    url: "/" + childState
                });
            });
        }
        function formActionPath(path) {
            return GlobalConfig.apiBase + path + "?sessionId=" + SessionInfo.sessionId;
        }
        function downloadAdminResource(path) {
            window.open(formActionPath(path), "_blank");
        }
        function getProxySite(houseCode, proxyType) {
            switch (proxyType) {
              case "FASTLY":
                return "https://bidspirit-" + houseCode + ".global.ssl.fastly.net";

              case "AWS_US_EAST_1":
                return "https://" + houseCode + "-p.bidspirit.com";

              case "ONE_AND_ONE":
                return "https://" + houseCode + "-p1.bidspirit.com";

              case "AWS_EU_CENTRAL_1":
                return "https://" + houseCode + "-p2.bidspirit.com";

              case "AZURE":
                return "https://" + houseCode + "-p3.bidspirit.com";

              default:
                return "https://" + houseCode + ".bidspirit.com";
            }
        }
        function getAppSiteUrl(houseCode, proxyType) {
            return proxyType && "NONE" != proxyType ? getProxySite(houseCode, proxyType) : "dev" == GlobalConfig.envName ? "http://" + houseCode + ".bidspirit.com:8080/systems" : "https://" + houseCode + ".bidspirit.com";
        }
        function getPortalServerName(portalType, region) {
            portalType = (portalType || "").toUpperCase();
            var isCars = "CARS" == portalType, isRealEstate = "REAL_ESTATE" == portalType;
            region = region || $rootScope.currentRegion;
            var serverName, subDomain, regionPart = region ? region.toLowerCase() : "", subDomain = GlobalConfig.envName;
            isCars && (subDomain += "-cars"), isRealEstate && (subDomain += "-houses"), regionPart && "all" != regionPart && (subDomain += "-" + regionPart), 
            "prod" == GlobalConfig.envName && (subDomain = subDomain.replace(/prod\-?/, "")), 
            "il" == regionPart && (isCars || isRealEstate) && (subDomain = subDomain.replace("-il", ""));
            var serverName = "bidspirit.com";
            return subDomain && (serverName = subDomain + "." + serverName), serverName;
        }
        function getPortalUrl(portalType, region) {
            return getPortalBaseAddress(portalType, region) + "portal/";
        }
        function getPortalBaseAddress(portalType, region) {
            var serverName = getPortalServerName(portalType, region);
            return "dev" == GlobalConfig.envName ? "http://" + serverName + ":8080/portal/" : "https://" + serverName + "/";
        }
        function getCurrentPortalBase() {
            return getPortalBaseAddress($rootScope.contentType, $rootScope.region);
        }
        function getAuctionHref(auction) {
            return getUiHref(auction.singleItemIdInApp ? "/lotPage/source/catalog/auction/" + auction.intKey + "/lot/" + auction.singleItemIdInApp + "/" : "/catalog/auction/" + auction.intKey + "/1");
        }
        function getCurrentUiHref() {
            return 0 == window.location.hash.indexOf("#!") ? window.location.hash.split("#!")[1] : -1 != window.location.href.indexOf("/ui/") ? "/" + window.location.href.split("/ui/")[1].split("?")[0] : "home";
        }
        function getUiHref(path) {
            var href = GlobalConfig.devEnv ? "/portal/ui" : "/ui";
            return 0 != path.indexOf("/") && (href += "/"), href += path, $rootScope.currentLang && (href += "?lang=" + $rootScope.currentLang), 
            href;
        }
        function getStaticFilesBase() {
            return GlobalConfig.useAlternateCdn ? "https://dnruccqi30a49.cloudfront.net" : "https://bidspirit-portal-static.global.ssl.fastly.net";
        }
        function getPortalTextsUrl(lang) {
            var textsDomains = "common-portal", textsFilePath = "texts/" + textsDomains + "/" + lang + ".properties", pathBase = OsInfoService.isOldIe() ? GlobalConfig.apiBase : GlobalConfig.cachedApiBase;
            return pathBase + textsFilePath + "?cacheVersion=" + SettingsService.getCacheVersion("TEXTS");
        }
        function getRegionByDomain() {
            var region = getQueryParam("region");
            if (!region) {
                var subdomain = window.location.host.split(".")[0].toLowerCase(), subdomainWithoutEnv = subdomain.replace(/(qa|dev)\-?/, "");
                if ("cars" == subdomainWithoutEnv || "houses" == subdomainWithoutEnv) return "IL";
                var regionDomainPart = subdomainWithoutEnv.replace("cars-", "").replace("houses-", "");
                return regionDomainPart.toUpperCase();
            }
            return region;
        }
        function validateHttps() {
            if (GlobalConfig.isMobileApp) return !0;
            if (GlobalConfig.devEnv || $rootScope.searchAgentRequest || 0 == window.location.host.indexOf("192")) return !0;
            if ("https:" == window.location.protocol && -1 == window.location.hostname.indexOf(".co.") && -1 == window.location.hostname.indexOf("www.")) return !0;
            var newHref = window.location.href.replace("http:", "https:");
            return newHref = newHref.replace("www.", ""), newHref = newHref.replace("bidspirit.co.il", "cars.bidspirit.com"), 
            window.location = newHref, !1;
        }
        function reloadStateAfterDelay(delay) {
            $timeout.cancel(mStateReloadTimer), mStateReloadTimer = $timeout($state.reload, delay);
        }
        function documentUrl(docPath) {
            return DOCUMENTS_BASE + docPath;
        }
        function getQueryParam(param, allowNull) {
            param = param.replace(/[\[]/, "\\[").replace(/[\]]/, "\\]");
            var regexS = "[\\?&]" + param + "=([^&#]*)", regex = new RegExp(regexS), results = regex.exec(window.location.href);
            return null != results && results[1] ? decodeURIComponent(results[1]) : mInitialQueryParams ? mInitialQueryParams[param] : allowNull ? null : "";
        }
        function newLocationWithParam(key, val) {
            if (getQueryParam(key) == val) return window.location.href;
            var newQuery = getQueryStringWithoutKey(key);
            return newQuery += newQuery ? "&" : "?", newQuery += key + "=" + val, getLocationWithQuery(newQuery);
        }
        function getLocationWithoutParam(key) {
            return getLocationWithQuery(getQueryStringWithoutKey(key));
        }
        function getLocationWithoutParams(keys) {
            for (var queryStr = window.location.search, i = 0; i < keys.length; i++) queryStr = getQueryStringWithoutKey(keys[i], queryStr);
            return getLocationWithQuery(queryStr);
        }
        function getLocationWithQuery(query) {
            return window.location.protocol + "//" + window.location.host + window.location.pathname + query + window.location.hash;
        }
        function getQueryStringWithoutKey(key, oldQueryStr) {
            for (var queryStr = oldQueryStr || window.location.search, queryParams = queryStr.split(/\?|\&/), newQueryStr = "", firstParam = !0, i = 1; i < queryParams.length; i++) {
                var queryParamParts = queryParams[i].split("="), queryParamKey = queryParamParts[0], queryParamVal = queryParamParts[1];
                queryParamKey && queryParamKey != key && (newQueryStr += firstParam ? "?" : "&", 
                newQueryStr += queryParamKey + "=" + queryParamVal, firstParam = !1);
            }
            return newQueryStr;
        }
        function addQueryParamToUrl(url, key, val) {
            var hashParts = url.split("#"), url = hashParts[0], separator = -1 == url.indexOf("?") ? "?" : "&";
            return url += separator + key + "=" + val, hashParts.length > 1 && (url += "#" + hashParts[1]), 
            url;
        }
        function reloadWindow(reason, minSecondsSinceLastReload) {
            minSecondsSinceLastReload = minSecondsSinceLastReload || 300;
            var previousReloadsStr = LocalStorageService.load("reloadsHistory") || "[]";
            reloadsHistory = JSON.parse(previousReloadsStr);
            var lastReload = reloadsHistory[0], now = new Date().getTime(), nextReload = now + 1e3;
            lastReload && (secondsSinceLastReload = (now - lastReload.time) / 1e3, minSecondsSinceLastReload > secondsSinceLastReload && (LogService.logError("Delying reloading (" + reason + ") - time since last reload " + secondsSinceLastReload + " is less than " + minSecondsSinceLastReload), 
            nextReload = lastReload.time + 1e3 * minSecondsSinceLastReload)), $timeout.cancel(mWindowReloadTimer), 
            mWindowReloadTimer = $timeout(function() {
                reloadsHistory.unshift({
                    reason: reason,
                    time: now
                }), reloadsHistory = reloadsHistory.slice(0, 10), LocalStorageService.store("reloadsHistory", JSON.stringify(reloadsHistory)), 
                $timeout(function() {
                    window.location.reload();
                }, 1e3);
            }, nextReload - now);
        }
        var BIDSPIRIT_LOGO_PATH = "http://s3.amazonaws.com/bidspirit-portal/images/logo.png", DOCUMENTS_BASE = "https://bidspirit-uploads-1.global.ssl.fastly.net/", mStatesProvider = angular.module("commonModules").$stateProvider, mStateReloadTimer = null, mWindowReloadTimer = null, mInitialQueryParams = $location.search();
        return {
            commonTemplatePath: commonTemplatePath,
            appTemplatePath: appTemplatePath,
            templatePath: templatePath,
            documentUrl: documentUrl,
            commonImagePath: commonImagePath,
            appImagePath: appImagePath,
            formActionPath: formActionPath,
            downloadAdminResource: downloadAdminResource,
            state: state,
            appTemplateState: appTemplateState,
            appModalState: appModalState,
            simpleChildStates: simpleChildStates,
            childSubviewTemplateState: childSubviewTemplateState,
            currentStateSuffix: currentStateSuffix,
            getQueryParam: getQueryParam,
            newLocationWithParam: newLocationWithParam,
            getLocationWithoutParam: getLocationWithoutParam,
            getLocationWithoutParams: getLocationWithoutParams,
            getQueryStringWithoutKey: getQueryStringWithoutKey,
            addQueryParamToUrl: addQueryParamToUrl,
            validateHttps: validateHttps,
            getAppSiteUrl: getAppSiteUrl,
            getPortalTextsUrl: getPortalTextsUrl,
            getPortalUrl: getPortalUrl,
            getCurrentPortalBase: getCurrentPortalBase,
            getPortalBaseAddress: getPortalBaseAddress,
            getCurrentUiHref: getCurrentUiHref,
            getUiHref: getUiHref,
            getAuctionHref: getAuctionHref,
            getRegionByDomain: getRegionByDomain,
            reloadStateAfterDelay: reloadStateAfterDelay,
            reloadWindow: reloadWindow,
            getStaticFilesBase: getStaticFilesBase,
            bidspiritLogo: BIDSPIRIT_LOGO_PATH
        };
    });
}), define("common/js/modules/paths/filters", [ "./pathsModule" ], function(module) {
    return module.filter("appTemplate", [ "PathsService", function(PathsService) {
        return function(name) {
            return PathsService.appTemplatePath(name);
        };
    } ]).filter("commonTemplate", [ "PathsService", function(PathsService) {
        return function(name) {
            return PathsService.commonTemplatePath(name);
        };
    } ]).filter("commonImage", [ "PathsService", function(PathsService) {
        return function(name) {
            return PathsService.commonImagePath(name);
        };
    } ]).filter("documentUrl", [ "PathsService", function(PathsService) {
        return function(documentPath) {
            return PathsService.documentUrl(documentPath);
        };
    } ]).filter("portalUrl", [ "PathsService", function(PathsService) {
        return function(contentType, region) {
            return PathsService.getPortalUrl(contentType, region);
        };
    } ]).filter("uiHref", [ "PathsService", function(PathsService) {
        return function(path) {
            return PathsService.getUiHref(path);
        };
    } ]).filter("formActionPath", [ "PathsService", function(PathsService) {
        return function(path) {
            return PathsService.formActionPath(path);
        };
    } ]);
}), define("common/js/modules/paths/index", [ "./pathsModule", "./pathsService", "./filters" ], function() {}), 
define("common/js/modules/i18n/i18nModule", [ "angular" ], function(ng) {
    return ng.module("commonModules.i18n", []);
}), define("common/js/modules/i18n/i18nFilters", [ "./i18nModule" ], function(module) {
    return module.filter("i18n", [ "I18nService", function(I18nService) {
        return function(key, params) {
            return I18nService.getText(key, params);
        };
    } ]).filter("sumInCurrency", [ "I18nService", function(I18nService) {
        return function(text, currency) {
            return I18nService.sumInCurrency(text, currency);
        };
    } ]).filter("i18nWithRegion", [ "I18nService", function(I18nService) {
        return function(key, params) {
            return I18nService.getTextWithRegion(key, params);
        };
    } ]).filter("langField", [ "I18nService", function(I18nService) {
        return function(field, options) {
            return I18nService.getLangField(field, options);
        };
    } ]).filter("valueWithUnits", [ "I18nService", function(I18nService) {
        return function(value, units, house) {
            return I18nService.valueWithUnits(value, units, house);
        };
    } ]).filter("langName", [ "I18nService", "StringsService", function(I18nService, StringsService) {
        return function(langKey, displayLang) {
            return "english" == displayLang ? StringsService.capitalize(I18nService.langEnglishName(langKey)) : I18nService.langNativeName(langKey);
        };
    } ]).filter("houseName", [ "I18nService", function(I18nService) {
        return function(house, options) {
            return I18nService.getHouseName(house, options);
        };
    } ]);
}), define("common/js/modules/i18n/i18nService", [ "./i18nModule" ], function(module) {
    module.factory("I18nService", function($interpolate, $http, $log, $q, $filter, $rootScope, $timeout, $transitions, $location, StringsService, LocalStorageService, PathsService, SettingsService, DateUtilsService, PortalMobileUtils) {
        function addToLog(message) {
            var now = new Date();
            mLog.push("(" + now.getHours() + ":" + now.getMinutes() + ":" + now.getSeconds() + "[" + now.getMilliseconds() + "]) " + message);
        }
        function getDebugInfo() {
            return {
                log: mLog,
                currentLang: mCurrentLang
            };
        }
        function init(reourcePathFn, preferredLang, addToQuery) {
            mResourcePathFn = reourcePathFn;
            var lang;
            return lang = $rootScope.searchAgentRequest ? getLangForSnapshot(preferredLang) : getLangForBrowser(preferredLang), 
            isSupportedLang(lang) || (lang = DEFAULT_LANG), addToQuery && $transitions.onSuccess({}, setLangQuery), 
            setLang(lang);
        }
        function setLangQuery() {
            mCurrentLang && $location.search({
                lang: mCurrentLang
            });
        }
        function getLangForBrowser(preferredLang) {
            var lang = preferredLang || LocalStorageService.load("lastLang") || PathsService.getQueryParam("lang");
            return lang || (lang = SettingsService.get("suggestedLanguage"), "other" == lang && (lang = DEFAULT_LANG)), 
            lang;
        }
        function getLangForSnapshot(preferredLang) {
            var queryLang = PathsService.getQueryParam("lang");
            if (queryLang) return StringsService.trim(queryLang).toLowerCase();
            var region = PathsService.getRegionByDomain();
            return region ? langByRegion(region) : preferredLang || DEFAULT_LANG;
        }
        function setLang(lang) {
            var defered = $q.defer();
            return addToLog("Setting lang " + lang), lang != mCurrentLang ? loadLang(lang).then(function() {
                mCurrentLang = lang, defered.resolve(), $rootScope.$broadcast("i18n.languageChanged");
            }) : (defered.resolve(), $rootScope.$broadcast("i18n.languageChanged")), defered.promise;
        }
        function loadLang(lang) {
            addToLog(lang + ": Loading");
            var promise;
            if (GlobalConfig.isMobileApp) promise = PortalMobileUtils.getTextsLoadPromise(lang); else {
                var url = mResourcePathFn(lang);
                addToLog("Loading from " + url), promise = $http({
                    url: url,
                    cache: !0
                });
            }
            return promise.then(function(texts) {
                try {
                    addToLog(lang + ": Loaded. content length:" + texts.data.length);
                    var entries = texts.data.split(/\n/m);
                    addToLog(lang + ": " + entries.length + " entries found."), setTexts(lang, entries), 
                    addToLog(lang + ": Success");
                } catch (e) {
                    addToLog(lang + ":Exception while parsing lang -  " + e), setTexts(lang, [ "error:failed to parse" ]), 
                    $log.warn(lang + ":Exception while parsing lang -  " + e);
                }
            }, function(error) {
                addToLog(lang + ":Error while loading lang -  " + error);
            }), promise;
        }
        function reloadTextsAfterDelay(delay) {
            $timeout.cancel(mTextReloadTimer);
            var defered = $q.defer();
            return mTextReloadTimer = $timeout(function() {
                loadLang(mCurrentLang).then(function() {
                    $rootScope.$broadcast("i18n.languageChanged");
                }).then(defered.resolve);
            }, delay), defered.promise;
        }
        function setTexts(lang, textLines) {
            for (var textsMap = {}, i = 0; i < textLines.length; i++) addTextLineToMap(textsMap, textLines[i]);
            mTextsMap = textsMap;
        }
        function addTextLineToMap(textsMap, textLine) {
            var seperatorInd = textLine.indexOf("=");
            if (-1 == seperatorInd) StringsService.isBlank(textLine) || $log.warn("I18n: Failed to parse lang resource line:" + textLine); else {
                var key = StringsService.trim(textLine.substr(0, seperatorInd)), val = StringsService.trim(textLine.substr(seperatorInd + 1));
                textsMap[key] = val;
            }
        }
        function getCurrentLang() {
            return mCurrentLang;
        }
        function getSupportedLangs() {
            return mSupportedLangs;
        }
        function isSupportedLang(lang) {
            return -1 != mSupportedLangs.indexOf(lang);
        }
        function searchTextByKey(key, textsMap) {
            textsMap || (textsMap = mTextsMap);
            var text = textsMap[key];
            return text || key == key.toLowerCase() || (text = searchTextByKey(key.toLowerCase(), textsMap)), 
            text;
        }
        function getText(key, params, textsMap) {
            if (!key) return "";
            var text = searchTextByKey(key, textsMap);
            return text ? (params && (translatedParams = {}, angular.forEach(params, function(paramVal, paramKey) {
                translatedParams[paramKey] = "string" == typeof paramVal ? searchTextByKey(paramVal, textsMap) || paramVal : paramVal;
            }), text = $interpolate(text)(translatedParams)), text) : ($log.warn("I18n: Failed to find text for key:" + key), 
            key);
        }
        function getTextWithRegion(key, params, region) {
            if (!region && params && (region = params.region), region || (region = $rootScope.currentRegion), 
            "ALL" == region && searchTextByKey(key + "_global")) return getText(key + "_global", params);
            var regionName = getText("region_" + region), paramsWithRegion = angular.copy(params) || {};
            return paramsWithRegion.region = regionName, paramsWithRegion.country = regionName, 
            getText(key, paramsWithRegion);
        }
        function getDateDisplay(date, time, options, textsMap) {
            if (options.withoutDayOfMonth) return getMonth(date.getMonth(), textsMap) + " " + $filter("date")(date, "yyyy");
            var dateStr = $filter("date")(date, "d.M.yy");
            if (!options.withoutDayOfWeek) {
                var day = getWeekDay(date.getDay(), textsMap);
                6 == date.getDay() && time > "16" && "he" == getCurrentLang() && (day = " "), 
                dateStr = day + ", " + dateStr;
            }
            return time && !options.withoutTime ? dateStr + ", " + time : dateStr;
        }
        function getDurationDisplay(time) {
            function and(str) {
                return getText("and", {
                    text: str
                });
            }
            function timeText(timePart) {
                return " " + getText(timePart);
            }
            var timeDiff = DateUtilsService.parseDuration(SettingsService.timeUntil(time)), timeDisplay = "";
            return timeDiff.days > 0 ? (timeDisplay = timeDiff.days + timeText("days"), timeDiff.hours > 0 && (timeDisplay += " " + and(timeDiff.hours + timeText("hours")))) : timeDiff.hours > 0 ? (timeDisplay = timeDiff.hours + timeText("hours"), 
            timeDiff.minutes > 0 && (timeDisplay += " " + and(timeDiff.minutes + timeText("minutes")))) : timeDisplay = timeDiff.minutes > 0 ? timeDiff.seconds > 45 ? timeDiff.minutes + 1 + timeText("minutes") : timeDiff.seconds > 15 && timeDiff.minutes < 5 ? timeDiff.minutes + timeText("minutes") + " " + and(30 + timeText("seconds")) : timeDiff.minutes + timeText("minutes") : timeDiff.seconds + timeText("seconds"), 
            timeDisplay;
        }
        function getHouseName(house, options) {
            if (!house.details) return "";
            var houseName = getLangField(house.details.name, options);
            if ("full" == options) {
                var fullNameKey = "house_full_name_art";
                return "ART" != house.houseType && (fullNameKey = "CARS_COMPANY" == house.houseType ? "house_full_name_cars_company" : "house_full_name_lawyers"), 
                houseName = houseName.replace(getText(fullNameKey, {
                    house: ""
                }), ""), getText(fullNameKey, {
                    house: houseName
                });
            }
            return "short" == options && (houseName = houseName.replace(/  |  | | | /, "")), 
            houseName;
        }
        function getHouseTermsTitle(house) {
            var textKey = "LAWYERS" == house.houseType ? "law_office_terms" : "house_terms";
            return getText(textKey, {
                house: getHouseName(house, "full")
            });
        }
        function getLangField(field, options) {
            if (!field) return "";
            options || (options = {});
            var fieldInCurrentLang = field[options.lang || getCurrentLang()];
            if (fieldInCurrentLang) return fieldInCurrentLang;
            if (options.currentLangOnly) return "";
            var fieldInDefaultLang = field[DEFAULT_LANG];
            if (fieldInDefaultLang) return fieldInDefaultLang;
            for (var lang in field) {
                var fieldInAnyLang = field[lang];
                if (fieldInAnyLang) return fieldInAnyLang;
            }
            return "";
        }
        function guessLangauge(str) {
            for (var i = 0; i < str.length; i++) {
                var c = str.charAt(i);
                if (c >= "" && "" >= c) return "he";
                if ("" == c || "" == c || "" == c || "" == c || "" == c || "" == c || "" == c) return "es";
                if (c >= "" && "" >= c) return "ru";
                if (c >= "" && "" >= c) return "el";
            }
            return "en";
        }
        function valueWithUnits(number, unit, house) {
            if (!number) return "";
            var formatedValue = StringsService.readableNumber((number + "").replace(/[^\d]/g, ""));
            return formatedValue ? ("cc" == unit && house && "ru" == house.languages[0] && (unit = "litre", 
            formatedValue = StringsService.readableNumber(1 * number / 1e3)), formatedValue + " " + getText("unit_" + unit)) : "";
        }
        function langNativeName(lang) {
            switch (lang) {
              case "en":
                return "English";

              case "ru":
                return "";

              case "he":
                return "";

              case "jp":
                return "";

              case "de":
                return "Deutsch";

              case "es":
                return "Espaol";

              case "pt":
                return "Portugus";

              case "el":
                return "";

              case "ro":
                return "Romn";

              case "zh":
                return "";
            }
        }
        function langEnglishName(lang) {
            switch (lang) {
              case "en":
                return "english";

              case "ru":
                return "russian";

              case "he":
                return "hebrew";

              case "jp":
                return "japanese";

              case "de":
                return "german";

              case "es":
                return "spanish";

              case "pt":
                return "portuguese";

              case "el":
                return "greek";

              case "ro":
                return "romanian";

              case "zh":
                return "chinese";

              default:
                return lang;
            }
        }
        function langByRegion(region) {
            switch (region) {
              case "IL":
                return "he";

              case "RU":
                return "ru";

              case "SA":
                return "es";

              case "RO":
                return "ro";

              default:
                return mCurrentLang || DEFAULT_LANG;
            }
        }
        function setLangByRegion(region) {
            setLang(langByRegion(region));
        }
        function getWeekDay(day, textsMap) {
            var daysArr = getText("week_days", null, textsMap).split(",");
            return StringsService.trim(daysArr[day]);
        }
        function getMonth(month, textsMap) {
            var monthsArr = getText("months", null, textsMap).split(",");
            return StringsService.trim(monthsArr[month]);
        }
        function getPhoneForRegion(phone, region, lang) {
            return "IL" == region && "he" != lang && phone && 0 == phone.indexOf("0") ? "(972) " + phone.substr(1) : phone;
        }
        function sumInCurrency(sum, currency) {
            var sumStr = StringsService.readableNumber(sum);
            switch (currency) {
              case "$":
              case "":
              case "":
              case "":
              case "":
              case "":
                return currency + sumStr;

              case "CHF":
              case "Rs.":
              case "$U":
                return currency + " " + sumStr;

              case "USD":
                return sumStr + " " + currency;

              default:
                return sumStr + currency;
            }
        }
        function isoCurrency(currency) {
            switch (currency) {
              case "$":
                return "USD";

              case "":
                return "ILS";

              case "$U":
                return "UYU";

              case "p":
              case "":
                return "RUB";

              case "":
                return "GBP";

              case "":
                return "EUR";

              case "":
              case "Rs.":
                return "INR";

              default:
                return currency;
            }
        }
        function parseCurrency(priceDisplay, currency) {
            var parsed = 1 * (priceDisplay + "").replace(currency, "").replace(/,|\s/g, "").replace(/\&nbsp\;/g, "");
            return isNaN(parsed) ? null : parsed;
        }
        var DEFAULT_LANG = "en", mCurrentLang = null, mTextsMap = null, mResourcePathFn = null, mTextReloadTimer = null, mSupportedLangs = [ "he", "en", "ru", "es" ], mLog = [];
        return {
            init: init,
            getCurrentLang: getCurrentLang,
            getSupportedLangs: getSupportedLangs,
            setLang: setLang,
            setLangByRegion: setLangByRegion,
            reloadTextsAfterDelay: reloadTextsAfterDelay,
            langNativeName: langNativeName,
            langEnglishName: langEnglishName,
            getPhoneForRegion: getPhoneForRegion,
            getText: getText,
            getTextWithRegion: getTextWithRegion,
            getLangField: getLangField,
            searchTextByKey: searchTextByKey,
            getHouseName: getHouseName,
            getHouseTermsTitle: getHouseTermsTitle,
            getWeekDay: getWeekDay,
            getMonth: getMonth,
            getDateDisplay: getDateDisplay,
            getDurationDisplay: getDurationDisplay,
            getDebugInfo: getDebugInfo,
            guessLangauge: guessLangauge,
            valueWithUnits: valueWithUnits,
            sumInCurrency: sumInCurrency,
            parseCurrency: parseCurrency,
            isoCurrency: isoCurrency,
            DEFAULT_LANG: DEFAULT_LANG
        };
    });
}), define("common/js/modules/i18n/i18nContentWithLinks", [ "./i18nModule" ], function(module) {
    module.directive("i18nContentWithLinks", function($compile, $rootScope, I18nService) {
        return {
            restrict: "E",
            replace: !0,
            link: function(scope, element, attrs) {
                function parseMap(jsonStr) {
                    return jsonStr ? eval("(function(){return " + jsonStr + ";})()") : null;
                }
                function setHtml() {
                    var params = parseMap(attrs.params), linksActions = parseMap(attrs.linksActions), text = I18nService.getText(attrs.key, params);
                    for (key in linksActions) text = text.replace("<a " + key, "<a ng-click=" + linksActions[key]);
                    element.html(text), $compile(element.contents())(scope);
                }
                setHtml();
            }
        };
    });
}), define("common/js/modules/i18n/currentLangDirective", [ "./i18nModule" ], function(module) {
    module.directive("bsCurrentLang", function($rootScope, I18nService) {
        return {
            restrict: "A",
            link: function(scope, element) {
                function setLang() {
                    element.removeClass(currentLang), currentLang = I18nService.getCurrentLang(), element.addClass(currentLang);
                }
                var currentLang = null;
                scope.$on("i18n.languageChanged", setLang), setLang();
            }
        };
    });
}), define("common/js/modules/i18n/index", [ "./i18nModule", "./i18nFilters", "./i18nService", "./i18nContentWithLinks", "./currentLangDirective" ], function() {}), 
define("common/js/modules/dialogs/dialogsModule", [ "angular", "../utils/index" ], function(ng) {
    return ng.module("commonModules.dialogs", [ "commonModules.utils" ]);
}), define("common/js/modules/dialogs/dialogsService", [ "./dialogsModule", "../paths/index" ], function(module) {
    module.factory("DialogsService", function($uibModal, PathsService, I18nService) {
        function showAlert(dataOrMessage) {
            return angular.isString(dataOrMessage) ? showAlertWithMessage(dataOrMessage) : showAlertWithData(dataOrMessage);
        }
        function showAlertWithMessage(message) {
            return showAlertWithData({
                message: message
            });
        }
        function showAlertWithData(data) {
            return newModalWindow({
                templateName: "alert",
                data: data
            });
        }
        function showConfirm(dataOrMessage) {
            return angular.isString(dataOrMessage) ? showConfirmWithMessage(dataOrMessage) : showConfirmWithData(dataOrMessage);
        }
        function showConfirmWithMessage(message) {
            return showConfirmWithData({
                message: message
            });
        }
        function showConfirmWithData(data) {
            return newModalWindow({
                templateName: "confirm",
                data: data
            });
        }
        function showImage(imageName, imagePath) {
            return newModalWindow({
                templateName: "image",
                data: {
                    imageName: imageName,
                    imagePath: imagePath
                },
                size: "lg"
            });
        }
        function newModalWindow(options) {
            var message;
            return options.data.message && (message = options.data.message, message.match("^[a-z_]+$") && (message = I18nService.getText(message, options.data.params))), 
            $uibModal.open({
                templateUrl: PathsService.commonTemplatePath("dialogs/" + options.templateName),
                controller: "DialogController",
                size: options.size,
                resolve: {
                    dialogData: function() {
                        return angular.extend({}, options.data, {
                            message: message
                        });
                    }
                }
            }).result;
        }
        return {
            showAlert: showAlert,
            showConfirm: showConfirm,
            showImage: showImage
        };
    });
}), define("common/js/modules/dialogs/dialogController", [ "./dialogsModule" ], function(module) {
    module.controller("DialogController", [ "$scope", "$uibModalInstance", "dialogData", function($scope, $uibModalInstance, dialogData) {
        $scope.dialogData = dialogData, $scope.close = function() {
            $uibModalInstance.close(!1);
        }, $scope.ok = function() {
            $uibModalInstance.close(!0);
        };
    } ]);
}), define("common/js/modules/dialogs/bsScopeAlertDirective", [ "./dialogsModule" ], function(module) {
    module.directive("bsScopeAlert", function($animate, PathsService) {
        return {
            restrict: "E",
            replace: !0,
            templateUrl: PathsService.commonTemplatePath("dialogs/scopeAlert"),
            controller: function($scope) {
                $scope.alert = {
                    message: null,
                    type: null
                }, $scope.hideScopeAlert = function() {
                    $scope.alert.message = null;
                }, $scope.showScopeAlert = function(message, type) {
                    $scope.alert = {
                        message: message,
                        type: type || "info"
                    };
                };
            }
        };
    });
}), define("common/js/modules/dialogs/index", [ "./dialogsModule", "./dialogsService", "./dialogController", "./bsScopeAlertDirective" ], function() {}), 
define("common/js/modules/asyncButton/asyncButtonModule", [ "angular", "../utils/index" ], function(ng) {
    return ng.module("commonModules.asyncButton", [ "commonModules.utils" ]);
}), define("common/js/modules/asyncButton/asyncButtonDirective", [ "./asyncButtonModule" ], function(module) {
    module.directive("bsAsyncButton", function($log, PathsService, AsyncButtonService) {
        return {
            restrict: "E",
            transclude: !0,
            replace: !0,
            scope: {
                actionFn: "&",
                bsFormController: "=",
                name: "=",
                buttonClass: "=",
                label: "="
            },
            link: function(scope, elm, attrs) {
                function handleActionResult(result) {
                    result && result.then ? result.then(handleActionResult, unlock) : unlock();
                }
                function lock() {
                    scope.locked = !0;
                }
                function unlock() {
                    scope.locked = !1;
                }
                scope.locked = !1, scope.executeAction = function() {
                    scope.locked || (attrs.actionFn ? (lock(), scope.$on("bsFormSuccess", unlock), handleActionResult(scope.actionFn())) : scope.bsFormController ? (lock(), 
                    scope.$on("bsFormSuccess", unlock), scope.$on("bsFormError", unlock), scope.bsFormController.submit() || unlock()) : ($log.warn("Nothing to do with async button"), 
                    $log.warn(scope)));
                }, AsyncButtonService.register(scope);
            },
            templateUrl: PathsService.commonTemplatePath("forms/asyncButton")
        };
    });
}), define("common/js/modules/asyncButton/asyncButtonService", [ "./asyncButtonModule" ], function(module) {
    module.factory("AsyncButtonService", function($log, $q) {
        function register(buttonScope) {
            buttonScope.name && (mButtonsRegistery[buttonScope.name] = buttonScope);
        }
        function invokeButton(asyncButtonName) {
            var buttonScope = mButtonsRegistery[asyncButtonName];
            buttonScope ? buttonScope.executeAction() : $log.warn("Trying to invoke an unknown async button " + asyncButtonName);
        }
        function fakeSuccess(asyncButtonName) {
            var buttonScope = mButtonsRegistery[asyncButtonName];
            return buttonScope.$broadcast("bsFormSuccess"), $q.defer().promise;
        }
        var mButtonsRegistery = {};
        return {
            register: register,
            invokeButton: invokeButton,
            fakeSuccess: fakeSuccess
        };
    });
}), define("common/js/modules/asyncButton/index", [ "./asyncButtonModule", "./asyncButtonDirective", "./asyncButtonService" ], function() {}), 
define("common/js/modules/bsForm/bsFormModule", [ "angular" ], function(ng) {
    return ng.module("commonModules.bsForm", []);
}), define("common/js/modules/bsForm/bsFormDirective", [ "./bsFormModule" ], function(module) {
    module.directive("bsForm", function($parse, $log, PathsService, FormConstants) {
        return {
            restrict: "A",
            replace: !0,
            require: [ "form" ],
            link: function(scope, element, attributes, controllers) {
                function updateFieldsAttentions() {
                    mFormController && !mFormController.$valid && angular.forEach(mInputsControllers, function(inputController, inputName) {
                        checkInputAttention(inputName);
                    }), scope.$$phase || scope.$digest(), angular.forEach(getSubForms(), function(subForm) {
                        subForm.updateFieldsAttentions();
                    });
                }
                function getSubForms() {
                    var subForms = [], subFormsElements = element.find("ng-form");
                    if (mFormController) for (var i = 0; i < subFormsElements.length; i++) {
                        var subFormController = mFormController[subFormsElements[i].attributes.name.value];
                        subFormController && subForms.push(subFormController);
                    }
                    return subForms;
                }
                function bindSumbit() {
                    mFormController.submit = submitForm;
                }
                function submitForm() {
                    return setTimeout(updateFieldsAttentions, 200), mFormController.$valid ? (scope.submitCall(scope).then(function() {
                        scope.$broadcast("bsFormSuccess", {
                            formName: mFormController.$name
                        });
                    }, function() {
                        scope.$broadcast("bsFormError", {
                            formName: mFormController.$name
                        });
                    }), !0) : (scope.$broadcast("bsFormError", {
                        formName: mFormController.$name
                    }), scope.$$phase || scope.$digest(), !1);
                }
                function checkInputAttention(inputName) {
                    var inputController = mInputsControllers[inputName];
                    return inputController.$valid ? inputController.attentionTouch = null : ($log.info("input " + inputName + " is invalid. (" + JSON.stringify(inputController.$error) + ")"), 
                    inputController.attentionTouch = new Date().getTime()), inputController.attentionTouch;
                }
                function removeAttentionIfValid(inputName) {
                    var inputController = mInputsControllers[inputName];
                    if (inputController.attentionTouch) {
                        if (inputController.$valid) return inputController.attentionTouch = null, !0;
                        inputController.attentionTouch = new Date().getTime();
                    }
                    return !1;
                }
                function setInputBehaviour(input) {
                    var inputName = input.attr("name");
                    input.bind("blur", function() {
                        checkInputAttention(inputName), setTimeout(function() {
                            scope.$digest();
                        });
                    }), angular.forEach([ "keyup", "change" ], function(eventKey) {
                        input.bind(eventKey, function() {
                            removeAttentionIfValid(inputName) && scope.$digest();
                        });
                    });
                }
                function addInputController(input) {
                    var inputName = input.attr("name");
                    if (inputName && scope.formController[inputName]) {
                        var inputController = scope.formController[inputName];
                        mInputsControllers[inputName] = inputController, function(_input) {
                            setInputBehaviour(_input);
                        }(input);
                    }
                }
                function initInputControllers() {
                    angular.forEach([ "input", "select", "textarea" ], function(tagName) {
                        for (var inputs = element.find(tagName), i = 0; i < inputs.length; i++) addInputController(angular.element(inputs[i]));
                    }), mFormController.updateFieldsAttentions = updateFieldsAttentions, mFormController.bsFormFirstErrorMessage = scope.bsFormFirstErrorMessage;
                }
                function initAction() {
                    element.attr("action") || element.attr("action", "javascript:null");
                }
                function initButtons() {
                    angular.forEach(element.find("button"), function(button) {
                        var buttonElement = angular.element(button);
                        buttonElement.attr("type") || buttonElement.attr("type", "button");
                    });
                }
                function init() {
                    mFormController = scope.formController, initAction(), initButtons(), bindSumbit(), 
                    initInputControllers();
                }
                scope.formController = controllers[0], scope.submitCall = $parse(attributes.bsSubmit), 
                scope.bsValidationPatterns = FormConstants.validationPatterns;
                var mFormController = null, mInputsControllers = {};
                scope.bsFormFirstErrorMessage = function() {
                    for (inputName in mInputsControllers) {
                        var inputController = mInputsControllers[inputName], errorMessage = inputController.errorMessage;
                        if (inputController.attentionTouch && errorMessage) return errorMessage;
                    }
                    for (var subForms = getSubForms(), i = 0; i < subForms.length; i++) {
                        var subFormError = subForms[i].bsFormFirstErrorMessage();
                        if (subFormError) return subFormError;
                    }
                    return null;
                }, setTimeout(function() {
                    init();
                }, 100);
            }
        };
    });
}), define("common/js/modules/bsForm/bsCheckListDirective", [ "./bsFormModule" ], function(module) {
    module.directive("bsChecklistModel", function($parse, $compile) {
        function contains(arr, item) {
            if (angular.isArray(arr)) for (var i = 0; i < arr.length; i++) if (angular.equals(arr[i], item)) return !0;
            return !1;
        }
        function add(arr, item) {
            arr = angular.isArray(arr) ? arr : [];
            for (var i = 0; i < arr.length; i++) if (angular.equals(arr[i], item)) return arr;
            return arr.push(item), arr;
        }
        function remove(arr, item) {
            if (angular.isArray(arr)) for (var i = 0; i < arr.length; i++) if (angular.equals(arr[i], item)) {
                arr.splice(i, 1);
                break;
            }
            return arr;
        }
        function postLinkFn(scope, elem, attrs) {
            $compile(elem)(scope);
            var getter = $parse(attrs.bsChecklistModel), setter = getter.assign, value = $parse(attrs.checklistValue)(scope.$parent);
            "true" == elem.parent().attr("check-on-click") && elem.parent().bind("click", function(e) {
                "INPUT" != e.target.tagName && (scope.checked = !scope.checked);
            }), scope.$watch("checked", function(newValue, oldValue) {
                if (newValue !== oldValue) {
                    var current = getter(scope.$parent);
                    newValue === !0 ? setter(scope.$parent, add(current, value)) : setter(scope.$parent, remove(current, value));
                }
            }), scope.$parent.$watch(attrs.bsChecklistModel, function(newArr) {
                scope.checked = contains(newArr, value);
            }, !0);
        }
        return {
            restrict: "A",
            priority: 1e3,
            terminal: !0,
            scope: !0,
            compile: function(tElement, tAttrs) {
                if ("INPUT" !== tElement[0].tagName || !tElement.attr("type", "checkbox")) throw 'bs-checklist-model should be applied to `input[type="checkbox"]`.';
                if (!tAttrs.checklistValue) throw "You should provide `checklist-value`.";
                return tElement.removeAttr("bs-checklist-model"), tElement.attr("ng-model", "checked"), 
                postLinkFn;
            }
        };
    });
}), define("common/js/modules/bsForm/bsDateFieldDirective", [ "./bsFormModule" ], function(module) {
    module.directive("bsDateField", function() {
        return {
            restrict: "A",
            replace: !0,
            require: "ngModel",
            link: function(scope, elem, attr, ngModel) {
            }
        };
    });
}), define("common/js/modules/bsForm/bsFormValidationMessage", [ "./bsFormModule" ], function(module) {
    module.directive("bsFormValidationMessage", function($rootScope, I18nService) {
        return mDefaultValidationMessages = {
            required: "error_mandatory",
            minlength: "error_bad_pattern",
            pattern: "error_bad_pattern",
            email: "error_bad_email"
        }, {
            restrict: "E",
            require: [ "^form", "^bsFormGroup" ],
            replace: !0,
            template: '<div class="help-block {{helpCssClass}}"></div>',
            link: function($scope, el, attrs, controllers) {
                function checkErrors() {
                    var html = "", field = formController[fieldName];
                    if (debug("chcking " + fieldName), debug(field), field && field.attentionTouch) {
                        debug(field), field.errorMessage = null;
                        var errors = field.$error;
                        for (var error in errors) if (errors.hasOwnProperty(error) && errors[error]) {
                            var errorCode = attrs[error];
                            errorCode || (errorCode = mDefaultValidationMessages[error]), field.errorMessage = I18nService.getText(errorCode, {
                                field: fieldLabel
                            }), errorCode && !attrs.hidden && (html = "<span>" + field.errorMessage + "</span>");
                        }
                    }
                    el.html(html);
                }
                function debug() {
                    attrs.debug;
                }
                var formController = controllers[0], formGroupController = controllers[1];
                debug(formGroupController), debug(formController);
                var formName = formController.$name, fieldLabel = attrs.fieldLabel;
                fieldLabel || (fieldLabel = formGroupController.fieldLabel);
                var fieldName = formGroupController.fieldName;
                $scope[formName] = formController, $scope.helpCssClass = attrs.cssClass, $scope.$watch(formName + "." + fieldName + ".attentionTouch", function(attentionTouch) {
                    el.css("display", attentionTouch ? "" : "none"), checkErrors();
                });
            }
        };
    });
}), define("common/js/modules/bsForm/bsFormGroupDirective", [ "./bsFormModule" ], function(module) {
    module.directive("bsFormGroup", function($rootScope, I18nService, DomUtilsService, PathsService) {
        return {
            restrict: "EA",
            require: "^form",
            replace: !0,
            transclude: !0,
            scope: {
                label: "@",
                fieldName: "@",
                cssClass: "@"
            },
            templateUrl: PathsService.commonTemplatePath("forms/formGroup"),
            link: function(scope, element, attrs, formController) {
                function setLabel() {
                    scope.label && element.find("label").html(I18nService.getText(scope.label));
                }
                function debug() {
                    attrs.debug;
                }
                var formName = formController.$name;
                if (formName) {
                    scope[formName] = formController;
                    var watchExpression = formName + "." + scope.fieldName + ".attentionTouch";
                    scope.$watch(watchExpression, function(attentionTouch) {
                        if (attentionTouch) {
                            debug("attention!");
                            var field = scope[formName][scope.fieldName], hasError = !1, errors = field.$error;
                            for (var error in errors) if (errors.hasOwnProperty(error) && errors[error]) {
                                hasError = !0;
                                break;
                            }
                            hasError ? element.addClass("has-error") : element.removeClass("has-error");
                        } else element.removeClass("has-error");
                    }), setLabel();
                }
            },
            controller: function($scope) {
                this.fieldLabel = $scope.label, this.fieldName = $scope.fieldName;
            }
        };
    });
}), define("common/js/modules/bsForm/bsPlaceHolderDirective", [ "./bsFormModule" ], function(module) {
    module.directive("bsPlaceHolder", function(I18nService, OsInfoService) {
        return {
            restrict: "A",
            require: [ "ngModel", "^bsFormGroup" ],
            priority: 1,
            link: function(scope, elem, attrs, controllers) {
                function handleFocused(focused) {
                    elem.val() || !setDirection || focused ? !focused || "email" != elem.attr("type") && "password" != elem.attr("type") || (elem.attr("dir", "ltr"), 
                    setDirection = !0) : (elem.removeAttr("dir"), setDirection = !1), focused ? elem.attr("placeholder", "") : elem.attr("placeholder", text);
                }
                function setValue(val) {
                    val ? (elem.removeClass(emptyClassName), elem.val(val), is_pwd && hidePasswordPlaceholder()) : (elem.addClass(emptyClassName), 
                    is_pwd ? showPasswordPlaceholder() : elem.val(text));
                }
                function setupPasswordPlaceholder() {
                    clone = angular.element("<input/>").attr(angular.extend(extractAttributes(domElem), {
                        type: "text",
                        value: text,
                        placeholder: "",
                        id: "",
                        name: ""
                    })).addClass(emptyClassName).addClass("ng-hide").bind("focus", function() {
                        hidePasswordPlaceholder(), domElem.focus();
                    }), domElem.parentNode.insertBefore(clone[0], domElem);
                }
                function showPasswordPlaceholder() {
                    elem.addClass("ng-hide"), clone.removeClass("ng-hide");
                }
                function hidePasswordPlaceholder() {
                    clone.addClass("ng-hide"), elem.removeClass("ng-hide");
                }
                function extractAttributes(element) {
                    for (var attr = element.attributes, copy = {}, skip = /^jQuery\d+/, i = 0; i < attr.length; i++) attr[i].specified && !skip.test(attr[i].name) && (copy[attr[i].name] = attr[i].value);
                    return copy;
                }
                var clone, ngModel = controllers[0], bsFormGroup = controllers[1], orig_val = elem.val() || "", is_pwd = "password" === attrs.type, emptyClassName = "empty", domElem = elem[0], textKey = attrs.bsPlaceHolder;
                if (textKey || (textKey = bsFormGroup.fieldLabel), textKey) {
                    handleFocused(!1);
                    var text = I18nService.getText(textKey);
                    if (OsInfoService.isIe9()) {
                        is_pwd && setupPasswordPlaceholder(), setValue(orig_val), ngModel.$setViewValue(orig_val);
                        var setDirection = !1;
                        elem.bind("focus", function() {
                            handleFocused(!0), elem.hasClass(emptyClassName) && (elem.val(""), elem.removeClass(emptyClassName), 
                            elem.removeClass("error"));
                        }), elem.bind("blur", function() {
                            handleFocused(!1);
                            var val = elem.val();
                            scope.$apply(function() {
                                setValue(val), ngModel.$setViewValue(val);
                            });
                        }), ngModel.$render = function() {
                            setValue(ngModel.$viewValue);
                        };
                    } else elem.attr("placeholder", text), elem.bind("focus", function() {
                        handleFocused(!0);
                    }), elem.bind("blur", function() {
                        handleFocused(!1);
                    });
                }
            }
        };
    });
}), define("common/js/modules/bsForm/bsBlinkOnFormErrorDirective", [ "./bsFormModule" ], function(module) {
    module.directive("bsBlinkOnFormError", function($timeout) {
        return {
            restrict: "A",
            require: "^form",
            link: function(scope, element, attrs, formController) {
                function setBlinkOn(isOn, millis) {
                    $timeout(function() {
                        isOn ? element.addClass("blink") : element.removeClass("blink");
                    }, millis);
                }
                var formName = formController.$name;
                scope[formName] = formController;
                var firstTime = !0;
                scope.$on("bsFormError", function() {
                    var delayBefroeFirstBlink = 0;
                    firstTime && (delayBefroeFirstBlink = 1500, firstTime = !1), setBlinkOn(!0, delayBefroeFirstBlink), 
                    setBlinkOn(!1, delayBefroeFirstBlink + 2e3);
                });
            }
        };
    });
}), define("common/js/modules/bsForm/formConstants", [ "./bsFormModule" ], function(module) {
    module.factory("FormConstants", function() {
        return {
            validationPatterns: {
                alpha: /^[^0-9\\`\\~\\!\\@\\#\\$\\%\\^\\&\\*\\(\\)\\-\\=\\\\_\\+]*$/,
                nonHebrew: /^[^-]*$/,
                phone: /^[0-9\(\)\.\-\ \\\-\+]*$/,
                email: /^\S+@\S+\.\S+$/
            }
        };
    });
}), define("common/js/modules/bsForm/bsCheckboxDirective", [ "./bsFormModule" ], function(module) {
    module.directive("bsCheckbox", function() {
        return {
            restrict: "E",
            replace: !0,
            scope: {
                bsModel: "="
            },
            link: function(scope) {
                scope.toggleChecked = function() {
                    scope.bsModel = !scope.bsModel;
                };
            },
            template: '<div class="bs-checkbox" ng-class="{checked:bsModel}" ng-click="toggleChecked()">&nbsp;</div>'
        };
    });
}), define("common/js/modules/bsForm/bsMonthPickerDirective", [ "./bsFormModule" ], function(module) {
    module.directive("bsMonthPicker", function(PathsService, $filter) {
        return {
            restrict: "E",
            replace: !0,
            scope: {
                bsModel: "=",
                onChange: "&",
                label: "@"
            },
            link: function(scope) {
                scope.data = {
                    selectedDate: null
                }, scope.$watch("selectedDate", function(newValue, oldValue) {
                    newValue != oldValue && (scope.bsModel = $filter("date")(scope.selectedDate, "yyyy-MM"), 
                    scope.onChange && scope.onChange());
                }), scope.$watch("bsModel", function(newValue, oldValue) {
                    newValue != oldValue && scope.bsModel && (scope.selectedDate = new Date(scope.bsModel));
                });
            },
            templateUrl: PathsService.commonTemplatePath("forms/monthPicker")
        };
    });
}), define("common/js/modules/bsForm/index", [ "./bsFormModule", "./bsFormDirective", "./bsCheckListDirective", "./bsDateFieldDirective", "./bsFormValidationMessage", "./bsFormGroupDirective", "./bsPlaceHolderDirective", "./bsBlinkOnFormErrorDirective", "./formConstants", "./bsCheckboxDirective", "./bsMonthPickerDirective" ], function() {}), 
define("common/js/modules/validate/validateModule", [ "angular" ], function(ng) {
    return ng.module("commonModules.validate", []);
}), define("common/js/modules/validate/validateDirective", [ "./validateModule" ], function(module) {
    module.directive("bsValidate", function() {
        return {
            restrict: "A",
            require: "ngModel",
            link: function(scope, elm, attrs, ctrl) {
                function apply_watch(watch) {
                    return angular.isString(watch) ? void scope.$watchCollection(watch, function() {
                        angular.forEach(validators, function(validatorFn) {
                            validatorFn(ctrl.$modelValue);
                        });
                    }) : angular.isArray(watch) ? void angular.forEach(watch, function(expression) {
                        scope.$watch(expression, function() {
                            angular.forEach(validators, function(validatorFn) {
                                validatorFn(ctrl.$modelValue);
                            });
                        });
                    }) : void (angular.isObject(watch) && angular.forEach(watch, function(expression, validatorKey) {
                        angular.isString(expression) && scope.$watch(expression, function() {
                            validators[validatorKey](ctrl.$modelValue);
                        }), angular.isArray(expression) && angular.forEach(expression, function(intExpression) {
                            scope.$watch(intExpression, function() {
                                validators[validatorKey](ctrl.$modelValue);
                            });
                        });
                    }));
                }
                var validateFn, validators = {}, validateExpr = scope.$eval(attrs.bsValidate);
                validateExpr && (angular.isString(validateExpr) && (validateExpr = {
                    validator: validateExpr
                }), angular.forEach(validateExpr, function(exprssn, key) {
                    validateFn = function(valueToValidate) {
                        var expression = scope.$eval(exprssn, {
                            $value: valueToValidate
                        });
                        return angular.isObject(expression) && angular.isFunction(expression.then) ? (expression.then(function() {
                            ctrl.$setValidity(key, !0);
                        }, function() {
                            ctrl.$setValidity(key, !1);
                        }), valueToValidate) : expression ? (ctrl.$setValidity(key, !0), valueToValidate) : (ctrl.$setValidity(key, !1), 
                        valueToValidate);
                    }, validators[key] = validateFn, ctrl.$formatters.push(validateFn), ctrl.$parsers.push(validateFn);
                }), attrs.bsValidateWatch && apply_watch(scope.$eval(attrs.bsValidateWatch)));
            }
        };
    });
}), define("common/js/modules/validate/index", [ "./validateModule", "./validateDirective" ], function() {}), 
define("common/js/modules/animations/animationsModule", [ "angular" ], function(ng) {
    return ng.module("commonModules.animations", []);
}), define("common/js/modules/animations/markDirective", [ "./animationsModule" ], function(module) {
    module.directive("bsMark", function($animate) {
        return function(scope, elem, attributes) {
            scope.$watch(attributes.bsMark, function(newValue, oldValue) {
                if (newValue != oldValue) {
                    var cssClass = "mark-animation";
                    setTimeout(function() {
                        $animate.addClass(elem, cssClass, function() {
                            $animate.removeClass(elem, cssClass);
                        });
                    }, 300);
                }
            });
        };
    });
}), define("common/js/modules/animations/index", [ "./animationsModule", "./markDirective" ], function() {}), 
define("common/js/modules/cloudinary/cloudinaryModule", [ "angular" ], function(ng) {
    return ng.module("commonModules.cloudinary", []);
}), define("common/js/modules/cloudinary/cloudinaryService", [ "./cloudinaryModule" ], function(module) {
    module.factory("CloudinaryService", function() {
        function getSizePart(sizePart, extactSize) {
            if (-1 != sizePart.indexOf(".")) return sizePart;
            var sizePartInt = 1 * sizePart;
            return extactSize ? sizePartInt : 100 >= sizePartInt ? 100 : 400 >= sizePartInt ? 400 : 1e3;
        }
        function parseParams(params) {
            var commandParts = [];
            if (params) {
                if (params.size) {
                    commandParts.push("q_80");
                    var sizeParts = params.size.split("x"), sizeCommand = "";
                    sizeParts[0] && (sizeCommand = "w_" + getSizePart(sizeParts[0], params.exactSize)), 
                    sizeParts[1] && (sizeCommand += (sizeCommand ? "," : "") + "h_" + getSizePart(sizeParts[1], params.exactSize)), 
                    commandParts.push(sizeCommand), commandParts.push(params.mode ? "c_" + params.mode : "c_limit");
                }
                params.effect && commandParts.push("e_" + params.effect);
            }
            return commandParts.toString();
        }
        function getUrl(path, params) {
            if (!path) return null;
            var url = BASE_URL + parseParams(params) + "/" + path;
            return params && params.quality && (url += ".jpg"), url;
        }
        function jsonParamsToUrlParams(params) {
            var url = "";
            for (param in params) -1 == param.indexOf("$$") && (url += "," + param + "_" + params[param]);
            return url;
        }
        function stripBase(imageUrl) {
            return imageUrl.split(/\/v\d+\//)[1];
        }
        function getCollageUrl(imageUrls, collageSettings) {
            if (0 == imageUrls.length) return null;
            for (var result = "", i = 0; i < collageSettings.length && i < imageUrls.length; i++) {
                if (i > 0) {
                    result += "/l_";
                    var imageUrl = imageUrls[i];
                    imageUrl && (result += stripBase(imageUrl) + ",");
                }
                result += "g_north_west,c_fill" + jsonParamsToUrlParams(collageSettings[i]);
            }
            return imageUrls[0] && (result += "/" + stripBase(imageUrls[0])), BASE_URL + result;
        }
        return BASE_URL = "https://bidspirit-cloudinary.global.ssl.fastly.net/bidspirit/image/upload/", 
        ALTERNATE_BASE_URL = "https://d363j9ul48wcb3.cloudfront.net/bidspirit/image/upload/", 
        {
            getUrl: getUrl,
            parseParams: parseParams,
            getCollageUrl: getCollageUrl,
            BASE_URL: BASE_URL
        };
    });
}), define("common/js/modules/cloudinary/cloudinaryFilter", [ "./cloudinaryModule" ], function(module) {
    return module.filter("cloudinary", [ "CloudinaryService", function(CloudinaryService) {
        return function(path, params) {
            if (!path) return null;
            var url = CloudinaryService.getUrl(path, params);
            return params && params.asBg ? "background-image:url(" + url + ")" : url;
        };
    } ]);
}), define("common/js/modules/cloudinary/cloudinaryBgDirective", [ "./cloudinaryModule" ], function(module) {
    module.directive("bsCloudinaryBg", function(CloudinaryService) {
        return {
            restrict: "A",
            scope: {
                path: "@bsCloudinaryBg",
                params: "="
            },
            link: function(scope, element) {
                function setUrl() {
                    var url = CloudinaryService.getUrl(scope.path, scope.params);
                    url ? element.css("background-image", "url(" + url + ")") : element.css("background-image", "");
                }
                setUrl(), scope.$watch("path", setUrl);
            }
        };
    });
}), define("common/js/modules/cloudinary/index", [ "./cloudinaryModule", "./cloudinaryService", "./cloudinaryFilter", "./cloudinaryBgDirective" ], function() {}), 
define("common/js/modules/socialPlugins/socialPluginsModule", [ "angular" ], function(ng) {
    return ng.module("commonModules.socialPlugins", []);
}), define("common/js/modules/socialPlugins/facebookService", [ "./socialPluginsModule" ], function(module) {
    module.factory("FacbookService", function($q) {
        function loadFb(deferred) {
            window.fbAsyncInit = function() {
                FB.init({
                    appId: "542961752415314",
                    xfbml: !0,
                    version: "v3.1"
                }), mInitialized = !0, deferred.resolve();
            }, function(d, s, id) {
                var js, fjs = d.getElementsByTagName(s)[0];
                d.getElementById(id) || (js = d.createElement(s), js.id = id, js.src = "//connect.facebook.net/en_US/" + (DEBUG_MODE ? "sdk/debug.js" : "sdk.js"), 
                fjs.parentNode.insertBefore(js, fjs));
            }(document, "script", "facebook-jssdk");
        }
        function validateInitialized() {
            var deferred = $q.defer();
            return mInitialized ? deferred.resolve() : loadFb(deferred), deferred.promise;
        }
        function ensureLoggedIn() {
            var deferred = $q.defer();
            return validateInitialized().then(function() {
                FB.getLoginStatus(function(response) {
                    "connected" == response.status ? deferred.resolve(response) : FB.login(function(response) {
                        deferred.resolve(response);
                    }, {
                        scope: "publish_actions,publish_pages,manage_pages "
                    });
                });
            }), deferred.promise.then(function(response) {
                mCurrentUserFbId = response.authResponse.userID;
            }), deferred.promise;
        }
        function getPageData(pageId) {
            var deferred = $q.defer();
            return FB.api(mCurrentUserFbId + "/accounts", function(response) {
                for (var i = 0; i < response.data.length; i++) {
                    var pageData = response.data[i];
                    if (pageData.id == pageId) return void deferred.resolve(pageData);
                }
                console.warn("Faild to get page data for page id " + pageId), deferred.reject();
            }), deferred.promise;
        }
        function callPostToFeedApi(pageId, accessToken, message, link) {
            var deferred = $q.defer();
            return FB.api("/" + pageId + "/feed", "POST", {
                access_token: accessToken,
                message: message,
                link: link
            }, function(response) {
                deferred.resolve(response);
            }), deferred.promise;
        }
        function postTextToFeed(pageId, message, link) {
            var deferred = $q.defer();
            return ensureLoggedIn().then(function() {
                getPageData(pageId).then(function(pageData) {
                    callPostToFeedApi(pageId, pageData.access_token, message, link).then(function(response) {
                        deferred.resolve(response);
                    });
                });
            }), deferred.promise;
        }
        var mInitialized = !1, DEBUG_MODE = !1, mCurrentUserFbId = null;
        return {
            postTextToFeed: postTextToFeed
        };
    });
}), define("common/js/modules/socialPlugins/index", [ "./socialPluginsModule", "./facebookService" ], function() {}), 
define("common/js/modules/log/logModule", [ "angular" ], function(ng) {
    return ng.module("commonModules.log", []);
}), function(root, factory) {
    "function" == typeof define && define.amd ? define("common/js/lib/logEntries", [ root ], factory) : "object" == typeof exports ? module.exports = factory(root) : root.LE = factory(root);
}(this, function(window) {
    function LogStream(options) {
        var _traceCode = (Math.random() + Math.PI).toString(36).substring(2, 10), _doTrace = options.trace, _pageInfo = options.page_info, _token = options.token, _print = options.print, _endpoint = "js.logentries.com/v1", _shouldCall = !0, _SSL = function() {
            return "undefined" == typeof XDomainRequest ? options.ssl : "https:" === location.protocol ? !0 : !1;
        }(), _backlog = [], _active = !1, _sentPageInfo = !1;
        if (options.catchall) {
            var oldHandler = window.onerror, newHandler = function(msg, url, line) {
                return _rawLog({
                    error: msg,
                    line: line,
                    location: url
                }).level("ERROR").send(), oldHandler ? oldHandler(msg, url, line) : !1;
            };
            window.onerror = newHandler;
        }
        var _agentInfo = function() {
            var nav = window.navigator || {
                doNotTrack: void 0
            }, screen = window.screen || {}, _location = window.location || {};
            return {
                url: _location.pathname,
                referrer: document.referrer,
                screen: {
                    width: screen.width,
                    height: screen.height
                },
                window: {
                    width: window.innerWidth,
                    height: window.innerHeight
                },
                browser: {
                    name: nav.appName,
                    version: nav.appVersion,
                    cookie_enabled: nav.cookieEnabled,
                    do_not_track: nav.doNotTrack
                },
                platform: nav.platform
            };
        }, _getEvent = function() {
            var raw = null, args = Array.prototype.slice.call(arguments);
            if (0 === args.length) throw new Error("No arguments!");
            return raw = 1 === args.length ? args[0] : args;
        }, _rawLog = function() {
            var event = _getEvent.apply(this, arguments), data = {
                event: event
            };
            return "never" !== _pageInfo && (_sentPageInfo && "per-entry" !== _pageInfo || (_sentPageInfo = !0, 
            "undefined" == typeof event.screen && "undefined" == typeof event.browser && _rawLog(_agentInfo()).level("PAGE").send())), 
            _doTrace && (data.trace = _traceCode), {
                level: function(l) {
                    if (_print && "undefined" != typeof console && "PAGE" !== l) try {
                        console[l.toLowerCase()].call(console, data);
                    } catch (ex) {}
                    return data.level = l, {
                        send: function() {
                            var cache = [], serialized = JSON.stringify(data, function(key, value) {
                                var _indexOf = function(array, obj) {
                                    for (var i = 0; i < array.length; i++) if (obj === array[i]) return i;
                                    return -1;
                                };
                                if ("undefined" == typeof value) return "undefined";
                                if ("object" == typeof value && null !== value) {
                                    if (-1 !== _indexOf(cache, value)) return "<?>";
                                    cache.push(value);
                                }
                                return value;
                            });
                            _active ? _backlog.push(serialized) : _apiCall(_token, serialized);
                        }
                    };
                }
            };
        };
        this.log = _rawLog;
        var _apiCall = function(token, data) {
            _active = !0;
            var _getAjaxObject = function() {
                return "undefined" != typeof XDomainRequest ? new XDomainRequest() : new XMLHttpRequest();
            }, request = _getAjaxObject();
            if (_shouldCall) {
                request.constructor === XMLHttpRequest ? request.onreadystatechange = function() {
                    4 === request.readyState && (request.status >= 400 ? (console.error("Couldn't submit events."), 
                    410 === request.status && console.warn("This version of le_js is no longer supported!")) : (301 === request.status && console.warn("This version of le_js is deprecated! Consider upgrading."), 
                    _backlog.length > 0 ? _apiCall(token, _backlog.shift()) : _active = !1));
                } : request.onload = function() {
                    _backlog.length > 0 ? _apiCall(token, _backlog.shift()) : _active = !1;
                };
                var uri = (_SSL ? "https://" : "http://") + _endpoint + "/logs/" + _token;
                request.open("POST", uri, !0), request.constructor === XMLHttpRequest, request.send(data);
            }
        };
    }
    function Logger(options) {
        var logger, dict = {
            ssl: !0,
            catchall: !1,
            trace: !0,
            page_info: "never",
            print: !1,
            token: null
        };
        if ("object" != typeof options) throw new Error("Invalid parameters for createLogStream()");
        for (var k in options) dict[k] = options[k];
        if (null === dict.token) throw new Error("Token not present.");
        logger = new LogStream(dict);
        var _log = function() {
            if (logger) return logger.log.apply(this, arguments);
            throw new Error("You must call LE.init(...) first.");
        };
        return {
            log: function() {
                _log.apply(this, arguments).level("LOG").send();
            },
            warn: function() {
                _log.apply(this, arguments).level("WARN").send();
            },
            error: function() {
                _log.apply(this, arguments).level("ERROR").send();
            },
            info: function() {
                _log.apply(this, arguments).level("INFO").send();
            }
        };
    }
    var loggers = {}, _getLogger = function(name) {
        if (!loggers.hasOwnProperty(name)) throw new Error("Invalid name for logStream");
        return loggers[name];
    }, _createLogStream = function(options) {
        if ("string" != typeof options.name) throw new Error("Name not present.");
        if (loggers.hasOwnProperty(options.name)) throw new Error("Alrready exist this name for a logStream");
        return loggers[options.name] = new Logger(options), !0;
    }, _deprecatedInit = function(options) {
        var dict = {
            name: "default"
        };
        if ("object" == typeof options) for (var k in options) dict[k] = options[k]; else {
            if ("string" != typeof options) throw new Error("Invalid parameters for init()");
            dict.token = options;
        }
        return _createLogStream(dict);
    }, _destroyLogStream = function(name) {
        "undefined" == typeof name && (name = "default"), delete loggers[name];
    };
    return {
        init: _deprecatedInit,
        createLogStream: _createLogStream,
        to: _getLogger,
        destroy: _destroyLogStream,
        log: function() {
            for (var k in loggers) loggers[k].log.apply(this, arguments);
        },
        warn: function() {
            for (var k in loggers) loggers[k].warn.apply(this, arguments);
        },
        error: function() {
            for (var k in loggers) loggers[k].error.apply(this, arguments);
        },
        info: function() {
            for (var k in loggers) loggers[k].info.apply(this, arguments);
        }
    };
}), define("common/js/modules/log/logService", [ "./logModule", "common/js/lib/logEntries" ], function(module, LE) {
    module.factory("LogService", function($rootScope, $log, SessionInfo, OsInfoService) {
        function init(token) {
            if (!$rootScope.searchAgentRequest) {
                if (!token) return void consoleWarn("initializing log without token!");
                LE.init({
                    token: token,
                    ssl: !0
                }), mInitialized = !0, window.onerror = handleError;
            }
        }
        function logEvent(event) {
            if (mInitialized) {
                var message = "";
                if ("object" == typeof event) for (var key in event) message += "	" + key + ":" + event[key]; else message = event;
                logMessage(message);
            }
        }
        function logMessage(message) {
            if (mInitialized) try {
                var text = SessionInfo.sessionId;
                $rootScope.currentUser && (text += "	" + $rootScope.currentUser.email), text += "	" + message, 
                LE.log(text), addToLogHistory(text);
            } catch (e) {
                consoleWarn("error while logging message " + message, e);
            }
        }
        function isImportantErrorMessage(message) {
            return message ? "Script error." == message || "Script error" == message ? !1 : -1 != (message + "").indexOf("b.responseText") ? !1 : -1 != (message + "").indexOf("retrieveJsMessages") ? !1 : !0 : !1;
        }
        function handleError(msg, url, line) {
            var message = msg + " Url: " + url + " Line: " + line;
            GlobalConfig.devMode && GlobalConfig.isMobileApp && alert(message);
            try {
                message += "Stack: " + new Error().stack;
            } catch (e) {}
            return $rootScope.debug("error:" + message), printTrace(), (isImportantErrorMessage(msg) || line > 1) && logError(message), 
            GlobalConfig.devEnv ? !1 : !0;
        }
        function printTrace() {
            try {
                console.trace();
            } catch (e) {}
        }
        function exceptionMessage(e) {
            var message = e.message;
            return message || (message = JSON.stringify(e)), e.stack && (message += " | stack: " + e.stack), 
            message;
        }
        function secondsSinceStart() {
            return Math.round((new Date().getTime() - GlobalConfig.pageLoadTime) / 1e3);
        }
        function consoleWarn(message) {
            window.console && window.console.warn(message);
        }
        function logError(errorStr, e) {
            try {
                if (-1 != navigator.userAgent.indexOf("Googlebot")) return;
                var errorToLog = window.location.href + " " + OsInfoService.getOsInfoString() + " " + errorStr;
                GlobalConfig.isMobileApp && (errorToLog = "MOBILE APP " + errorToLog), e && (errorToLog += " " + exceptionMessage(e)), 
                consoleWarn(errorToLog), errorToLog = "(" + secondsSinceStart() + ") " + errorToLog, 
                5 > mLoggedErrors && (mLoggedErrors++, logEvent({
                    eventType: "jsError",
                    message: errorToLog
                })), addToErrorsHistory(errorStr);
            } catch (e1) {
                consoleWarn("failed to log message: " + exceptionMessage(e1)), printTrace();
            }
        }
        function addToErrorsHistory(message) {
            if (window.localStorage) {
                var errorHistory = JSON.parse(localStorage.errorHistory || "[]");
                errorHistory.push(new Date() + " " + message), errorHistory.length > 20 && errorHistory.shift(), 
                localStorage.errorHistory = JSON.stringify(errorHistory);
            }
        }
        function addToLogHistory(message) {
            if (window.localStorage) try {
                var logHistory = JSON.parse(localStorage.logHistory || "[]");
                logHistory.push((new Date() + " " + message).substr(0, 200)), logHistory.length > 20 && logHistory.shift(), 
                localStorage.logHistory = JSON.stringify(logHistory);
            } catch (e) {
                consoleWarn("Failed to add message " + message + " to log history.");
            }
        }
        function initRootScopeDebug() {
            GlobalConfig.debugInfo = {
                lastDebugTime: GlobalConfig.pageLoadTime,
                count: 0
            }, $rootScope.debugMessage = "", $rootScope.debug = function(msg) {
                var now = new Date();
                $rootScope.debugMessage += "\n<Br> (" + now.getHours() + ":" + now.getMinutes() + ":" + now.getSeconds() + "[" + now.getMilliseconds() + "]) " + msg, 
                GlobalConfig.debugInfo.lastDebugTime = now.getTime(), GlobalConfig.isMobileApp && BidspiritLoader.addDebugInfo(msg);
            }, $rootScope.debug("debug init"), GlobalConfig.isMobileApp && ($rootScope.debugMessage += BidspiritLoader.mDebugInfo);
        }
        function getDebugInfo() {
            return {
                errorHistory: JSON.parse(localStorage.errorHistory || "[]"),
                logHistory: JSON.parse(localStorage.logHistory || "[]")
            };
        }
        function test() {}
        var mInitialized = !1, mLoggedErrors = 0;
        return initRootScopeDebug(), {
            logEvent: logEvent,
            logMessage: logMessage,
            exceptionMessage: exceptionMessage,
            logError: logError,
            init: init,
            test: test,
            getDebugInfo: getDebugInfo
        };
    });
}), define("common/js/modules/log/bsLogClickDirective", [ "./logModule" ], function(module) {
    module.directive("bsLogClick", function(LogService) {
        return {
            restrict: "A",
            link: function(scope, elem, attributes) {
                elem.bind("click", function() {
                    LogService.logEvent({
                        click: attributes.bsLogClick
                    });
                });
            }
        };
    });
}), define("common/js/modules/log/analyticsService", [ "./logModule" ], function(module) {
    module.factory("AnalyticsService", function($http, PathsService, ApiService, Analytics, LogService, LocalStorageService, SessionInfo, StringsService) {
        function trackEvent(category, action, label, options) {
            if (new Date().getTime() - GlobalConfig.pageLoadTime > TRACKED_EVENTS_DELAY) {
                var key = category + "_" + action + "_" + label;
                try {
                    if (options) {
                        if (!LocalStorageService.isEnabled()) return;
                        var analyticsInfo = LocalStorageService.load("analyticsInfo");
                        if (analyticsInfo) try {
                            analyticsInfo = JSON.parse(analyticsInfo);
                        } catch (e) {
                            LogService.logError("failed to parse analyticsInfo " + StringsService.trimToWord(analyticsInfo, 300)), 
                            analyticsInfo = {};
                        } else analyticsInfo = {};
                        var infoForKey = analyticsInfo[key];
                        if (options.dailyUnique && infoForKey && isEntryFromToDay(infoForKey)) return;
                        cleanOldAnalyticsEntries(analyticsInfo), analyticsInfo[key] = {
                            time: new Date().getTime()
                        }, LocalStorageService.store("analyticsInfo", JSON.stringify(analyticsInfo)), options.appSiteTrackInfo && trackAppSiteEvent(options.appSiteTrackInfo);
                    }
                    if (GlobalConfig.isMobileApp && window.analytics) window.analytics.trackEvent(category, action, label); else {
                        if (mIsBidspiritEmployee) return;
                        Analytics.trackEvent(category, action, label);
                    }
                } catch (e) {
                    LogService.logError("failed to log event in analytics " + key + "," + JSON.stringify(options), e);
                }
            } else mDelayedTrackedEvent.push({
                category: category,
                action: action,
                label: label,
                options: options
            });
        }
        function cleanOldAnalyticsEntries(analyticsInfo) {
            for (key in analyticsInfo) {
                var entry = analyticsInfo[key];
                entry && entry.time && isEntryFromToDay(entry) || delete analyticsInfo[key];
            }
        }
        function isEntryFromToDay(analyticsInfoEntry) {
            return new Date().getTime() - analyticsInfoEntry.time < 864e5;
        }
        function trackDailyUniqueEvent(category, action, label) {
            trackEvent(category, action, label, {
                dailyUnique: !0
            });
        }
        function trackUserId(userId) {
            Analytics.set("userId", userId);
        }
        function trackAppSiteEvent(appSiteTrackInfo) {
            var house = appSiteTrackInfo.house;
            if (house && house.hostingServerName) {
                var apiPath = PathsService.getAppSiteUrl(house.code) + "/api/" + appSiteTrackInfo.api + "?localId=" + SessionInfo.sessionId, params = appSiteTrackInfo.params;
                if (params) for (param in params) apiPath += "&" + param + "=" + params[param];
                $http.get(apiPath);
            }
        }
        function trackDailyUniqueAuctionEvent(auction, eventCategoy, eventName) {
            auction && auction.house && (trackDailyUniqueEvent(eventCategoy, eventName + "InHouse", "house:" + auction.house.code), 
            trackDailyUniqueEvent(eventCategoy, eventName + "InAuction", "house:" + auction.house.code + ", auction:" + auction.date + " " + auction.time));
        }
        function saveLotView(lotId) {
            ApiService.callApi("/stats/saveLotView", {
                lotId: lotId
            });
        }
        function trackPage(page) {
            clearTimeout(mPageTrackDelay), mPageTrackDelay = setTimeout(function() {
                if (GlobalConfig.isMobileApp && window.analytics) window.analytics.trackView(page); else {
                    if (mIsBidspiritEmployee) return;
                    Analytics.trackPage(page);
                }
                window.fbq && window.fbq("track", "PageView");
            }, 1e3);
        }
        function traceDelayedEvents() {
            for (var i = 0; i < mDelayedTrackedEvent.length; i++) {
                var event = mDelayedTrackedEvent[i];
                trackEvent(event.category, event.action, event.label, event.options);
            }
        }
        function loadFacebookPixel() {
            var pixelId = "498166040569160";
            !function(f, b, e, v, n, t, s) {
                f.fbq || (n = f.fbq = function() {
                    n.callMethod ? n.callMethod.apply(n, arguments) : n.queue.push(arguments);
                }, f._fbq || (f._fbq = n), n.push = n, n.loaded = !0, n.version = "2.0", n.queue = [], 
                t = b.createElement(e), t.async = !0, t.src = v, s = b.getElementsByTagName(e)[0], 
                s.parentNode.insertBefore(t, s));
            }(window, document, "script", "https://connect.facebook.net/en_US/fbevents.js"), 
            fbq("init", pixelId), window.fbq("track", "PageView");
        }
        function init() {
            loadFacebookPixel(), setTimeout(traceDelayedEvents, TRACKED_EVENTS_DELAY + 200);
        }
        TRACKED_EVENTS_DELAY = GlobalConfig.devEnv ? 0 : 3e4;
        var mDelayedTrackedEvent = [], mIsBidspiritEmployee = "true" == LocalStorageService.load("bidspiritEmployee"), mPageTrackDelay = null;
        return {
            trackEvent: trackEvent,
            trackDailyUniqueEvent: trackDailyUniqueEvent,
            trackDailyUniqueAuctionEvent: trackDailyUniqueAuctionEvent,
            trackPage: trackPage,
            trackUserId: trackUserId,
            saveLotView: saveLotView,
            init: init
        };
    });
}), define("common/js/modules/log/index", [ "./logModule", "./logService", "./bsLogClickDirective", "./analyticsService" ], function() {}), 
define("common/js/modules/mobileApp/mobileAppModule", [ "angular" ], function(ng) {
    return ng.module("commonModules.mobileApp", []);
}), define("common/js/modules/mobileApp/puffinService", [ "./mobileAppModule" ], function(module) {
    module.factory("PuffinService", function() {
        function tryToLaunchWithPuffin(url) {
            var openNormally = function() {
                window.open(url, "_system");
            }, openWithProtocol = function(protocol) {
                window.open(url.replace("https", protocol), "_system");
            }, openWithPuffin = function() {
                openWithProtocol("puffin");
            }, openWithPuffinFree = function() {
                openWithProtocol("puffin");
            };
            "undefined" == typeof device ? openNormally() : checkPuffinExists(openWithPuffin, function() {
                checkPuffinFreeExists(openWithPuffinFree, openNormally);
            });
        }
        function checkSchemeExists(iosScheme, androidSceme, onFound, onNotFound) {
            var scheme = null;
            "undefined" != typeof device && ("iOS" === device.platform ? scheme = iosScheme : "Android" === device.platform && (scheme = androidSceme)), 
            scheme && "undefined" != typeof appAvailability ? appAvailability.check(scheme, onFound, onNotFound) : onNotFound();
        }
        function checkPuffinExists(onFound, onNotFound) {
            return checkSchemeExists("puffin://", "com.cloudmosa.puffin", onFound, onNotFound);
        }
        function checkPuffinFreeExists(onFound, onNotFound) {
            return checkSchemeExists("puffinFree://", "com.cloudmosa.puffinFree", onFound, onNotFound);
        }
        return {
            tryToLaunchWithPuffin: tryToLaunchWithPuffin
        };
    });
}), define("common/js/modules/mobileApp/portalMobileUtils", [ "./mobileAppModule" ], function(module) {
    module.factory("PortalMobileUtils", function($rootScope, $http, $q, SettingsService, LocalStorageService, PathsService) {
        function displayFailure(message) {
            $rootScope.debug("Error:" + message), BidspiritLoader.addErrorInfo(message), BidspiritLoader.displayDebugIfDev();
        }
        function addToDebug(message) {
            $rootScope.debug(message);
        }
        function storeLocalTexts(lang) {
            var textsVersion = SettingsService.getAll().cacheVersions.TEXTS, deferred = $q.defer(), fileName = getLocalTextFileName(lang, textsVersion), url = PathsService.getPortalTextsUrl(lang);
            return addToDebug("loading lang from url " + url), $http({
                url: url,
                cache: !1
            }).then(function(textsData) {
                BidspiritLoader.writeToFile(fileName, textsData.data, function() {
                    addToDebug("stored at " + fileName), deferred.resolve();
                }, function(error) {
                    deferred.reject("failed to save file " + fileName + "," + JSON.stringify(error));
                });
            }, function(e) {
                deferred.reject("failed to load updated texts. " + JSON.stringify(e));
            }), deferred.promise;
        }
        function updateLocalTextsInAllLangs(newTextsVersion) {
            addToDebug("updating texts to " + newTextsVersion);
            var langs = SettingsService.get("languages"), deferred = $q.defer();
            return BidspiritLoader.getDirectoryEntry("localTexts", function() {
                for (var promises = [], i = 0; i < langs.length; i++) promises.push(storeLocalTexts(langs[i], newTextsVersion));
                return $q.all(promises).then(function() {
                    removeOldLocalTexts(newTextsVersion), deferred.resolve();
                }, function(error) {
                    displayFailure("error while storing local texts:" + error), deferred.reject();
                });
            }, function() {
                displayFailure("failed to get local text directory"), deferred.reject();
            }), deferred.promise;
        }
        function removeOldLocalTexts(currentTextsVersion) {
            BidspiritLoader.getDirectoryEntry("localTexts", function(directoryEntry) {
                removeDirectoryFilesOfDiffrentVersion(directoryEntry, currentTextsVersion);
            });
        }
        function getLocalTextFileName(lang, version) {
            return "localTexts/" + lang + "." + version + ".properties";
        }
        function getTextsLoadPromise(lang) {

		function loadDefaultTexts(){
				addToDebug("Loading default texts from "+appDefaultPath);
				
				$http({url:appDefaultPath, cache:true}).then(function(response){
					var texts = response.data;
					addToDebug("loaded. firstLine "+texts[0]);
					deferred.resolve({data:texts});
				});
			}	



            var appDefaultPath = "texts/texts." + lang + ".properties", textsVersion = SettingsService.getAll().cacheVersions.TEXTS, deferred = $q.defer();
            return BidspiritLoader.readFile(getLocalTextFileName(lang, textsVersion), function(loadedTexts) {
                null != loadedTexts ? (addToDebug("loaded local texts for " + textsVersion + " in lang " + lang + ". data length:" + loadedTexts.length), 
                loadedTexts.length > 1e4 ? (GlobalConfig.loadedTextsVersion = textsVersion, deferred.resolve({
                    data: loadedTexts
                })) : (displayFailure("Text file probably corrupted... Texts too short (" + loadedTexts.length + "), using default"), 
                removeOldLocalTexts("none"), loadDefaultTexts())) : (displayFailure("local texts not found, using default "), 
                loadDefaultTexts());
            }, function() {
                displayFailure("failed to read local texts, using default "), loadDefaultTexts();
            }), deferred.promise;
        }
        function handleUpdateFailure(message) {
            displayFailure(message), BidspiritLoader.reset(), updateFailCounter = LocalStorageService.load("updateFailCounter") || 0, 
            LocalStorageService.store("updateFailCounter", 1 * updateFailCounter + 1);
        }
        function removeDirectoryFilesOfDiffrentVersion(dirEntry, version) {
            var deferred = $q.defer();
            return addToDebug("removing files directory " + dirEntry.name + " with version different than " + version), 
            dirEntry.createReader().readEntries(function(entries) {
                for (var removePromises = [], i = 0; i < entries.length; i++) {
                    var entry = entries[i], isOfNewVersion = -1 != entry.name.indexOf("." + version);
                    isOfNewVersion || !function(_entry) {
                        var removeDefered = $q.defer();
                        addToDebug("removing " + _entry.name), entry.remove(function() {
                            addToDebug("removed " + _entry.name), removeDefered.resolve();
                        }, function() {
                            removeDefered.reject("failed to removed " + _entry.name);
                        }), removePromises.push(removeDefered.promise);
                    }(entry);
                }
                $q.all(removePromises).then(function() {
                    deferred.resolve();
                }, function(error) {
                    deferred.reject(error);
                });
            }, function() {
                addToDebug("remove old version files - failed to read entries for entry " + dirEntry.name), 
                deferred.reject();
            }), deferred.promise;
        }
        function updateBidspiritDataAndTheme(appVersion) {
            addToDebug("updating version to " + appVersion);
            var contentUrl, styleUrl;
            if (GlobalConfig.devMode) {
                var portalBase = PathsService.getCurrentPortalBase();
                contentUrl = portalBase + "debug/all.debug.js?v=" + appVersion, styleUrl = portalBase + "/portal/styles/style.css?v=" + appVersion;
            } else {
                var serverFilesBase = SettingsService.get("serverFilesBase");
                addToDebug("serverFilesBase:" + serverFilesBase), contentUrl = "https:" + serverFilesBase + "/portal/js/all.js?v=" + appVersion, 
                styleUrl = "https:" + serverFilesBase + "/portal/styles/style.css?v=" + appVersion;
            }
            addToDebug("loading theme from url:" + styleUrl), $http.get(styleUrl).then(function(response) {
                var themeData = response.data;
                addToDebug("got theme " + themeData.length + " ..." + themeData.substr(themeData.length - 100)), 
                themeData.length > 1e5 && themeData.match("}$") ? (addToDebug("storing theme..."), 
                BidspiritLoader.writeToFile("app/theme." + appVersion, themeData, function() {
                    addToDebug("getting content from url " + contentUrl), $http.get(contentUrl).then(function(response) {
                        var data = response.data;
                        addToDebug("got data of length" + data.length + ", ..." + data.substr(data.length - 100)), 
                        data.length > 1e5 ? BidspiritLoader.writeToFile("app/content." + appVersion, data + ";\nBidspiritLoader.localContentLoaded=true;", function() {
                            addToDebug("content saved"), BidspiritLoader.getDirectoryEntry("app", function(baseDir) {
                                removeDirectoryFilesOfDiffrentVersion(baseDir, appVersion).then(function() {
                                    BidspiritLoader.writeToFile("app/data", GlobalConfig.mobileAppVersion + "," + appVersion + "," + GlobalConfig.envName, function() {
                                        addToDebug("data file saved"), LocalStorageService.store("updateFailCounter", 0), 
                                        GlobalConfig.devMode && alert("update data done. reloading..."), PathsService.reloadWindow("new mobile app version");
                                    }, function() {
                                        handleUpdateFailure("failed to write versions data");
                                    });
                                }, function() {
                                    handleUpdateFailure("failed to clear old file");
                                });
                            }, function() {
                                handleUpdateFailure("failed to write content");
                            });
                        }, function() {
                            handleUpdateFailure("failed to write content");
                        }) : handleUpdateFailure("bad content. length:" + data.length + ", ..." + data.substr(data.length - 100));
                    }, function(error) {
                        handleUpdateFailure("failed to get content from url " + contentUrl + ", " + JSON.stringify(error).substr(0, 100) + "...");
                    });
                }, function() {
                    handleUpdateFailure("failed to get store theme");
                })) : handleUpdateFailure("bad theme data from url " + styleUrl + ": length:" + themeData.length + " ..." + themeData.substr(themeData.length - 100));
            }, function(error) {
                handleUpdateFailure("failed to get theme from url " + styleUrl + ", " + JSON.stringify(error).substr(0, 100));
            });
        }
        function getDebugInfo() {
            var deferred = $q.defer();
            if (GlobalConfig.isMobileApp) try {
                BidspiritLoader.getBaseDirEntry(function(baseDir) {
                    getDebugInfoForDirectoryEntry(baseDir).then(function(debugInfo) {
                        BidspiritLoader.readFile("app/data", function(data) {
                            debugInfo.dataFileContent = data, debugInfo.loaderDebugInfo = BidspiritLoader.mDebugInfo.split("\n"), 
                            deferred.resolve(debugInfo);
                        }, function(error) {
                            debugInfo.dataFileContent = "Error while reading data file content: " + error, deferred.resolve(debugInfo);
                        });
                    });
                });
            } catch (e) {
                deferred.resolve({
                    error: "Error while getting mobile app debug info: " + e
                });
            } else deferred.resolve(null);
            return deferred.promise;
        }
        function getDebugInfoForDirectoryEntry(dirEntry) {
            var deferred = $q.defer(), debugInfo = {};
            try {
                $rootScope.debug("getDebugInfoForDirectoryEntry " + dirEntry.name), dirEntry.createReader().readEntries(function(entries) {
                    $rootScope.debug(entries.length + " entries");
                    for (var subPromises = [], i = 0; i < entries.length; i++) !function(entry) {
                        try {
                            subPromises.push(entry.name.length > 2 && entry.isDirectory ? getDebugInfoForDirectoryEntry(entry).then(function(dirDebugInfo) {
                                debugInfo[entry.name] = dirDebugInfo;
                            }) : getDebugInfoForFileEntry(entry).then(function(fileDebugInfo) {
                                debugInfo[entry.name] = fileDebugInfo;
                            }));
                        } catch (e) {
                            deferred.resolve({
                                error: "Exception getting debugInfo for sub entry " + entry.name + " of directory " + dirEntry.name + ": " + e
                            });
                        }
                    }(entries[i]);
                    $q.all(subPromises).then(function() {
                        deferred.resolve(debugInfo);
                    });
                }, function(error) {
                    deferred.resolve({
                        error: "error while reading entries for directory " + dirEntry.name + ": " + error
                    });
                });
            } catch (e) {
                deferred.resolve({
                    error: "Exception getting debugInfo for  directory " + dirEntry.name + ": " + e
                });
            }
            return deferred.promise;
        }
        function getDebugInfoForFileEntry(fileEntry) {
            var deferred = $q.defer();
            try {
                $rootScope.debug("getDebugInfoForFileEntry " + fileEntry.name), fileEntry.getMetadata(function(metaData) {
                    deferred.resolve(metaData);
                }, function(error) {
                    deferred.resolve({
                        error: "Error while getting meta data: " + error
                    });
                });
            } catch (e) {
                deferred.resolve({
                    error: "Exception while getting file debug info: " + e
                });
            }
            return deferred.promise;
        }
        return {
            updateBidspiritDataAndTheme: updateBidspiritDataAndTheme,
            getTextsLoadPromise: getTextsLoadPromise,
            updateLocalTextsInAllLangs: updateLocalTextsInAllLangs,
            getDebugInfo: getDebugInfo
        };
    });
}), define("common/js/modules/mobileApp/index", [ "./mobileAppModule", "./puffinService", "./portalMobileUtils" ], function() {}), 
define("common/js/modules/catalogUtils/catalogUtilsModule", [ "angular" ], function(ng) {
    return ng.module("commonModules.catalogUtils", []);
}), define("common/js/modules/catalogUtils/bidRulesService", [ "./catalogUtilsModule" ], function(module) {
    module.factory("BidRulesService", function($q, $rootScope, $uibModal, ArraysService, StringsService, I18nService) {
        function validBid(lot, price, bidLimit) {
            var errorKey = null, currency = lot.auction.catalogInfo.currency, minPrice = newPreBidMinPrice(lot), textParams = {
                price: price
            }, parsedPrice = null;
            if (StringsService.isBlank(price)) errorKey = "empty"; else if (parsedPrice = I18nService.parseCurrency(price, currency)) if (null != bidLimit && parsedPrice > bidLimit) errorKey = "bidlimit"; else if (parsedPrice == minPrice) errorKey = null; else if (minPrice > parsedPrice) errorKey = "low"; else {
                var increments = getNearIncrementPrices(lot, parsedPrice);
                if (increments.prev == parsedPrice) ; else if (0 == increments.prev) minPrice = increments.next, 
                errorKey = "low"; else if (parsedPrice < increments.prev) errorKey = "low", minPrice = increments.prev; else {
                    errorKey = "increment";
                    var minIncreement = Math.max(increments.prev, minPrice);
                    textParams.prev = I18nService.sumInCurrency(minIncreement, currency), textParams.next = I18nService.sumInCurrency(increments.next, currency);
                }
            } else errorKey = "illegal";
            return errorKey ? {
                error: errorKey,
                textParams: textParams,
                minPrice: minPrice
            } : {
                error: null,
                parsedPrice: parsedPrice
            };
        }
        function minBidPrice(lot) {
            if (lot.startPrice) return lot.startPrice;
            if (!lot.house) return 0;
            var increments = lot.house.increments;
            return increments ? lot.estimatedPrice ? minPriceFromEstimated(increments, lot) : lot.carInfo ? 5e3 : lot.realEstateInfo ? 5e4 : minIncrementPrice(increments, lot) : 0;
        }
        function minPriceFromEstimated(increments, lot) {
            var lowEstimate = 1 * lot.estimatedPrice.replace(/\\/g).split("-")[0].replace(/[^0-9]/g, ""), margin = lot.house.marginFromEstiamteToStartPrice;
            return null == margin || 0 == margin ? lowEstimate : getNearIncrementPrices(lot, lowEstimate * (100 - margin) / 100).prev;
        }
        function minIncrementPrice(increments) {
            var price = Object.keys(increments)[0];
            if (0 != price) return price;
            var step = increments[price];
            return step;
        }
        function getNextBidPrices(lot, startPrice, count) {
            if (!lot.house) return [ startPrice ];
            var increments = lot.house.increments, prevStep = null, price = startPrice, nextPrice = getNearIncrementPrices(lot, startPrice).next, nextPrices = [ price, nextPrice ];
            if (price = nextPrice, !increments) return nextPrices;
            for (var step in increments) {
                for (;step > price; ) {
                    var currentStep = prevStep;
                    if (currentStep || (currentStep = step), price += 1 * increments[currentStep], nextPrices.push(price), 
                    nextPrices.length >= count) return nextPrices;
                }
                prevStep = step;
            }
            for (;nextPrices.length < count; ) price += 1 * increments[prevStep], nextPrices.push(price);
            return nextPrices;
        }
        function getNearIncrementPrices(lot, price) {
            var increments = lot.house.increments;
            if (!increments) return {
                prev: price,
                next: price
            };
            for (var step = getStepForPrice(increments, price), stepPrice = 1 * increments[step], prevIncrementPrice = 1 * step, nextIncrementPrice = prevIncrementPrice + stepPrice; price >= nextIncrementPrice; ) prevIncrementPrice = nextIncrementPrice, 
            nextIncrementPrice += stepPrice;
            return {
                prev: prevIncrementPrice,
                next: nextIncrementPrice
            };
        }
        function getStepForPrice(increments, price) {
            var prevStep = null;
            for (var step in increments) {
                if (step > price) return prevStep ? prevStep : step;
                prevStep = step;
            }
            return prevStep;
        }
        function newPreBidMinPrice(lot) {
            var minPrice = minBidPrice(lot), leadingBidBasedPrice = 0;
            if (lot.leadingBid && "ENDED" != lot.auction.state) {
                var leadingBidPrice = lot.leadingBid.price;
                leadingBidBasedPrice = lot.selfAbsenteeBid && lot.selfAbsenteeBid.userIdInApp == lot.leadingBid.userIdInApp && !lot.leadingBid.underReserved ? leadingBidPrice : getNearIncrementPrices(lot, leadingBidPrice).next;
            }
            return Math.max(leadingBidBasedPrice, minPrice);
        }
        return {
            validBid: validBid,
            minBidPrice: minBidPrice,
            newPreBidMinPrice: newPreBidMinPrice,
            getNextBidPrices: getNextBidPrices
        };
    });
}), define("common/js/modules/catalogUtils/catalogUtilsService", [ "./catalogUtilsModule" ], function(module) {
    module.factory("CatalogUtilsService", function($rootScope, CloudinaryService, PathsService, StringsService, ArraysService, I18nService, DateUtilsService, BidRulesService, SettingsService) {
        function sortLots(items, options) {
            return items ? (items.sort(function(item1, item2) {
                return compareLots(item1, item2, options || {});
            }), items) : null;
        }
        function getPaddedIndex(index) {
            for (var digitCount = 0, stippedIndex = (index + "").replace(/^0+/, ""), i = 0; i < stippedIndex.length && stippedIndex.charAt(i) >= "0" && stippedIndex.charAt(i) <= "9"; i++) digitCount++;
            return StringsService.pad(stippedIndex.substr(0, digitCount), 10, "0") + stippedIndex.substr(digitCount);
        }
        function compareLots(item1, item2, options) {
            options || (options = {});
            var auctionDateCompare = 0;
            if (item1.auctionDate != item2.auctionDate ? auctionDateCompare = item1.auctionDate > item2.auctionDate ? 1 : -1 : item1.auctionId != item2.auctionId && (auctionDateCompare = item1.auctionId > item2.auctionId ? 1 : -1), 
            options.reverseAuctionDate && (auctionDateCompare = -1 * auctionDateCompare), 0 != auctionDateCompare) return auctionDateCompare;
            switch (options.sortOrder) {
              case "index":
                return compareIndexes(item1.itemIndex, item2.itemIndex);

              case "order_in_shop":
                return item1.orderInShop - item2.orderInShop;

              case "newest":
                return item2.addedTime - item1.addedTime;

              case "low_price":
                return comparePrices(item1, item2);

              case "high_price":
                return -comparePrices(item1, item2);

              default:
                return item1.itemIndex && item2.itemIndex ? compareIndexes(item1.itemIndex, item2.itemIndex) : item1.addedTime - item2.addedTime;
            }
        }
        function comparePrices(item1, item2) {
            return getPriceForComparision(item1) - getPriceForComparision(item2);
        }
        function getPriceForComparision(item) {
            return item.purchase ? item.purchase.price || item.purchase.actionPrice : item.shopPrice ? item.shopPrice : item.leadingBid ? item.leadingBid.price : item.startPrice ? item.startPrice : item.estimatedPrice ? BidRulesService.minBidPrice(item) : null;
        }
        function compareIndexes(index1, index2) {
            var paddedIndex1 = getPaddedIndex(index1), paddedIndex2 = getPaddedIndex(index2);
            return paddedIndex1 == paddedIndex2 ? 0 : paddedIndex1 > paddedIndex2 ? 1 : -1;
        }
        function getLotPage(items, lotKey, itemsPerPage) {
            var lotInd = ArraysService.getIndByKey(items, "idInApp", lotKey);
            return null == lotInd ? 1 : Math.ceil((lotInd + 1) / itemsPerPage);
        }
        function getPageItems(allItems, page, itemsPerPage) {
            if (!allItems) return [];
            var startInd = (page - 1) * itemsPerPage, endInd = startInd + 1 * itemsPerPage;
            return allItems.slice(startInd, endInd);
        }
        function isSoldPriceHidden(lot) {
            return lot.house ? "IL" == lot.house.region && "ART" != lot.house.defaultCatalogContentType && !lot.selfPurchase : !0;
        }
        function getBidLabel(lot, options) {
            options = options || {};
            var bid, labelKey = null, bidType = null, hidePrice = !1, priceVisibleToAdmin = !1;
            return lot.selfPurchase ? (bidType = "self-sold", bid = lot.selfPurchase, labelKey = "lot_self_sold_bid") : lot.purchase ? (bidType = lot.selfAbsenteeBid ? "outbidded" : "sold", 
            bid = lot.purchase, labelKey = "sold_for", isSoldPriceHidden(lot) && (labelKey = "lot_sold", 
            hidePrice = !0, $rootScope.currentUser && "SYSTEM" == $rootScope.currentUser.role && options.showSalePriceForAdmin && (priceVisibleToAdmin = !0, 
            hidePrice = !1))) : lot.selfAbsenteeBid ? (bidType = "self-absentee", bid = lot.selfAbsenteeBid, 
            labelKey = "your_bid") : lot.bidRequest && lot.bidRequest.price && (bidType = "bid-request", 
            bid = lot.bidRequest, labelKey = "your_bid"), bid ? {
                text: I18nService.getText(labelKey),
                price: hidePrice ? "" : I18nService.sumInCurrency(bid.price || bid.actionPrice, lot.catalogInfo.currency),
                type: bidType,
                priceVisibleToAdmin: priceVisibleToAdmin
            } : void 0;
        }
        function matchCarInfoField(phrase, carInfo) {
            if (!carInfo) return !1;
            for (var i = 0; i < SEARCHABLE_CAR_FIELDS.length; i++) {
                var field = SEARCHABLE_CAR_FIELDS[i], value = carInfo[field];
                if (value && -1 != (value + "").replace(/\-/g, "").toLowerCase().indexOf(phrase)) return !0;
            }
        }
        function matchRealEstateInfoField(phrase, realEstateInfo) {
            if (!realEstateInfo) return !1;
            for (var i = 0; i < SEARCHABLE_REAL_ESTATE_FIELDS.length; i++) {
                var field = SEARCHABLE_REAL_ESTATE_FIELDS[i], value = realEstateInfo[field];
                if (value && -1 != (value + "").replace(/\-/g, "").toLowerCase().indexOf(phrase)) return !0;
            }
        }
        function checkLotMatchPhrase(lot, phrase) {
            var score = 0;
            if (SettingsService.isIgnoredSearchToken(phrase)) score = 0; else if (getPaddedIndex(lot.itemIndex) == getPaddedIndex(phrase)) score = 20; else if (lot.itemIndex && lot.itemIndex.indexOf(phrase) > -1) score = 4 - lot.itemIndex.indexOf(phrase); else {
                for (var langFields = [ "artist", "name", "description", "details" ], i = 0; i < langFields.length; i++) {
                    var field = langFields[i], fieldValue = I18nService.getLangField(lot[field]), lowerPharser = phrase.toLowerCase();
                    fieldValue && fieldValue.toLowerCase().indexOf(lowerPharser) > -1 && (score += 4 - i / 2 + phrase.length / 2);
                }
                if (phrase.length > 3) {
                    var phraseDigits = phrase.replace(/[^\d]/g, "");
                    phraseDigits && (lot.startPrice && lot.startPrice == phraseDigits && (score += 1), 
                    lot.estimatedPrice && lot.estimatedPrice.replace(/[^\d]/g, "").indexOf(phraseDigits) > -1 && (score += 1));
                }
                matchCarInfoField(phrase.toLowerCase().replace(/\-/g, ""), lot.carInfo) && (score += 2), 
                matchRealEstateInfoField(phrase.toLowerCase().replace(/\-/g, ""), lot.realEstateInfo) && (score += 2);
            }
            return {
                lot: lot,
                score: score
            };
        }
        function getHouseBadgeForLot(item) {
            var text;
            return item.house ? (item.auction ? (text = StringsService.trimToWord(I18nService.getLangField(item.house.details.name), 20), 
            text += " <span dir='ltr'>(" + getAuctionTimeDisplay(item.auction, !0, !0) + ")</span>") : item.shop && (text = I18nService.getText("shop_info_title", {
                houseName: StringsService.trimToWord(I18nService.getLangField(item.house.details.name), 20)
            })), {
                text: text,
                color: item.house.details.brandColor
            }) : "";
        }
        function getAuctionTimeDisplay(auction, dateOnly, withoutDayOfWeek, textsMap) {
            if (!auction.date) return "";
            var auctionDate = DateUtilsService.parseServerDate(auction.date), time = dateOnly || auction.hideTime || "ENDED" == auction.state ? null : auction.time;
            return I18nService.getDateDisplay(auctionDate, time, {
                withoutTime: dateOnly,
                withoutDayOfMonth: auction.unknownExactDate,
                withoutDayOfWeek: withoutDayOfWeek
            }, textsMap);
        }
        function getAbsenteeBidLabelForPastLot(lot) {
            if (!lot.auction) return null;
            if ((lot.purchase || "ENDED" == lot.auction.state) && lot.selfAbsenteeBid) {
                var price = I18nService.sumInCurrency(lot.selfAbsenteeBid.price, lot.auction.catalogInfo.currency);
                return I18nService.getText("your_absentee_bid", {
                    price: price
                });
            }
            return null;
        }
        function getSortFieldName(field) {
            var textKey = field;
            switch (field) {
              case "index":
                textKey = "lot_number";
                break;

              case "index":
                textKey = "lot_number";
                break;

              default:
                field = textKey;
            }
            return I18nService.getText(textKey);
        }
        function getLeadingBidInfo(lot) {
            var info = {};
            if (!lot.auction) return info;
            var currency = lot.catalogInfo.currency, leadingBid = lot.leadingBid, selfPreBid = lot.selfAbsenteeBid, purchase = lot.purchase, isSelfLeading = selfPreBid ? selfPreBid.userIdInApp == leadingBid.userIdInApp : !1;
            info.isPastItem = "ENDED" == lot.auction.state || null != purchase;
            var selfPreBidPrice = selfPreBid ? I18nService.sumInCurrency(selfPreBid.price, currency) : null, displayPrice = I18nService.sumInCurrency(leadingBid.price, currency);
            if (info.label = "leading_bid", purchase) info.leadingBidType = "sold", lot.selfPurchase ? selfPreBid && (info.message = selfPreBid.price > purchase.price ? "your_max_bid_price" : "your_absentee_bid", 
            info.messagePrice = selfPreBidPrice, info.leadingBidType += " self") : selfPreBid && (info.messagePrice = selfPreBidPrice, 
            info.leadingBidType += " outbidded", info.message = purchase.price > selfPreBid.price ? "your_bid_lost" : leadingBid.price != selfPreBid.price || isSelfLeading ? "your_absentee_bid" : "leading_bid_outbidded_time"); else if (info.isPastItem && leadingBid.underReserved && !isSelfLeading) info.leadingBidType = "outbidded", 
            info.message = "leading_bid_under_reserved", info.messagePrice = displayPrice; else if (isSelfLeading && leadingBid.underReserved) info.leadingBidType = "outbidded", 
            info.message = "your_bid_under_reserved", info.label = "leading_bid_self", info.messagePrice = selfPreBidPrice; else if (selfPreBid && !isSelfLeading) info.leadingBidType = "outbidded", 
            info.messagePrice = selfPreBidPrice, info.message = leadingBid.price == selfPreBid.price ? "leading_bid_outbidded_time" : "leading_bid_outbidded_price"; else if (isSelfLeading) info.leadingBidType = "self", 
            info.label = "leading_bid_self", info.message = "your_max_bid_price", info.messagePrice = selfPreBidPrice; else if (info.isPastItem) return {
                hidden: !0
            };
            return info.isSelfLeading = isSelfLeading, info.displayPrice = displayPrice, leadingBid.underReserved && (info.leadingBidType += " under-reserved"), 
            info.isPastItem && (info.leadingBidType += " past"), info;
        }
        function auctionComparableDate(auction) {
            return auction.date + " " + auction.time;
        }
        function compareAuctions(auction1, auction2) {
            return auctionComparableDate(auction1).localeCompare(auctionComparableDate(auction2));
        }
        function getCatalogOwnerTopImage(catalogOwner) {
            var imgPath = catalogOwner.resources && catalogOwner.resources.topItem;
            return imgPath || (imgPath = catalogOwner.house && catalogOwner.house.resources.mainPageLogo), 
            imgPath ? CloudinaryService.getUrl(imgPath) : PathsService.bidspiritLogo;
        }
        function sortAuctions(auctions) {
            auctions.sort(compareAuctions);
        }
        var SEARCHABLE_CAR_FIELDS = [ "model", "carNumber", "manufacturer", "engine", "engineVolumeCc", "drive", "horsePower", "additions", "color", "hand", "overview", "ownership", "previousOwnership", "finish", "gear", "notes" ], SEARCHABLE_REAL_ESTATE_FIELDS = [ "city", "propertyType", "address", "neighborhood", "notes", "propertyCondition" ];
        return {
            sortLots: sortLots,
            getPaddedIndex: getPaddedIndex,
            compareLots: compareLots,
            compareIndexes: compareIndexes,
            getPageItems: getPageItems,
            getLotPage: getLotPage,
            getAuctionTimeDisplay: getAuctionTimeDisplay,
            getHouseBadgeForLot: getHouseBadgeForLot,
            checkLotMatchPhrase: checkLotMatchPhrase,
            getLeadingBidInfo: getLeadingBidInfo,
            getBidLabel: getBidLabel,
            isSoldPriceHidden: isSoldPriceHidden,
            getAbsenteeBidLabelForPastLot: getAbsenteeBidLabelForPastLot,
            sortAuctions: sortAuctions,
            compareAuctions: compareAuctions,
            getSortFieldName: getSortFieldName,
            getCatalogOwnerTopImage: getCatalogOwnerTopImage
        };
    });
}), define("common/js/modules/catalogUtils/index", [ "./catalogUtilsModule", "./bidRulesService", "./catalogUtilsService" ], function() {}), 
define("commonModules", [ "angular", "ngdir/angular-ui-router", "ngdir/angular-ng-cookies", "common/js/modules/strings/index", "common/js/modules/utils/index", "common/js/modules/domUtils/index", "common/js/modules/api/index", "common/js/modules/system/index", "common/js/modules/paths/index", "common/js/modules/i18n/index", "common/js/modules/dialogs/index", "common/js/modules/asyncButton/index", "common/js/modules/bsForm/index", "common/js/modules/validate/index", "common/js/modules/animations/index", "common/js/modules/cloudinary/index", "common/js/modules/socialPlugins/index", "common/js/modules/log/index", "common/js/modules/mobileApp/index", "common/js/modules/catalogUtils/index" ], function(ng) {
    return ng.module("commonModules", [ "ui.router", "ngCookies", "commonModules.strings", "commonModules.utils", "commonModules.api", "commonModules.system", "commonModules.paths", "commonModules.cloudinary", "commonModules.socialPlugins", "commonModules.dialogs", "commonModules.asyncButton", "commonModules.bsForm", "commonModules.i18n", "commonModules.validate", "commonModules.log", "commonModules.animations", "commonModules.domUtils", "commonModules.mobileApp", "commonModules.catalogUtils" ]).config(function($stateProvider, $sceDelegateProvider, $httpProvider, $sceProvider) {
        angular.module("commonModules").$stateProvider = $stateProvider, angular.module("ui.bootstrap.tooltip").value("$tooltipSuppressWarning", !0), 
        $sceDelegateProvider.resourceUrlWhitelist([ "self", GlobalConfig.serverFilesBase + "**", GlobalConfig.jsFilesBase + "**" ]), 
        $httpProvider.interceptors.push("ApiInterceptor"), $sceProvider.enabled(!1);
    }).run(function($rootScope, $state, $stateParams, $transitions) {
        $transitions.onSuccess({}, function(transition) {
            $state.previous = transition.from();
        }), $rootScope.$state = $state, $rootScope.$stateParams = $stateParams, $rootScope.serverFilesBase = GlobalConfig.serverFilesBase;
    });
}), window.console || (console = {
    log: function() {}
});

var textAngular = angular.module("textAngular", [ "ngSanitize" ]);

textAngular.directive("textAngular", [ "$compile", "$window", "$document", "$rootScope", "$timeout", "taFixChrome", function($compile, $window, $document, $rootScope, $timeout, taFixChrome) {
    function deepExtend(destination, source) {
        for (var property in source) source[property] && source[property].constructor && source[property].constructor === Object ? (destination[property] = destination[property] || {}, 
        arguments.callee(destination[property], source[property])) : destination[property] = source[property];
        return destination;
    }
    $rootScope.textAngularOpts = deepExtend({
        toolbar: [ [ "h1", "h2", "h3", "p", "pre", "quote", "color" ], [ "bold", "italics", "underline", "ul", "ol", "redo", "undo", "clear" ], [ "justifyLeft", "justifyCenter", "justifyRight" ], [ "html", "insertImage", "insertLink", "unlink" ] ],
        classes: {
            focussed: "focussed",
            toolbar: "btn-toolbar",
            toolbarGroup: "btn-group",
            toolbarButton: "btn btn-default",
            toolbarButtonActive: "active",
            textEditor: "form-control",
            htmlEditor: "form-control"
        }
    }, null != $rootScope.textAngularOpts ? $rootScope.textAngularOpts : {});
    var queryFormatBlockState = function(command) {
        command = command.toLowerCase();
        var val = $document[0].queryCommandValue("formatBlock").toLowerCase();
        return val === command || val === command;
    };
    return $rootScope.textAngularTools = deepExtend({
        html: {
            display: "<button type='button' ng-click='action()' ng-class='displayActiveToolClass(active)'>Toggle HTML</button>",
            action: function() {
                var _this = this;
                this.$parent.showHtml = !this.$parent.showHtml, this.$parent.showHtml ? $timeout(function() {
                    return _this.$parent.displayElements.html[0].focus();
                }, 100) : $timeout(function() {
                    return _this.$parent.displayElements.text[0].focus();
                }, 100), this.active = this.$parent.showHtml;
            }
        },
        color: {
            display: "<button type='button'  ng-class='displayActiveToolClass(active)' ><input type='color' ng-change='action()' ng-model='color'></button>",
            action: function() {
                var color = angular.element(this.$parent.displayElements.toolbar)[0].querySelector("input[type=color]").value;
                return this.$parent.wrapSelection("foreColor", color);
            },
            activeState: function() {
                return queryFormatBlockState("color");
            }
        },
        h1: {
            display: "<button type='button' ng-click='action()' ng-class='displayActiveToolClass(active)'>H1</button>",
            action: function() {
                return this.$parent.wrapSelection("formatBlock", "<H1>");
            },
            activeState: function() {
                return queryFormatBlockState("h1");
            }
        },
        h2: {
            display: "<button type='button' ng-click='action()' ng-class='displayActiveToolClass(active)'>H2</button>",
            action: function() {
                return this.$parent.wrapSelection("formatBlock", "<H2>");
            },
            activeState: function() {
                return queryFormatBlockState("h2");
            }
        },
        h3: {
            display: "<button type='button' ng-click='action()' ng-class='displayActiveToolClass(active)'>H3</button>",
            action: function() {
                return this.$parent.wrapSelection("formatBlock", "<H3>");
            },
            activeState: function() {
                return queryFormatBlockState("h3");
            }
        },
        p: {
            display: "<button type='button' ng-click='action()' ng-class='displayActiveToolClass(active)'>P</button>",
            action: function() {
                return this.$parent.wrapSelection("formatBlock", "<P>");
            },
            activeState: function() {
                return queryFormatBlockState("p");
            }
        },
        pre: {
            display: "<button type='button' ng-click='action()' ng-class='displayActiveToolClass(active)'>pre</button>",
            action: function() {
                return this.$parent.wrapSelection("formatBlock", "<PRE>");
            },
            activeState: function() {
                return queryFormatBlockState("pre");
            }
        },
        ul: {
            display: "<button type='button' ng-click='action()' ng-class='displayActiveToolClass(active)'><i class='fa fa-list-ul'></i></button>",
            action: function() {
                return this.$parent.wrapSelection("insertUnorderedList", null);
            },
            activeState: function() {
                return $document[0].queryCommandState("insertUnorderedList");
            }
        },
        ol: {
            display: "<button type='button' ng-click='action()' ng-class='displayActiveToolClass(active)'><i class='fa fa-list-ol'></i></button>",
            action: function() {
                return this.$parent.wrapSelection("insertOrderedList", null);
            },
            activeState: function() {
                return $document[0].queryCommandState("insertOrderedList");
            }
        },
        quote: {
            display: "<button type='button' ng-click='action()' ng-class='displayActiveToolClass(active)'><i class='fa fa-quote-right'></i></button>",
            action: function() {
                return this.$parent.wrapSelection("formatBlock", "<BLOCKQUOTE>");
            },
            activeState: function() {
                return queryFormatBlockState("blockquote");
            }
        },
        undo: {
            display: "<button type='button' ng-click='action()' ng-class='displayActiveToolClass(active)'><i class='fa fa-undo'></i></button>",
            action: function() {
                return this.$parent.wrapSelection("undo", null);
            }
        },
        redo: {
            display: "<button type='button' ng-click='action()' ng-class='displayActiveToolClass(active)'><i class='fa fa-repeat'></i></button>",
            action: function() {
                return this.$parent.wrapSelection("redo", null);
            }
        },
        bold: {
            display: "<button type='button' ng-click='action()' ng-class='displayActiveToolClass(active)'><i class='fa fa-bold'></i></button>",
            action: function() {
                return this.$parent.wrapSelection("bold", null);
            },
            activeState: function() {
                return $document[0].queryCommandState("bold");
            }
        },
        justifyLeft: {
            display: "<button type='button' ng-click='action()' ng-class='displayActiveToolClass(active)'><i class='fa fa-align-left'></i></button>",
            action: function() {
                return this.$parent.wrapSelection("justifyLeft", null);
            },
            activeState: function() {
                return $document[0].queryCommandState("justifyLeft");
            }
        },
        justifyRight: {
            display: "<button type='button' ng-click='action()' ng-class='displayActiveToolClass(active)'><i class='fa fa-align-right'></i></button>",
            action: function() {
                return this.$parent.wrapSelection("justifyRight", null);
            },
            activeState: function() {
                return $document[0].queryCommandState("justifyRight");
            }
        },
        justifyCenter: {
            display: "<button type='button' ng-click='action()' ng-class='displayActiveToolClass(active)'><i class='fa fa-align-center'></i></button>",
            action: function() {
                return this.$parent.wrapSelection("justifyCenter", null);
            },
            activeState: function() {
                return $document[0].queryCommandState("justifyCenter");
            }
        },
        italics: {
            display: "<button type='button' ng-click='action()' ng-class='displayActiveToolClass(active)'><i class='fa fa-italic'></i></button>",
            action: function() {
                return this.$parent.wrapSelection("italic", null);
            },
            activeState: function() {
                return $document[0].queryCommandState("italic");
            }
        },
        underline: {
            display: "<button type='button' ng-click='action()' ng-class='displayActiveToolClass(active)'><i class='fa fa-underline'></i></button>",
            action: function() {
                return this.$parent.wrapSelection("underline", null);
            },
            activeState: function() {
                return $document[0].queryCommandState("underline");
            }
        },
        clear: {
            display: "<button type='button' ng-click='action()' ng-class='displayActiveToolClass(active)'><i class='fa fa-ban'></i></button>",
            action: function() {
                return this.$parent.wrapSelection("removeFormat", null);
            }
        },
        insertImage: {
            display: "<button type='button' ng-click='action()' ng-class='displayActiveToolClass(active)'><i class='fa fa-picture-o'></i></button>",
            action: function() {
                var imageLink;
                return imageLink = prompt("Please enter an image URL to insert", "http://"), "" !== imageLink ? this.$parent.wrapSelection("insertImage", imageLink) : void 0;
            }
        },
        insertLink: {
            display: "<button type='button' ng-click='action()' ng-class='displayActiveToolClass(active)'><i class='fa fa-link'></i></button>",
            action: function() {
                var urlLink;
                return urlLink = prompt("Please enter an URL to insert", "http://"), "" !== urlLink ? this.$parent.wrapSelection("createLink", urlLink) : void 0;
            }
        },
        unlink: {
            display: "<button type='button' ng-click='action()' ng-class='displayActiveToolClass(active)'><i class='fa fa-unlink'></i></button>",
            action: function() {
                return this.$parent.wrapSelection("unlink", null);
            }
        }
    }, null != $rootScope.textAngularTools ? $rootScope.textAngularTools : {}), {
        require: "ngModel",
        scope: {},
        restrict: "EA",
        link: function(scope, element, attrs, ngModel) {
            var group, groupElement, keydown, keyup, tool, toolElement;
            angular.extend(scope, $rootScope.textAngularOpts, {
                wrapSelection: function(command, opt) {
                    document.execCommand(command, !1, opt), ("insertUnorderedList" === command || "insertOrderedList" === command) && taFixChrome(scope.displayElements.text), 
                    scope.showHtml ? scope.displayElements.html[0].focus() : scope.displayElements.text[0].focus(), 
                    scope.updateSelectedStyles(), scope.showHtml || scope.updateTaBindtext();
                },
                showHtml: !1
            }), attrs.taToolbar && (scope.toolbar = scope.$eval(attrs.taToolbar)), attrs.taFocussedClass && (scope.classes.focussed = scope.$eval(attrs.taFocussedClass)), 
            attrs.taToolbarClass && (scope.classes.toolbar = attrs.taToolbarClass), attrs.taToolbarGroupClass && (scope.classes.toolbarGroup = attrs.taToolbarGroupClass), 
            attrs.taToolbarButtonClass && (scope.classes.toolbarButton = attrs.taToolbarButtonClass), 
            attrs.taToolbarActiveButtonClass && (scope.classes.toolbarButtonActive = attrs.taToolbarActiveButtonClass), 
            attrs.taTextEditorClass && (scope.classes.textEditor = attrs.taTextEditorClass), 
            attrs.taHtmlEditorClass && (scope.classes.htmlEditor = attrs.taHtmlEditorClass), 
            scope.displayElements = {
                toolbar: angular.element("<div></div>"),
                forminput: angular.element("<input type='hidden' style='display: none;'>"),
                html: angular.element("<textarea ng-show='showHtml' ta-bind='html' ng-model='html' ></textarea>"),
                text: angular.element("<div contentEditable='true' ng-hide='showHtml' ta-bind='text' ng-model='text' ></div>")
            }, element.append(scope.displayElements.toolbar), element.append(scope.displayElements.text), 
            element.append(scope.displayElements.html), attrs.name && (scope.displayElements.forminput.attr("name", attrs.name), 
            element.append(scope.displayElements.forminput)), $compile(scope.displayElements.text)(scope), 
            $compile(scope.displayElements.html)(scope), element.addClass("ta-root"), scope.displayElements.toolbar.addClass("ta-toolbar " + scope.classes.toolbar), 
            scope.displayElements.text.addClass("ta-text ta-editor " + scope.classes.textEditor), 
            scope.displayElements.html.addClass("ta-html ta-editor " + scope.classes.textEditor), 
            element.on("focusin", function() {
                element.addClass(scope.classes.focussed), $timeout(function() {
                    element.triggerHandler("focus");
                }, 0);
            }), element.on("focusout", function() {
                $timeout(function() {
                    $document[0].activeElement !== scope.displayElements.html[0] && $document[0].activeElement !== scope.displayElements.text[0] && (element.removeClass(scope.classes.focussed), 
                    $timeout(function() {
                        element.triggerHandler("blur");
                    }, 0));
                }, 0);
            }), scope.tools = {};
            for (var _i = 0; _i < scope.toolbar.length; _i++) {
                group = scope.toolbar[_i], groupElement = angular.element("<div></div>"), groupElement.addClass(scope.classes.toolbarGroup);
                for (var _j = 0; _j < group.length; _j++) {
                    tool = group[_j], toolElement = angular.element($rootScope.textAngularTools[tool].display), 
                    toolElement.addClass(scope.classes.toolbarButton), toolElement.attr("unselectable", "on"), 
                    toolElement.attr("ng-disabled", "showHtml()");
                    var childScope = angular.extend(scope.$new(!0), $rootScope.textAngularTools[tool], {
                        name: tool,
                        showHtml: function() {
                            return "html" !== this.name ? this.$parent.showHtml : !1;
                        },
                        displayActiveToolClass: function(active) {
                            return active ? this.$parent.classes.toolbarButtonActive : "";
                        }
                    });
                    scope.tools[tool] = childScope, groupElement.append($compile(toolElement)(childScope));
                }
                scope.displayElements.toolbar.append(groupElement);
            }
            ngModel.$render = function() {
                if (scope.displayElements.forminput.val(ngModel.$viewValue), void 0 !== ngModel.$viewValue && $document[0].activeElement !== scope.displayElements.html[0] && $document[0].activeElement !== scope.displayElements.text[0]) {
                    var val = ngModel.$viewValue || "";
                    scope.text = val, scope.html = val;
                }
            }, scope.$watch("text", function(newValue) {
                scope.html = newValue, ngModel.$setViewValue(newValue), scope.displayElements.forminput.val(newValue);
            }), scope.$watch("html", function(newValue) {
                scope.text = newValue, ngModel.$setViewValue(newValue), scope.displayElements.forminput.val(newValue);
            }), scope.bUpdateSelectedStyles = !1, scope.updateSelectedStyles = function() {
                for (var _k = 0; _k < scope.toolbar.length; _k++) for (var groups = scope.toolbar[_k], _l = 0; _l < groups.length; _l++) tool = groups[_l], 
                null != scope.tools[tool].activeState && (scope.tools[tool].active = scope.tools[tool].activeState.apply(scope));
                this.bUpdateSelectedStyles && $timeout(this.updateSelectedStyles, 200);
            }, keydown = function() {
                scope.bUpdateSelectedStyles = !0, scope.$apply(function() {
                    scope.updateSelectedStyles();
                });
            }, scope.displayElements.html.on("keydown", keydown), scope.displayElements.text.on("keydown", keydown), 
            keyup = function() {
                scope.bUpdateSelectedStyles = !1;
            }, scope.displayElements.html.on("keyup", keyup), scope.displayElements.text.on("keyup", keyup), 
            mouseup = function() {
                scope.$apply(function() {
                    scope.updateSelectedStyles();
                });
            }, scope.displayElements.html.on("mouseup", mouseup), scope.displayElements.text.on("mouseup", mouseup);
        }
    };
} ]).directive("taBind", [ "$sanitize", "$document", "taFixChrome", function($sanitize, $document, taFixChrome) {
    return {
        require: "ngModel",
        scope: {
            taBind: "@"
        },
        link: function(scope, element, attrs, ngModel) {
            var isContentEditable = "textarea" !== element[0].tagName.toLowerCase() && "input" !== element[0].tagName.toLowerCase() && void 0 !== element.attr("contenteditable"), compileHtml = function() {
                var result = taFixChrome(angular.element("<div>").append(element.html())).html();
                return "html" === scope.taBind && isContentEditable && (result = result.replace(/&lt;/g, "<").replace(/&gt;/g, ">").replace(/&amp;/g, "&")), 
                result;
            };
            scope.$parent["updateTaBind" + scope.taBind] = function() {
                var compHtml = compileHtml(), tempParsers = ngModel.$parsers;
                ngModel.$parsers = [], ngModel.$oldViewValue = compHtml, ngModel.$setViewValue(compHtml), 
                ngModel.$parsers = tempParsers;
            }, isContentEditable && element.on("keyup", function() {
                ngModel.$setViewValue(compileHtml());
            }), ngModel.$parsers.push(function(value) {
                void 0 === ngModel.$oldViewValue && (ngModel.$oldViewValue = value);
                try {
                    $sanitize(value);
                } catch (e) {
                    return ngModel.$oldViewValue;
                }
                return ngModel.$oldViewValue = value, value;
            }), ngModel.$render = function() {
                if (void 0 !== ngModel.$viewValue) if ($document[0].activeElement !== element[0]) {
                    var val = ngModel.$viewValue || "";
                    ngModel.$oldViewValue = val, "text" === scope.taBind ? (element.html(val), element.find("a").on("click", function(e) {
                        return e.preventDefault(), !1;
                    })) : isContentEditable || "textarea" !== element[0].tagName.toLowerCase() && "input" !== element[0].tagName.toLowerCase() ? element.html(val.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;")) : element.val(val);
                } else isContentEditable || element.val(val);
            };
        }
    };
} ]).factory("taFixChrome", function() {
    var taFixChrome = function($html) {
        for (var spans = angular.element($html).find("span"), s = 0; s < spans.length; s++) {
            var span = angular.element(spans[s]);
            span.attr("style") && span.attr("style").match(/line-height: 1.428571429;|color: inherit; line-height: 1.1;/i) && (span.next().length > 0 && "BR" === span.next()[0].tagName && span.next().remove(), 
            span.replaceWith(span.html()));
        }
        var result = $html.html().replace(/style="[^"]*?(line-height: 1.428571429;|color: inherit; line-height: 1.1;)[^"]*"/gi, "");
        return $html.html(result), $html;
    };
    return taFixChrome;
}), define("ngdir/text/textAngular", [ "angular" ], function() {}), !function(a, b) {
    b["true"] = a, function(a, b) {
        function c() {
            this.$get = [ "$$sanitizeUri", function(a) {
                return function(b) {
                    var c = [];
                    return f(b, k(c, function(b, c) {
                        return !/^unsafe/.test(a(b, c));
                    })), c.join("");
                };
            } ];
        }
        function d(a) {
            var c = [], d = k(c, b.noop);
            return d.chars(a), c.join("");
        }
        function e(a) {
            var b, c = {}, d = a.split(",");
            for (b = 0; b < d.length; b++) c[d[b]] = !0;
            return c;
        }
        function f(a, c) {
            function d(a, d, f, h) {
                if (d = b.lowercase(d), A[d]) for (;j.last() && B[j.last()]; ) e("", j.last());
                z[d] && j.last() == d && e("", d), h = w[d] || !!h, h || j.push(d);
                var i = {};
                f.replace(o, function(a, b, c, d, e) {
                    var f = c || d || e || "";
                    i[b] = g(f);
                }), c.start && c.start(d, i, h);
            }
            function e(a, d) {
                var e, f = 0;
                if (d = b.lowercase(d)) for (f = j.length - 1; f >= 0 && j[f] != d; f--) ;
                if (f >= 0) {
                    for (e = j.length - 1; e >= f; e--) c.end && c.end(j[e]);
                    j.length = f;
                }
            }
            var f, h, i, j = [], k = a;
            for (j.last = function() {
                return j[j.length - 1];
            }; a; ) {
                if (h = !0, j.last() && C[j.last()]) a = a.replace(new RegExp("(.*)<\\s*\\/\\s*" + j.last() + "[^>]*>", "i"), function(a, b) {
                    return b = b.replace(r, "$1").replace(t, "$1"), c.chars && c.chars(g(b)), "";
                }), e("", j.last()); else if (0 === a.indexOf("<!--") ? (f = a.indexOf("--", 4), 
                f >= 0 && a.lastIndexOf("-->", f) === f && (c.comment && c.comment(a.substring(4, f)), 
                a = a.substring(f + 3), h = !1)) : s.test(a) ? (i = a.match(s), i && (a = a.replace(i[0], ""), 
                h = !1)) : q.test(a) ? (i = a.match(n), i && (a = a.substring(i[0].length), i[0].replace(n, e), 
                h = !1)) : p.test(a) && (i = a.match(m), i && (a = a.substring(i[0].length), i[0].replace(m, d), 
                h = !1)), h) {
                    f = a.indexOf("<");
                    var u = 0 > f ? a : a.substring(0, f);
                    a = 0 > f ? "" : a.substring(f), c.chars && c.chars(g(u));
                }
                if (a == k) throw l("badparse", "The sanitizer was unable to parse the following block of html: {0}", a);
                k = a;
            }
            e();
        }
        function g(a) {
            if (!a) return "";
            var b = H.exec(a), c = b[1], d = b[3], e = b[2];
            return e && (G.innerHTML = e.replace(/</g, "&lt;"), e = "textContent" in G ? G.textContent : G.innerText), 
            c + e + d;
        }
        function h(a) {
            return a.replace(/&/g, "&amp;").replace(u, function(a) {
                var b = a.charCodeAt(0), c = a.charCodeAt(1);
                return "&#" + (1024 * (b - 55296) + (c - 56320) + 65536) + ";";
            }).replace(v, function(a) {
                var b = a.charCodeAt(0);
                return 159 >= b || 173 == b || b >= 1536 && 1540 >= b || 1807 == b || 6068 == b || 6069 == b || b >= 8204 && 8207 >= b || b >= 8232 && 8239 >= b || b >= 8288 && 8303 >= b || 65279 == b || b >= 65520 && 65535 >= b ? "&#" + b + ";" : a;
            }).replace(/</g, "&lt;").replace(/>/g, "&gt;");
        }
        function i(a) {
            var c = "", d = a.split(";");
            return b.forEach(d, function(a) {
                var d = a.split(":");
                if (2 == d.length) {
                    var e = I(b.lowercase(d[0])), a = I(b.lowercase(d[1]));
                    ("color" === e && (a.match(/^rgb\([0-9%,\. ]*\)$/i) || a.match(/^rgba\([0-9%,\. ]*\)$/i) || a.match(/^hsl\([0-9%,\. ]*\)$/i) || a.match(/^hsla\([0-9%,\. ]*\)$/i) || a.match(/^#[0-9a-f]{3,6}$/i) || a.match(/^[a-z]*$/i)) || "text-align" === e && ("left" === a || "right" === a || "center" === a || "justify" === a) || "float" === e && ("left" === a || "right" === a || "none" === a) || ("width" === e || "height" === e) && a.match(/[0-9\.]*(px|em|rem|%)/)) && (c += e + ": " + a + ";");
                }
            }), c;
        }
        function j(a, b, c, d) {
            return "img" === a && b["ta-insert-video"] && ("ta-insert-video" === c || "allowfullscreen" === c || "frameborder" === c || "contenteditble" === c && "false" === d) ? !0 : !1;
        }
        function k(a, c) {
            var d = !1, e = b.bind(a, a.push);
            return {
                start: function(a, f, g) {
                    a = b.lowercase(a), !d && C[a] && (d = a), d || D[a] !== !0 || (e("<"), e(a), b.forEach(f, function(d, g) {
                        var k = b.lowercase(g), l = "img" === a && "src" === k || "background" === k;
                        ("style" === k && "" !== (d = i(d)) || j(a, f, k, d) || F[k] === !0 && (E[k] !== !0 || c(d, l))) && (e(" "), 
                        e(g), e('="'), e(h(d)), e('"'));
                    }), e(g ? "/>" : ">"));
                },
                end: function(a) {
                    a = b.lowercase(a), d || D[a] !== !0 || (e("</"), e(a), e(">")), a == d && (d = !1);
                },
                chars: function(a) {
                    d || e(h(a));
                }
            };
        }
        var l = b.$$minErr("$sanitize"), m = /^<\s*([\w:-]+)((?:\s+[\w:-]+(?:\s*=\s*(?:(?:"[^"]*")|(?:'[^']*')|[^>\s]+))?)*)\s*(\/?)\s*>/, n = /^<\s*\/\s*([\w:-]+)[^>]*>/, o = /([\w:-]+)(?:\s*=\s*(?:(?:"((?:[^"])*)")|(?:'((?:[^'])*)')|([^>\s]+)))?/g, p = /^</, q = /^<\s*\//, r = /<!--(.*?)-->/g, s = /<!DOCTYPE([^>]*?)>/i, t = /<!\[CDATA\[(.*?)]]>/g, u = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g, v = /([^\#-~| |!])/g, w = e("area,br,col,hr,img,wbr"), x = e("colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr"), y = e("rp,rt"), z = b.extend({}, y, x), A = b.extend({}, x, e("address,article,aside,blockquote,caption,center,del,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5,h6,header,hgroup,hr,ins,map,menu,nav,ol,pre,script,section,table,ul")), B = b.extend({}, y, e("a,abbr,acronym,b,bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,q,ruby,rp,rt,s,samp,small,span,strike,strong,sub,sup,time,tt,u,var")), C = e("script,style"), D = b.extend({}, w, A, B, z), E = e("background,cite,href,longdesc,src,usemap"), F = b.extend({}, E, e("abbr,align,alt,axis,bgcolor,border,cellpadding,cellspacing,class,clear,color,cols,colspan,compact,coords,dir,face,headers,height,hreflang,hspace,ismap,lang,language,nohref,nowrap,rel,rev,rows,rowspan,rules,scope,scrolling,shape,size,span,start,summary,target,title,type,valign,value,vspace,width")), G = document.createElement("pre"), H = /^(\s*)([\s\S]*?)(\s*)$/, I = function() {
            return String.prototype.trim ? function(a) {
                return b.isString(a) ? a.trim() : a;
            } : function(a) {
                return b.isString(a) ? a.replace(/^\s\s*/, "").replace(/\s\s*$/, "") : a;
            };
        }();
        b.module("ngSanitize", []).provider("$sanitize", c), b.module("ngSanitize").filter("linky", [ "$sanitize", function(a) {
            var c = /((ftp|https?):\/\/|(mailto:)?[A-Za-z0-9._%+-]+@)\S*[^\s.;,(){}<>]/, e = /^mailto:/;
            return function(f, g) {
                function h(a) {
                    a && n.push(d(a));
                }
                function i(a, c) {
                    n.push("<a "), b.isDefined(g) && (n.push('target="'), n.push(g), n.push('" ')), 
                    n.push('href="'), n.push(a), n.push('">'), h(c), n.push("</a>");
                }
                if (!f) return f;
                for (var j, k, l, m = f, n = []; j = m.match(c); ) k = j[0], j[2] == j[3] && (k = "mailto:" + k), 
                l = j.index, h(m.substr(0, l)), i(k, j[0].replace(e, "")), m = m.substring(l + j[0].length);
                return h(m), a(n.join(""));
            };
        } ]);
    }(window, window.angular);
}({}, function() {
    return this;
}()), define("ngdir/text/textAngular-sanitize", [ "angular" ], function() {}), define("portal/js/modules/external/externalsModule", [ "angular" ], function(ng) {
    return ng.module("app.externals", []);
}), define("portal/js/modules/external/wallop/wallop-slider-directive", [ "../externalsModule" ], function(module) {
    module.directive("wallopSlider", function() {
        return {
            template: '<div class="wallop-slider {{animationClass}}"><ul class="wallop-slider__list"><li class="wallop-slider__item {{itemClasses[$index]}}" ng-repeat="i in images"><img ng-src="{{i}}"></li></ul></div>',
            restrict: "EA",
            transclude: !0,
            replace: !1,
            scope: {
                images: "=",
                animation: "@",
                currentItemIndex: "=",
                nextItemIndex: "=",
                onNext: "&",
                onPrevious: "&"
            },
            controller: function($scope) {
                function _nextDisabled() {
                    return $scope.currentItemIndex + 1 === $scope.images.length;
                }
                function _prevDisabled() {
                    return !$scope.currentItemIndex;
                }
                function _updatePagination() {
                    $scope.nextDisabled = _nextDisabled(), $scope.prevDisabled = _prevDisabled();
                }
                function _clearClasses() {
                    for (var i = 0; i < $scope.images.length; i++) $scope.itemClasses[i] = "";
                }
                function _goTo(index) {
                    if (index >= $scope.images.length || 0 > index || index === $scope.currentItemIndex) return void (index || ($scope.itemClasses[0] = _displayOptions.currentItemClass));
                    _clearClasses(), $scope.itemClasses[$scope.currentItemIndex] = index > $scope.currentItemIndex ? _displayOptions.hidePreviousClass : _displayOptions.hideNextClass;
                    var currentClass = index > $scope.currentItemIndex ? _displayOptions.showNextClass : _displayOptions.showPreviousClass;
                    $scope.itemClasses[index] = _displayOptions.currentItemClass + " " + currentClass, 
                    $scope.currentItemIndex = index, _updatePagination();
                }
                $scope.itemClasses = [], $scope.$watch("images", function(images) {
                    images.length && _goTo(0);
                }), $scope.animation && ($scope.animationClass = "wallop-slider--" + $scope.animation);
                var _displayOptions = {
                    btnPreviousClass: "wallop-slider__btn--previous",
                    btnNextClass: "wallop-slider__btn--next",
                    itemClass: "wallop-slider__item",
                    currentItemClass: "wallop-slider__item--current",
                    showPreviousClass: "wallop-slider__item--show-previous",
                    showNextClass: "wallop-slider__item--show-next",
                    hidePreviousClass: "wallop-slider__item--hide-previous",
                    hideNextClass: "wallop-slider__item--hide-next"
                };
                $scope.onPrevButtonClicked = function() {
                    _goTo($scope.currentItemIndex - 1);
                }, $scope.onNextButtonClicked = function() {
                    _goTo($scope.currentItemIndex + 1);
                }, $scope.$watch("nextItemIndex", function(newVal, oldVal) {
                    newVal != oldVal && _goTo(newVal);
                }), $scope.$watch("currentItemIndex", function(newVal, oldVal) {
                    oldVal > newVal ? "function" == typeof $scope.onPrevious && $scope.onPrevious() : "function" == typeof $scope.onNext && $scope.onNext();
                });
            }
        };
    });
}), define("portal/js/modules/external/magnify/ng-magnify", [ "../externalsModule" ], function(module) {
    module.directive("ngMagnify", function() {
        return {
            restrict: "EA",
            replace: !0,
            template: '<div class="magnify-container" data-ng-style="getContainerStyle()"  ><div class="magnify-glass" data-ng-style="getGlassStyle()" ng-click="showDebug()"></div><img class="magnify-image" data-ng-src="{{ imageSrc }}"/></div>',
            scope: {
                imageSrc: "@",
                imageWidth: "=",
                imageHeight: "=",
                glassWidth: "=",
                glassHeight: "=",
                magnifyRatio: "="
            },
            link: function(scope, element) {
                var el, nWidth, nHeight, magnifyCSS, glass = element.find("div"), image = element.find("img");
                if (debug = !1, loaded = !1, !("ontouchstart" in window || window.DocumentTouch && document instanceof DocumentTouch)) {
                    var magnifyRatio;
                    element.on("mousemove", function(evt) {
                        el = angular.extend(scope.getOffset(element[0]), {
                            width: element[0].offsetWidth,
                            height: element[0].offsetHeight,
                            imageWidth: image[0].offsetWidth,
                            imageHeight: image[0].offsetHeight,
                            glassWidth: glass[0].offsetWidth,
                            glassHeight: glass[0].offsetHeight
                        }), magnifyCSS = scope.magnify(evt), magnifyCSS && glass.css(magnifyCSS);
                    }).on("mouseout", function() {
                        glass.on("mouseleave", function() {
                            glass.css({
                                opacity: 0,
                                filter: "alpha(opacity=0)"
                            });
                        });
                    }).on("contextmenu", function(evt) {
                        return evt.preventDefault(), window.open(scope.imageSrc, "_blank"), !1;
                    }), scope.showDebug = function() {
                        debug = !0;
                    }, scope.$watch("imageSrc", function() {
                        loaded = !1, glass.css({
                            opacity: 0
                        });
                    }), scope.magnify = function(evt) {
                        var mx, my, rx, ry, px, py, bgp, img;
                        return loaded ? (mx = evt.pageX ? evt.pageX - el.left : evt.x, my = evt.pageY ? evt.pageY - el.top : evt.y, 
                        mx < el.width && my < el.height && mx > 0 && my > 0 ? (glass.css({
                            opacity: 1,
                            "z-index": 1,
                            filter: "alpha(opacity=100)"
                        }), rx = -1 * Math.round(mx / el.imageWidth * nWidth * magnifyRatio - el.glassWidth / 2), 
                        ry = -1 * Math.round(my / el.imageHeight * nHeight * magnifyRatio - el.glassHeight / 2), 
                        bgp = rx + "px " + ry + "px", debug && (debug = !1), px = mx - el.glassWidth / 2, 
                        py = my - el.glassHeight / 2, {
                            left: px + "px",
                            top: py + "px",
                            backgroundPosition: bgp
                        }) : void glass.css({
                            opacity: 0,
                            "z-index": -1,
                            filter: "alpha(opacity=0)"
                        })) : (img = new Image(), img.onload = function() {
                            nWidth = img.width, nHeight = img.height, loaded = !0, magnifyRatio = nWidth >= el.imageWidth ? scope.magnifyRatio : scope.magnifyRatio * el.imageWidth / nWidth, 
                            glass.css({
                                "background-size": Math.round(nWidth / el.glassWidth * magnifyRatio * 100) + "%",
                                opacity: 1
                            });
                        }, img.src = scope.imageSrc, void 0);
                    }, scope.getOffset = function(_el) {
                        var de = document.documentElement, box = _el.getBoundingClientRect(), top = box.top + window.pageYOffset - de.clientTop, left = box.left + window.pageXOffset - de.clientLeft;
                        return {
                            top: top,
                            left: left
                        };
                    }, scope.getContainerStyle = function() {
                        return {
                            width: scope.imageWidth ? scope.imageWidth + "px" : "",
                            height: scope.imageHeight ? scope.imageHeight + "px" : ""
                        };
                    }, scope.getGlassStyle = function() {
                        return {
                            "background-image": "url(" + scope.imageSrc + ") ",
                            "background-repeat": "no-repeat",
                            width: scope.glassWidth ? scope.glassWidth + "px" : "",
                            height: scope.glassHeight ? scope.glassHeight + "px" : ""
                        };
                    };
                }
            }
        };
    });
}), define("portal/js/modules/external/index", [ "./externalsModule", "./wallop/wallop-slider-directive", "./magnify/ng-magnify" ], function() {}), 
define("portal/js/modules/main/portalMainModule", [ "angular" ], function(ng) {
    return ng.module("app.main", []);
}), define("portal/js/modules/main/portalMainController", [ "./portalMainModule" ], function(module) {
    module.controller("MainController", [ "$scope", "$rootScope", "$state", "$timeout", "ArraysService", "I18nService", "CssLoaderService", "PathsService", "DomUtilsService", "LocalStorageService", "OsInfoService", "SessionsService", "LogService", "SettingsService", "ViewPortService", "DialogsService", "HouseEventsListenerService", "AnalyticsService", "CometService", "MobilePushService", "PortalNavigationService", "HeartBeatService", "PortalStates", "PortalInfoService", "PortalAuthService", "PortalTextsService", "LegalApprovalService", "AdsService", "UserAlertsService", "AuctionParticipationService", function($scope, $rootScope, $state, $timeout, ArraysService, I18nService, CssLoaderService, PathsService, DomUtilsService, LocalStorageService, OsInfoService, SessionsService, LogService, SettingsService, ViewPortService, DialogsService, HouseEventsListenerService, AnalyticsService, CometService, MobilePushService, PortalNavigationService, HeartBeatService, PortalStates, PortalInfoService, PortalAuthService, PortalTextsService, LegalApprovalService, AdsService, UserAlertsService, AuctionParticipationService) {
        function onInit() {
            "loaded" != $rootScope.loadState && ($rootScope.loadState = "loaded", $rootScope.isMobile = OsInfoService.isMobile(), 
            PortalStates.init(), PortalTextsService.init(), onLangUpdate(), $scope.dataState = "loaded", 
            initLog(), $rootScope.debug("loadState: " + $rootScope.loadState), initRegions(), 
            $rootScope.searchAgentRequest || (HouseEventsListenerService.init(), HeartBeatService.init(), 
            LegalApprovalService.init(), UserAlertsService.checkUnsubscriptionLink(), AnalyticsService.init(), 
            AuctionParticipationService.init()), PortalNavigationService.init(), AdsService.init(), 
            GlobalConfig.isMobileApp && (MobilePushService.init(), hideSplash()), handleDebugSending(), 
            checkIfToOverrideInitialScene(), $rootScope.debug("MainController initialization done"));
        }
        function checkIfToOverrideInitialScene() {
            PathsService.getQueryParam("showRegistration") && !$rootScope.currentUser && (PortalAuthService.showAuthModalOrScene("register"), 
            $rootScope.initialStateOverridden = !0), PathsService.getQueryParam("forgotPassword") && (PortalAuthService.showAuthModalOrScene("login", "recoverPassword"), 
            $rootScope.initialStateOverridden = !0);
        }
        function hideSplash() {
            setTimeout(function() {
                navigator.splashscreen && (navigator.splashscreen.hide(), StatusBar.overlaysWebView(!1));
            }, 1e3);
        }
        function handleDebugSending() {
            PathsService.getQueryParam("sendDebug") && (LogService.logEvent("debug from " + PathsService.getQueryParam("sendDebug")), 
            PortalInfoService.sendDebugInfo("d1", "pageLoad"));
        }
        function initLog() {
            LogService.init(SettingsService.get("logEntriesToken"));
            var osInfo = OsInfoService.getOsInfo();
            "unknown" == osInfo.browser && (osInfo = {
                agent: navigator.userAgent
            });
            var eventInfo = angular.extend({
                eventName: "enterPage",
                url: PortalStates.getInitialUrl(),
                referrer: document.referrer || "unknown"
            }, osInfo), user = SessionsService.getSessionUser();
            user && (eventInfo.user = user.email), LogService.logEvent(eventInfo), $rootScope.debugLog = "";
        }
        function initRegions() {
            $rootScope.regions = SettingsService.get("regions").slice();
            var domainRegion = PathsService.getRegionByDomain();
            !$rootScope.devMode && "ALL" != domainRegion && "SA" != domainRegion && SessionsService.getRegion() && ArraysService.remove($rootScope.regions, "ALL"), 
            ArraysService.remove($rootScope.regions, "SA"), ArraysService.remove($rootScope.regions, "RO"), 
            domainRegion && -1 == $rootScope.regions.indexOf(domainRegion) && $rootScope.regions.push(domainRegion), 
            $rootScope.currentRegion = SessionsService.getRegion();
        }
        function onLangUpdate() {
            $rootScope.currentLang = I18nService.getCurrentLang(), $rootScope.dir = DomUtilsService.getDirection($rootScope.currentLang);
        }
        function checkFirstVisit() {
            var lastVisit = LocalStorageService.load("lastVisit");
            $scope.firstVisit = lastVisit ? !1 : !0, LocalStorageService.store("lastVisit", new Date().getTime());
        }
        function getLoadStateInfo() {
            return "css :" + CssLoaderService.isCssLoaded() + ", lang:" + I18nService.getCurrentLang() + ", app:" + GlobalConfig.appVersion + ", caches:" + JSON.stringify(SettingsService.getAll() ? SettingsService.getAll().cacheVersions : "");
        }
        function checkAllResourcesLoaded() {
            $rootScope.debug(getLoadStateInfo()), CssLoaderService.isCssLoaded() && I18nService.getCurrentLang() && onInit();
        }
        function getInitialRegion() {
            var lastRegion = LocalStorageService.load("region");
            "ALL" == lastRegion && (lastRegion = null);
            var domainRegion = PathsService.getRegionByDomain();
            return isSupportSession() ? domainRegion || "ALL" : null == lastRegion || null == domainRegion || lastRegion == domainRegion || GlobalConfig.isMobileApp ? lastRegion || domainRegion : domainRegion;
        }
        function isSupportSession() {
            return window.location.href.match(/ui\/[^\/]*support/i);
        }
        function getContentType() {
            if (-1 != window.location.host.indexOf("cars")) return "CARS";
            if (-1 != window.location.host.indexOf("houses")) return "REAL_ESTATE";
            if (GlobalConfig.isMobileApp) {
                var lastContentType = (LocalStorageService.load("catalogContentType") || "").toUpperCase();
                if (-1 != [ "ART", "CARS", "REAL_ESTATE" ].indexOf(lastContentType)) return lastContentType;
            }
            return "ART";
        }
        function initConfig() {
            $rootScope.isMobileApp = GlobalConfig.isMobileApp, $rootScope.qaEnv = GlobalConfig.qaEnv, 
            PathsService.getQueryParam("searchAgentRequest") && ($rootScope.searchAgentRequest = !0), 
            ("active" == PathsService.getQueryParam("devMode") || GlobalConfig.devMode) && ($rootScope.devMode = !0), 
            ("1" == PathsService.getQueryParam("judaica") || -1 != window.location.host.indexOf("judaica")) && ($rootScope.judaicaOnly = !0), 
            $rootScope.contentType = getContentType(), "ART" == $rootScope.contentType && ($rootScope.showPastAuctionsResult = !0), 
            "1" == PathsService.getQueryParam("inIframe") && ($rootScope.inIframe = !0);
        }
        function init() {
            initConfig(), checkFirstVisit(), ViewPortService.bindViewPortSizeToWindowWidth(), 
            $rootScope.$on("i18n.languageChanged", onLangUpdate), CssLoaderService.loadCss($rootScope.serverFilesBase + GlobalConfig.appName + "/styles/style.css").then(checkAllResourcesLoaded), 
            PortalInfoService.init(getInitialRegion()).success(function() {
                I18nService.init(PathsService.getPortalTextsUrl, PathsService.getQueryParam("lang"), !0).then(checkAllResourcesLoaded);
            }).error(function(error) {
                error && "BLOCKED" == error.errorType && window.document.write("<h3>You have been blocked.</h3> For support, please contact us at info@bidspirit.com");
            });
        }
        $rootScope.loadState = "loading", $scope.dataState = "loading", $scope.firstVisit = !1, 
        $rootScope.currentLang = null, $scope.showErrorPopup = function(messageData) {
            DialogsService.showAlert(messageData);
        }, $rootScope.showGeneralError = function(message) {
            DialogsService.showAlert({
                title: "notice",
                message: message || "error_unknown",
                params: {
                    email: $scope.BidspiritInfo.emailLink,
                    phone: $scope.BidspiritInfo.phoneLink
                }
            });
        }, GlobalConfig.isMobileApp && !OsInfoService.isMobileAppDebug() ? document.addEventListener("deviceready", init, !1) : init();
    } ]);
}), define("portal/js/modules/main/portalInfoService", [ "./portalMainModule" ], function(module) {
    module.factory("PortalInfoService", function($q, $rootScope, $timeout, $http, ApiService, ArraysService, I18nService, SettingsService, StringsService, LocalStorageService, LogService, DateUtilsService, OsInfoService, PortalMobileUtils, SessionInfo, SessionsService, CachedApiService) {
        function resetData() {
            mHouses = [], mHousesMap = {}, mAuctions = [], mAuctionsMap = {}, mAuctionsMapById = {}, 
            mAuctionsMapByDay = {}, mHousesAuctions = {}, mInfo = {};
        }
        function initHouses(houses, resourcesMap, housesDetails, housesIncrements) {
            mHousesMap = ArraysService.listToMapById(houses);
            for (var detailsMap = ArraysService.listToMap(housesDetails, "auctionHouseId"), incrementsMap = ArraysService.listToMap(housesIncrements, "auctionHouseId"), i = 0; i < houses.length; i++) {
                var house = houses[i];
                ArraysService.addOrReplaceById(mHouses, house), house.resources = resourcesMap[house.id] || {}, 
                house.details = detailsMap[house.id] || {}, incrementsMap[house.id] && (house.increments = incrementsMap[house.id].steps);
            }
            sortHouses();
        }
        function loadAuction(auctionKey) {
            var defered = $q.defer();
            return ApiService.callApi("/portal/getAuctionInfo", {
                auctionKey: auctionKey
            }).success(function(auctionInfo) {
                var auction = auctionInfo.auction;
                auction && (auction.resources = auctionInfo.resources, auction.catalogInfo = auctionInfo.catalogInfo, 
                auction = putAuctionInCache(getHouse(auction.houseId), auction)), defered.resolve(auction);
            }), defered.promise;
        }
        function loadShop(shopKey) {
            var defered = $q.defer();
            return ApiService.callApi("/portal/getShopInfo", {
                shopKey: shopKey
            }).success(function(shopInfo) {
                var shop = shopInfo.shop;
                shop && (shop.resources = shopInfo.resources, shop.catalogInfo = shopInfo.catalogInfo, 
                putShopInCache(getHouse(shop.houseId), shop)), defered.resolve(shop);
            }), defered.promise;
        }
        function isMobileAppSupported() {
            return "REAL_ESTATE" == $rootScope.contentType ? !1 : "RU" == $rootScope.currentRegion ? "ART" == $rootScope.contentType ? !0 : !1 : "IL" == $rootScope.currentRegion ? !0 : !1;
        }
        function initAuctions(auctions, resourcesMap) {
            mHousesAuctions = {};
            for (var i = 0; i < auctions.length; i++) {
                var auction = auctions[i];
                auction.catalogInfo = mInfo.catalogsInfo[auction.intKey];
                var house = getHouse(auction.houseId);
                if (house) {
                    putAuctionInCache(house, auction);
                    var houseAuctions = mHousesAuctions[house.id];
                    houseAuctions || (houseAuctions = [], mHousesAuctions[house.id] = houseAuctions), 
                    shouldShowAuction(auction) && houseAuctions.push(auction);
                }
            }
            ArraysService.setPropertyFromMapById(mAuctions, "resources", resourcesMap, {});
        }
        function putAuctionInCache(house, auction) {
            return house ? (auction.house = house, shouldShowAuction(auction) && ArraysService.addOrReplaceById(mAuctions, auction), 
            auction.dayIdInApp && (mAuctionsMapByDay[house.code + "_" + auction.dayIdInApp] = auction), 
            mAuctionsMap[auction.intKey] = auction, mAuctionsMapById[auction.id] = auction, 
            auction.judaicaOnly && (house.hasJudaicaAuctions = !0), auction) : null;
        }
        function putShopInCache(house, shop) {
            house && (shop.house = house, ArraysService.addOrReplaceById(mShops, shop), mShopsMap[shop.intKey] = shop);
        }
        function initShops(shops, resourcesMap) {
            if (shops) {
                for (var i = 0; i < shops.length; i++) {
                    var shop = shops[i], house = getHouse(shop.houseId);
                    house && (shop.house = house, shop.catalogInfo = mInfo.catalogsInfo[shop.intKey], 
                    ArraysService.addOrReplaceById(mShops, shop));
                }
                mShopsMap = ArraysService.listToMap(mShops, "intKey"), ArraysService.setPropertyFromMapById(mShops, "resources", resourcesMap, {});
            }
        }
        function getHouseShop(houseId) {
            return ArraysService.getByKey(mShops, "houseId", houseId);
        }
        function shouldShowAuction(auction) {
            return auction.house && (null != auction.catalogInfo && auction.house.hostingServerName || "ENDED" != auction.state) ? $rootScope.devMode ? !0 : auction.hidden || auction.house.hidden ? !1 : !0 : !1;
        }
        function checkHasEndedAuctions() {
            return ArraysService.containsByKey(mInfo.auctions, "state", "ENDED");
        }
        function getAllFutureAuctions() {
            var futureAuctions = ArraysService.filterWithFunction(mInfo.auctions, function(auction) {
                return "ENDED" == auction.state ? !1 : shouldShowAuction(auction) ? getMinutesUntilAuction(auction) < 0 ? !1 : !0 : !1;
            });
            return ArraysService.sort(futureAuctions, "date"), futureAuctions;
        }
        function clearCachedPortalInfo() {
            LocalStorageService.clearByPrefix("portalInfo_");
        }
        function loadLastStoredPortalInfo(region) {
            var lastStoredInfo = LocalStorageService.load("portalInfo_" + $rootScope.contentType + "_" + (region || "ALL"));
            if (!lastStoredInfo) return $rootScope.firstTimeVisit = !0, null;
            $rootScope.firstTimeVisit = !1;
            try {
                var portalInfo = JSON.parse(lastStoredInfo), settings = portalInfo.sessionInfo.settings;
                if (settings.appVersion != GlobalConfig.appVersion) return clearCachedPortalInfo(), 
                null;
                if (portalInfo.sessionInfo.sessionId == SessionInfo.sessionId) return settings.serverTime = null, 
                mLoadedRegion = region, handleLoadedPortalInfo(portalInfo, !1), SessionsService.setSessionInfo(mInfo.sessionInfo), 
                CachedApiService.cachedPromiseWrap(mInfo);
            } catch (e) {
                LogService.logError("Failed to load cached portal info", e);
            }
        }
        function init(region) {
            if (-1 == [ "IL", "RU", "RO", "SA", "ALL" ].indexOf(region) && (region = null), 
            SessionsService.loadPreviousSessionId(), mInfo = {}, $rootScope.searchAgentRequest) return loadForRegion(region, !0).success(function(portalInfo) {
                SessionsService.setSessionInfo(portalInfo.sessionInfo);
            });
            var cachedDataPromise = loadLastStoredPortalInfo(region || "ALL"), freshDataPromise = loadForRegion(region, !1);
            return $timeout(function() {
                loadForRegion(region, !0);
            }, 2e3), cachedDataPromise || freshDataPromise;
        }
        function loadForRegion(region, includeOldAuctions) {
            var params = {
                persistentSession: SessionsService.hasPersistentSession(),
                region: region,
                judaicaOnly: $rootScope.judaicaOnly,
                contentType: $rootScope.contentType,
                tzOffetInMinutes: new Date().getTimezoneOffset(),
                includeOldAuctions: includeOldAuctions
            };
            return ApiService.callApi("/portal/getPortalInfo", params).success(function(portalInfo) {
                var storeInCache = !1;
                includeOldAuctions || (storeInCache = !0), mLoadedRegion = region, handleLoadedPortalInfo(portalInfo, storeInCache), 
                mLastRefreshFromServer = new Date().getTime();
            });
        }
        function storeInfoInCache() {
            var key = "portalInfo_" + $rootScope.contentType + "_" + (mLoadedRegion || "ALL");
            LocalStorageService.store(key, JSON.stringify(mInfo));
        }
        function udpateCachedSessionUser() {
            mInfo.sessionInfo.user = $rootScope.currentUser, storeInfoInCache();
        }
        function handleLoadedPortalInfo(portalInfo, storeInCache) {
            mInfo.sessionInfo && mInfo.sessionInfo.settings.cacheVersions.TEXTS != portalInfo.sessionInfo.settings.cacheVersions.TEXTS && I18nService.reloadTextsAfterDelay(1e3), 
            resetData(), angular.copy(portalInfo, mInfo), SessionsService.setSessionInfo(mInfo.sessionInfo), 
            SettingsService.init(mInfo.sessionInfo.settings), mTags = mInfo.tags, initHouses(portalInfo.houses, portalInfo.housesResources, portalInfo.housesDetails, portalInfo.housesIncrements), 
            initAuctions(mInfo.auctions, portalInfo.auctionsResources), initShops(mInfo.shops, portalInfo.shopsResources), 
            $rootScope.$broadcast("portalInfo.infoUpdated"), storeInCache && storeInfoInCache();
        }
        function getAuction(catalogKey) {
            var auction = mAuctionsMap[catalogKey];
            return auction || (auction = mAuctionsMapById[catalogKey]), auction;
        }
        function getShop(catalogKey) {
            return mShopsMap[catalogKey];
        }
        function getAuctionByDayIdInApp(houseCode, dayIdInApp) {
            return mAuctionsMapByDay[houseCode + "_" + dayIdInApp];
        }
        function getAuctions() {
            return mAuctions;
        }
        function getHouseAuctions(houseId) {
            return mHousesAuctions[houseId] || [];
        }
        function getShops() {
            return mShops;
        }
        function getTags() {
            return mTags;
        }
        function getInfo() {
            return mInfo;
        }
        function getAllHouses() {
            return mHouses;
        }
        function getHouse(houseId) {
            return mHousesMap[houseId];
        }
        function getHousesByIds(houseIds) {
            for (var houses = [], i = 0; i < houseIds.length; i++) {
                var house = mHousesMap[houseIds[i]];
                house && houses.push(house);
            }
            return houses;
        }
        function getHouseByCode(code) {
            return ArraysService.getByKey(mHouses, "code", code);
        }
        function sendContactRequest(contactRequest) {
            return ApiService.callApi("/portal/sendContactRequest", contactRequest, "post");
        }
        function sendContactRequestForSale(contactRequest) {
            return ApiService.callApi("/portal/sendContactRequestForSale", contactRequest, "post");
        }
        function timeSinceLastRefreshFromServer() {
            return new Date().getTime() - mLastRefreshFromServer;
        }
        function getProductInfo() {
            return CachedApiService.callCachableApi("productInfo", "/portal/getProductInfo");
        }
        function getHelpScreensInfo(prefix) {
            return CachedApiService.callCachableApi("helpeScreens", "/portal/getHelpScreensInfo", {
                prefix: prefix,
                contentType: $rootScope.contentType
            });
        }
        function getHouseTermsUrl(houseId, lang) {
            return CachedApiService.callCachableApi("terms_" + houseId + "_" + lang, "/portal/getHouseTermsUrl", {
                houseId: houseId,
                lang: lang
            });
        }
        function getHouseTerms(house) {
            var defered = $q.defer();
            return mHouseTermsCache && mHouseTermsCache.houseId == house.id ? defered.resolve(mHouseTermsCache.content) : getHouseTermsUrl(house.id, I18nService.getCurrentLang()).success(function(url) {
                $http.get(url.val).then(function(response) {
                    var content = response.data;
                    mHouseTermsCache = {
                        content: content,
                        houseId: house.id
                    }, defered.resolve(content);
                });
            }), defered.promise;
        }
        function getHouseIncrementsSteps(houseId) {
            var defered = $q.defer();
            return CachedApiService.callCachableApi("increments_" + houseId, "/portal/getHouseIncrements", {
                houseId: houseId
            }).success(function(incrementsInfo) {
                var steps = [];
                for (var price in incrementsInfo.steps) steps.push({
                    price: 1 * price,
                    increment: 1 * incrementsInfo.steps[price]
                });
                defered.resolve(steps);
            }), defered.promise;
        }
        function sortHouses() {
            mHouses.sort(function(house1, house2) {
                var house1Name = I18nService.getLangField(house1.details.name).toLowerCase(), house2Name = I18nService.getLangField(house2.details.name).toLowerCase();
                if (house1Name == house2Name) return 0;
                var isHouse1Heb = StringsService.isHebChar(house1Name.charAt(0)), isHouse2Heb = StringsService.isHebChar(house2Name.charAt(0));
                return isHouse1Heb && !isHouse2Heb ? -1 : !isHouse1Heb && isHouse2Heb ? 1 : house1Name > house2Name ? 1 : -1;
            });
        }
        function checkRunningAuctionsChanged(newRunningAuctions) {
            for (var changed = !1, i = 0; newRunningAuctions > i; i++) {
                var auction = getAuction(newRunningAuctions[i]);
                auction && "RUNNING" != auction.state && (changed = !0, auction.state = "RUNNING");
            }
            return changed && $rootScope.$broadcast("portalInfo.newRunningAuction"), changed;
        }
        function sendLotInquiryRequest(lotId, lotTitle, content) {
            return ApiService.callApi("/portal/sendLotInquiryRequest", {
                lotId: lotId,
                lotTitle: lotTitle,
                content: content
            }, "postForm");
        }
        function getLegalDoc(code) {
            var lang = I18nService.getCurrentLang();
            return "IL" == $rootScope.currentRegion && "ART" != $rootScope.contentType && (lang = "he"), 
            ApiService.callApi("/portal/getLegalDocContent", {
                code: code,
                lang: lang,
                cacheVersion: SettingsService.getCacheVersion("LEGAL_DOCS")
            });
        }
        function getMinutesUntilAuction(auction) {
            return SettingsService.timeUntil(auction.startTimeMillis) / 6e4;
        }
        function isAuctionInPostSaleMode(auction) {
            return auction ? "ENDED" != auction.state ? !1 : auction.startPriceHidden ? !1 : auction.postAuctionSaleEndTime ? SettingsService.timeUntil(auction.postAuctionSaleEndTime) > 0 : !1 : !1;
        }
        function setCurrentUserPreferredLang(lang) {
            return ApiService.callApi("/users/setPreferredLang", {
                lang: lang
            });
        }
        function reloadInfoAfterDelay(delay) {
            $timeout.cancel(mReloadTimer), mReloadTimer = $timeout(function() {
                loadForRegion($rootScope.currentRegion, !0);
            }, delay);
        }
        function getDebugInfo(debugCode, source) {
            var deferred = $q.defer();
            switch (debugCode.toLowerCase().substring(0, 2)) {
              case "d1":
                PortalMobileUtils.getDebugInfo().then(function(appDebugInfo) {
                    deferred.resolve({
                        source: source,
                        appDebugInfo: appDebugInfo,
                        globalConfig: GlobalConfig,
                        url: window.location.href,
                        osInfo: OsInfoService.getOsInfo(),
                        userAgent: navigator.userAgent,
                        currentUser: $rootScope.currentUser,
                        settings: SettingsService.getAll(),
                        i18nDebug: I18nService.getDebugInfo(),
                        localStorage: LocalStorageService.getDebugInfo(),
                        log: LogService.getDebugInfo(),
                        rootDebug: $rootScope.debugMessage
                    });
                });
                break;

              default:
                deferred.resolve({
                    error: "Unknown debug code :" + debugCode
                });
            }
            return deferred.promise;
        }
        function sendDebugInfo(debugCode, source) {
            return getDebugInfo(debugCode, source).then(function(debugInfo) {
                LogService.logMessage("got debug info");
                try {
                    sendContactRequest({
                        region: $rootScope.currentRegion,
                        contentType: $rootScope.contentType,
                        debug: JSON.stringify(debugInfo, null, 2),
                        lang: "en"
                    });
                } catch (e) {
                    LogService.logError("Failed to send debug info", e);
                }
            });
        }
        return mHouses = [], mHousesMap = {}, mShops = [], mShopsMap = {}, mAuctions = [], 
        mAuctionsMapById = {}, mAuctionsMap = {}, mAuctionsMapByDay = {}, mHousesAuctions = {}, 
        mInfo = {}, mTags = [], mLoadedRegion = null, mReloadTimer = null, mLastRefreshFromServer = null, 
        mHouseTermsCache = null, $rootScope.$on("i18n.languageChanged", sortHouses), {
            init: init,
            loadForRegion: loadForRegion,
            reloadInfoAfterDelay: reloadInfoAfterDelay,
            getHousesByIds: getHousesByIds,
            getAllHouses: getAllHouses,
            getHouse: getHouse,
            getHouseByCode: getHouseByCode,
            getAuctions: getAuctions,
            getAuction: getAuction,
            getAuctionByDayIdInApp: getAuctionByDayIdInApp,
            loadAuction: loadAuction,
            getHouseAuctions: getHouseAuctions,
            getAllFutureAuctions: getAllFutureAuctions,
            checkHasEndedAuctions: checkHasEndedAuctions,
            getShops: getShops,
            getShop: getShop,
            loadShop: loadShop,
            getHouseShop: getHouseShop,
            getMinutesUntilAuction: getMinutesUntilAuction,
            isAuctionInPostSaleMode: isAuctionInPostSaleMode,
            getTags: getTags,
            getProductInfo: getProductInfo,
            getHelpScreensInfo: getHelpScreensInfo,
            storeInfoInCache: storeInfoInCache,
            clearCachedPortalInfo: clearCachedPortalInfo,
            udpateCachedSessionUser: udpateCachedSessionUser,
            getPortalInfo: getInfo,
            timeSinceLastRefreshFromServer: timeSinceLastRefreshFromServer,
            getHouseTermsUrl: getHouseTermsUrl,
            getHouseTerms: getHouseTerms,
            getHouseIncrementsSteps: getHouseIncrementsSteps,
            sendContactRequest: sendContactRequest,
            sendContactRequestForSale: sendContactRequestForSale,
            getLegalDoc: getLegalDoc,
            sendLotInquiryRequest: sendLotInquiryRequest,
            setCurrentUserPreferredLang: setCurrentUserPreferredLang,
            checkRunningAuctionsChanged: checkRunningAuctionsChanged,
            isMobileAppSupported: isMobileAppSupported,
            sendDebugInfo: sendDebugInfo
        };
    });
}), define("portal/js/modules/main/portalTextsService", [ "./portalMainModule" ], function(module) {
    module.factory("PortalTextsService", function($rootScope, SessionsService, OsInfoService, SettingsService, DomUtilsService, I18nService, PortalNavigationService) {
        function init() {
            mInfo.email = SettingsService.get("supportEmail"), mInfo.phone = SettingsService.get("supportPhone"), 
            mInfo.itunesAppLink = "https://itunes.apple.com/app/id1059711315", mInfo.playstoreAppLink = "//play.google.com/store/apps/details?id=com.bidspirit.prod", 
            $rootScope.BidspiritInfo = mInfo, ajdustInfoToLang();
        }
        function ajdustInfoToLang() {
            var phone = I18nService.getPhoneForRegion(mInfo.phone, SessionsService.getRegion(), I18nService.getCurrentLang()) || "", phoneHtml = DomUtilsService.noWrap(phone, "ltr"), shortPhone = 0 == phone.indexOf("*") ? phone.match(/[\d\*]+/)[0] : phone;
            mInfo.phoneLink = OsInfoService.isMobile() ? DomUtilsService.link("tel:" + shortPhone, phoneHtml) : phoneHtml, 
            mInfo.fullPhone = phone, mInfo.emailLink = DomUtilsService.link("mailto:" + mInfo.email, mInfo.email);
        }
        function getGeneralErrorMessage() {
            return I18nService.getText("error_unknown", {
                email: mInfo.emailLink,
                phone: mInfo.phoneLink
            });
        }
        function getHouseConnectivityErrorParams(house) {
            return {
                email: $rootScope.BidspiritInfo.emailLink,
                phone: $rootScope.BidspiritInfo.phoneLink,
                house: house ? I18nService.getHouseName(house, {
                    full: !0
                }) : ""
            };
        }
        function getHouseTextParams(house) {
            if (!house || !house.details) return {};
            var houseDetails = house.details, params = {
                name: I18nService.getLangField(houseDetails.name)
            }, email = houseDetails.email;
            email && (params.email = DomUtilsService.link("mailto:" + email, email));
            var secondaryEmail = houseDetails.secondaryEmail;
            secondaryEmail && (params.secondaryEmail = DomUtilsService.link("mailto:" + secondaryEmail, secondaryEmail));
            var phone = houseDetails.phone;
            phone && (params.phone = OsInfoService.isMobile() ? DomUtilsService.link("tel:" + phone, phone) : phone);
            var secondaryPhone = houseDetails.secondaryPhone;
            secondaryPhone && (params.secondaryPhone = OsInfoService.isMobile() ? DomUtilsService.link("tel:" + secondaryPhone, secondaryPhone) : secondaryPhone);
            var website = house.website;
            if (website) {
                var protocol = 0 == website.indexOf("https") ? "https" : "http", websiteNoProtocol = website.replace(protocol + "://", "").replace(/\/$/, "");
                params.link = DomUtilsService.link(protocol + "://" + websiteNoProtocol, websiteNoProtocol, PortalNavigationService.getNewWindowTarget());
            }
            return params;
        }
        function getHouseConnectivityError(house) {
            return I18nService.getText("my_account_unknown_error", getHouseConnectivityErrorParams(house));
        }
        var mInfo = {};
        return {
            init: init,
            getGeneralErrorMessage: getGeneralErrorMessage,
            getHouseConnectivityError: getHouseConnectivityError,
            getHouseConnectivityErrorParams: getHouseConnectivityErrorParams,
            getHouseTextParams: getHouseTextParams
        };
    });
}), define("portal/js/modules/main/heartBeatService", [ "./portalMainModule" ], function(module) {
    module.factory("HeartBeatService", function($rootScope, $interval, $uibModal, ApiService, SettingsService, PathsService, I18nService, SessionsService, LocalStorageService, AnalyticsService, LogService, MobilePushService, PortalMobileUtils, PortalInfoService, PortalNavigationService) {
        function reloadPageAfterDelay(reason) {
            clearTimeout(mPageReloadTimer), mPageReloadTimer = setTimeout(function() {
                PathsService.reloadWindow(reason);
            }, getNextReloadTime(0, 60));
        }
        function getNextReloadTime(secondsToWait, secondsToSpread) {
            return GlobalConfig.devEnv || GlobalConfig.isMobileApp && $rootScope.devMode ? 1e4 : 1e3 * secondsToWait + Math.round(1e3 * Math.random() * secondsToSpread);
        }
        function heartBeat() {
            ApiService.callApi("/portal/heartBeat").success(function(heartBeatResponse) {
                var user = $rootScope.currentUser, userUpdated = !1;
                user ? heartBeatResponse.hasSession ? user.lastUpdate != heartBeatResponse.lastUserUpdate && (userUpdated = !0) : (LogService.logMessage("session ended."), 
                SessionsService.setSessionUser(null)) : heartBeatResponse.hasSession && SessionsService.refreshCurrentSession();
                var settings = SettingsService.getAll(), currentCacheVersions = settings.cacheVersions, newCacheVersions = heartBeatResponse.cacheVersions, newTexts = !1, runningAuctionsChanged = PortalInfoService.checkRunningAuctionsChanged(heartBeatResponse.runningAuctions);
                if (currentCacheVersions.TEXTS != newCacheVersions.TEXTS && (newTexts = !0, currentCacheVersions.TEXTS = newCacheVersions.TEXTS), 
                heartBeatResponse.requestDebug ? (LogService.logMessage("handling debug request"), 
                PortalInfoService.sendDebugInfo("d1", "Heart beat")) : userUpdated ? PortalInfoService.loadForRegion($rootScope.currentRegion, !0) : (currentCacheVersions.PORTAL_INFO != newCacheVersions.PORTAL_INFO || runningAuctionsChanged || PortalInfoService.timeSinceLastRefreshFromServer() > 36e5) && (currentCacheVersions.PORTAL_INFO = newCacheVersions.PORTAL_INFO, 
                PortalInfoService.reloadInfoAfterDelay(getNextReloadTime(120, 120))), heartBeatResponse.inMaintenanceMode && !settings.inMaintenanceMode ? (settings.inMaintenanceMode = heartBeatResponse.inMaintenanceMode, 
                PortalNavigationService.handleMaintenanceBehaviour()) : settings.inMaintenanceMode && !heartBeatResponse.inMaintenanceMode && reloadPageAfterDelay("Maintenance Ended"), 
                GlobalConfig.isMobileApp) {
                    if (!mAppUpdateMessageDisplayed && 1 * GlobalConfig.mobileAppVersion < 1 * heartBeatResponse.requiredMobileAppVersion) displayAppUpgradePopup(); else if (GlobalConfig.appVersion != heartBeatResponse.appVersion) {
                        var lastUpgradeAttempt = JSON.parse(LocalStorageService.load("lastUpgradeAttempt") || '{"version":0,"time":0}'), now = new Date().getTime();
                        (lastUpgradeAttempt.version != heartBeatResponse.appVersion || now - lastUpgradeAttempt.time > 864e5) && LocalStorageService.store("updateFailCounter", 0);
                        var updateFailCounter = LocalStorageService.load("updateFailCounter") || 0;
                        updateFailCounter > 3 ? $rootScope.debug("failed to upgrade app") : mUpdatingMobileVersion || (lastUpgradeAttempt.version = heartBeatResponse.appVersion, 
                        lastUpgradeAttempt.time = now, LocalStorageService.store("lastUpgradeAttempt", JSON.stringify(lastUpgradeAttempt)), 
                        mUpdatingMobileVersion = !0, $rootScope.debug("new version: " + heartBeatResponse.appVersion + ". So far failed " + updateFailCounter), 
                        setTimeout(function() {
                            PortalMobileUtils.updateBidspiritDataAndTheme(heartBeatResponse.appVersion);
                        }, getNextReloadTime(0, 60)));
                    }
                    GlobalConfig.loadedTextsVersion == newCacheVersions.TEXTS || mUpdatingMobileTexts || ($rootScope.debug("new texts " + newCacheVersions.TEXTS + " (old texts: " + GlobalConfig.loadedTextsVersion + ")"), 
                    mUpdatingMobileTexts = !0, PortalMobileUtils.updateLocalTextsInAllLangs(newCacheVersions.TEXTS).then(function() {
                        I18nService.reloadTextsAfterDelay(1e3), PortalInfoService.storeInfoInCache(), $rootScope.debug("texts updated"), 
                        mUpdatingMobileTexts = !1;
                    }, function() {
                        $rootScope.debug("failed to update text");
                    }));
                } else settings.appVersion != heartBeatResponse.appVersion ? (settings.appVersion = heartBeatResponse.appVersion, 
                PortalInfoService.clearCachedPortalInfo(), newTexts ? I18nService.reloadTextsAfterDelay(getNextReloadTime(30, 30)).then(function() {
                    reloadPageAfterDelay("app and texts versions changed");
                }) : reloadPageAfterDelay("app vesion changed")) : newTexts && (I18nService.reloadTextsAfterDelay(getNextReloadTime(120, 120)), 
                PortalInfoService.storeInfoInCache());
            });
        }
        function displayAppUpgradePopup() {
            mAppUpdateMessageDisplayed || (mAppUpdateMessageDisplayed = !0, $uibModal.open({
                templateUrl: PathsService.appTemplatePath("info/upgradeRequired"),
                size: "lg",
                backdrop: "static",
                controller: function($scope) {
                    $scope.redirectToUpgrade = function() {
                        window.open(PathsService.getCurrentPortalBase() + "/app", "_system");
                    };
                }
            }));
        }
        function init() {
            $rootScope.searchAgentRequest || (heartBeat(), $interval(heartBeat, 1e3 * mHeartBitRate), 
            GlobalConfig.isMobileApp && (AnalyticsService.trackDailyUniqueEvent("appAction", "activated"), 
            document.addEventListener("resume", function() {
                PortalInfoService.reloadInfoAfterDelay(5), MobilePushService.registerForPushIfNeeded(), 
                AnalyticsService.trackDailyUniqueEvent("appAction", "activated");
            })));
        }
        return mPageReloadTimer = null, mHeartBitRate = GlobalConfig.devEnv ? 60 : 60, mAppUpdateMessageDisplayed = !1, 
        mUpdatingMobileVersion = !1, mUpdatingMobileTexts = !1, {
            init: init,
            heartBeat: heartBeat
        };
    });
}), define("portal/js/modules/main/portalStates", [ "./portalMainModule" ], function(module) {
    module.factory("PortalStates", function($state, $timeout, $rootScope, $urlService, $location, LocalStorageService, PathsService) {
        function defineStates() {
            PathsService.appTemplateState("app", "portalMain", {
                url: "/"
            }), PathsService.appTemplateState("app.home", "auctions/home/homeMain", {
                url: "home/{scrollTo:[^?]*}",
                optionalParams: [ "scrollTo" ]
            }), PathsService.appTemplateState("app.results", "auctions/results/auctionsResults", {
                url: "results/:house/:page"
            }), PathsService.appTemplateState("app.auctionCatalog", "auctions/catalog/auctionCatalog", {
                url: "catalog/auction/:catalogKey/:page"
            }), PathsService.appTemplateState("app.lotPage", "catalogs/lotPage/lotPageMain", {
                url: "lotPage/source/:source/:ownerType/:catalogKey/lot/:lotKey"
            }), PathsService.appTemplateState("app.lotPageWithDesc", "catalogs/lotPage/lotPageMain", {
                url: "lotPage/source/:source/:ownerType/:catalogKey/lot/:lotKey/{lotDesc:raw}"
            }), PathsService.childSubviewTemplateState("app.lotPage", "zoom", "catalogs/lotPage/mobile/lotZoomSubScene", {
                url: "/zoom/:imageInd"
            }), PathsService.childSubviewTemplateState("app.lotPageWithDesc", "zoom", "catalogs/lotPage/mobile/lotZoomSubScene", {
                url: "/zoom/:imageInd"
            }), PathsService.appTemplateState("app.search", "catalogs/search/searchMain", {
                url: "search"
            }), PathsService.appTemplateState("app.searchWithTags", "catalogs/search/searchMain", {
                url: "searchWithTags/:tag"
            }), PathsService.appTemplateState("app.searchWithToken", "catalogs/search/searchMain", {
                url: "searchWithToken/{token:raw}"
            }), PathsService.appTemplateState("app.searchWithTokenAndTime", "catalogs/search/searchMain", {
                url: "searchWithToken/:time/{token:raw}"
            }), PathsService.appTemplateState("app.customSearch", "catalogs/search/searchMain", {
                url: "customSearch/:searchCode"
            }), PathsService.appTemplateState("app.tags", "catalogs/search/tagsScene", {
                url: "tags"
            }), PathsService.appTemplateState("app.houses", "houses/housesList", {
                url: "houses"
            }), PathsService.appTemplateState("app.house", "houses/housePage", {
                url: "houses/:houseCode,:showUpcomingAuctions"
            }), PathsService.appTemplateState("app.houseNoComa", "houses/housePage", {
                url: "houses/:houseCode"
            }), PathsService.appTemplateState("app.shops", "shops/shopsMain", {
                url: "shops"
            }), PathsService.appTemplateState("app.shopCatalog", "shops/catalog/shopCatalog", {
                url: "catalog/shop/:catalogKey/:page"
            }), PathsService.appTemplateState("app.support", "support/support", {
                url: "support"
            }), PathsService.appTemplateState("app.searchSupport", "support/support", {
                url: "searchSupport/:searchToken"
            }), PathsService.appTemplateState("app.supportCase", "support/supportCase", {
                url: "support/:caseId"
            }), PathsService.appTemplateState("app.about", "info/about", {
                url: "about"
            }), PathsService.appTemplateState("app.product", "info/product/productMain", {
                url: "product"
            }), PathsService.appTemplateState("app.help", "info/helpScreen", {
                url: "help/:code"
            }), PathsService.appTemplateState("app.faq", "info/faq", {
                url: "faq/:code",
                optionalParams: [ "code" ]
            }), PathsService.appTemplateState("app.downForHolyDay", "info/downForHolyDay", {
                url: "downForHolyDay"
            }), PathsService.appTemplateState("app.downForMaintenance", "info/downForMaintenance", {
                url: "downForMaintenance"
            }), PathsService.appTemplateState("app.choosePortal", "components/navigation/choosePortal", {
                url: "choosePortal"
            }), PathsService.appTemplateState("app.contact", "info/contact", {
                url: "contact"
            }), PathsService.simpleChildStates("app.contact", [ "thanks" ]), PathsService.appTemplateState("app.contactForSale", "info/contactForSale", {
                url: "contactForSale"
            }), PathsService.appTemplateState("app.popupScene", "components/popups/popupAsScene", {
                url: "popupAsScene/:code"
            }), PathsService.appTemplateState("app.houseApproval", "account/houseApproval/houseApprovalScene", {
                url: "houseApproval/:houseId,:fromLot"
            }), PathsService.appTemplateState("app.bidApproval", "account/bidApproval/bidApprovalScene", {
                url: "bidApproval/:houseId,:fromLot"
            }), PathsService.appTemplateState("app.userDetails", "userDetails/userDetailsMain", {
                url: "userDetails"
            }), PathsService.appTemplateState("app.accountActions", "account/accountActions/accountActionsMain", {
                url: "account/:actionType"
            }), PathsService.appTemplateState("app.alerts", "alerts/manage/userAlertsMain", {
                url: "alerts"
            }), PathsService.appTemplateState("app.installMobileApp", "nudges/scenes/installApp", {
                url: "installMobileApp"
            }), PathsService.appTemplateState("app.auth", "auth/authScene", {
                url: "auth/:authScene/:authSubScene/:args"
            }), PathsService.appTemplateState("app.reload", "components/navigation/reload", {
                url: "reload"
            });
        }
        function init() {
            PathsService.validateHttps() && (defineStates(), loadInitialState(), saveAcquisitionInfo());
        }
        function loadInitialState() {
            var initailState = $urlService.match({
                path: PathsService.getCurrentUiHref()
            });
            initailState ? $state.go(initailState.rule.state, initailState.match) : $state.go("app.home");
        }
        function saveAcquisitionInfo() {
            var initialReferer = LocalStorageService.load("initialReferer");
            if (!initialReferer) {
                var referer = GlobalConfig.referer;
                referer && "null" != referer && "true" != referer && (referer = "Unknown"), LocalStorageService.store("initialReferer", referer || "Unknown");
            }
            var initialSource = LocalStorageService.load("initialSource"), source = PathsService.getQueryParam("from") || "Unknown";
            initialSource || LocalStorageService.store("initialSource", source);
        }
        function getInitialUrl() {
            return mInitialUrl;
        }
        var mInitialUrl = window.location.href + "";
        return {
            init: init,
            getInitialUrl: getInitialUrl
        };
    });
}), define("portal/js/modules/main/index", [ "./portalMainModule", "./portalMainController", "./portalInfoService", "./portalTextsService", "./heartBeatService", "./portalStates" ], function() {}), 
define("portal/js/modules/auth/portalAuthModule", [ "angular" ], function(ng) {
    return ng.module("app.auth", [ "app.auth.login", "app.auth.register" ]);
}), define("portal/js/modules/auth/portalAuthService", [ "./portalAuthModule" ], function(module) {
    module.factory("PortalAuthService", function($q, $rootScope, $state, $uibModal, $uibModalStack, $interval, $timeout, AnalyticsService, LogService, LocalStorageService, PathsService, ApiService, PopupsService, SessionsService, PortalInfoService) {
        function register(registrationInfo) {
            return ApiService.callApi("/auth/register", registrationInfo, "post").success(function(user) {
                user.justRegistered = !0, SessionsService.setSessionUser(user), LocalStorageService.store("lastLoggedinEmail", user.email);
            });
        }
        function confirmEmail(emailConfirmationKey) {
            return ApiService.callApi("/auth/confirmEmail", {
                emailConfirmationKey: emailConfirmationKey
            }).success(function(user) {
                SessionsService.setSessionUser(user, SessionsService.hasPersistentSession()), LocalStorageService.store("lastLoggedinEmail", user.email);
            });
        }
        function login(email, password, lang, region, remember) {
            return ApiService.callApi("/auth/login", {
                email: email,
                password: password,
                lang: lang,
                region: region,
                remember: remember,
                contentType: $rootScope.contentType
            }).success(function(user) {
                SessionsService.setSessionUser(user, remember), LocalStorageService.store("lastLoggedinEmail", email);
            });
        }
        function sendPasswordRecovery(email) {
            return ApiService.callApi("/auth/sendPasswordRecovery", {
                email: email,
                contentType: $rootScope.contentType
            });
        }
        function resendEmailConfirmationRequest() {
            return ApiService.callApi("/auth/resendEmailConfirmationRequest", {
                contentType: $rootScope.contentType
            });
        }
        function completeRegistration(completeRegistrationInfo) {
            return ApiService.callApi("/auth/completeRegistration", completeRegistrationInfo, "post").success(function() {
                AnalyticsService.trackEvent("authAction", "completeRegistration", "source:" + LocalStorageService.load("initialSource"));
            });
        }
        function updateEmail(email) {
            return ApiService.callApi("/auth/updateEmail", {
                email: email,
                contentType: $rootScope.contentType
            });
        }
        function updatePassword(existingPassword, newPassword) {
            return ApiService.callApi("/auth/updatePassword", {
                existingPassword: existingPassword,
                newPassword: newPassword
            });
        }
        function validateUserLoggedIn() {
            return $rootScope.currentUser ? $rootScope.currentUser : void showAuthModalOrScene("login");
        }
        function validateCompleteUserProfile(args) {
            if ($rootScope.currentUser) {
                if ("COMPLETE" == $rootScope.currentUser.registrationStage) return $rootScope.currentUser;
                showAuthModalOrScene("warning", null, args);
            } else showAuthModalOrScene("login", null, args);
        }
        function getTempAuthInfo() {
            return mTempAuthInfo;
        }
        function logout() {
            return ApiService.callApi("/auth/logout").success(function() {
                SessionsService.setSessionUser(null);
            });
        }
        function showAuthModalOrScene(scene, subScene, args) {
            $rootScope.viewPort.pcMedia ? showAuthModalPopup(scene, subScene, args).result.then(function() {}) : $state.go("app.auth", {
                authScene: scene,
                authSubScene: subScene || scene,
                args: args ? JSON.stringify(args) : "{}"
            });
        }
        function isLoginFormDisplayed() {
            return mLoginFormDisplayed;
        }
        function setLoginFormDisplayed() {
            mLoginFormDisplayed = !0;
        }
        function showAuthModalPopup(scene, subScene, args) {
            closeAuthModalPopup();
            var modalInstance = $uibModal.open({
                templateUrl: PathsService.appTemplatePath("auth/authModalPopup"),
                windowClass: "modal auth-modal-popup",
                controller: function($scope) {
                    $scope.authDisplayInfo = {
                        popupScene: scene,
                        popupSubScene: subScene || scene,
                        args: args || ""
                    }, mAuthPopupOn = !0;
                }
            });
            return modalInstance.result.then(function() {
                mAuthPopupOn = !1, $rootScope.$broadcast("auth.modalPopupClosed");
            }), modalInstance;
        }
        function closeAuthModalPopup() {
            $uibModalStack.dismissAll(), mAuthPopupOn = !1;
        }
        function loadAccountStateForHouse(houseId) {
            var deferred = $q.defer();
            return ApiService.callApi("/account/getAccountStateForHouse", {
                houseId: houseId
            }).success(function(response) {
                (!mCurrentHouseAccountState.lastUpdate || new Date().getTime() - mCurrentHouseAccountState.lastUpdate > 5e3) && (mCurrentHouseAccountState.houseId = houseId), 
                mCurrentHouseAccountState.houseId == houseId && (setCurrentHouseAccountState(houseId, response.approvalState), 
                setMailingListApproved(houseId, response.mailingListApproved)), deferred.resolve(response.approvalState);
            }), deferred.promise;
        }
        function setCurrentHouseAccountState(houseId, approvalState, initalState) {
            mCurrentHouseAccountState.houseId = houseId;
            var previousState = mCurrentHouseAccountState.approvalState;
            mCurrentHouseAccountState.approvalState = approvalState, mCurrentHouseAccountState.lastUpdate = new Date().getTime(), 
            previousState == approvalState || initalState || $rootScope.$broadcast("auth.houseApprovalChanged", approvalState);
        }
        function setMailingListApproved(houseId, approved, initalState) {
            mCurrentHouseAccountState.houseId == houseId && (mCurrentHouseAccountState.mailingListApproved = approved, 
            initalState || $rootScope.$broadcast("auth.mailingListApprovalChanged", approved));
        }
        function isCurrentUserKnownAsApprovedToHouse(houseId) {
            var house = PortalInfoService.getHouse(houseId);
            return house && $rootScope.currentUser && $rootScope.currentUser.approvedHousesCodes ? -1 != $rootScope.currentUser.approvedHousesCodes.indexOf(house.code) : !1;
        }
        function isWaitingForApprovalInHouse(houseId) {
            var approvalState = getHouseApprovalState(houseId), house = PortalInfoService.getHouse(houseId);
            return !house || house.auctionBasedUserApproval ? !1 : "PENDING" == approvalState || "REJECTED" == approvalState;
        }
        function isMailingListApprovalRequired(houseId) {
            var approvalState = getHouseApprovalState(houseId);
            return "APPROVED" == approvalState ? 0 == mCurrentHouseAccountState.mailingListApproved : void 0;
        }
        function getHouseApprovalState(houseId) {
            return houseId && mCurrentHouseAccountState ? $rootScope.currentUser ? mCurrentHouseAccountState.houseId == houseId ? mCurrentHouseAccountState.approvalState : isCurrentUserKnownAsApprovedToHouse(houseId) ? "APPROVED" : "UNKNOWN" : "NOT_LOGGED_IN" : null;
        }
        function createTokenForAppSite(houseId, token) {
            return ApiService.callApi("/auth/createTokenForAppSite", {
                houseId: houseId,
                token: token
            });
        }
        function isAuthPopupOn() {
            return mAuthNavBarPopupOn || mAuthPopupOn;
        }
        function checkIfPendingHouseStateUpdate() {
            mCurrentHouseAccountState && isWaitingForApprovalInHouse(mCurrentHouseAccountState.houseId) && loadAccountStateForHouse(mCurrentHouseAccountState.houseId);
        }
        function getCurrentHouseAccountState() {
            return mCurrentHouseAccountState;
        }
        function loginWithAppSiteSession(house) {
            var deferred = $q.defer();
            window.addEventListener("message", function(event) {
                if ("bidspiritAppSiteInfo" == event.data.eventType) {
                    var sessionId = event.data.sessionId, email = event.data.email;
                    email && sessionId && ApiService.callApi("/auth/loginWithAppSiteSession", {
                        houseCode: house.code,
                        email: email,
                        appSiteSession: sessionId,
                        lang: $rootScope.currentLang,
                        region: $rootScope.currentRegion,
                        contentType: $rootScope.contentType
                    }).success(function(user) {
                        SessionsService.setSessionUser(user, !1), LocalStorageService.store("lastLoggedinEmail", email), 
                        $timeout(function() {
                            deferred.resolve();
                        }, 10);
                    });
                }
            }, !0);
            var iframe = angular.element("<iframe>").css({
                background: "red"
            });
            angular.element(document.body).append(iframe);
            var urlBase = PathsService.getAppSiteUrl(house.code) + "/html", url = urlBase + "/static/crossSubdomainInfo.html?" + window.location.host.split(".")[0] + "&nocache=" + new Date().getTime();
            return iframe.attr({
                src: url,
                height: 0
            }), deferred.promise;
        }
        var mTempAuthInfo = {}, mCurrentHouseAccountState = {}, mAuthPopupOn = !1, mAuthNavBarPopupOn = !1, mLoginFormDisplayed = !1;
        return $rootScope.$on("auth.upperNavPopupDisplay", function(event, navAuthPopupOn) {
            mAuthNavBarPopupOn = navAuthPopupOn;
        }), $rootScope.$on("auth.newSessionUser", function() {
            mCurrentHouseAccountState = {}, mTempAuthInfo = {}, PortalInfoService.udpateCachedSessionUser();
        }), $interval(checkIfPendingHouseStateUpdate, 12e4), {
            register: register,
            login: login,
            validateUserLoggedIn: validateUserLoggedIn,
            validateCompleteUserProfile: validateCompleteUserProfile,
            confirmEmail: confirmEmail,
            sendPasswordRecovery: sendPasswordRecovery,
            resendEmailConfirmationRequest: resendEmailConfirmationRequest,
            updateEmail: updateEmail,
            updatePassword: updatePassword,
            completeRegistration: completeRegistration,
            createTokenForAppSite: createTokenForAppSite,
            getTempAuthInfo: getTempAuthInfo,
            isLoginFormDisplayed: isLoginFormDisplayed,
            setLoginFormDisplayed: setLoginFormDisplayed,
            showAuthModalOrScene: showAuthModalOrScene,
            showAuthModalPopup: showAuthModalPopup,
            closeAuthModalPopup: closeAuthModalPopup,
            setCurrentHouseAccountState: setCurrentHouseAccountState,
            loadAccountStateForHouse: loadAccountStateForHouse,
            getHouseApprovalState: getHouseApprovalState,
            isWaitingForApprovalInHouse: isWaitingForApprovalInHouse,
            isCurrentUserKnownAsApprovedToHouse: isCurrentUserKnownAsApprovedToHouse,
            getCurrentHouseAccountState: getCurrentHouseAccountState,
            isMailingListApprovalRequired: isMailingListApprovalRequired,
            setMailingListApproved: setMailingListApproved,
            loginWithAppSiteSession: loginWithAppSiteSession,
            logout: logout,
            isAuthPopupOn: isAuthPopupOn
        };
    });
}), define("portal/js/modules/auth/authUpperNavigationController", [ "./portalAuthModule" ], function(module) {
    module.controller("AuthUpperNavigationController", [ "$rootScope", "$scope", "$timeout", "$state", "$transitions", "PortalAuthService", "PortalNavigationService", function($rootScope, $scope, $timeout, $state, $transitions, PortalAuthService, PortalNavigationService) {
        function shoudDisplayRegistrationWarning() {
            var user = $rootScope.currentUser;
            return user && "COMPLETE" != user.registrationStage;
        }
        function checkUserWarningDisplay() {
            shoudDisplayRegistrationWarning() ? ($rootScope.debug("set display registration warning timer"), 
            $timeout.cancel(mWarningPopupTimer), mWarningPopupTimer = $timeout(function() {
                if (shoudDisplayRegistrationWarning()) {
                    $rootScope.debug("display registration warning");
                    var stateName = $state.current.name;
                    "app.postRegistrationDetails" != stateName && "app.userDetails" != stateName && "app.auth" != stateName && $scope.setAuthScene("warning");
                }
            }, 1e3)) : $scope.hidePopup();
        }
        function onSessionUserChanged() {
            $scope.hidePopup(), checkUserWarningDisplay();
        }
        mWarningPopupTimer = null, mHideTimer = null, $scope.authDisplayInfo = {
            popupScene: null,
            popupSubScene: null,
            menuVisible: !1
        }, $rootScope.debugAuth = $scope.authDisplayInfo, $scope.setAuthScene = function(sceneName) {
            $scope.authDisplayInfo.popupScene = sceneName, $scope.setAuthSubScene(sceneName), 
            $scope.authDisplayInfo.menuVisible = !1, $rootScope.$broadcast("auth.upperNavPopupDisplay", !0);
        }, $scope.setAuthSubScene = function(subScene) {
            $scope.authDisplayInfo.popupSubScene = subScene;
        }, $scope.hidePopup = function() {
            $timeout.cancel(mWarningPopupTimer), $scope.authDisplayInfo.popupScene = null, $scope.authDisplayInfo.popupSubScene = null, 
            $rootScope.$broadcast("auth.upperNavPopupDisplay", !1);
        }, $scope.togglePopupView = function(popupAuthScene) {
            popupAuthScene == $scope.authDisplayInfo.popupScene ? $scope.hidePopup() : $scope.setAuthScene(popupAuthScene);
        }, $scope.setMenuVisiblity = function(menuVisibilty) {
            $timeout.cancel(mHideTimer), "warning" != $scope.authDisplayInfo.popupScene && ($scope.hidePopup(), 
            $scope.authDisplayInfo.menuVisible = menuVisibilty, $rootScope.$broadcast("auth.menuVisible", $scope.authDisplayInfo.menuVisible));
        }, $scope.hideMenuAfterDelay = function() {
            $timeout.cancel(mHideTimer), mHideTimer = $timeout(function() {
                $scope.setMenuVisiblity(!1);
            }, 100);
        }, $scope.linkText = PortalNavigationService.linkText, $scope.$on("auth.newSessionUser", onSessionUserChanged), 
        $scope.$on("auth.authStateChanged", checkUserWarningDisplay), $transitions.onSuccess({}, function() {
            $scope.hidePopup(), $scope.setMenuVisiblity(!1);
        }), $scope.$on("auth.modalPopupDisplay", function(event, isOn) {
            isOn && $scope.hidePopup();
        }), checkUserWarningDisplay();
    } ]);
}), define("portal/js/modules/auth/authModalPopupController", [ "./portalAuthModule" ], function(module) {
    module.controller("AuthModalPopupController", [ "$rootScope", "$scope", "$timeout", "$transitions", "$state", "PortalAuthService", function($rootScope, $scope, $timeout, $transitions, $state, PortalAuthService) {
        function close() {
            PortalAuthService.closeAuthModalPopup();
        }
        function init() {
            $rootScope.$broadcast("auth.modalPopupDisplay", !0), $scope.$on("auth.authStateChanged", close), 
            $scope.$on("auth.newSessionUser", close), $transitions.onSuccess({}, close);
        }
        $scope.setAuthScene = function(sceneName) {
            $scope.authDisplayInfo.popupScene = sceneName, $scope.setAuthSubScene(sceneName);
        }, $scope.setAuthSubScene = function(subScene) {
            $scope.authDisplayInfo.popupSubScene = subScene;
        }, $scope.titleKey = function() {
            switch ($scope.authDisplayInfo.popupScene) {
              case "login":
                return "login";

              case "warning":
              case "approval":
                return "notice";

              default:
                return "registeration";
            }
        }, init();
    } ]);
}), define("portal/js/modules/auth/authSceneController", [ "./portalAuthModule" ], function(module) {
    module.controller("AuthSceneController", [ "$scope", "$rootScope", "$state", "$stateParams", "PortalAuthService", "PortalNavigationService", function($scope, $rootScope, $state, $stateParams, PortalAuthService, PortalNavigationService) {
        function init() {
            var sceneName = $stateParams.authScene;
            if (!$rootScope.currentUser || "login" != sceneName && "register" != sceneName) {
                $scope.authDisplayInfo.authScene = sceneName, $scope.setAuthSubScene($stateParams.authSubScene || sceneName);
                var args = $stateParams.args;
                args && 0 == args.indexOf("{") && (args = JSON.parse(args)), $scope.authDisplayInfo.args = args, 
                PortalNavigationService.setBackFn(onBackPress);
            } else $state.go("app.home");
            window.scrollTo(0, 0);
        }
        function onBackPress() {
            $scope.authDisplayInfo.authSubScene != $scope.authDisplayInfo.authScene ? $scope.setAuthSubScene($scope.authDisplayInfo.authScene) : PortalNavigationService.goBack(!0);
        }
        function redirectUserToNextScene() {
            var user = $rootScope.currentUser;
            if (user && !user.shouldApproveLegal) switch (user.registrationStage) {
              case "UNCONFIRMED_EMAIL":
                $scope.setAuthScene("warning");
                break;

              case "INCOMPLETE_PROFILE":
                $scope.setAuthScene("postRegistrationDetails");
                break;

              case "COMPLETE":
                ("login" == $scope.authDisplayInfo.authScene || "warning" == $scope.authDisplayInfo.authScene) && ($rootScope.$previousState && "app.auth" != $rootScope.$previousState.name ? $state.go($rootScope.$previousState.name, $rootScope.$previousState.args) : $state.go("app.home"));
            }
        }
        function onAuthSceneChanged() {
            "postRegistrationDetails" != $scope.authDisplayInfo.authScene && $state.go("app.home");
        }
        $scope.authDisplayInfo = {
            authScene: null,
            authSubScene: null
        }, $scope.setAuthScene = function(authScene, arg) {
            $state.go("app.auth", {
                authScene: authScene,
                arg: arg
            });
        }, $scope.setAuthSubScene = function(subScene) {
            $scope.authDisplayInfo.authSubScene = subScene;
        }, $scope.titleKey = function() {
            switch ($scope.authDisplayInfo.authScene) {
              case "login":
                return "login";

              default:
                return "registeration";
            }
        }, $scope.$on("auth.newSessionUser", redirectUserToNextScene), $scope.$on("auth.authStateChanged", onAuthSceneChanged), 
        init();
    } ]);
}), define("portal/js/modules/auth/legalApprovalService", [ "./portalAuthModule" ], function(module) {
    module.factory("LegalApprovalService", function($rootScope, $document, $timeout, $state, $uibModal, $uibModalStack, $transitions, ApiService, PopupsService, SessionsService) {
        function checkLegalApproval() {
            var user = $rootScope.currentUser;
            user && user.shouldApproveLegal && "app.popupScene" != $state.$current.name && ($uibModalStack.dismissAll(), 
            PopupsService.showPopup({
                contentInclude: "auth/legalApproval/legalApprovalRequired",
                titleKey: "approve_terms",
                size: "sm",
                showLegalDoc: PopupsService.showLegalDocPopup,
                legalApprovalMessage: user.approvedLegalVersion ? "legal_reapproval_updated" : "legal_reapproval_first_time",
                code: "legalApproval",
                buttons: [ {
                    type: "default",
                    text: "i_dont_agree",
                    action: rejectLegalTerms
                }, {
                    type: "primary",
                    text: "i_agree",
                    action: acceptLegalTerms
                } ],
                unclosable: !0
            }), bindShowAgainOnEscape());
        }
        function bindShowAgainOnEscape() {
            mEscapeKeyHandled || (mEscapeKeyHandled = !0, $document.bind("keydown", function(evt) {
                27 === evt.which && $timeout(checkLegalApproval, 1e3);
            }));
        }
        function rejectLegalTerms() {
            ApiService.callApi("/auth/setLegalDocsApprovalState", {
                approvalState: "NOT_APPROVED"
            }).then(function() {
                $state.go("app.home"), SessionsService.setSessionUser(null), $uibModalStack.dismissAll(), 
                $timeout(function() {
                    PopupsService.showPopup({
                        contentInclude: "auth/legalApproval/legalTermsRejected",
                        titleKey: "approve_terms",
                        size: "sm",
                        code: "legalTermsRejected",
                        buttons: [ {
                            type: "primary",
                            text: "close",
                            isCloseButton: !0
                        } ]
                    });
                }, 1e3);
            });
        }
        function acceptLegalTerms() {
            ApiService.callApi("/auth/setLegalDocsApprovalState", {
                approvalState: "APPROVED"
            }).then(function() {
                $rootScope.currentUser.shouldApproveLegal = !1, $uibModalStack.dismissAll(), $rootScope.viewPort.mobileMedia && $state.go("app.home");
            });
        }
        function onNewSessionUser() {
            $rootScope.currentUser && checkLegalApproval();
        }
        function init() {
            $transitions.onSuccess({}, function() {
                $timeout(checkLegalApproval, 1e3);
            }), $rootScope.$on("auth.newSessionUser", onNewSessionUser);
        }
        return mEscapeKeyHandled = !1, {
            init: init,
            checkLegalApproval: checkLegalApproval
        };
    });
}), define("portal/js/modules/auth/login/portalLoginModule", [ "angular" ], function(ng) {
    return ng.module("app.auth.login", []);
}), define("portal/js/modules/auth/login/portalLoginController", [ "./portalLoginModule" ], function(module) {
    module.controller("PortalLoginController", [ "$scope", "$timeout", "$cookies", "StringsService", "LocalStorageService", "I18nService", "SessionsService", "LogService", "OsInfoService", "PortalAuthService", function($scope, $timeout, $cookies, StringsService, LocalStorageService, I18nService, SessionsService, LogService, OsInfoService, PortalAuthService) {
        $scope.loginInfo = {}, $scope.loginErrorVisible = !1, $scope.loginHelpVisible = !1, 
        $scope.passwordVisible = !1, $scope.focusOnPassword = !1, $timeout(function() {
            $scope.loginInfo = PortalAuthService.getTempAuthInfo();
            var invitedUserEmail = $cookies.get("invitedUserEmail");
            invitedUserEmail && ($scope.loginInfo.email = invitedUserEmail, $scope.loginInfo.remember = !0), 
            $scope.loginInfo.email || GlobalConfig.devEnv && ($scope.loginInfo = {
                email: "zemer@bidspirit.com",
                password: "zzzzzzz",
                remember: !1
            }), $scope.loginInfo.email || ($scope.loginInfo.email = LocalStorageService.load("lastLoggedinEmail"));
        }, 100), $scope.login = function() {
            return PortalAuthService.login($scope.loginInfo.email, $scope.loginInfo.password, I18nService.getCurrentLang(), $scope.currentRegion, $scope.loginInfo.remember).success(function(user) {
                user ? LogService.logMessage("Login success for email:" + $scope.loginInfo.email) : LogService.logError("Empty user response for email:" + $scope.loginInfo.email + ", password: " + StringsService.mask($scope.loginInfo.password));
            }).error(function(error) {
                LogService.logMessage("Login failed for email:" + $scope.loginInfo.email + ", password: " + StringsService.mask($scope.loginInfo.password) + " - " + JSON.stringify(error)), 
                $scope.loginErrorVisible = !0;
            });
        }, $scope.hideLoginError = function() {
            $scope.loginErrorVisible && ($scope.loginErrorVisible = !1, $scope.loginHelpVisible = !1);
        }, $scope.togglePasswordVisible = function() {
            $scope.passwordVisible = !$scope.passwordVisible, (!OsInfoService.isIos() || GlobalConfig.isMobileApp) && ($scope.focusOnPassword = !0, 
            $timeout(function() {
                $scope.focusOnPassword = !1;
            }, 100));
        }, $scope.$on("$destroy", function() {
            $scope.loginInfo.password = "";
        }), PortalAuthService.setLoginFormDisplayed();
    } ]);
}), define("portal/js/modules/auth/login/recoverPasswordController", [ "./portalLoginModule" ], function(module) {
    module.controller("RecoverPasswordController", [ "$rootScope", "$scope", "$timeout", "I18nService", "PathsService", "PortalAuthService", function($rootScope, $scope, $timeout, I18nService, PathsService, PortalAuthService) {
        function checkIfToSendPasswordOnInit() {
            if (!$rootScope.sentPassowrdOnInit) {
                var queryEmail = PathsService.getQueryParam("forgotPassword");
                queryEmail && ($scope.info.email = queryEmail, $scope.sendPassword(), $rootScope.sentPassowrdOnInit = !0);
            }
        }
        $scope.email = null, $scope.stage = 1, $scope.info = {}, $scope.data = {}, $scope.info = PortalAuthService.getTempAuthInfo(), 
        $scope.sendPassword = function() {
            return PortalAuthService.sendPasswordRecovery($scope.info.email).success(function() {
                $scope.stage = 2;
            }).error(function() {
                $scope.data.emailUnknown = !0;
            });
        }, checkIfToSendPasswordOnInit();
    } ]);
}), define("portal/js/modules/auth/login/index", [ "./portalLoginModule", "./portalLoginController", "./recoverPasswordController" ], function() {}), 
define("portal/js/modules/auth/register/registerModule", [ "angular" ], function(ng) {
    return ng.module("app.auth.register", []);
}), define("portal/js/modules/auth/register/registerController", [ "./registerModule" ], function(module) {
    module.controller("RegisterController", [ "$rootScope", "$scope", "$timeout", "LogService", "I18nService", "LocalStorageService", "OsInfoService", "DialogsService", "PortalInfoService", "PortalAuthService", "PopupsService", function($rootScope, $scope, $timeout, LogService, I18nService, LocalStorageService, OsInfoService, DialogsService, PortalInfoService, PortalAuthService, PopupsService) {
        function setRegistrationEnvInfo() {
            $scope.registrationInfo.lang = I18nService.getCurrentLang(), $scope.registrationInfo.region = $rootScope.currentRegion, 
            $scope.registrationInfo.catalogContentType = $rootScope.contentType;
            var acquisitionInfo = {
                initialReferer: LocalStorageService.load("initialReferer")
            };
            LocalStorageService.load("initialSource") ? acquisitionInfo.initialSource = LocalStorageService.load("initialSource") : GlobalConfig.isMobileApp && (acquisitionInfo.initialSource = "Mobile app (" + OsInfoService.osName() + ")"), 
            $scope.registrationInfo.acquisitionInfo = acquisitionInfo;
        }
        $scope.registrationInfo = {}, $scope.scrollToFisrtLine = !1, $timeout(function() {
            $scope.registrationInfo = PortalAuthService.getTempAuthInfo(), "dev" == GlobalConfig.envName && angular.extend($scope.registrationInfo, {
                firstName: "zzzz",
                lastName: "zzzz",
                email: "zemer@bidspirit.com",
                password: "zzzzzzz",
                passwordConfirm: "zzzzzzz",
                terms: !0,
                over18: !0
            }), window.innerHeight < 1e3 && "register" == $scope.authDisplayInfo.authScene && ($scope.scrollToFisrtLine = !0);
        }, 100), $scope.existingEmails = [], $scope.register = function() {
            return setRegistrationEnvInfo(), LogService.logEvent({
                attemptRegistration: $scope.registrationInfo.email
            }), PortalAuthService.register($scope.registrationInfo).success(function() {
                LogService.logEvent({
                    successRegistration: $scope.registrationInfo.email
                });
            }).error(function(error) {
                switch (LogService.logEvent({
                    failedRegistration: error.errorType
                }), error.errorType) {
                  case "ALREADY_EXISTS":
                    $scope.existingEmails.push($scope.registrationInfo.email), $timeout(function() {
                        $scope.registerForm.updateFieldsAttentions();
                    }, 150);
                    break;

                  case "OPTED_OUT":
                    DialogsService.showAlert({
                        title: "opted_out_user",
                        message: "opted_out_user_message"
                    });
                    break;

                  default:
                    $scope.showGeneralError();
                }
            });
        }, $scope.emailExists = function(email) {
            return -1 != $scope.existingEmails.indexOf(email);
        }, $scope.passwordConfirmedMatch = function() {
            var info = $scope.registrationInfo;
            return info.passwordConfirm == info.password ? !0 : !1;
        }, $scope.displayLoginLink = function() {
            return $scope.registerForm && $scope.registerForm.email ? $scope.registerForm.email.attentionTouch && $scope.registerForm.email.$error.exists : void 0;
        }, $scope.showTerms = function() {
            PopupsService.showLegalDocPopup("terms");
        }, $scope.$on("$destroy", function() {});
    } ]);
}), define("portal/js/modules/auth/register/postRegistrationDetailsController", [ "./registerModule" ], function(module) {
    module.controller("PostRegistrationDetailsController", [ "$rootScope", "$timeout", "$scope", "$state", "PortalAuthService", "UserDetailsService", function($rootScope, $timeout, $scope, $state, PortalAuthService, UserDetailsService) {
        function load() {
            $scope.userDetails = angular.copy($rootScope.currentUser), UserDetailsService.getUserDetails().success(function(details) {
                angular.extend($scope.userDetails, details), $scope.userDataLoaded = !0;
            });
        }
        function init() {
            $rootScope.currentUser ? load() : $timeout(function() {
                $rootScope.currentUser ? load() : $state.go("app.home");
            }, 2e3);
        }
        $scope.userDataLoaded = !1, $scope.formSubmitted = !1, $scope.save = function() {
            return PortalAuthService.completeRegistration($scope.userDetails).success(function(userDetails) {
                $scope.userDetails.addresses = userDetails.addresses, $scope.currentUser.phone = userDetails.phone, 
                $scope.currentUser.registrationStage = "COMPLETE", $scope.currentUser.residenceIsShipping = userDetails.shippingAddress.residenceIsShipping, 
                $scope.currentUser.company = userDetails.company, $scope.formSubmitted = !0, $rootScope.$broadcast("auth.authStateChanged"), 
                window.scrollTo(0, 0);
            });
        }, $scope.$on("auth.authStateChanged", function() {
            "COMPLETE" == $scope.currentUser.registrationStage && ($scope.formSubmitted = !0);
        }), $scope.$on("$destroy", function() {
            $scope.currentUser && ($scope.currentUser.justConfirmed = !1);
        }), init();
    } ]);
}), define("portal/js/modules/auth/register/authWarningController", [ "./registerModule" ], function(module) {
    module.controller("AuthWarningController", [ "$scope", "$rootScope", "$stateParams", "PortalAuthService", function($scope, $rootScope) {
        function init() {
            var user = $rootScope.currentUser;
            if (user) switch (user.registrationStage) {
              case "UNCONFIRMED_EMAIL":
                $scope.warning = "unconfirmedEmail";
                break;

              case "INCOMPLETE_PROFILE":
                $scope.warning = "incompleteProfile";
            }
        }
        init(), $scope.$on("auth.authStateChanged", init);
    } ]);
}), define("portal/js/modules/auth/register/index", [ "./registerModule", "./registerController", "./postRegistrationDetailsController", "./authWarningController" ], function() {}), 
define("portal/js/modules/auth/index", [ "./portalAuthModule", "./portalAuthService", "./authUpperNavigationController", "./authModalPopupController", "./authSceneController", "./legalApprovalService", "./login/index", "./register/index" ], function() {}), 
define("portal/js/modules/userDetails/userDetailsModule", [ "angular" ], function(ng) {
    return ng.module("app.userDetails", []);
}), define("portal/js/modules/userDetails/userDetailsController", [ "./userDetailsModule" ], function(module) {
    module.controller("UserDetailsController", [ "$scope", "$rootScope", "$state", "$filter", "$timeout", "ArraysService", "I18nService", "OsInfoService", "UserDetailsService", "PortalAuthService", function($scope, $rootScope, $state, $filter, $timeout, ArraysService, I18nService, OsInfoService, UserDetailsService) {
        function init() {
            $scope.currentUser ? (UserDetailsService.getUserDetails().success(function(userDetails) {
                $scope.data.savedDetails = userDetails, resetData(), initSections(), openEmailSectionIfUnconfirmed();
            }), $scope.$on("auth.newSessionUser", function() {
                $state.go("app.home");
            }), $scope.$watchCollection("opened", onSectionChanged)) : $state.go("app.home");
        }
        function onSectionChanged() {
            var newOpenSection = null;
            for (section in $scope.opened) $scope.opened[section] && (newOpenSection = section);
            newOpenSection != openedSection && (openedSection = newOpenSection, $scope.display = {});
        }
        function initSections() {
            var sections;
            sections = "COMPLETE" == $scope.currentUser.registrationStage ? [ "email", "password", "name", "phone", "company", "residence", "shipping", "english" ] : [ "email", "password", "name" ], 
            ArraysService.replaceContent($scope.sections, sections);
        }
        function resetData() {
            $scope.data.user = angular.copy($scope.currentUser), $scope.data.userDetails = angular.copy($scope.data.savedDetails);
        }
        function openEmailSectionIfUnconfirmed() {
            $scope.opened.email = "UNCONFIRMED_EMAIL" == $scope.currentUser.registrationStage ? !0 : !1;
        }
        function getPasswordSummry() {
            var lastUpdate = $scope.currentUser.lastPasswordUpdate;
            if (lastUpdate) {
                var updateTime = $filter("date")(lastUpdate, "HH:mm:ss");
                return I18nService.getText("user_details_password_updated_on", {
                    updateTime: updateTime
                });
            }
            return "********";
        }
        function englishInfoSummary() {
            return OsInfoService.isMobile() ? "" : $scope.currentUser.engFirstName ? $scope.currentUser.engFirstName + " " + $scope.currentUser.engLastName + ", " + $scope.currentUser.engShippingAddress : "";
        }
        function addressSummary(addressName) {
            if (OsInfoService.isMobile()) return "";
            if (!$scope.data.savedDetails) return "";
            var address = $scope.data.savedDetails[addressName + "Address"];
            if (!address) return "";
            var summary = "";
            return address.address && (summary += address.address + ", "), address.city && (summary += address.city + ", "), 
            address.state && (summary += address.state + ", "), address.country && (summary += address.country + ", "), 
            address.zipCode && (summary += address.zipCode + ", "), summary && (summary = summary.substr(0, summary.lastIndexOf(","))), 
            summary;
        }
        $scope.sections = [], $scope.data = {}, $scope.opened = {}, $scope.display = {};
        var openedSection = null;
        $scope.updateUserInfo = function(section) {
            return UserDetailsService.updateUserInfo($scope.data.user).success(function(user) {
                angular.extend($scope.currentUser, user), $scope.onUpdateDone(section);
            });
        }, $scope.updateResidenceAddress = function() {
            return UserDetailsService.updateAddress($scope.data.userDetails.residenceAddress).success(function(updatedAddress) {
                angular.extend($scope.data.savedDetails.residenceAddress, updatedAddress), $scope.onUpdateDone("residence");
            });
        }, $scope.updateShippingAddress = function() {
            var address = $scope.data.userDetails.shippingAddress;
            return UserDetailsService.updateAddress(address).success(function(updatedAddress) {
                angular.extend($scope.data.savedDetails.shippingAddress, updatedAddress), $scope.currentUser.residenceIsShipping = updatedAddress.residenceIsShipping, 
                $scope.onUpdateDone("shipping");
            });
        }, $scope.onUpdateDone = function(section) {
            $scope.opened[section] = !1, resetData(), "email" == section && openEmailSectionIfUnconfirmed(), 
            OsInfoService.isMobile() && window.scrollTo(0, 50);
        }, $scope.$on("userDetails.updateCanceled", function(event, section) {
            $scope.onUpdateDone(section);
        }), $scope.$on("auth.authStateChanged", function() {
            initSections(), openEmailSectionIfUnconfirmed();
        }), $scope.$on("auth.authStateChanged", function() {
            initSections(), openEmailSectionIfUnconfirmed();
        }), $scope.sectionNameKey = function(section) {
            if ($scope.opened[section]) return "";
            switch (section) {
              case "residence":
                return "residence_address";

              case "shipping":
                return "shipping_address";

              case "english":
                return "user_details_english";

              case "billing":
                return "credit_card";

              default:
                return section;
            }
        }, $scope.getSectionSummary = function(section) {
            if ($scope.opened[section]) return "";
            switch (section) {
              case "email":
                return $scope.currentUser.email;

              case "password":
                return getPasswordSummry();

              case "name":
                return $scope.currentUser.firstName + " " + $scope.currentUser.lastName;

              case "phone":
                return "<span dir='ltr'>" + $scope.currentUser.phone + "</span>";

              case "company":
                return $scope.currentUser.company;

              case "residence":
                return addressSummary("residence");

              case "shipping":
                return addressSummary($scope.currentUser.residenceIsShipping ? "residence" : "shipping");

              case "english":
                return englishInfoSummary();

              default:
                return "";
            }
        }, init();
    } ]);
}), define("portal/js/modules/userDetails/userDetailsService", [ "./userDetailsModule" ], function(module) {
    module.factory("UserDetailsService", function($rootScope, $q, ApiService, SessionsService, I18nService, PopupsService) {
        function getUserDetails() {
            return ApiService.callApi("/users/getUserDetails");
        }
        function updateUserInfo(user) {
            return ApiService.callApi("/users/updateUserInfo", user, "post");
        }
        function updateAddress(address) {
            return ApiService.callApi("/users/updateAddress", address, "post");
        }
        function getCurrentUserFeatureInfo(feature) {
            if (!$rootScope.currentUser) return null;
            var featuresInfo = $rootScope.currentUser.featuresInfo;
            featuresInfo || (featuresInfo = $rootScope.currentUser.featuresInfo = {});
            var featureInfo = featuresInfo[feature];
            return featureInfo || (featureInfo = featuresInfo[feature] = {}), featureInfo;
        }
        function checkIfEnglishDetailsNeeded(house) {
            var deferred = $q.defer(), user = $rootScope.currentUser;
            return user && !user.engFirstName && house.readableLang && user.detailsLang && house.readableLang != user.detailsLang && "en" != user.detailsLang ? PopupsService.showPopup({
                code: "requestEngDetails",
                contentInclude: "userDetails/engDetails/requestEngDetails",
                data: {
                    user: user,
                    house: house,
                    deferred: deferred
                }
            }) : deferred.resolve(), deferred.promise;
        }
        function updateEngDetails(engFirstName, engLastName, engShippingAddress) {
            return ApiService.callApi("/users/updateEngDetails", {
                engFirstName: engFirstName,
                engLastName: engLastName,
                engShippingAddress: engShippingAddress
            }).then(function() {
                $rootScope.currentUser.engFirstName = engFirstName, $rootScope.currentUser.engLastName = engLastName, 
                $rootScope.currentUser.engShippingAddress = engShippingAddress;
            });
        }
        function getCreditCardFormIframeUrl(auctionId) {
            return ApiService.callApi("/billing/getCreditCardFormIframeUrl", {
                lang: I18nService.getCurrentLang(),
                auctionId: auctionId
            });
        }
        function getUserCreditCardsInfo() {
            return ApiService.callApi("/billing/getUserCreditCardsInfo");
        }
        function deleteCreditCardInfo(creditCardId) {
            return ApiService.callApi("/billing/deleteCreditCardInfo", {
                creditCardId: creditCardId
            });
        }
        return {
            getUserDetails: getUserDetails,
            updateUserInfo: updateUserInfo,
            updateAddress: updateAddress,
            getCurrentUserFeatureInfo: getCurrentUserFeatureInfo,
            checkIfEnglishDetailsNeeded: checkIfEnglishDetailsNeeded,
            updateEngDetails: updateEngDetails,
            getCreditCardFormIframeUrl: getCreditCardFormIframeUrl,
            getUserCreditCardsInfo: getUserCreditCardsInfo,
            deleteCreditCardInfo: deleteCreditCardInfo
        };
    });
}), define("portal/js/modules/userDetails/editEmailDirective", [ "./userDetailsModule" ], function(module) {
    module.directive("bsEditEmail", function($rootScope, AsyncButtonService, StringsService, PathsService, I18nService, DomUtilsService, PortalAuthService) {
        return {
            restrict: "E",
            replace: !0,
            scope: {},
            link: function(scope, element) {
                function setError(messageKey, args) {
                    scope.errorMessage = I18nService.getText(messageKey, args), DomUtilsService.addCssClassTemporarily(element[0].querySelector(".error-message.blinkable"), "blink", 2e3, 1500);
                }
                function validateEmail() {
                    return scope.data.email ? StringsService.isValidEmailAddress(scope.data.email) ? !0 : (setError("error_bad_email"), 
                    !1) : (setError("error_mandatory", {
                        field: "email"
                    }), !1);
                }
                scope.currentLang = $rootScope.currentLang, scope.sendingConfirmationAgain = !1, 
                scope.sentConfirmationAgain = !1, scope.stage = "UNCONFIRMED_EMAIL" == $rootScope.currentUser.registrationStage ? "not_confirmed" : "edit", 
                scope.data = {
                    email: $rootScope.currentUser.email
                }, scope.notConfirmedTitle = "email_not_confirmed", $rootScope.currentUser.justRegistered && (scope.notConfirmedTitle = "email_not_confirmed_title_post_register", 
                $rootScope.currentUser.justRegistered = !1), scope.clearError = function() {
                    scope.errorMessage = null;
                }, scope.sendEmailConfirmationAgain = function() {
                    scope.sendingConfirmationAgain || (scope.sentConfirmationAgain = !1, scope.sendingConfirmationAgain = !0, 
                    PortalAuthService.resendEmailConfirmationRequest().success(function() {
                        scope.sentConfirmationAgain = !0, scope.sendingConfirmationAgain = !1;
                    }));
                }, scope.getEmail = function() {
                    return $rootScope.currentUser.email;
                }, scope.updateEmail = function() {
                    if ($rootScope.currentUser.email != scope.data.email) {
                        if (!validateEmail()) return;
                        return PortalAuthService.updateEmail(scope.data.email).success(function() {
                            $rootScope.currentUser.email = scope.data.email, $rootScope.currentUser.registrationStage = "UNCONFIRMED_EMAIL", 
                            scope.stage = "not_confirmed", scope.notConfirmedTitle = "email_updated", scope.$emit("auth.authStateChanged");
                        }).error(function(error) {
                            switch (error.errorType) {
                              case "ALREADY_EXISTS":
                                setError("error_email_exists");
                            }
                        });
                    }
                    return scope.cancelEdit(), AsyncButtonService.fakeSuccess("changeEmail");
                }, scope.cancelEdit = function() {
                    "UNCONFIRMED_EMAIL" == $rootScope.currentUser.registrationStage && (scope.stage = "not_confirmed"), 
                    scope.data.email = $rootScope.currentUser.email, scope.$emit("userDetails.updateCanceled", "email");
                };
            },
            templateUrl: PathsService.appTemplatePath("userDetails/reusableElements/editEmail")
        };
    });
}), define("portal/js/modules/userDetails/addressDirective", [ "./userDetailsModule" ], function(module) {
    module.directive("bsUserDetailsAddress", function($q, PathsService, FormConstants) {
        return {
            restrict: "E",
            scope: {
                address: "="
            },
            link: function(scope) {
                scope.bsValidationPatterns = FormConstants.validationPatterns;
            },
            templateUrl: PathsService.appTemplatePath("userDetails/reusableElements/address")
        };
    });
}), define("portal/js/modules/userDetails/editEngDetails", [ "./userDetailsModule" ], function(module) {
    module.directive("bsEditEngDetails", function($rootScope, PathsService, I18nService, DomUtilsService, FormConstants, UserDetailsService) {
        return {
            restrict: "E",
            replace: !0,
            scope: {
                deferred: "=",
                closeFn: "&"
            },
            link: function(scope) {
                function getFieldErrorKey(field, alphaOnly) {
                    var val = scope.data[field];
                    return val ? val.length < 2 ? "error_bad_pattern" : "en" != I18nService.guessLangauge(val) ? "error_must_be_in_english" : alphaOnly && !val.match(FormConstants.validationPatterns.alpha) ? "error_must_be_in_english" : void 0 : "error_mandatory";
                }
                function validateField(field, fieldName, alphaOnly) {
                    var errorKey = getFieldErrorKey(field, alphaOnly);
                    return errorKey ? (scope.error[field] = I18nService.getText(errorKey, {
                        field: fieldName
                    }), !1) : (scope.error[field] = null, !0);
                }
                function validate() {
                    if (GlobalConfig.hackMode) return !0;
                    var valid = !0;
                    return validateField("engFirstName", "user_details_eng_first_name", !0) || (valid = !1), 
                    validateField("engLastName", "user_details_eng_last_name", !0) || (valid = !1), 
                    validateField("engShippingAddress", "user_details_eng_shipping_address") || (valid = !1), 
                    valid;
                }
                scope.currentLang = $rootScope.currentLang;
                var user = $rootScope.currentUser;
                scope.data = {
                    engFirstName: user.engFirstName,
                    engLastName: user.engLastName,
                    engShippingAddress: user.engShippingAddress
                }, scope.error = {}, scope.submit = function() {
                    validate() && UserDetailsService.updateEngDetails(scope.data.engFirstName, scope.data.engLastName, scope.data.engShippingAddress).then(function() {
                        scope.closeFn(), scope.deferred && scope.deferred.resolve();
                    });
                }, scope.cancel = function() {
                    scope.closeFn();
                };
            },
            templateUrl: PathsService.appTemplatePath("userDetails/reusableElements/editEngDetails")
        };
    });
}), define("portal/js/modules/userDetails/passwordUpdateController", [ "./userDetailsModule" ], function(module) {
    module.controller("PasswordUpdateController", [ "$scope", "$timeout", "PortalAuthService", function($scope, $timeout, PortalAuthService) {
        function initData() {
            $scope.data = {}, $scope.wrongPasswords = [];
        }
        $scope.updatePassword = function() {
            return PortalAuthService.updatePassword($scope.data.existingPassword, $scope.data.newPassword).success(function() {
                $scope.currentUser.lastPasswordUpdate = new Date(), $scope.updateDone();
            }).error(function(error) {
                "BAD_CREDENTIALS" == error.errorType && $scope.wrongPasswords.push($scope.data.existingPassword);
            });
        }, $scope.updateDone = function() {
            $scope.onUpdateDone("password"), initData();
        }, $scope.wrongPassword = function(password) {
            return -1 != $scope.wrongPasswords.indexOf(password);
        }, $scope.passwordConfirmedMatch = function() {
            return $scope.data.passwordConfirm == $scope.data.newPassword ? !0 : !1;
        }, initData();
    } ]);
}), define("portal/js/modules/userDetails/editCreditCardDetailsDirective", [ "./userDetailsModule" ], function(module) {
    module.directive("bsEditCreditCardDetails", function($q, $rootScope, $timeout, PathsService, DialogsService, UserDetailsService, OsInfoService) {
        return {
            restrict: "E",
            scope: {
                address: "=",
                auctionId: "=",
                newWindow: "="
            },
            link: function(scope, element) {
                function waitForIframeToLoad() {
                    var iframe = angular.element(element[0].querySelector("iframe"));
                    iframe.on("load", function() {
                        $timeout(function() {
                            scope.data.iframeLoaded = !0;
                        }, 10);
                    });
                }
                function loadCreditCardIframe() {
                    scope.data.iframeUrl = null, scope.data.iframeLoaded = !1, UserDetailsService.getCreditCardFormIframeUrl(scope.auctionId).then(function(response) {
                        $rootScope.viewPort.mobileMedia ? (scope.data.iframeWidth = 460, scope.data.iframeHeight = 800, 
                        OsInfoService.isAndroid() && GlobalConfig.isMobileApp && (scope.data.iframeWidth = 400, 
                        scope.data.iframeHeight = 850, OsInfoService.getAndroidVersion() >= 8 && (scope.data.iframeWidth = 460, 
                        scope.data.iframeHeight = 1e3))) : (scope.data.iframeWidth = 520, scope.data.iframeHeight = 340), 
                        $rootScope.resizeBloced = !0, GlobalConfig.devEnv, scope.data.iframeUrl = response.data.val, 
                        waitForIframeToLoad();
                    });
                }
                scope.data = {};
                scope.$on("bidspiritIframeEvent.creditCardError", function() {
                    $rootScope.$broadcast("creditCard.error"), DialogsService.showAlert("user_details_credit_card_error").then(loadCreditCardIframe);
                }), scope.$on("bidspiritIframeEvent.creditCardSaved", function() {
                    $rootScope.$broadcast("creditCard.saved");
                }), scope.$on("bidspiritIframeEvent.creditCardCancelled", function() {
                    $rootScope.$broadcast("creditCard.cancelled");
                }), loadCreditCardIframe();
            },
            templateUrl: PathsService.appTemplatePath("userDetails/reusableElements/editCreditCardDetails")
        };
    });
}), define("portal/js/modules/userDetails/billingInfoController", [ "./userDetailsModule" ], function(module) {
    module.controller("BillingInfoController", [ "$scope", "$rootScope", "$state", "$timeout", "DialogsService", "I18nService", "OsInfoService", "UserDetailsService", "PortalAuthService", function($scope, $rootScope, $state, $timeout, DialogsService, I18nService, OsInfoService, UserDetailsService) {
        function init() {
            loadBillingInfo();
        }
        function loadBillingInfo() {
            $scope.data.billingInfoInfoLoaded = !1, UserDetailsService.getUserCreditCardsInfo().then(function(response) {
                $scope.data.creditCardsInfo = response.data, $scope.data.billingInfoInfoLoaded = !0;
            });
        }
        $scope.showCreditCardForm = function() {
            $scope.display.showCreditCardForm = !0;
        }, $scope.deleteCreditCardInfo = function(creditCardId) {
            return DialogsService.showConfirm({
                message: "user_details_credit_card_confirm_remove",
                title: "notice"
            }).then(function(confirmed) {
                confirmed && UserDetailsService.deleteCreditCardInfo(creditCardId).then(function() {
                    $rootScope.currentUser.hasValidCreditCard = !1, loadBillingInfo();
                });
            });
        }, $scope.$on("creditCard.saved", function() {
            $scope.display.showCreditCardSaved = !0, $scope.display.showCreditCardForm = !1, 
            $timeout(function() {
                $scope.display.showCreditCardSaved = !1, $rootScope.currentUser.hasValidCreditCard = !0, 
                $scope.data.creditCardsInfo, loadBillingInfo();
            }, 3e3);
        }), init();
    } ]);
}), define("portal/js/modules/userDetails/index", [ "./userDetailsModule", "./userDetailsController", "./userDetailsService", "./editEmailDirective", "./addressDirective", "./editEngDetails", "./passwordUpdateController", "./editCreditCardDetailsDirective", "./billingInfoController" ], function() {}), 
define("portal/js/modules/alerts/userAlertsModule", [ "angular" ], function(ng) {
    return ng.module("app.userAlerts", []);
}), define("portal/js/modules/alerts/userAlertsController", [ "./userAlertsModule" ], function(module) {
    module.controller("UserAlertsController", [ "$scope", "$timeout", "$rootScope", "$state", "$stateParams", "ArraysService", "CatalogUtilsService", "CatalogsService", "PortalAuthService", "PortalInfoService", "UserAlertsService", "AccountService", function($scope, $timeout, $rootScope, $state, $stateParams, ArraysService, CatalogUtilsService, CatalogsService, PortalAuthService, PortalInfoService, UserAlertsService, AccountService) {
        function init() {
            $scope.currentUser ? ($scope.data = $scope.currentUser.alertsPreferences && $scope.currentUser.alertsPreferences[$rootScope.contentType] ? angular.copy($scope.currentUser.alertsPreferences[$rootScope.contentType]) : {
                userId: $scope.currentUser.id,
                housesToAlert: [],
                housesAlertChoice: null,
                catalogContentType: $rootScope.contentType
            }, $scope.enableAlerts = !0, $scope.data.region = $rootScope.currentRegion, $scope.houses = PortalInfoService.getAllHouses(), 
            $scope.saved = !1, $scope.setChoice($scope.data.housesAlertChoice), $stateParams.houseCode && ($scope.setChoice("SOME_HOUSES_ALERTS"), 
            ArraysService.addIfNotExists($scope.data.housesToAlert, $stateParams.houseCode)), 
            $scope.auctions = PortalInfoService.getAllFutureAuctions()) : $timeout(initIfLoggedIn, 2e3), 
            $scope.$on("auth.modalPopupClosed", initIfLoggedIn), $scope.$on("auth.newSessionUser", init);
        }
        function initIfLoggedIn() {
            $scope.currentUser ? init() : PortalAuthService.showAuthModalOrScene("login");
        }
        function loadItemAlerts() {
            AccountService.searchSelfAccountActions("ITEM_ALERT", null, !0, null, "FUTURE", 1e3, 1).then(function(response) {
                $scope.itemsWithAlerts = response.items, CatalogsService.setItemsCatalogInfo($scope.itemsWithAlerts), 
                CatalogUtilsService.sortLots($scope.itemsWithAlerts), angular.forEach($scope.itemsWithAlerts, function(item) {
                    item.itemAlertOn = !0, item.houseBadge = CatalogUtilsService.getHouseBadgeForLot(item);
                });
            });
        }
        $scope.opened = {
            catalogs: !0,
            auctionsStart: !1,
            itemAlerts: !1
        }, $scope.setChoice = function(choice) {
            $scope.data.housesAlertChoice = choice;
        }, $scope.save = function() {
            UserAlertsService.updateAlertsPreferences($scope.data).success(function(preferences) {
                $scope.data = preferences, $scope.currentUser.alertsPreferences = preferences, $scope.saved = !0, 
                window.scroll(0, 0);
            });
        }, $scope.closeAll = function() {
            for (section in $scope.opened) $scope.opened[section] = !1;
            $scope.saved = !1;
        }, $scope.$watch("opened.itemAlerts", function(isOpen) {
            isOpen && loadItemAlerts();
        }), init();
    } ]);
}), define("portal/js/modules/alerts/userAlertsService", [ "./userAlertsModule" ], function(module) {
    module.factory("UserAlertsService", function($rootScope, $uibModal, $timeout, ApiService, PopupsService, AnalyticsService, ArraysService, PathsService, AccountService, UserDetailsService, PortalAuthService, PortalInfoService, MobilePushService) {
        function showInstallApp(messageKey, messageCode) {
            if (!GlobalConfig.isMobileApp) {
                {
                    $rootScope.currentUser;
                }
                PopupsService.showInstallAppPopup(messageKey, messageCode), setPushNotificationRequested();
            }
        }
        function updateAlertsPreferences(preferences) {
            return ApiService.callApi("/users/updateAlertsPreferences", preferences, "post");
        }
        function setPushNotificationRequested() {
            var user = $rootScope.currentUser;
            "NOT_REQUESTED" == user.pushNotificationRequestState && (ApiService.callApi("/users/setPushNotificationRequested"), 
            user.pushNotificationRequestState = "REQUESTED");
        }
        function updateNotifiedAuction(auctionId, isOn) {
            if ($rootScope.currentUser) {
                for (var oldNotifiedAuctions = $rootScope.currentUser.auctionsToNotifyStart || [], newNotifiedAuctions = isOn ? [ auctionId ] : [], i = 0; i < oldNotifiedAuctions.length; i++) {
                    var otherAuctionId = oldNotifiedAuctions[i], auction = PortalInfoService.getAuction(otherAuctionId), oldAuction = !auction || "ENDED" == auction.state;
                    oldAuction || auctionId == otherAuctionId || newNotifiedAuctions.push(otherAuctionId);
                }
                ApiService.callApi("/users/updateAuctionsToNotifyStart", {
                    auctionsToNotifyStart: newNotifiedAuctions
                }).then(function() {
                    $rootScope.currentUser.auctionsToNotifyStart = newNotifiedAuctions, updateLastActivate("AUCTION_START_ALERT"), 
                    setPushNotificationRequested();
                });
            }
        }
        function confirmFirstAlert(messageKey, onConfirm) {
            $uibModal.open({
                templateUrl: PathsService.appTemplatePath("alerts/popups/confirmFirstAlertPopup"),
                windowClass: "confirm-first-alert",
                controller: function($scope) {
                    $scope.messageKey = messageKey, $scope.onConfirm = function() {
                        GlobalConfig.isMobileApp && MobilePushService.registerForPushNotification(), onConfirm(), 
                        $scope.$close();
                    };
                }
            });
        }
        function isItemAlertEnabled(lot) {
            if (!PortalInfoService.isMobileAppSupported()) return !1;
            var auction = lot.auction;
            return !auction || "ENDED" == auction.state || auction.catalogOnly || auction.absenteeBidsOnly ? !1 : !0;
        }
        function setAuctionStartAlert(auction, isOn) {
            if (isAuctionStartAlertEditable(auction)) {
                AnalyticsService.trackDailyUniqueAuctionEvent(auction, "userAlerts", "toggleAuctionStartClicked");
                var user = PortalAuthService.validateUserLoggedIn();
                user && (user.userDevices && user.userDevices.length > 0 ? isOn && !UserDetailsService.getCurrentUserFeatureInfo("AUCTION_START_ALERT").lastActivated ? confirmFirstAlert("first_auction_alert_message", function() {
                    updateNotifiedAuction(auction.id, isOn);
                }) : updateNotifiedAuction(auction.id, isOn) : showInstallApp("app_install_alert_title_auction", "app_install_alert_message"));
            }
        }
        function updateLastActivate(featureName) {
            UserDetailsService.getCurrentUserFeatureInfo(featureName).lastActivated = new Date().getTime();
        }
        function isAuctionStartAlertOn(auction) {
            var user = $rootScope.currentUser;
            return user && auction ? ArraysService.contains(user.auctionsToNotifyStart, auction.id) : !1;
        }
        function isAuctionStartAlertEditable(auction) {
            return PortalInfoService.getMinutesUntilAuction(auction) > 0;
        }
        function updateAlertInAccount(item, isOn) {
            AccountService.setItemAlert(item, isOn).then(function() {
                updateLastActivate("ITEM_ALERT"), setPushNotificationRequested();
            }), isOn && item.house && AnalyticsService.trackEvent("userAlerts", "itemAlert", "item alert in house: " + item.house.code + ", auction:" + item.auctionDate + ", item:" + item.itemIndex);
        }
        function setItemAlert(item, isOn) {
            AnalyticsService.trackDailyUniqueAuctionEvent(item.auction, "userAlerts", "toggleItemAlertClicked");
            var user = PortalAuthService.validateUserLoggedIn();
            user && (user.userDevices && user.userDevices.length > 0 ? isOn && !UserDetailsService.getCurrentUserFeatureInfo("ITEM_ALERT").lastActivated ? confirmFirstAlert("first_item_alert_message", function() {
                updateAlertInAccount(item, isOn), UserDetailsService.getCurrentUserFeatureInfo("ITEM_ALERT").lastActivated = new Date().getTime();
            }) : updateAlertInAccount(item, isOn) : showInstallApp("app_install_alert_title_item", "app_install_alert_message"));
        }
        function setItemAlertAfterDelay(item, isOn, delay) {
            $timeout(function() {
                setItemAlert(item, isOn);
            }, delay);
        }
        function checkUnsubscriptionLink() {
            var unsubscribeEmail = PathsService.getQueryParam("unsubscribeEmail"), safetyToken = PathsService.getQueryParam("st");
            unsubscribeEmail && ApiService.callApi("/users/getUserDetailsForUnsubscription", {
                email: unsubscribeEmail,
                safetyToken: safetyToken,
                region: $rootScope.currentRegion
            }).then(function(info) {
                var data = info.data;
                data.alertConfiguration && "NO_HOUSES_ALERTS" != data.alertConfiguration.housesAlertChoice && displayUnsubscriptionConfirmationPopup(unsubscribeEmail, safetyToken, data.name);
            });
        }
        function displayUnsubscriptionConfirmationPopup(email, safetyToken, name) {
            $uibModal.open({
                templateUrl: PathsService.appTemplatePath("alerts/popups/confirmUnsubscriptionPopup"),
                windowClass: "confirm-first-alert",
                controller: function($scope) {
                    $scope.name = name, $scope.onConfirm = function() {
                        ApiService.callApi("/users/unsubscribeFromAlerts", {
                            email: email,
                            safetyToken: safetyToken,
                            region: $rootScope.currentRegion
                        }).then(function() {
                            $scope.removed = !0;
                        });
                    }, $scope.$on("modal.closing", function() {
                        window.location.href = PathsService.getLocationWithoutParams([ "unsubscribeEmail", "st" ]);
                    });
                }
            });
        }
        return {
            showInstallApp: showInstallApp,
            updateAlertsPreferences: updateAlertsPreferences,
            isAuctionStartAlertOn: isAuctionStartAlertOn,
            setAuctionStartAlert: setAuctionStartAlert,
            isAuctionStartAlertEditable: isAuctionStartAlertEditable,
            setItemAlert: setItemAlert,
            isItemAlertEnabled: isItemAlertEnabled,
            setItemAlertAfterDelay: setItemAlertAfterDelay,
            setPushNotificationRequested: setPushNotificationRequested,
            checkUnsubscriptionLink: checkUnsubscriptionLink
        };
    });
}), define("portal/js/modules/alerts/index", [ "./userAlertsModule", "./userAlertsController", "./userAlertsService" ], function() {}), 
define("portal/js/modules/info/infoScenesModule", [ "angular" ], function(ng) {
    return ng.module("app.info", [ "app.info.contact", "app.info.product", "app.info.about", "app.info.helpScreen" ]);
}), define("portal/js/modules/info/contact/contactModule", [ "angular" ], function(ng) {
    return ng.module("app.info.contact", []);
}), define("portal/js/modules/info/contact/contactController", [ "./contactModule" ], function(module) {
    module.controller("ContactController", [ "$rootScope", "$scope", "$q", "$state", "LocalStorageService", "PortalInfoService", "SettingsService", "I18nService", "PortalMobileUtils", function($rootScope, $scope, $q, $state, LocalStorageService, PortalInfoService) {
        function isDebugCode(message) {
            return 0 == message.toLowerCase().indexOf("d") && 1 * message.charAt(1) > 0;
        }
        $scope.contact = {
            region: $rootScope.currentRegion,
            contentType: $rootScope.contentType,
            lastVisitedLot: LocalStorageService.load("lastVisitedLot")
        }, $scope.send = function() {
            return $scope.contact.lang = $rootScope.currentLang, PortalInfoService.sendContactRequest($scope.contact).success(function() {
                $state.go(".thanks"), window.scroll(0, 0);
            });
        }, $scope.gotoContactForSale = function() {
            $state.go("app.contactForSale");
        }, $scope.sendDebugInfo = function() {
            var message = $scope.contact.message;
            return $scope.contact.lang = $rootScope.currentLang, isDebugCode(message) ? (PortalInfoService.sendDebugInfo(message, "Contact request").then(function() {
                $scope.contact.message = "Thanks.";
            }), !0) : !1;
        }, $rootScope.currentUser && ($scope.contact.email = $rootScope.currentUser.email, 
        $scope.contact.name = $rootScope.currentUser.firstName + " " + $rootScope.currentUser.lastName, 
        $scope.contact.phone = $rootScope.currentUser.phone);
    } ]);
}), define("portal/js/modules/info/contact/contactForSaleController", [ "./contactModule" ], function(module) {
    module.controller("ContactForSaleController", [ "$rootScope", "$scope", "$q", "$state", "DomUtilsService", "OsInfoService", "ArraysService", "LocalStorageService", "PortalInfoService", "SettingsService", "I18nService", "PortalMobileUtils", function($rootScope, $scope, $q, $state, DomUtilsService, OsInfoService, ArraysService, LocalStorageService, PortalInfoService) {
        function debug() {}
        switch ($scope.contact = {
            region: $rootScope.currentRegion,
            contentType: $rootScope.contentType
        }, $scope.upladedImagesInfo = [], $scope.send = function() {
            return $scope.contact.lang = $rootScope.currentLang, $scope.contact.images = ArraysService.getAttributesList($scope.upladedImagesInfo, "url"), 
            PortalInfoService.sendContactRequestForSale($scope.contact).success(function() {
                window.scroll(0, 0), $scope.showThanks = !0;
            });
        }, $scope.addPicFromResponse = function(response) {
            debug(response.data);
            for (var uploadedImages = response.data, i = 0; i < uploadedImages.length; i++) {
                var imageUrl = uploadedImages[i], pendingImage = ArraysService.getByKey($scope.upladedImagesInfo, "pending", !0);
                !function(image, imageSrc) {
                    image.pending = !1, DomUtilsService.loadImage(imageSrc, 1e3, 100).then(function() {
                        image.url = imageSrc;
                    });
                }(pendingImage, imageUrl);
            }
        }, $scope.removeImage = function(image) {
            ArraysService.remove($scope.upladedImagesInfo, image);
        }, $scope.allowMultiple = !0, $scope.addPendingPic = function(info) {
            for (var i = 0; i < info.length; i++) $scope.upladedImagesInfo.push({
                pending: !0
            }), info[i] && debug(info[i].name + "," + info[i].size + "\n");
        }, $scope.handleError = function(response) {
            debug("Error: " + response.data);
        }, $rootScope.currentUser && ($scope.contact.email = $rootScope.currentUser.email, 
        $scope.contact.name = $rootScope.currentUser.firstName + " " + $rootScope.currentUser.lastName, 
        $scope.contact.phone = $rootScope.currentUser.phone), $rootScope.contentType) {
          case "CARS":
            $scope.titleTextKey = "sell_your_car", $scope.line1Key = "contact_for_car_sale_message_line_1", 
            $scope.descriptionKey = "contact_for_car_sale_description";
            break;

          case "REAL_ESTATE":
            $scope.titleTextKey = "sell_real_estate", $scope.line1Key = "contact_for_real_estate_sale_message_line_1", 
            $scope.descriptionKey = "real_estate_description";
            break;

          default:
            $scope.titleTextKey = "selling_items", $scope.line1Key = "contact_for_sale_message_line_1", 
            $scope.descriptionKey = "lot_description";
        }
    } ]);
}), define("portal/js/modules/info/contact/index", [ "./contactModule", "./contactController", "./contactForSaleController" ], function() {}), 
define("portal/js/modules/info/product/productModule", [ "angular" ], function(ng) {
    return ng.module("app.info.product", []);
}), define("portal/js/modules/info/product/productController", [ "./productModule" ], function(module) {
    module.controller("ProductController", [ "$scope", "$rootScope", "ArraysService", "PortalInfoService", "AppSiteWinodwsService", function($scope, $rootScope, ArraysService, PortalInfoService, AppSiteWinodwsService) {
        function init() {
            $scope.mainFeature = {}, PortalInfoService.getProductInfo().success(function(productInfo) {
                $scope.features = productInfo.features, ArraysService.setPropertyFromMapById($scope.features, "resources", productInfo.resources, {}), 
                angular.copy(ArraysService.getByKey($scope.features, "code", "main"), $scope.mainFeature);
            });
        }
        $scope.showDemo = function(demoCode) {
            AppSiteWinodwsService.showDemo(demoCode);
        }, init();
    } ]);
}), define("portal/js/modules/info/product/index", [ "./productModule", "./productController" ], function() {}), 
define("portal/js/modules/info/about/aboutModule", [ "angular" ], function(ng) {
    return ng.module("app.info.about", []);
}), define("portal/js/modules/info/about/aboutController", [ "./aboutModule" ], function(module) {
    module.controller("AboutController", [ "$scope", "I18nService", function($scope, I18nService) {
        $scope.versionInfo = GlobalConfig.isMobileApp ? "Version: " + (GlobalConfig.mobileAppVersion || "") + " (" + GlobalConfig.appVersion + ")" : "Version: " + GlobalConfig.appVersion, 
        $scope.contentAwareText = function(textKey) {
            return "CARS" == $scope.contentType && (textKey += "_cars"), I18nService.getText(textKey);
        };
    } ]);
}), define("portal/js/modules/info/about/index", [ "./aboutModule", "./aboutController" ], function() {}), 
define("portal/js/modules/info/helpScreens/helpScreensModule", [ "angular" ], function(ng) {
    return ng.module("app.info.helpScreen", []);
}), define("portal/js/modules/info/helpScreens/helpScreensController", [ "./helpScreensModule" ], function(module) {
    module.controller("HelpScreensController", [ "$scope", "$rootScope", "$stateParams", "ArraysService", "PortalInfoService", "PortalAuthService", "SearchService", "AppSiteWinodwsService", function($scope, $rootScope, $stateParams, ArraysService, PortalInfoService, PortalAuthService, SearchService, AppSiteWinodwsService) {
        function setScreenshot() {
            $scope.sceenshot = $scope.data.helpScreensInfo.resources[$scope.helpScreen.id][$rootScope.currentLang];
        }
        function init() {
            $scope.code = {}, PortalInfoService.getHelpScreensInfo("screen").success(function(helpScreensInfo) {
                $scope.data.helpScreensInfo = helpScreensInfo, $scope.helpScreen = ArraysService.getByKey(helpScreensInfo.screens, "code", "screen_" + $stateParams.code), 
                ArraysService.setPropertyFromMapById($scope.helpScreens, "resources", helpScreensInfo.resources, {}), 
                setScreenshot();
            });
        }
        $scope.data = {}, $scope.showDemo = function(demoCode) {
            AppSiteWinodwsService.showDemo(demoCode);
        }, $scope.doSearch = function() {
            SearchService.gotoSearchScene($scope.data.searchToken);
        }, $scope.showRegistration = function() {
            PortalAuthService.showAuthModalOrScene("register");
        }, init();
    } ]);
}), define("portal/js/modules/info/helpScreens/faqController", [ "./helpScreensModule" ], function(module) {
    module.controller("FaqController", [ "$scope", "$rootScope", "$stateParams", "PathsService", "ArraysService", "PortalInfoService", "PortalAuthService", "SearchService", "AppSiteWinodwsService", function($scope, $rootScope, $stateParams, PathsService, ArraysService, PortalInfoService) {
        function parseGroups(faqs) {
            $scope.data.groups = {};
            for (var i = 0; i < faqs.length; i++) {
                var faq = faqs[i], groupCode = faq.code.split("_")[1], groupFaqs = $scope.data.groups[groupCode];
                groupFaqs || (groupFaqs = [], $scope.data.groups[groupCode] = groupFaqs), faq.location = window.location.href, 
                groupFaqs.push(faq), $scope.data.answerVisible[faq.code] = !1;
            }
        }
        function init() {
            $scope.code = {}, PortalInfoService.getHelpScreensInfo("faq").success(function(response) {
                parseGroups(response.screens);
                var code = $stateParams.code;
                $scope.data.answerVisible[code] = !0, $scope.data.scrollTo = code;
            });
        }
        $scope.data = {
            answerVisible: {}
        }, $scope.openInNewWindow = function(question) {
            $rootScope.viewPort.pcMedia && window.open(PathsService.getUiHref("/faq/" + question.code));
        }, init();
    } ]);
}), define("portal/js/modules/info/helpScreens/index", [ "./helpScreensModule", "./helpScreensController", "./faqController" ], function() {}), 
define("portal/js/modules/info/index", [ "./infoScenesModule", "./contact/index", "./product/index", "./about/index", "./helpScreens/index" ], function() {}), 
define("portal/js/modules/catalogs/catalogsModule", [ "angular" ], function(ng) {
    return ng.module("app.catalogs", [ "app.catalogs.list", "app.catalogs.lotPage", "app.catalogs.search", "app.catalogs.lotElements" ]);
}), define("portal/js/modules/catalogs/catalogsService", [ "./catalogsModule" ], function(module) {
    module.factory("CatalogsService", function($q, $rootScope, $state, $stateParams, $timeout, ApiService, I18nService, StringsService, ArraysService, DateUtilsService, PathsService, LogService, PortalInfoService, LocalStorageService, CloudinaryService, CatalogUtilsService, ViewPortService, LotTextsService) {
        function clear() {
            mNavState = {
                data: {
                    catalogOwner: null,
                    items: null
                },
                pagesData: {
                    currentPage: 1,
                    itemsPerPage: $rootScope.viewPort.pcMedia ? 48 : 20
                },
                filterData: {
                    category: "all"
                },
                lastLotPageVisited: null
            }, "dev" == GlobalConfig.envName, mCurrentCatalogCache = {
                ownerKey: null,
                items: null,
                itemsById: null,
                itemsByIdInApp: null
            };
        }
        function getNavState() {
            return mNavState || clear(), mNavState;
        }
        function resetNavState(catalogOwner, items) {
            getNavState(), mNavState.data.catalogOwner = catalogOwner, mNavState.data.items = items, 
            mNavState.filterData.category = "all", mNavState.filterData.phrase = "", mNavState.filterData.soldState = "all", 
            setVisibleItems(items);
        }
        function updatePageItems() {
            var pagesData = mNavState.pagesData;
            pagesData.visibleItems && (pagesData.pageItems = CatalogUtilsService.getPageItems(pagesData.visibleItems, pagesData.currentPage, pagesData.itemsPerPage), 
            LocalStorageService.store("itemsPerPage", pagesData.itemsPerPage));
        }
        function getCatalogItems(catalogOwner, apiPath, attempt) {
            mCurrentCatalogCache || clear();
            var deferred = $q.defer();
            return catalogOwner ? mCurrentCatalogCache.ownerKey == catalogOwner.intKey ? deferred.resolve(mCurrentCatalogCache.items) : catalogOwner.catalogInfo && ApiService.callApi({
                api: apiPath,
                data: {
                    intKey: catalogOwner.intKey,
                    cacheVersion: catalogOwner.catalogInfo.catalogCacheVersion,
                    attempt: attempt
                },
                useCdnCache: !0
            }).success(function(items) {
                CatalogUtilsService.sortLots(items), resetNavState(catalogOwner, items), setCurrentItemsCache(catalogOwner, items), 
                deferred.resolve(mCurrentCatalogCache.items);
            }).error(function() {
                attempt > 5 ? (LogService.logError("Failed on attempt " + attempt + " to load catalog " + catalogOwner.intKey), 
                deferred.resolve([])) : (attempt || (attempt = 0), $timeout(function() {
                    getCatalogItems(catalogOwner, apiPath, attempt + 1).then(function(items) {
                        deferred.resolve(items);
                    });
                }, 1e3 * attempt));
            }) : deferred.resolve([]), deferred.promise;
        }
        function setItemsCatalogInfo(items) {
            for (var allFound = !0, i = 0; i < items.length; i++) {
                var item = items[i];
                if (item.auctionId) {
                    var auction = PortalInfoService.getAuction(item.ownerKey);
                    auction ? setItemCatalogInfo(item, auction) : allFound = !1;
                } else item.shopId && setItemCatalogInfo(item, PortalInfoService.getShop(item.ownerKey));
            }
            return allFound;
        }
        function setCurrentItemsCache(catalogOwner, items) {
            mCurrentCatalogCache.ownerKey = catalogOwner.intKey, mCurrentCatalogCache.itemsById = {}, 
            mCurrentCatalogCache.itemsByIdInApp = {}, angular.forEach(items, function(item) {
                setItemCatalogInfo(item, catalogOwner), mCurrentCatalogCache.itemsById[item.id] = item, 
                mCurrentCatalogCache.itemsByIdInApp[item.idInApp] = item;
            }), mCurrentCatalogCache.items = items;
        }
        function getCachedCatalogItems(catalogOwner) {
            return catalogOwner && mCurrentCatalogCache.ownerKey == catalogOwner.intKey ? mCurrentCatalogCache.items : void 0;
        }
        function setItemCatalogInfo(item, catalogOwner) {
            catalogOwner && (item.auctionId && catalogOwner.id == item.auctionId && (item.auction = catalogOwner), 
            item.shopId && catalogOwner.id == item.shopId && (item.shop = catalogOwner), item.house = catalogOwner.house, 
            item.catalogInfo = catalogOwner.catalogInfo);
        }
        function setVisibleItems(visibleItems) {
            mNavState.pagesData.visibleItems = visibleItems, mNavState.pagesData.itemsCount = visibleItems.length;
        }
        function getAuctionItems(auction) {
            return getCatalogItems(auction, "/portal/getAuctionItems");
        }
        function updateCachedItem(lot, field) {
            if (mCurrentCatalogCache && mCurrentCatalogCache.itemsByIdInApp) {
                var cachedLot = mCurrentCatalogCache.itemsByIdInApp[lot.idInApp];
                cachedLot && (cachedLot[field] = lot[field]);
            }
        }
        function getAuctionItem(auction, itemIdInApp) {
            var deferred = $q.defer();
            return getAuctionItems(auction).then(function() {
                deferred.resolve(getCachedItem(auction, itemIdInApp));
            }), deferred.promise;
        }
        function getShopItems(shop) {
            return getCatalogItems(shop, "/portal/getShopItems");
        }
        function getShopItem(shop, itemIdInApp) {
            var deferred = $q.defer();
            return getShopItems(shop).then(function() {
                deferred.resolve(getCachedItem(shop, itemIdInApp));
            }), deferred.promise;
        }
        function getCachedItem(catalogOwner, itemIdInApp) {
            if (mCurrentCatalogCache.ownerKey == catalogOwner.intKey) {
                var itemByIdInApp = mCurrentCatalogCache.itemsByIdInApp[itemIdInApp];
                return itemByIdInApp ? itemByIdInApp : mCurrentCatalogCache.itemsById[itemIdInApp];
            }
        }
        function getCachedItemById(itemId) {
            return mCurrentCatalogCache ? mCurrentCatalogCache.itemsById[itemId] : void 0;
        }
        function getLotImageUrl(lot, imageInd, size, imageMode) {
            if (!lot) return "";
            var houseCode = lot.houseCode;
            if (houseCode || (lotOwner = lot.auction || lot.shop, lotOwner && lotOwner.house && (houseCode = lotOwner.house.code)), 
            !houseCode) return "";
            imageInd || (imageInd = 0);
            var imageName = lot.imagesList[imageInd];
            if (!imageName) return null;
            var transformationPath = CloudinaryService.parseParams({
                size: size,
                mode: imageMode
            });
            return lot.imagesCloned ? getLotClonedImageUrl(houseCode, lot, imageName, transformationPath) : getLotCloudinaryImageUrl(houseCode, lot, imageName, transformationPath);
        }
        function getLotCloudinaryImageUrl(houseCode, lot, imageName, transformationPath) {
            var url = CloudinaryService.BASE_URL + (transformationPath ? transformationPath + "/" : "");
            return url += lot.imagesBase ? houseCode + "_" + lot.imagesBase : houseCode + "_" + lot.itemIndex, 
            url += "_" + imageName;
        }
        function getLotClonedImageUrl(envDir, lot, imageName, transformationPath) {
            var url = IMAGES_CLONE_SERVER + envDir + "/cloned-images/";
            if (lot.imagesBase) {
                var imagesBase = lot.imagesBase.replace(/\_/g, "/");
                imagesBase = imagesBase.replace("auction/", "auction_").replace("import/", "import_"), 
                url += imagesBase;
            } else {
                var importPart = lot.auction.catalogInfo.imagesBase.match(/(import_\d+)/)[0];
                url += "auction_" + lot.auction.auctionIdInApp + "/lots/" + importPart + "/" + lot.itemIndex;
            }
            return url += "/" + imageName.split(".")[0] + "/", transformationPath && (url += "a_ignore_" + transformationPath.replace(/,/g, "_") + "_"), 
            url += imageName;
        }
        function filterListWithPhrase(lotItems, phrase) {
            if (!phrase) return lotItems;
            for (var matches = [], result = [], i = 0; i < lotItems.length; i++) {
                var lotMatch = CatalogUtilsService.checkLotMatchPhrase(lotItems[i], phrase);
                lotMatch.score > 0 && matches.push(lotMatch);
            }
            ArraysService.sort(matches, "score", !0);
            for (var i = 0; i < matches.length; i++) matches[i].lot.score = matches[i].score, 
            result.push(matches[i].lot);
            return result;
        }
        function filterListWithCategory(lotItems, category) {
            for (var result = [], i = 0; i < lotItems.length; i++) {
                var lotItem = lotItems[i], lotCategory = lotItem.category[I18nService.getCurrentLang()], match = !1;
                if (lotCategory == category && (match = !0), lotItem.tags) for (var j = 0; j < lotItem.tags.length; j++) getTagName(lotItem.tags[j]) == category && (match = !0);
                match && result.push(lotItem);
            }
            return result;
        }
        function filterListWithSoldState(lotItems, soldState) {
            for (var result = [], i = 0; i < lotItems.length; i++) {
                var lotItem = lotItems[i];
                ("all" == soldState || lotItem.purchase && "sold" == soldState || !lotItem.purchase && "unsold" == soldState) && result.push(lotItem);
            }
            return result;
        }
        function notmalizedTag(tag) {
            return tag.match(/_all$/) ? tag.split("_")[0] : tag;
        }
        function getTagName(tag) {
            return I18nService.searchTextByKey("tag_" + notmalizedTag(tag));
        }
        function getCategoriesList(lotItems) {
            for (var catagoriesCount = {}, i = 0; i < lotItems.length; i++) {
                var lot = lotItems[i], lotCategories = [ lot.category[I18nService.getCurrentLang()] ];
                if (lot.tags) for (var j = 0; j < lot.tags.length; j++) {
                    var tagName = getTagName(lot.tags[j]);
                    tagName && -1 == lotCategories.indexOf(tagName) && lotCategories.push(tagName);
                }
                for (var j = 0; j < lotCategories.length; j++) {
                    var category = lotCategories[j];
                    if (!StringsService.isBlank(category)) {
                        var count = catagoriesCount[category];
                        catagoriesCount[category] = count ? catagoriesCount[category] + 1 : 1;
                    }
                }
            }
            var catagories = [];
            for (category in catagoriesCount) {
                var count = catagoriesCount[category];
                count < lotItems.length && catagories.push({
                    name: category + " (" + count + ")",
                    value: category
                });
            }
            return ArraysService.sort(catagories, "name"), catagories;
        }
        function getMobileElementsDimensions(recalc) {
            return (!mMobileElementsDimensions.infoWidth || recalc) && (mMobileElementsDimensions.infoWidth = Math.min(Math.max(ViewPortService.clientWidth(), 500), 995) - 220), 
            mMobileElementsDimensions;
        }
        function isLastPageRelevantToCurrentCatalog() {
            if (!mNavState || !mNavState.data.catalogOwner) return !1;
            var previousState = $rootScope.$previousState;
            if (!previousState) return !1;
            if (previousState.args.catalogKey != mNavState.data.catalogOwner.intKey) return !1;
            var previusStateUrl = previousState.url;
            return 0 == previusStateUrl.indexOf("catalog") || 0 == previusStateUrl.indexOf("lotPage") ? !0 : !1;
        }
        function backToLastVisitedLot() {
            if (mNavState && mNavState.lastLotPageVisited) {
                var lot = mNavState.lastLotPageVisited.lot;
                gotoLotPage(lot, mNavState.lastLotPageVisited.source);
            }
        }
        function backToLastVisitedCatalog() {
            if (mNavState && mNavState.data.catalogOwner && mNavState.pagesData) {
                var owner = mNavState.data.catalogOwner;
                $state.go("app." + owner.catalogType.toLowerCase() + "Catalog", {
                    catalogKey: owner.intKey,
                    page: mNavState.pagesData.currentPage
                });
            }
        }
        function gotoLotPage(lot, source) {
            var catalogKey, ownerType;
            if (lot.shop) ownerType = "shop", catalogKey = lot.shop.intKey; else {
                if (!lot.auction) return void LogService.logError("Trying to go to a lot without an owner " + lot.id);
                ownerType = "auction", catalogKey = lot.auction.intKey;
            }
            $state.go("app.lotPageWithDesc", {
                source: source || "catalog",
                catalogKey: catalogKey,
                lotKey: lot.idInApp,
                ownerType: ownerType,
                lotDesc: LotTextsService.getLotHrefDesc(lot)
            });
        }
        var mCurrentCatalogCache, mNavState, IMAGES_CLONE_SERVER = "https://bidspirit-images.global.ssl.fastly.net/", mMobileElementsDimensions = {};
        return $rootScope.$on("viewPort.windowSizeChanged", function() {
            getMobileElementsDimensions(!0);
        }), $rootScope.$on("auth.newSessionUser", function() {
            $rootScope.currentUser || clear();
        }), {
            getAuctionItems: getAuctionItems,
            getAuctionItem: getAuctionItem,
            setItemsCatalogInfo: setItemsCatalogInfo,
            getShopItems: getShopItems,
            getShopItem: getShopItem,
            getCachedCatalogItems: getCachedCatalogItems,
            getCachedItem: getCachedItem,
            getCachedItemById: getCachedItemById,
            updateCachedItem: updateCachedItem,
            getLotImageUrl: getLotImageUrl,
            filterListWithPhrase: filterListWithPhrase,
            filterListWithCategory: filterListWithCategory,
            filterListWithSoldState: filterListWithSoldState,
            getCategoriesList: getCategoriesList,
            getNavState: getNavState,
            resetNavState: resetNavState,
            isLastPageRelevantToCurrentCatalog: isLastPageRelevantToCurrentCatalog,
            updatePageItems: updatePageItems,
            setVisibleItems: setVisibleItems,
            getMobileElementsDimensions: getMobileElementsDimensions,
            backToLastVisitedLot: backToLastVisitedLot,
            backToLastVisitedCatalog: backToLastVisitedCatalog,
            gotoLotPage: gotoLotPage
        };
    });
}), define("portal/js/modules/catalogs/catalogAccountService", [ "./catalogsModule" ], function(module) {
    module.factory("CatalogAccountService", function($q, $rootScope, $uibModal, ArraysService, ApiService, PathsService, CatalogUtilsService, CometService, PortalAuthService, CatalogsService, PortalInfoService, AccountService) {
        function loadForAuction(auction, noCache) {
            var deferred = $q.defer(), currentUserId = $rootScope.currentUser ? $rootScope.currentUser.id : null;
            return isCurrentCachedCatalog(auction.intKey) && currentUserId == mCachedCatalogAccountInfo.userId && !noCache ? (deferred.resolve(), 
            initPrivateCometChannel()) : (mLoadDeferes[auction.id] ? mLoadDeferes[auction.id].defferds.push(deferred) : mLoadDeferes[auction.id] = {
                defferds: [ deferred ]
            }, mCachedCatalogAccountInfo = null, (!mLoadDeferes[auction.id].handler || noCache) && (mLoadDeferes[auction.id].handler = function(info) {
                if (AccountService.resetItemsAppBidsCache(), mCachedCatalogAccountInfo = info, mCachedCatalogAccountInfo.lastSync = new Date().getTime(), 
                mCachedCatalogAccountInfo.auction = auction, mCachedCatalogAccountInfo.houseCode = auction.houseCode, 
                mCachedCatalogAccountInfo.catalogKey = auction.intKey, mCachedCatalogAccountInfo.userId = currentUserId, 
                info.publicInfo) if (AccountService.addBidsInfoToItems(auction, info.publicInfo.purchases, "purchase"), 
                setLeadingBids(auction, info.publicInfo.leadingBids), auction.absenteeBidsEnabled = info.publicInfo.absenteeBidsEnabled, 
                info.userInfo) {
                    if (mCachedCatalogAccountInfo.userIdInApp = info.userInfo.userIdInApp, PortalAuthService.setCurrentHouseAccountState(auction.houseId, info.userInfo.approvalState, !0), 
                    PortalAuthService.setMailingListApproved(auction.houseId, info.userInfo.mailingListApproved, !0), 
                    info.userInfo.userIdInApp) {
                        var selfPurchases = ArraysService.getFilteredList(info.publicInfo.purchases, "userIdInApp", !0, mCachedCatalogAccountInfo.userIdInApp);
                        AccountService.addBidsInfoToItems(auction, selfPurchases, "selfPurchase"), AccountService.addBidsInfoToItems(auction, info.userInfo.bidRequests, "bidRequest"), 
                        AccountService.addBidsInfoToItems(auction, info.userInfo.absenteeBids, "selfAbsenteeBid");
                    }
                    AccountService.addFavoriteFlagToItems(auction, info.userInfo.favoriteLotIdsInApp), 
                    AccountService.addItemAlertToItems(auction, info.userInfo.itemAlertsLotIdsInApp);
                } else mCachedCatalogAccountInfo.userIdInApp = null;
                auction.house && (auction.house.increments = mCachedCatalogAccountInfo.increments), 
                initPrivateCometChannel(), $rootScope.$broadcast("account.dataLoaded");
                for (var defferds = mLoadDeferes[auction.id].defferds, i = 0; i < defferds.length; i++) defferds[i].resolve();
                mLoadDeferes[auction.id] = null;
            }, CatalogsService.getAuctionItems(auction).then(function() {
                ApiService.callApi("/account/getAccountActionsForAuction", {
                    auctionId: auction.id
                }).success(mLoadDeferes[auction.id].handler);
            }))), deferred.promise;
        }
        function initPrivateCometChannel() {
            mCachedCatalogAccountInfo.userInfo && CometService.setPrivateChannel(mCachedCatalogAccountInfo.userInfo.privateCometChannel);
        }
        function loadForShop(shop, noCache) {
            var deferred = $q.defer(), currentUserId = $rootScope.currentUser ? $rootScope.currentUser.id : null;
            return isCurrentCachedCatalog(shop.intKey) && currentUserId == mCachedCatalogAccountInfo.userId && !noCache ? deferred.resolve() : (mCachedCatalogAccountInfo = null, 
            CatalogsService.getShopItems(shop).then(function() {
                ApiService.callApi("/account/getAccountActionsForShop", {
                    shopId: shop.id
                }).success(function(info) {
                    mCachedCatalogAccountInfo = info, AccountService.resetItemsAppBidsCache(), mCachedCatalogAccountInfo.userIdInApp = info.userIdInApp, 
                    mCachedCatalogAccountInfo.houseCode = shop.houseCode, mCachedCatalogAccountInfo.userIdInApp && AccountService.addBidsInfoToItems(shop, ArraysService.getFilteredList(info.purchases, "userIdInApp", !0, mCachedCatalogAccountInfo.userIdInApp), "selfPurchase"), 
                    AccountService.addFavoriteFlagToItems(shop, info.favoriteLots), AccountService.addBidsInfoToItems(shop, info.purchases, "purchase"), 
                    mCachedCatalogAccountInfo.shop = shop, mCachedCatalogAccountInfo.catalogKey = shop.intKey, 
                    mCachedCatalogAccountInfo.userId = currentUserId, $rootScope.$broadcast("account.dataLoaded"), 
                    deferred.resolve();
                });
            })), deferred.promise;
        }
        function isAuctionOfCachedInfo(auction) {
            return auction && mCachedCatalogAccountInfo && mCachedCatalogAccountInfo.auction && mCachedCatalogAccountInfo.auction.id == auction.id;
        }
        function getCachedAccountInfo() {
            return mCachedCatalogAccountInfo;
        }
        function setLeadingBids(auction, leadingBids) {
            if (leadingBids) for (var i = 0; i < leadingBids.length; i++) {
                var bid = leadingBids[i], item = CatalogsService.getCachedItem(auction, bid.lotIdInApp);
                AccountService.updateLeadingBid(item, bid);
            }
        }
        function isCurrentCachedCatalog(catalogKey) {
            return mCachedCatalogAccountInfo && mCachedCatalogAccountInfo.catalogKey == catalogKey;
        }
        function isCurrentUserIdInApp(userIdInApp) {
            return mCachedCatalogAccountInfo && mCachedCatalogAccountInfo.userIdInApp ? userIdInApp == mCachedCatalogAccountInfo.userIdInApp : !1;
        }
        function getCurrentCachedCatalogBidRequests(catalogKey) {
            return isCurrentCachedCatalog(catalogKey) && mCachedCatalogAccountInfo.userInfo ? mCachedCatalogAccountInfo.userInfo.bidRequests : null;
        }
        function reloadAccountInfo() {
            return mCachedCatalogAccountInfo && mCachedCatalogAccountInfo.auction ? (CatalogsService.getAuctionItems(mCachedCatalogAccountInfo.auction).then(function(items) {
                for (var i = 0; i < items.length; i++) AccountService.setBidInfoForItem(items[i], "selfAbsenteeBid", null), 
                AccountService.setBidInfoForItem(items[i], "selfPurchase", null);
            }), loadForAuction(mCachedCatalogAccountInfo.auction, !0)) : void 0;
        }
        function convertAppSiteBid(bid) {
            return bid ? {
                price: bid.price,
                actionPrice: bid.price,
                lotIdInApp: bid.lotItemId,
                userIdInApp: bid.bidderUserId,
                underReserved: bid.underReserved
            } : null;
        }
        function handleLeadingBidUpdate(updateInfo) {
            var item = CatalogsService.getCachedItem(mCachedCatalogAccountInfo.auction, updateInfo.lotId);
            AccountService.updateLeadingBid(item, convertAppSiteBid(updateInfo.preBid));
        }
        function handleSelfBidUpdate(updatedBid) {
            if (isCurrentUserIdInApp(updatedBid.bidderUserId)) {
                var auction = mCachedCatalogAccountInfo.auction, item = CatalogsService.getCachedItem(auction, updatedBid.lotItemId), bid = convertAppSiteBid(updatedBid);
                AccountService.handleSelfAbsenteeBidUpdate(item, bid), updateCachedInfoBid(item, bid);
            }
        }
        function handleSelfBidRequestUpdate(bidRequest) {
            var item = CatalogsService.getCachedItem(mCachedCatalogAccountInfo.auction, bidRequest.lotItemId);
            if (item) {
                var bidRequests = getCurrentCachedCatalogBidRequests(item.ownerKey);
                bidRequests && bidRequests.push(bidRequest), AccountService.setBidInfoForItem(item, "bidRequest", convertAppSiteBid(bidRequest)), 
                $rootScope.$broadcast("auctionParticipation.approvalStateChanged");
            }
        }
        function handleShopPurchase(shopItem) {
            if (shopItem.shopId == mCachedCatalogAccountInfo.shop.idInApp) {
                var item = CatalogsService.getCachedItem(mCachedCatalogAccountInfo.shop, shopItem.lotId), purchase = {
                    price: shopItem.soldPrice,
                    actionPrice: shopItem.soldPrice,
                    lotIdInApp: shopItem.lotId,
                    userIdInApp: shopItem.buyerId
                };
                AccountService.setBidInfoForItem(item, "purchase", purchase);
            }
        }
        function handleSelfBidCancel(canceledBid) {
            if (isCurrentUserIdInApp(canceledBid.bidderUserId)) {
                var item = CatalogsService.getCachedItem(mCachedCatalogAccountInfo.auction, canceledBid.lotItemId);
                AccountService.handleSelfAbsenteeBidUpdate(item, null), updateCachedInfoBid(item, null);
            }
        }
        function updateCachedInfoBid(item, bid) {
            var auction = item.auction;
            if (isAuctionOfCachedInfo(auction)) {
                var bids = mCachedCatalogAccountInfo.userInfo.absenteeBids;
                ArraysService.removeByKey(bids, "lotIdInApp", item.idInApp), bid && bids && bids.push(bid), 
                $rootScope.$broadcast("catalogAccount.cachedInfoChanged");
            }
        }
        function isRelevantBidForLimit(preBid) {
            var currentAuction = mCachedCatalogAccountInfo.auction;
            if (preBid.auctionIdInApp != currentAuction.auctionIdInApp) return !1;
            if (AccountService.getItemBidByAppIds(preBid.auctionIdInApp, preBid.lotIdInApp, "purchase")) return !1;
            var leadingBid = AccountService.getItemBidByAppIds(preBid.auctionIdInApp, preBid.lotIdInApp, "leadingBid");
            if (leadingBid && !isCurrentUserIdInApp(leadingBid.userIdInApp)) return !1;
            var bidAuction = PortalInfoService.getAuctionByDayIdInApp(currentAuction.house.code, preBid.auctionDayIdInApp);
            return bidAuction ? "ENDED" == bidAuction.state ? !1 : !0 : !1;
        }
        function getBidLimitForLot(lot) {
            if (mCachedCatalogAccountInfo && mCachedCatalogAccountInfo.userInfo && mCachedCatalogAccountInfo.auction && mCachedCatalogAccountInfo.userInfo.bidLimitByAuction) {
                for (var bidLimit = mCachedCatalogAccountInfo.userInfo.bidLimitByAuction[mCachedCatalogAccountInfo.auction.auctionIdInApp], prebids = AccountService.getAppItemsBidsByField("selfAbsenteeBid"), soldBids = AccountService.getAppItemsBidsByField("selfPurchase"), i = 0; i < prebids.length; i++) {
                    var preBid = prebids[i];
                    isRelevantBidForLimit(preBid) && (preBid.lotIdInApp == lot.idInApp || (bidLimit -= preBid.price));
                }
                for (var i = 0; i < soldBids.length; i++) bidLimit -= soldBids[i].price;
                return bidLimit;
            }
        }
        function isRejectedInCurrentHouse() {
            return mCachedCatalogAccountInfo && mCachedCatalogAccountInfo.userInfo ? mCachedCatalogAccountInfo.userInfo.ignoredUser || "REJECTED" == mCachedCatalogAccountInfo.userInfo.approvalState : !1;
        }
        function isBlockIgnoredInHouse() {
            return mCachedCatalogAccountInfo && mCachedCatalogAccountInfo.userInfo ? mCachedCatalogAccountInfo.userInfo.ignoreBlocked : !1;
        }
        var mCachedCatalogAccountInfo = null, mLoadDeferes = {};
        return CometService.scope.$on("cometEvent", function(e, event) {
            if (mCachedCatalogAccountInfo && mCachedCatalogAccountInfo.houseCode == event.houseCode) switch (event.name) {
              case "Catalog.leadingBidUpdate":
                handleLeadingBidUpdate(event.arg);
                break;

              case "Account.selfPreBidUpdate":
                handleSelfBidUpdate(event.arg);
                break;

              case "Account.selfPresaleBidCancel":
                handleSelfBidCancel(event.arg);
                break;

              case "Account.selfBidRequestUpdate":
                handleSelfBidRequestUpdate(event.arg);
                break;

              case "Shop.itemPurchase":
                handleShopPurchase(event.arg);
            }
        }), $rootScope.$on("catalogContextChanged", function(e, catalowOwner) {
            catalowOwner && isCurrentCachedCatalog(catalowOwner.intKey) || (mCachedCatalogAccountInfo = null);
        }), $rootScope.$on("auth.newSessionUser", reloadAccountInfo), $rootScope.$on("auth.houseApprovalChanged", reloadAccountInfo), 
        {
            loadForAuction: loadForAuction,
            loadForShop: loadForShop,
            getCachedAccountInfo: getCachedAccountInfo,
            isAuctionOfCachedInfo: isAuctionOfCachedInfo,
            isCurrentUserIdInApp: isCurrentUserIdInApp,
            handleLeadingBidUpdate: handleLeadingBidUpdate,
            getBidLimitForLot: getBidLimitForLot,
            getCurrentCachedCatalogBidRequests: getCurrentCachedCatalogBidRequests,
            isRejectedInCurrentHouse: isRejectedInCurrentHouse,
            isBlockIgnoredInHouse: isBlockIgnoredInHouse
        };
    });
}), define("portal/js/modules/catalogs/lotElements/lotElementsModule", [ "angular" ], function(ng) {
    return ng.module("app.catalogs.lotElements", []);
}), define("portal/js/modules/catalogs/lotElements/lotFilters", [ "./lotElementsModule" ], function(module) {
    return module.filter("lotText", [ "LotTextsService", function(LotTextsService) {
        return function(lot, length) {
            return LotTextsService.getLotText(lot, length);
        };
    } ]).filter("lotImage", [ "CatalogsService", function(CatalogsService) {
        return function(lot, size) {
            return CatalogsService.getLotImageUrl(lot, 0, size);
        };
    } ]).filter("lotHref", [ "LotTextsService", function(LotTextsService) {
        return function(lot, source) {
            return LotTextsService.getLotHref(lot, source);
        };
    } ]);
}), define("portal/js/modules/catalogs/lotElements/lotImageDirective", [ "./lotElementsModule" ], function(module) {
    module.directive("bsLotImage", function($timeout, $rootScope, PathsService, I18nService, StringsService, DomUtilsService, CatalogsService, LotTextsService) {
        return {
            restrict: "E",
            replace: !0,
            scope: {
                lot: "=",
                size: "@",
                imageInd: "=",
                asBg: "=",
                imageMode: "=",
                watchable: "=",
                loadedImageInfo: "=",
                enableMagnifier: "@",
                moveInFrame: "=",
                debug: "="
            },
            link: function(scope, element) {
                function loadImage() {
                    function displayImage() {
                        scope.asBg ? element.css({
                            "background-image": "url(" + imageUrl + ")",
                            "background-repeat": "no-repeat"
                        }) : (scope.loadedImageSrc = imageUrl, setImgSize()), setStateInfo(null);
                    }
                    imageLoaded = !1, setStateInfo(null), scope.narrowHeight = !1, rect = null;
                    $rootScope.search;
                    $timeout(function() {
                        imageLoaded || scope.stateInfo || $rootScope.searchAgentRequest || setStateInfo("image_load");
                    }, 100), element.css({
                        "background-image": "none",
                        "margin-left": "",
                        width: ""
                    }), setImgAlt();
                    var imageUrl = CatalogsService.getLotImageUrl(scope.lot, scope.imageInd, scope.size, scope.imageMode);
                    imageUrl ? $rootScope.searchAgentRequest ? displayImage() : DomUtilsService.loadImage(imageUrl).then(function(imageInfo) {
                        !imageInfo.src != imageUrl && (loadedImageSize = imageInfo.size, displayImage(), 
                        scope.moveInFrame && setElementPositionInFrame(0, 0), element.addClass("loaded"), 
                        scope.loadedImageInfo && (scope.loadedImageInfo.loaded = !0, scope.loadedImageInfo.size = imageInfo.size), 
                        imageLoaded = !0, $timeout(function() {
                            element[0].offsetHeight && element[0].offsetHeight < 250 && (scope.narrowHeight = !0);
                        }, 50));
                    }, function() {
                        setMissingImage();
                    }) : setMissingImage();
                }
                function getImgElement() {
                    return angular.element(element[0].querySelector("img"));
                }
                function setImgSize() {
                    if (scope.size) {
                        var img = getImgElement(), sizeParts = scope.size.split("x");
                        sizeParts[0] && (sizeParts[0] < 100 && (scope.smallImage = !0), img.css({
                            "max-width": sizeParts[0] + "px"
                        })), sizeParts[1] && img.css({
                            "max-height": sizeParts[1] + "px"
                        });
                    } else element[0].clientWidth > loadedImageSize.width && (element.css({
                        "margin-left": (element[0].clientWidth - loadedImageSize.width) / 2 + "px"
                    }), element.css({
                        width: loadedImageSize.width + "px"
                    }));
                }
                function setImgAlt() {
                    var img = getImgElement(), text = LotTextsService.getLotText(scope.lot, 50).split("...")[0];
                    text = StringsService.stripTags(text), img.attr({
                        alt: text
                    });
                }
                function setMissingImage() {
                    $rootScope.searchAgentRequest || setStateInfo(scope.smallImage ? "image_missing" : "pic_available_soon");
                }
                function setStateInfo(stateInfo) {
                    scope.stateInfo = stateInfo, stateInfo ? (stateElement.css({
                        display: "block"
                    }), stateElement.html(I18nService.getText(stateInfo))) : (stateElement.css({
                        display: "none"
                    }), stateElement.innerHTML = "");
                }
                function getRatio(offset, size) {
                    var margin = 50, ratio = Math.round((100 + margin) * offset / size) - margin / 2;
                    return ratio = Math.max(0, ratio), ratio = Math.min(100, ratio), ratio + "%";
                }
                function moveBg(e) {
                    rect || (rect = DomUtilsService.getBoundingRect(element));
                    var offsetX = (e.pageX || e.targetTouches[0].pageX) - rect.left, offsetY = (e.pageY || e.targetTouches[0].pageY) - rect.top, ratioX = getRatio(offsetX, rect.width), ratioY = getRatio(offsetY, rect.height);
                    setElementPositionInFrame(ratioX, ratioY), e.preventDefault();
                }
                function setElementPositionInFrame(ratioX, ratioY) {
                    if (loadedImageSize) {
                        var xPos = loadedImageSize.width < $rootScope.viewPort.innerWidth ? "center" : ratioX, yPos = loadedImageSize.height < $rootScope.viewPort.innerHeight - 200 ? "center" : ratioY;
                        element.css({
                            backgroundPosition: xPos + " " + yPos
                        });
                    }
                }
                var rect = null, loadedImageSize = null, imageLoaded = !1, stateElement = angular.element(element[0].querySelectorAll(".state-info")[0]);
                scope.watchable ? (scope.$watch("imageInd", function() {
                    element.css({
                        visibility: "hidden"
                    }), $timeout(function() {
                        loadImage(), $timeout(function() {
                            element.css({
                                visibility: "visible"
                            });
                        });
                    }, 10);
                }), scope.$watch("imageMode", function() {
                    loadImage();
                })) : loadImage(), scope.moveInFrame && (element.bind("touchmove", moveBg), element.bind("mousedown", moveBg));
            },
            templateUrl: PathsService.appTemplatePath("catalogs/elements/lotImage")
        };
    });
}), define("portal/js/modules/catalogs/lotElements/lotPriceDirective", [ "./lotElementsModule" ], function(module) {
    module.directive("bsLotPrice", function($timeout, PathsService, I18nService, DomUtilsService, PortalInfoService, CatalogsService, StructuredDataService, BidRulesService) {
        return {
            restrict: "E",
            replace: !0,
            scope: {
                lot: "=",
                maxWidth: "@",
                breakOnRow: "@",
                singleRow: "@",
                onlyEstimated: "@"
            },
            link: function(scope) {
                var lot = scope.lot;
                if (scope.showExactPrice = !1, scope.showNoPrice = !1, scope.showEstimatedPrice = !1, 
                lot.auction) {
                    var currency = lot.auction.catalogInfo.currency, startPrice = lot.startPrice;
                    "true" == scope.onlyEstimated ? lot.estimatedPrice && (scope.showEstimatedPrice = !0, 
                    scope.estimatedPrice = lot.estimatedPrice, currency) : PortalInfoService.isAuctionInPostSaleMode(lot.auction) ? startPrice && (scope.showExactPrice = !0, 
                    scope.exactPriceLabel = "price", scope.exactPrice = I18nService.sumInCurrency(startPrice, currency), 
                    scope.exactPrice = StructuredDataService.getPriceStructuredDataTag(scope.exactPrice, currency)) : (!startPrice && lot.auction.showLeadingBids && (startPrice = BidRulesService.minBidPrice(lot)), 
                    lot.auction.catalogInfo.startPriceHidden ? lot.estimatedPrice ? (scope.showEstimatedPrice = !0, 
                    scope.estimatedPrice = StructuredDataService.getPriceStructuredDataTag(lot.estimatedPrice, currency)) : scope.showEstimatedPrice = !1 : (startPrice ? (scope.showExactPrice = !0, 
                    scope.exactPriceLabel = "start_price", scope.exactPrice = I18nService.sumInCurrency(startPrice, currency), 
                    scope.exactPrice = StructuredDataService.getPriceStructuredDataTag(scope.exactPrice, currency)) : (scope.showExactPrice = !1, 
                    "ENDED" != lot.auction.state && (scope.showNoPrice = !0)), lot.estimatedPrice && "false" == scope.singleRow && (scope.showEstimatedPrice = !0, 
                    scope.estimatedPrice = lot.estimatedPrice, scope.exactPrice || (scope.estimatedPrice = StructuredDataService.getPriceStructuredDataTag(scope.estimatedPrice, currency)))));
                } else if (lot.shop) {
                    var currency = lot.shop.catalogInfo.currency;
                    scope.showExactPrice = !0, scope.exactPriceLabel = "price", scope.exactPrice = I18nService.sumInCurrency(lot.shopPrice, currency), 
                    scope.exactPrice = StructuredDataService.getPriceStructuredDataTag(scope.exactPrice, currency);
                }
            },
            templateUrl: PathsService.appTemplatePath("catalogs/elements/lotPrice")
        };
    });
}), define("portal/js/modules/catalogs/lotElements/lotTextsService", [ "./lotElementsModule" ], function(module) {
    module.factory("LotTextsService", function($rootScope, StringsService, I18nService, OsInfoService, PathsService) {
        function trimmedItemParts(item, maxLen, noHtml) {
            var artist = I18nService.getLangField(item.artist), textOptions = {};
            emptyTextsInLang(item, $rootScope.currentLang) || (textOptions.currentLangOnly = !0);
            {
                var name = I18nService.getLangField(item.name, textOptions), description = I18nService.getLangField(item.description, textOptions);
                I18nService.getLangField(item.details, textOptions);
            }
            item.carInfo && (name = getCarLotTitle(item)), item.realEstateInfo && (name = getRealEstateLotTitle(item)), 
            (noHtml || maxLen < (description + " " + artist + " " + name).length) && (description = StringsService.stripTags(escapeBoldTags(description))), 
            name && 0 != description.indexOf(name) || (name = description, description = "");
            var descMaxLen = maxLen ? maxLen - (artist + " " + name).length : description.length, nameMaxLen = maxLen ? maxLen - artist.length : name.length;
            return name = unEscapeBoldTags(StringsService.trimToWord(name, nameMaxLen)), description = unEscapeBoldTags(StringsService.trimToWord(description, descMaxLen)), 
            {
                name: name,
                artist: artist,
                description: description
            };
        }
        function escapeBoldTags(str) {
            return str.replace(/<b>/gi, "").replace(/<\/b>/gi, "");
        }
        function unEscapeBoldTags(str) {
            var unEscaped = str.replace(//g, "<b>").replace(//g, "</b>");
            return unEscaped.lastIndexOf("<b>") < unEscaped.lastIndexOf("</b>") && (unEscaped += "</b>"), 
            unEscaped;
        }
        function getCarLotTitle(lot) {
            var carInfo = lot.carInfo;
            if (!carInfo) return "";
            var year = carInfo.modelYear, modelText = carInfo.manufacturer;
            return modelText ? modelText += carInfo.model ? " " + carInfo.model : "" : modelText = carInfo.model, 
            year || (year = (carInfo.dateOnRoad || "").split("-")[0]), year ? I18nService.getText("car_title", {
                model: modelText,
                year: year
            }) : modelText;
        }
        function carLotDetails(lot) {
            var carInfo = lot.carInfo;
            if (!carInfo) return "";
            var text = "", delimiter = "";
            if (carInfo.mileage && (text += I18nService.valueWithUnits(carInfo.mileage, "km", lot.house), 
            delimiter = ","), carInfo.hand ? (text += carInfo.ownership ? delimiter + " " + I18nService.getText("car_summary_hand_from", {
                hand: carInfo.hand,
                ownership: carInfo.ownership
            }) : delimiter + " " + I18nService.getText("hand") + " " + carInfo.hand, delimiter = ".") : (carInfo.ownership && (text += delimiter + " " + I18nService.getText("current_ownership") + ": " + carInfo.ownership), 
            delimiter = "."), carInfo.tariffPrice && (text += delimiter + " " + I18nService.getText("tariff_price") + ": " + I18nService.sumInCurrency(carInfo.tariffPrice, lot.auction.catalogInfo.currency)), 
            carInfo.gear && (text += delimiter + " " + I18nService.getText("gear") + ": " + carInfo.gear), 
            text += ".", carInfo.color || carInfo.engine || carInfo.engineVolumeCc || carInfo.drive || carInfo.horsePower || carInfo.additions || carInfo.finish) {
                text += "\n", delimiter = ", ";
                var additionalDetails = "";
                carInfo.color && (additionalDetails += I18nService.getText("color") + ": " + carInfo.color + delimiter), 
                carInfo.engine && (additionalDetails += I18nService.getText("engine") + ": " + carInfo.engine + delimiter), 
                carInfo.engineVolumeCc && (additionalDetails += I18nService.getText("engine_volume") + ": " + I18nService.valueWithUnits(carInfo.engineVolumeCc, "cc") + delimiter), 
                carInfo.horsePower && (additionalDetails += I18nService.getText("horse_power") + ": " + carInfo.horsePower + delimiter), 
                carInfo.drive && (additionalDetails += I18nService.getText("drive") + ": " + carInfo.drive + delimiter), 
                carInfo.additions && additionalDetails.length < 150 && (additionalDetails += I18nService.getText("additions") + ": " + carInfo.additions + delimiter), 
                carInfo.finish && additionalDetails.length < 150 && (additionalDetails += I18nService.getText("car_finish") + ": " + carInfo.finish + delimiter), 
                text += additionalDetails.replace(/, $/, ".");
            }
            return text;
        }
        function getRealEstateLotTitle(lot) {
            var name = I18nService.getLangField(lot.name);
            if (name) return name;
            var realEstateInfo = lot.realEstateInfo;
            if (!realEstateInfo) return "";
            var text = "";
            return text += realEstateInfo.propertyType, realEstateInfo.rooms && (text += ", " + realEstateInfo.rooms + " " + I18nService.getText("rooms")), 
            realEstateInfo.city && (text += ", " + realEstateInfo.city), realEstateInfo.address && (text += ", " + realEstateInfo.address), 
            text;
        }
        function getLotText(lot, length) {
            if (!lot) return "";
            var text = "", trimmedParts = trimmedItemParts(lot, length, !0);
            return lot.carInfo ? StringsService.trimToSentence(getCarLotTitle(lot) + ". " + carLotDetails(lot), length) : lot.realEstateInfo ? getRealEstateLotTitle(lot) : (trimmedParts.description && (text = trimmedParts.description), 
            trimmedParts.name && (text && !trimmedParts.name.match(/\.$/) && (trimmedParts.name = trimmedParts.name + "."), 
            text = "<span class='lot-name'>" + trimmedParts.name + " </span>" + text), trimmedParts.artist && (text = "<span class='lot-artist'>" + trimmedParts.artist + "</span>" + (text ? " - " + text : "")), 
            text);
        }
        function getLotHrefDesc(lot) {
            if (0 == lot.published) return null;
            var browserName = OsInfoService.getOsInfo().browser;
            return !browserName || -1 != browserName.toLowerCase().indexOf("safari") || GlobalConfig.isMobileApp ? "lot" : StringsService.stripNonLetters(StringsService.stripTags(getLotText(lot, 40)));
        }
        function isBlankLangField(lot, field, lang) {
            return lot && lot[field] ? StringsService.isBlank(lot[field][lang]) : !0;
        }
        function emptyTextsInLang(lot, lang) {
            for (var textFields = [ "name", "artist", "description", "details" ], i = 0; i < textFields.length; i++) if (!isBlankLangField(lot, textFields[i], lang)) return !1;
            return !0;
        }
        function getLotHref(lot, source) {
            if (!lot) return "";
            var lotSuffix = "lot/" + lot.idInApp + "/" + getLotHrefDesc(lot), catalogType = lot.auction ? "auction" : lot.shop ? "shop" : null;
            return PathsService.getUiHref("/lotPage/source/" + source + "/" + catalogType + "/" + lot.ownerKey + "/" + lotSuffix);
        }
        return {
            getLotText: getLotText,
            getLotHrefDesc: getLotHrefDesc,
            getCarLotTitle: getCarLotTitle,
            getRealEstateLotTitle: getRealEstateLotTitle,
            getLotHref: getLotHref,
            emptyTextsInLang: emptyTextsInLang
        };
    });
}), define("portal/js/modules/catalogs/lotElements/lotBadgeDirective", [ "./lotElementsModule" ], function(module) {
    module.directive("bsLotBadge", function($rootScope, PathsService, I18nService, CatalogUtilsService, StringsService) {
        return {
            restrict: "E",
            replace: !0,
            scope: {
                lot: "="
            },
            link: function(scope, element) {
                function update() {
                    var bidLabel = CatalogUtilsService.getBidLabel(scope.lot), previousBadgeType = scope.badgeType;
                    scope.text = "", bidLabel && "self-absentee" == bidLabel.type && scope.lot.auction.showLeadingBids && (bidLabel = null), 
                    scope.lot.houseBadge ? (scope.badgeType = "house", scope.text = scope.lot.houseBadge.text, 
                    StringsService.stripTags(scope.text).length > 25 && (scope.longText = !0), scope.visible = !0, 
                    element.css({
                        "background-color": scope.lot.houseBadge.color || "#aaaaaa"
                    }), bidLabel && (scope.badgeType += " with-bid", scope.text += "<br><b>", scope.text += bidLabel.text, 
                    bidLabel.price && (scope.text += ": " + bidLabel.price), scope.text += "</b>")) : bidLabel && (scope.visible = !0, 
                    scope.badgeType = bidLabel.type, scope.text = scope.lot.purchase && CatalogUtilsService.isSoldPriceHidden(scope.lot) ? I18nService.getText("lot_sold") : bidLabel.text + ": <b>" + bidLabel.price + "</b>"), 
                    element.removeClass(previousBadgeType), element.addClass(scope.badgeType), scope.visible && scope.text ? (element.css({
                        display: "block"
                    }), scope.longText && textElement.addClass("long-text"), textElement.html(StringsService.capitalize(scope.text))) : element.css({
                        display: "none"
                    });
                }
                var textElement = angular.element(element[0].querySelectorAll(".text")[0]);
                scope.$watch("lot.lastBidUpdate", update), update();
            },
            templateUrl: PathsService.appTemplatePath("catalogs/elements/lotBadge")
        };
    });
}), define("portal/js/modules/catalogs/lotElements/lotExpirationDirective", [ "./lotElementsModule" ], function(module) {
    module.directive("bsLotExpiration", function($rootScope, PathsService, I18nService, SettingsService) {
        return {
            restrict: "E",
            replace: !0,
            scope: {
                lot: "="
            },
            link: function(scope, element) {
                element.css({
                    display: "none"
                });
            },
            templateUrl: PathsService.appTemplatePath("catalogs/elements/lotExpiration")
        };
    });
}), define("portal/js/modules/catalogs/lotElements/lotFavoriteFlagDirective", [ "./lotElementsModule" ], function(module) {
    module.directive("bsLotFavoriteFlag", function($rootScope, $timeout, PathsService, AccountService, PortalAuthService, OsInfoService) {
        return {
            restrict: "E",
            replace: !0,
            scope: {
                lot: "="
            },
            link: function(scope, element) {
                function setJustChanged(justChanged) {
                    scope.justChanged = justChanged, justChanged ? element.addClass("just-changed") : element.removeClass("just-changed");
                }
                function setFavoriteClassOn(isFavorite) {
                    element.removeClass("on off"), element.addClass(isFavorite ? "on" : "off");
                }
                function updateDisplay() {
                    setFavoriteClassOn(scope.lot.isFavorite);
                }
                var clearJustSetTimer = null;
                scope.toggleFavorite = function() {
                    $timeout.cancel(clearJustSetTimer);
                    var user = PortalAuthService.validateUserLoggedIn();
                    if (user) {
                        var isFavorite;
                        isFavorite = scope.lot.isFavorite ? !1 : !0, AccountService.setFavoriteItem(scope.lot.house, scope.lot, isFavorite).then(function() {
                            setJustChanged(!0), setFavoriteClassOn(isFavorite), OsInfoService.isMobile() && (clearJustSetTimer = $timeout(function() {
                                setJustChanged(!1);
                            }, 2e3));
                        });
                    }
                }, scope.onMouseOut = function() {
                    setJustChanged(!1), scope.lot.onFavoriteFlag = !1;
                }, scope.onMouseOver = function() {
                    setJustChanged(!1), scope.lot.onFavoriteFlag = !0;
                }, scope.$watch("lot.isFavorite", updateDisplay);
            },
            templateUrl: PathsService.appTemplatePath("catalogs/elements/lotFavoriteFlag")
        };
    });
}), define("portal/js/modules/catalogs/lotElements/lotShareButtons", [ "./lotElementsModule" ], function(module) {
    module.directive("bsLotShareButtons", function($rootScope, StringsService, OsInfoService, SettingsService, PathsService, CatalogsService, AnalyticsService, PortalNavigationService) {
        return {
            restrict: "E",
            replace: !0,
            scope: {
                lot: "=",
                text: "="
            },
            link: function(scope) {
                function trackShare(button) {
                    var item = scope.lot, house = scope.lot.house;
                    if (house) {
                        var eventCategory;
                        item.auction ? (eventCategory = "ENDED" == item.auction.state ? "pastCatalogAction" : "catalogAction", 
                        AnalyticsService.trackEvent(eventCategory, "lotShare", "lot shared in house: " + house.code + ", auction:" + item.auctionDate + ", item:" + item.itemIndex + " button:" + button)) : item.shop && (eventCategory = "shopAction"), 
                        AnalyticsService.trackEvent(eventCategory, "lotShareInHouse", "lot share in house " + house.code), 
                        AnalyticsService.trackEvent(eventCategory, "lotShareWith", "lot share with " + button);
                    }
                }
                function getShareUrl(button) {
                    var ownerParam = scope.lot.auction ? "a=" + scope.lot.auction.intKey : "s=" + scope.lot.shop.intKey, shortUrl = PathsService.getCurrentPortalBase().replace("https", "http") + "share/?b=" + button + "&" + ownerParam + "&l=" + scope.lot.idInApp + "&lang=" + $rootScope.currentLang, encodedShortUrl = encodeURIComponent(shortUrl), fixedTitle = scope.text.replace("<br>", " "), title = encodeURIComponent(fixedTitle), shortTitle = encodeURIComponent(StringsService.trimToWord(fixedTitle, 130 - shortUrl.length)), imageUrl = encodeURIComponent(CatalogsService.getLotImageUrl(scope.lot));
                    switch (button) {
                      case "fb":
                        return "https://www.facebook.com/sharer/sharer.php?u=" + encodedShortUrl;

                      case "twitter":
                        return "https://twitter.com/intent/tweet?status=" + shortTitle + "%0A" + encodedShortUrl;

                      case "pinterest":
                        return "https://pinterest.com/pin/create/bookmarklet/?media=" + imageUrl + "&url=" + encodedShortUrl + "&is_video=false&description=" + title;

                      case "google":
                        return "https://plus.google.com/share?url=" + encodedShortUrl;

                      case "email":
                        return "mailto:?subject=" + title + "&body=" + encodedShortUrl;
                    }
                }
                scope.share = function(button) {
                    trackShare(button);
                    var shareUrl = getShareUrl(button);
                    "email" == button ? window.location = shareUrl : PortalNavigationService.openWindow(shareUrl, "menubar=no,toolbar=no,resizable=yes,scrollbars=yes,height=600,width=600");
                }, scope.buttonName = function(button) {
                    switch (button) {
                      case "fb":
                        return "Facebook";

                      case "twitter":
                        return "Twitter";

                      case "pinterest":
                        return "Pinterest";

                      case "google":
                        return "Google plus";

                      case "email":
                        return "Email";
                    }
                };
            },
            templateUrl: PathsService.appTemplatePath("catalogs/elements/shareButtons")
        };
    });
}), define("portal/js/modules/catalogs/lotElements/index", [ "./lotElementsModule", "./lotFilters", "./lotImageDirective", "./lotPriceDirective", "./lotTextsService", "./lotBadgeDirective", "./lotExpirationDirective", "./lotFavoriteFlagDirective", "./lotShareButtons" ], function() {}), 
define("portal/js/modules/catalogs/list/catalogListModule", [ "angular" ], function(ng) {
    return ng.module("app.catalogs.list", []);
}), define("portal/js/modules/catalogs/list/catalogListItemsDirective", [ "./catalogListModule" ], function(module) {
    module.directive("bsCatalogListItems", function(CatalogsService, PathsService) {
        return {
            restrict: "E",
            replace: !0,
            templateUrl: PathsService.appTemplatePath("catalogs/list/catalogItems")
        };
    });
}), define("portal/js/modules/catalogs/list/catalogListController", [ "./catalogListModule" ], function(module) {
    module.controller("CatalogListController", [ "$rootScope", "$scope", "$timeout", "$state", "$stateParams", "$cookies", "AnalyticsService", "ArraysService", "LocalStorageService", "I18nService", "PortalNavigationService", "CatalogUtilsService", "PortalAuthService", "PortalInfoService", "CatalogsService", "CatalogAccountService", "LotTextsService", function($rootScope, $scope, $timeout, $state, $stateParams, $cookies, AnalyticsService, ArraysService, LocalStorageService, I18nService, PortalNavigationService, CatalogUtilsService, PortalAuthService, PortalInfoService, CatalogsService) {
        function handleInvitedUser() {
            var invitedUserEmail = $cookies.get("invitedUserEmail");
            !invitedUserEmail || "ART" == $rootScope.contentType || $rootScope.currentUser || PortalAuthService.isLoginFormDisplayed() || PortalAuthService.showAuthModalOrScene("login");
        }
        function setScroll() {
            var timeSinceLoad = new Date().getTime() - mLoadTime, timeSinceLastSearch = new Date().getTime() - $scope.filterData.lastSearchTime;
            if ($rootScope.$previousState && 0 == $rootScope.$previousState.url.indexOf("lotPage") && $scope.pagesData && 5e3 > timeSinceLoad && !mScrolledToLot) {
                var lotKey = $rootScope.$previousState.args.lotKey;
                $scope.pagesData.currentPage = CatalogUtilsService.getLotPage($scope.pagesData.visibleItems, lotKey, $scope.pagesData.itemsPerPage), 
                $scope.scrollTo = lotKey, mScrolledToLot = !0, $timeout(function() {
                    $scope.scrollTo = null;
                }, 100);
            } else {
                if (100 > timeSinceLastSearch) return;
                CatalogsService.isLastPageRelevantToCurrentCatalog() || timeSinceLoad > 4e3 ? scrollToPagination() : window.scrollTo(0, 0);
            }
        }
        function scrollToPagination() {
            $scope.scrollToPagination = !0, $timeout(function() {
                $scope.scrollToPagination = !1;
            }, 10);
        }
        function onNavParamChange() {
            CatalogsService.updatePageItems(), $scope.showFakeLoader();
        }
        function watchNavParams() {
            $scope.$watchGroup([ "pagesData.itemsPerPage", "pagesData.currentPage", "filterData.lastSearchTime" ], onNavParamChange);
        }
        var mFakeLoaderTimer = null, mLoadTime = null, mScrolledToLot = !1;
        $scope.data = {}, $scope.filterData = {}, $scope.loadNavStateInfo = function(navState) {
            $scope.mobileElementsDimensions = CatalogsService.getMobileElementsDimensions(), 
            navState.pagesData.currentPage = $stateParams.page ? $stateParams.page : 1, angular.copy(navState.data, $scope.data), 
            $scope.filterData = navState.filterData, $scope.pagesData = navState.pagesData, 
            $scope.houseApprovalState = PortalAuthService.getHouseApprovalState(navState.data.catalogOwner.houseId);
            var phrase = CatalogsService.getNavState().filterData.phrase;
            $timeout(function() {
                CatalogsService.getNavState().filterData.phrase = phrase;
            }, 100), mLoadTime = new Date().getTime(), setScroll(), watchNavParams(), handleInvitedUser();
        }, $scope.showFakeLoader = function() {
            $timeout.cancel(mFakeLoaderTimer), setScroll(), $scope.displayeItemsLoader = !0, 
            mFakeLoaderTimer = $timeout(function() {
                $scope.displayeItemsLoader = !1, setScroll();
            }, 50);
        }, $scope.gotoLot = function(lot, source) {
            CatalogsService.gotoLotPage(lot, source);
        }, watchNavParams();
    } ]);
}), define("portal/js/modules/catalogs/list/catalogListFilterDirective", [ "./catalogListModule" ], function(module) {
    module.directive("bsCatalogListFilter", function($rootScope, $timeout, PathsService, I18nService, ArraysService, SettingsService, DomUtilsService, CatalogsService, CatalogUtilsService) {
        return {
            restrict: "E",
            replace: !0,
            link: function(scope, element) {
                function getAllItems() {
                    return CatalogsService.getNavState().data.items;
                }
                function initSoldStateDisplay() {
                    scope.showSoldState = null != ArraysService.getNotNullKey(getAllItems(), "purchase");
                }
                function scrollToInput() {
                    DomUtilsService.scrollToElementTop(element.find("input"), -130);
                }
                function setCategories() {
                    var categories = CatalogsService.getCategoriesList(getAllItems());
                    categories.length > 0 && categories.unshift({
                        value: "all",
                        name: I18nService.getText("all_categories")
                    }), scope.filterData.categories = categories;
                }
                function sortVisibleItems() {
                    mVisibleItems = scope.pagesData.visibleItems, CatalogUtilsService.sortLots(mVisibleItems, {
                        sortOrder: scope.filterData.selectedSortOrder
                    }), CatalogsService.updatePageItems();
                }
                function setResultMessage() {
                    var messageKey;
                    messageKey = scope.filterData.phrase ? "search_results" : "catalog_results_count", 
                    scope.resultMessage = I18nService.getText(messageKey, {
                        count: scope.pagesData.visibleItems.length,
                        token: scope.filterData.phrase
                    });
                }
                function setSelectedSortOrder(selectedSortOrder) {
                    scope.filterData.selectedSortOrder = selectedSortOrder, scope.applySoldStateFilter();
                }
                function setSortOrders() {
                    var sortOrderValues = [ "high_price", "low_price" ];
                    scope.auction ? sortOrderValues.unshift("index") : scope.shop && (sortOrderValues.unshift("newest"), 
                    allItemsHasOrderInd() && sortOrderValues.unshift("order_in_shop")), scope.filterData.sortOrders = [];
                    for (var i = 0; i < sortOrderValues.length; i++) {
                        var sortOrderValue = sortOrderValues[i];
                        scope.filterData.sortOrders.push({
                            value: sortOrderValue,
                            text: CatalogUtilsService.getSortFieldName(sortOrderValue)
                        });
                    }
                    scope.filterData.selectedSortOrder ? scope.$watch("pagesData.visibleItems", sortVisibleItems) : setSelectedSortOrder(sortOrderValues[0]);
                }
                var mVisibleItems = [], foundItems = null;
                scope.contentType = $rootScope.contentType, scope.scrollToInput = !1, element.bind("keydown keypress", function(event) {
                    13 == event.which && element.find("input")[0].blur();
                }), scope.getSoldStateLabel = function(soldState) {
                    var key;
                    switch (soldState) {
                      case "all":
                        key = "all_items";
                        break;

                      case "sold":
                        key = "only_sold_items";
                        break;

                      case "unsold":
                        key = "only_unsold_items";
                    }
                    return I18nService.getText(key);
                }, scope.doSearch = function() {
                    var phrase = scope.filterData.phrase;
                    phrase && (scope.filterData.category = "all"), foundItems = CatalogsService.filterListWithPhrase(getAllItems(), phrase), 
                    scope.applySoldStateFilter(), scope.pagesData.currentPage = 1, scrollToInput();
                }, scope.onCategoryChanged = function() {
                    scope.pagesData.currentPage = 1, scope.filterByCategory();
                }, scope.filterByCategory = function() {
                    var category = scope.filterData.category;
                    "all" != category ? (scope.filterData.phrase = "", foundItems = CatalogsService.filterListWithCategory(getAllItems(), category)) : scope.filterData.phrase ? scope.searchAfterDelay() : foundItems = getAllItems(), 
                    scope.applySoldStateFilter();
                }, scope.applySoldStateFilter = function() {
                    mVisibleItems = CatalogsService.filterListWithSoldState(foundItems || getAllItems(), scope.filterData.soldState), 
                    CatalogsService.setVisibleItems(mVisibleItems), sortVisibleItems(), scope.filterData.lastSearchTime = new Date().getTime(), 
                    setResultMessage();
                }, scope.clearSearch = function() {
                    scope.filterData.phrase = "", scope.doSearch();
                }, allItemsHasOrderInd = function() {
                    for (var items = getAllItems(), i = 0; i < items.length; i++) if (null == items[i].orderInShop) return !1;
                    return !0;
                }, scope.updateSortOrder = function() {
                    sortVisibleItems(), scope.pagesData.currentPage = 1, CatalogsService.updatePageItems();
                }, scope.$on("i18n.languageChanged", function() {
                    setCategories();
                }), scope.$on("account.dataLoaded", function() {
                    initSoldStateDisplay();
                }), setCategories(), initSoldStateDisplay(), setResultMessage(), setSortOrders();
            },
            templateUrl: PathsService.appTemplatePath("catalogs/list/catalogListFilter")
        };
    });
}), define("portal/js/modules/catalogs/list/catalogListPaginationDirective", [ "./catalogListModule" ], function(module) {
    module.directive("bsCatalogListPagination", function($timeout, $rootScope, $stateParams, PathsService) {
        return {
            restrict: "E",
            replace: !0,
            scope: {
                pagesData: "=",
                positionInPage: "=",
                hrefPages: "=",
                onCurrentPageChange: "&"
            },
            link: function(scope, element) {
                function adjustWidth() {
                    var parent = element.parent()[0];
                    if (parent) {
                        var parentWidth = parent.offsetWidth, availableWidth = Math.min(850, parentWidth);
                        parentWidth > 800 && "upper" == scope.positionInPage && $rootScope.viewPort.pcMedia ? (scope.data.availableWidth = availableWidth - 350, 
                        scope.data.lifted = !0, element.css({
                            width: scope.data.availableWidth + "px"
                        })) : (scope.data.availableWidth = availableWidth, scope.data.lifted = !1);
                    }
                }
                scope.data = {}, adjustWidth(), element.addClass(scope.positionInPage);
            },
            templateUrl: PathsService.appTemplatePath("catalogs/list/catalogPagination")
        };
    });
}), define("portal/js/modules/catalogs/list/index", [ "./catalogListModule", "./catalogListItemsDirective", "./catalogListController", "./catalogListFilterDirective", "./catalogListPaginationDirective" ], function() {}), 
define("portal/js/modules/catalogs/search/searchModule", [ "angular" ], function(ng) {
    return ng.module("app.catalogs.search", []);
}), define("portal/js/modules/catalogs/search/searchService", [ "./searchModule" ], function(module) {
    module.factory("SearchService", function($q, $rootScope, $state, ApiService, I18nService, StringsService, ArraysService, LocalStorageService, AccountService, CatalogsService, PortalInfoService) {
        function getSearchHistory() {
            return mSearchHistory || (mSearchHistory = JSON.parse(LocalStorageService.load("searchHistory") || "[]")), 
            mSearchHistory;
        }
        function addTokenToSearchHistory(token) {
            getSearchHistory(), ArraysService.remove(mSearchHistory, token), mSearchHistory.unshift(token), 
            mSearchHistory = mSearchHistory.slice(0, 20), LocalStorageService.store("searchHistory", JSON.stringify(mSearchHistory));
        }
        function parseSearchServerResponse(response) {
            var info = {
                results: [],
                allAuctionsFound: !0,
                count: response.count
            };
            if (response.hits) for (var hits = JSON.parse(response.hits), i = 0; i < hits.length; i++) {
                var hit = hits[i], item = hit._source;
                item.searchScore = hit._score, info.results.push(item);
            }
            return AccountService.addAccountDataToItems(response, ArraysService.listToMapById(info.results)), 
            info.allAuctionsFound = CatalogsService.setItemsCatalogInfo(info.results), info;
        }
        function getLastSearchInfo() {
            return mLastSearchInfo;
        }
        function getNewSearchInfo() {
            return mNewSearchInfo;
        }
        function gotoSearchScene(token) {
            mNewSearchInfo.token = token, $state.go("app.search"), $rootScope.$broadcast("search.newToken", token);
        }
        function searchCatalogsWithSearchServer(templateCode, token, time, priceOrder, limit, page, tag, house, futureAuctionsOnly) {
            var deferred = $q.defer();
            return ApiService.callApi("/catalogs/searchItemsWithSearchServer/", {
                templateCode: templateCode,
                token: token,
                time: time,
                priceOrder: priceOrder,
                region: $rootScope.currentRegion,
                contentType: $rootScope.contentType,
                lang: I18nService.getCurrentLang(),
                limit: limit,
                skip: (page - 1) * limit,
                allowHidden: $rootScope.devMode,
                judaicaOnly: $rootScope.judaicaOnly,
                contentType: $rootScope.contentType,
                tag: tag,
                house: house,
                futureAuctionsOnly: futureAuctionsOnly
            }).success(function(response) {
                var parsedResponse = parseSearchServerResponse(response);
                parsedResponse.allAuctionsFound && !mTriedToLoadAll ? deferred.resolve(parsedResponse) : PortalInfoService.loadForRegion($rootScope.currentRegion, !0).then(function() {
                    mTriedToLoadAll = !0, parsedResponse = parseSearchServerResponse(response), deferred.resolve(parsedResponse);
                });
            }), deferred.promise;
        }
        function getSuggestions(prefix, time) {
            return ApiService.callApi("/catalogs/getSuggestions", {
                prefix: prefix,
                time: time,
                lang: I18nService.getCurrentLang(),
                contentType: $rootScope.contentType,
                region: $rootScope.currentRegion
            });
        }
        function getSearchTemplates() {
            return ApiService.callApi("/catalogs/getSearchTemplatesCodes");
        }
        var mLastSearchInfo = {}, mNewSearchInfo = {}, mTriedToLoadAll = !1, mSearchHistory = null;
        return {
            gotoSearchScene: gotoSearchScene,
            getLastSearchInfo: getLastSearchInfo,
            getNewSearchInfo: getNewSearchInfo,
            searchCatalogsWithSearchServer: searchCatalogsWithSearchServer,
            getSuggestions: getSuggestions,
            getSearchTemplates: getSearchTemplates,
            getSearchHistory: getSearchHistory,
            addTokenToSearchHistory: addTokenToSearchHistory
        };
    });
}), define("portal/js/modules/catalogs/search/searchInputDirective", [ "./searchModule" ], function(module) {
    module.directive("bsSearchInput", function($q, $rootScope, PathsService, SearchService) {
        return {
            restrict: "E",
            replace: !0,
            link: function(scope) {
                function getHisoryEntriesMatchingToPrefix(prefix) {
                    for (var searchHistory = SearchService.getSearchHistory(), entries = [], i = 0; searchHistory > i; i++) {
                        var entry = searchHistory[i];
                        -1 != entry.indexOf(prefix) && entries.push(entry);
                    }
                    return entries;
                }
                scope.direction = $rootScope.dir, scope.lang = $rootScope.currentLang, scope.showText = $rootScope.viewPort.pcMedia, 
                scope.getSuggestions = function(prefix) {
                    var deferred = $q.defer();
                    return prefix ? SearchService.getSuggestions(prefix, scope.data.searchTime || "FUTURE").then(function(response) {
                        deferred.resolve(getHisoryEntriesMatchingToPrefix(prefix).concat(response.data));
                    }) : deferred.resolve(SearchService.getSearchHistory()), deferred.promise;
                }, scope.onSuggestionSelect = function(selectedItem) {
                    scope.data.searchToken = selectedItem, scope.doSearch();
                };
            },
            templateUrl: PathsService.appTemplatePath("catalogs/search/searchInput")
        };
    });
}), define("portal/js/modules/catalogs/search/searchController", [ "./searchModule" ], function(module) {
    module.controller("SearchController", [ "$scope", "$timeout", "$state", "$stateParams", "$rootScope", "$q", "LocalStorageService", "CatalogUtilsService", "AnalyticsService", "ArraysService", "I18nService", "LogService", "StringsService", "CatalogsService", "AppSiteWinodwsService", "SearchService", "PortalInfoService", "TagsMenusService", function($scope, $timeout, $state, $stateParams, $rootScope, $q, LocalStorageService, CatalogUtilsService, AnalyticsService, ArraysService, I18nService, LogService, StringsService, CatalogsService, AppSiteWinodwsService, SearchService, PortalInfoService, TagsMenusService) {
        function setCurrentPageResults() {
            return getSearchResultsForCurrentPage().then(function(response) {
                var count = response.count;
                $scope.pagesData.itemsCount = count;
                var textKey = "", token = $scope.data.searchToken, tagName = $scope.data.tag ? I18nService.getText("tag_" + $scope.data.tag) : "";
                token || (token = tagName, tagName = ""), textKey = count ? tagName ? "search_results_tag" : "search_results" : tagName ? "search_no_results_tag" : "search_no_results", 
                $scope.resultMessage = I18nService.getText(textKey, {
                    count: count,
                    token: token,
                    tag: tagName
                }), setItems(response.results);
            });
        }
        function getSearchResultsForCurrentPage() {
            mSearchInfo.searchTime = new Date().getTime(), $scope.loadState = "loading";
            var token = $scope.data.searchToken, tag = $scope.data.tag;
            return tag && tag.match(/_all$/) && (tag = tag.split("_")[0]), token && SearchService.addTokenToSearchHistory(token), 
            SearchService.searchCatalogsWithSearchServer(getSearchTemplate(), token, $scope.data.searchTime, getPriceSortOrder(), $scope.pagesData.itemsPerPage, $scope.pagesData.currentPage, tag, $scope.data.houseCode, $scope.data.futureAuctionsOnly);
        }
        function trackSearch(token, tag) {
            if ($scope.data.lastTrackedToken != token || $scope.data.tag != $scope.data.lastTag || $scope.data.lastTrackedToken != token) {
                var eventCatagory = "PAST" == $scope.data.searchTime ? "pastCatalogAction" : "catalogAction";
                token && AnalyticsService.trackEvent(eventCatagory, "search", "search for token '" + token + "'"), 
                tag && AnalyticsService.trackEvent(eventCatagory, "search", "search for tag '" + tag + "'"), 
                $scope.data.lastTrackedToken = token, $scope.data.lastTag = tag, $scope.data.lastSearchTime = $scope.data.searchTime;
            }
        }
        function shouldDisplayItem(item) {
            return item.catalogInfo ? !0 : !1;
        }
        function setItems(items) {
            var visibleItems = [];
            angular.forEach(items, function(item) {
                shouldDisplayItem(item) && visibleItems.length < $scope.pagesData.itemsPerPage && (item.houseBadge = CatalogUtilsService.getHouseBadgeForLot(item), 
                visibleItems.push(item));
            }), $scope.pagesData.pageItems = visibleItems, $scope.loadState = "loaded";
        }
        function initToken(token, reloadSearch) {
            $scope.data.searchToken = token, reloadSearch && $scope.doSearch();
        }
        function getSearchTemplate() {
            switch ($scope.data.selectedSortOrder) {
              case "relevance":
                return "by_relevance";

              case "time":
                return "by_time";

              case "low_price":
                return "by_price";

              case "high_price":
                return "by_price";

              case "test":
                return "test";
            }
        }
        function getPriceSortOrder() {
            switch ($scope.data.selectedSortOrder) {
              case "low_price":
                return "ASC";

              case "high_price":
                return "DESC";

              default:
                return null;
            }
        }
        function onNewSearchEvent(event, token) {
            initToken(token, !0);
        }
        function handleSearchCode(code) {
            code && 0 == code.indexOf("auctions_only") && ($scope.data.tag = code.split("only_")[1], 
            $scope.data.futureAuctionsOnly = !0, $scope.data.selectedSortOrder = "time", $scope.doSearch());
        }
        function handleSearchTokenInUrl(token) {
            var token = $stateParams.token;
            token && ($scope.data.searchToken = decodeURIComponent(token), $stateParams.time && ($scope.data.searchTime = $stateParams.time), 
            $scope.doSearch());
        }
        function init() {
            mSearchInfo = SearchService.getLastSearchInfo(), $scope.mobileElementsDimensions = CatalogsService.getMobileElementsDimensions();
            var newSearchInfo = SearchService.getNewSearchInfo();
            $scope.loadState = "idle", $scope.scrollToPagination = !1, $scope.tags = TagsMenusService.getAllTags(), 
            null != newSearchInfo.token ? (initToken(newSearchInfo.token, !0), mSearchInfo.data = $scope.data, 
            mSearchInfo.pagesData = $scope.pagesData, window.scroll(0, 0)) : mSearchInfo.lastLot && CatalogsService.isLastPageRelevantToCurrentCatalog() && new Date().getTime() - mSearchInfo.searchTime < 6e5 ? ($scope.data = mSearchInfo.data, 
            $scope.pagesData = mSearchInfo.pagesData, $scope.scrollTo = mSearchInfo.lastLot ? mSearchInfo.lastLot.id : null, 
            $scope.loadState = "loaded", initToken($scope.data.searchToken, !1)) : (mSearchInfo.data = $scope.data, 
            mSearchInfo.pagesData = $scope.pagesData, $scope.data.tag = $stateParams.tag, $scope.data.tag && $scope.doSearch(), 
            handleSearchCode($stateParams.searchCode), handleSearchTokenInUrl(), window.scroll(0, 0)), 
            newSearchInfo.token = null, $rootScope.devMode && -1 == $scope.data.sortOrderCodes.indexOf("test") && $scope.data.sortOrderCodes.push("test"), 
            $rootScope.$on("search.newToken", onNewSearchEvent);
        }
        mSearchInfo = null, $scope.data = {
            searchTime: "FUTURE",
            selectedSortOrder: LocalStorageService.load("lastSortOrder") || "relevance",
            sortOrderCodes: [ "relevance", "high_price", "low_price", "time" ],
            futureAuctionsOnly: !1,
            houseCode: "all"
        }, "ART" != $rootScope.contentType && ($scope.data.selectedSortOrder = "relevance"), 
        $scope.catalogSource = "search", $scope.pagesData = {
            itemsPerPage: $rootScope.viewPort.pcMedia ? 50 : 20,
            currentPage: 1
        }, $scope.doSearch = function() {
            ($scope.data.searchToken || $scope.data.tag) && ($scope.pagesData.currentPage = 1, 
            $scope.pagesData.itemsCount = 0, $scope.pagesData.resultMessage = "", $scope.searching = !0, 
            LogService.logEvent({
                search: $scope.data.searchToken,
                time: $scope.data.searchTime,
                houseCode: $scope.data.houseCode,
                tag: $scope.data.tag
            }), trackSearch($scope.data.searchToken, $scope.data.tag), setCurrentPageResults().then(function() {
                $scope.searching = !1, $scope.data.searchedToken = $scope.data.searchToken;
            }), document.activeElement.blur());
        }, $scope.onPageChange = function() {
            $scope.scrollToPagination = !1, setCurrentPageResults().then(function() {
                $timeout(function() {
                    $scope.scrollToPagination = !0;
                }, 100);
            });
        }, $scope.gotoLot = function(lot) {
            lot.onFavoriteFlag || (mSearchInfo.lastLot = lot, CatalogsService.gotoLotPage(lot, "search"));
        }, $scope.gotoLotInNewWindow = function(lot) {
            lot.onFavoriteFlag || (mSearchInfo.lastLot = lot, CatalogsService.gotoLotPage(lot, "search"));
        }, $scope.setHouseFilter = function(houseCode) {
            $scope.data.houseCode = "all" == houseCode ? null : houseCode, $scope.doSearch();
        }, $scope.setSearchTime = function(searchTime) {
            $scope.data.searchTime = searchTime, $scope.doSearch();
        }, $scope.updateSortOrder = function() {
            LocalStorageService.store("lastSortOrder", $scope.data.selectedSortOrder), $scope.doSearch();
        }, $scope.getSortOrderName = function(sortCode) {
            return CatalogUtilsService.getSortFieldName(sortCode);
        }, init();
    } ]);
}), define("portal/js/modules/catalogs/search/index", [ "./searchModule", "./searchService", "./searchInputDirective", "./searchController" ], function() {}), 
define("portal/js/modules/catalogs/lotPage/lotPageModule", [ "angular" ], function(ng) {
    return ng.module("app.catalogs.lotPage", []);
}), define("portal/js/modules/catalogs/lotPage/lotPageController", [ "./lotPageModule" ], function(module) {
    module.controller("LotPageController", [ "$scope", "$state", "$stateParams", "$uibModal", "$rootScope", "$timeout", "$window", "AnalyticsService", "SettingsService", "ArraysService", "StringsService", "PathsService", "I18nService", "PortalAuthService", "PortalInfoService", "DomUtilsService", "CatalogUtilsService", "LocalStorageService", "PortalNavigationService", "StructuredDataService", "PopupsService", "AccountService", "UserAlertsService", "CatalogsService", "CatalogAccountService", "LotTextsService", function($scope, $state, $stateParams, $uibModal, $rootScope, $timeout, $window, AnalyticsService, SettingsService, ArraysService, StringsService, PathsService, I18nService, PortalAuthService, PortalInfoService, DomUtilsService, CatalogUtilsService, LocalStorageService, PortalNavigationService, StructuredDataService, PopupsService, AccountService, UserAlertsService, CatalogsService, CatalogAccountService, LotTextsService) {
        function initTexts() {
            var item = $scope.data.item;
            if (item) {
                var textOptions = {};
                LotTextsService.emptyTextsInLang(item, $rootScope.currentLang) || (textOptions.currentLangOnly = !0);
                var artist = I18nService.getLangField(item.artist), name = I18nService.getLangField(item.name, textOptions), description = I18nService.getLangField(item.description, textOptions), details = I18nService.getLangField(item.details, textOptions), shortTitle = "", fullTitle = "", fullTitle = "", lotDesc = description + "<br>" + details;
                item.carInfo ? ($scope.carInfo = item.carInfo, shortTitle = fullTitle = LotTextsService.getCarLotTitle(item), 
                lotDesc = "", initDocuments(item.carInfo.documents), $scope.data.carInfoNotes = item.carInfo.notes || "", 
                item.carInfo.tariffPrice && ($scope.data.carInfoNotes += "\n\n" + I18nService.getText("no_commitment_to_tariff_price")), 
                $scope.data.carInfoNotes = $scope.data.carInfoNotes.replace(/^\n+/, ""), $scope.contentType = "CARS") : item.realEstateInfo ? ($scope.realEstateInfo = item.realEstateInfo, 
                shortTitle = fullTitle = LotTextsService.getRealEstateLotTitle(item), $scope.contentType = "REAL_ESTATE", 
                initDocuments(item.realEstateInfo.documents)) : artist ? (shortTitle = fullTitle = LotTextsService.getRealEstateLotTitle(item), 
                $scope.contentType = "ART", shortTitle = StringsService.stripTags(artist), fullTitle = artist, 
                name && (shortTitle += "<br>", fullTitle += "<br>" + name, name.length > 60 ? (shortTitle += StringsService.trimToWord(name, 55), 
                $scope.showMore = !0) : shortTitle += name, lotDesc = name + "<br>" + lotDesc)) : name ? (fullTitle = name, 
                name.length > 120 ? (shortTitle = StringsService.trimToWord(name, 120), $scope.showMore = !0, 
                lotDesc = name + "<br>" + lotDesc) : shortTitle = name) : description && (shortTitle = StringsService.trimToWord(description, 120), 
                description.length > 100 && ($scope.showMore = !0)), StringsService.isBlank(StringsService.stripTags(lotDesc)) || ($scope.showMore = !0), 
                item.lotTitle = shortTitle, $scope.data.shortTitle = shortTitle, $scope.data.fullTitle = fullTitle, 
                $scope.data.lotDesc = lotDesc, StringsService.isBlank(StringsService.stripTags($scope.data.lotDesc)) && ($scope.data.lotDesc = "");
            }
        }
        function initDocuments(documents) {
            if ($scope.documents = [], documents) for (docKey in documents) {
                var link = documents[docKey];
                link && $scope.documents.push({
                    label: docKey,
                    link: link
                });
            }
            var item = $scope.data.item;
            if (item.auction && item.auction.documents) for (docKey in item.auction.documents) {
                var label = I18nService.getText("auction_doc_" + docKey);
                ArraysService.getByKey($scope.documents, "label", label) || $scope.documents.push({
                    label: label,
                    link: item.auction.documents[docKey]
                });
            }
        }
        function initFavoriteMessageWatch() {
            $scope.$watch("data.item.isFavorite", function(isFavorite, oldValue) {
                isFavorite !== oldValue && ($scope.favoriteToastMessage = isFavorite ? "lot_page_added_to_favorites" : "lot_page_removed_from_favorites", 
                $timeout(function() {
                    $scope.favoriteToastMessage = null;
                }, 15e3));
            });
        }
        function initItemAlertMessageWatch() {
            $scope.itemAlertsEnabled = UserAlertsService.isItemAlertEnabled($scope.data.item), 
            $scope.$watch("data.item.itemAlertOn", function(isOn, oldValue) {
                isOn !== oldValue && ($scope.itemAlertToastMessage = isOn ? "item_alert_added" : "item_alert_removed", 
                $timeout(function() {
                    $scope.itemAlertToastMessage = null;
                }, 15e3));
            });
        }
        function displayInquiryToast() {
            $scope.showInquiryToast = !0, $timeout(function() {
                $scope.showInquiryToast = !1;
            }, 15e3);
        }
        function setDocumentTitle() {
            var item = $scope.data.item, textForTitle = I18nService.getLangField(item.artist);
            textForTitle || (textForTitle = I18nService.getLangField(item.name)), textForTitle || (textForTitle = I18nService.getLangField(item.description)), 
            textForTitle || (textForTitle = ""), textForTitle = StringsService.stripTags(textForTitle);
            var titleWords = textForTitle.split(/\s/), documentTitle = "bidspirit";
            $scope.data.house && (documentTitle += " - " + I18nService.getLangField($scope.data.house.details.name));
            for (var addedWords = 0, i = 0; i < titleWords.length && 5 > addedWords; i++) {
                var word = titleWords[i];
                word && (0 == addedWords && (documentTitle += " -"), documentTitle += " " + word, 
                addedWords++);
            }
            document.title = documentTitle;
        }
        function setDocumentDescriptionTags() {
            var item = $scope.data.item;
            DomUtilsService.setMetaTag("property", "og:type", "og:product"), DomUtilsService.setMetaTag("name", "twitter:card", "product"), 
            StructuredDataService.setDescriptionMetaTags(StringsService.stripTags(LotTextsService.getLotText(item, 255))), 
            StructuredDataService.setImageMetaTags(CatalogsService.getLotImageUrl(item, 0, "400x400", "fit"), "400", "400"), 
            StructuredDataService.setPriceStructuredDataMetaTags(item, $scope.data.catalogOwner.currency), 
            item.auction && StructuredDataService.setTwitterData(2, I18nService.getText("auction_date"), CatalogUtilsService.getAuctionTimeDisplay(item.auction, !1));
        }
        function initDisplay() {
            var item = $scope.data.item;
            $window.scrollTo(0, 0), initTexts(), setDocumentTitle(), setTextDirection(), setDocumentDescriptionTags(), 
            item.auction ? (CatalogAccountService.loadForAuction(item.auction).then(function() {
                initFavoriteMessageWatch(), initItemAlertMessageWatch();
            }), trackEventsForAuction()) : item.shop && (CatalogAccountService.loadForShop(item.shop).then(function() {
                initFavoriteMessageWatch(), initItemAlertMessageWatch();
            }), trackEventsForShop()), setInforForAdmin(), AnalyticsService.saveLotView(item.id);
        }
        function setTextDirection() {
            var catalogDirection = $scope.data.catalogOwner.catalogTextDirection, langDirection = DomUtilsService.getDirection();
            catalogDirection && catalogDirection != langDirection ? ($scope.textDirection = catalogDirection, 
            $scope.forcedDirection = !0) : $scope.textDirection = langDirection;
        }
        function trackEventsForShop() {
            var item = $scope.data.item, shop = item.shop, house = shop ? shop.house : null;
            item && shop && house && !$scope.eventTracked && AnalyticsService.trackEvent("shopAction", "lotPageViewInHouse", "lot viewed in house " + house.code);
        }
        function trackEventsForAuction() {
            var item = $scope.data.item, auction = item.auction, house = auction ? auction.house : null;
            if (item && auction && house && !$scope.eventTracked) {
                $scope.eventTracked = !0;
                var eventCategory = "ENDED" == auction.state ? "pastCatalogAction" : "catalogAction";
                AnalyticsService.trackEvent(eventCategory, "lotPageViewInHouse", "lot viewed in house " + house.code), 
                AnalyticsService.trackEvent(eventCategory, "lotPageViewInAuction", "lot viewed in house: " + house.code + ", auction: " + item.auctionDate), 
                auction.auctionIdInApp && house.hostingServerName && AnalyticsService.trackEvent(eventCategory, "lotPageViewInAuctionForItem", "lot viewed in house: " + house.code + ", auction:" + item.auctionDate + ", item:" + item.itemIndex, {
                    appSiteTrackInfo: {
                        house: house,
                        api: "auctions/catalog/logLotPageView.api",
                        params: {
                            auctionId: auction.auctionIdInApp,
                            lotId: item.idInApp
                        }
                    }
                });
            }
        }
        function handleMissingCatalogOwner() {
            $state.go("app.home");
        }
        function handleMissingItem() {
            $scope.isFromAcount && $rootScope.currentUser ? $state.go("app.accountActions", {
                actionType: $stateParams.source
            }) : $state.go("app." + $stateParams.ownerType + "Catalog", {
                catalogKey: $stateParams.catalogKey
            });
        }
        function onItemLoaded(item) {
            if (item) {
                if ($scope.data.house = $scope.data.catalogOwner.house, LocalStorageService.store("lastVisitedLot", item.id), 
                !$scope.data.house) return void handleMissingCatalogOwner();
                $scope.data.item = item, CatalogsService.getNavState().lastLotPageVisited = {
                    lot: item,
                    source: $scope.source
                }, initDisplay();
            } else handleMissingItem(item);
            $scope.$on("viewPort.windowSizeChanged", function() {
                PathsService.reloadStateAfterDelay(200);
            }), $scope.$on("catalog.inquirySent", displayInquiryToast);
        }
        function setInforForAdmin() {
            var item = $scope.data.item;
            $rootScope.currentUser && item.auction && ("ADMIN" == $rootScope.currentUser.role || "SYSTEM" == $rootScope.currentUser.role) && $rootScope.viewPort.pcMedia && ($scope.shortLink = PathsService.getCurrentPortalBase() + "?auction=" + item.auction.intKey + "&lot=" + item.idInApp + "&from=link");
        }
        function init() {
            switch ($scope.source = $stateParams.source, ("purchases" == $scope.source || "absentee" == $scope.source) && ($scope.isFromAcount = !0), 
            $stateParams.ownerType) {
              case "auction":
                PortalInfoService.loadAuction($stateParams.catalogKey).then(function(auction) {
                    auction && "PENDING" != auction.state ? ($scope.data.catalogOwner = auction, $scope.contentType = auction.catalogContentType, 
                    CatalogsService.getAuctionItem(auction, $stateParams.lotKey).then(onItemLoaded)) : handleMissingCatalogOwner();
                });
                break;

              case "shop":
                var shop = PortalInfoService.getShop($stateParams.catalogKey);
                shop ? ($scope.data.catalogOwner = shop, $scope.contentType = shop.catalogContentType, 
                CatalogsService.getShopItem(shop, $stateParams.lotKey).then(onItemLoaded)) : handleMissingCatalogOwner();
                break;

              default:
                handleMissingCatalogOwner();
            }
        }
        $scope.data = {
            catalogOwner: null,
            item: null,
            focusedImage: 0
        }, $scope.scrollToDescriptionFlag = !1, $scope.showInquiryToast = !1, $scope.favoriteToastMessage = null, 
        $scope.openAuctionHouseTerms = function() {
            PopupsService.showHouseTerms($scope.data.house);
        }, $scope.scrollToDescription = function() {
            $scope.scrollToDescriptionFlag = !0, $timeout(function() {
                $scope.scrollToDescriptionFlag = !1;
            });
        }, $scope.showFullText = function() {
            $scope.data.showFullText = !0;
        }, $scope.showIncrements = function() {
            var title = I18nService.getText("house_increments_title", {
                house: I18nService.getLangField($scope.data.house.details.name)
            }), currency = $scope.data.item.catalogOwner.catalogInfo.currency;
            PortalInfoService.getHouseIncrementsSteps($scope.data.house.id).then(function(steps) {
                PopupsService.showInfoPopup({
                    title: title,
                    contentInclude: "catalogs/lotPage/common/increments",
                    code: "increments",
                    backText: "back",
                    data: {
                        steps: steps,
                        currency: currency
                    }
                });
            });
        }, $scope.showInquiryForm = function() {
            $scope.showInquiryToast = !1;
            var user = PortalAuthService.validateUserLoggedIn();
            user && ("UNCONFIRMED_EMAIL" == user.registrationStage ? PortalAuthService.showAuthModalOrScene("warning") : PopupsService.showPopup({
                contentInclude: "catalogs/lotPage/common/inquiry/inquiryForm",
                code: "inquiry",
                title: I18nService.getText("inquiry_form_title"),
                data: {
                    item: $scope.data.item,
                    user: user,
                    hideTopBackButton: !0,
                    house: I18nService.getLangField($scope.data.house.details.name)
                }
            }));
        }, $scope.toggleFavorite = function() {
            var user = PortalAuthService.validateUserLoggedIn();
            if ($scope.favoriteToastMessage = null, user) {
                var isFavorite;
                isFavorite = $scope.data.item.isFavorite ? !1 : !0, AccountService.setFavoriteItem($scope.data.house, $scope.data.item, isFavorite);
            }
        }, $scope.toggleItemAlert = function() {
            var user = PortalAuthService.validateUserLoggedIn();
            if ($scope.itemAlertToastMessage = null, user) {
                var isAlertOn;
                isAlertOn = $scope.data.item.itemAlertOn ? !1 : !0, UserAlertsService.setItemAlert($scope.data.item, isAlertOn);
            }
        }, $scope.openWindow = PortalNavigationService.openWindow, init();
    } ]);
}), define("portal/js/modules/catalogs/lotPage/lotPageNavigationDirective", [ "./lotPageModule" ], function(module) {
    module.directive("bsLotPageNavigation", function($stateParams, PathsService, PortalNavigationService, CatalogsService, ArraysService) {
        return {
            restrict: "E",
            replace: !0,
            scope: {
                lot: "="
            },
            link: function(scope) {
                if (scope.source = $stateParams.source, "catalog" == scope.source) {
                    var items = CatalogsService.getNavState().pagesData.visibleItems, lotInd = ArraysService.getIndById(items, scope.lot.id);
                    lotInd > 0 && (scope.previousLot = items[lotInd - 1]), lotInd < items.length - 1 && (scope.nextLot = items[lotInd + 1]);
                }
                var house;
                scope.lot.auction && (house = scope.lot.house, scope.catalogLink = PathsService.getAuctionHref(scope.lot.auction)), 
                scope.lot.shop && (house = scope.lot.shop.house, scope.catalogLink = PathsService.getUiHref("/catalog/shop/" + scope.lot.shop.intKey + "/")), 
                scope.backToList = function() {
                    PortalNavigationService.backFromLotPageToList(house.id, $stateParams.source);
                };
            },
            templateUrl: PathsService.appTemplatePath("catalogs/lotPage/common/navigation/lotPageNavigation")
        };
    });
}), define("portal/js/modules/catalogs/lotPage/lotPageNavLinkDirective", [ "./lotPageModule" ], function(module) {
    module.directive("bsLotPageNavLink", function($rootScope, PathsService) {
        return {
            restrict: "E",
            replace: !0,
            scope: {
                name: "="
            },
            link: function(scope) {
                scope.direction = $rootScope.dir, scope.lang = $rootScope.currentLang, scope.showText = $rootScope.viewPort.pcMedia;
            },
            templateUrl: PathsService.appTemplatePath("catalogs/lotPage/common/navigation/lotPageNavLink")
        };
    });
}), define("portal/js/modules/catalogs/lotPage/lotPageZoomDirective", [ "./lotPageModule" ], function(module) {
    module.directive("bsLotPageZoom", function($stateParams, $rootScope, PathsService, ViewPortService, OsInfoService) {
        return {
            restrict: "E",
            replace: !0,
            scope: {
                lot: "=",
                initialImageInd: "="
            },
            link: function(scope, element) {
                function init() {
                    window.scroll(0, 0), ViewPortService.updateViewportInfo(), scope.selectedImageInd = null != $stateParams.imageInd ? $stateParams.imageInd : scope.initialImageInd, 
                    scope.loadedImageInfo = {}, scope.enableImageModeSwitch = !1, OsInfoService.isMobile() ? (scope.options = {
                        moveInFrame: !0,
                        imageMode: "limit",
                        maxThumbsWidth: ViewPortService.clientWidth() - 150 + "px",
                        asBg: !0
                    }, scope.$on("viewPort.windowSizeChanged", setThumbScrollPosition)) : scope.options = {
                        enableMagnifier: !0,
                        maxThumbsWidth: "800px"
                    };
                }
                function waitForImageToLoad() {
                    scope.loadedImageInfo.loaded = !1, scope.cursorZoomClass = null;
                }
                function setThumbScrollPosition() {
                    var thumbsParent = angular.element(element[0].querySelector(".thumbs")), thumb = element[0].querySelectorAll(".thumb")[scope.selectedImageInd], nonImageHeight = 192;
                    if (thumb && (thumbsParent[0].scrollLeft = thumb.offsetLeft - thumb.offsetWidth - 100, 
                    nonImageHeight += 100), scope.options.moveInFrame) {
                        var css = {
                            height: $rootScope.viewPort.clientHeight - nonImageHeight + "px"
                        };
                        angular.element(element[0].querySelector(".big-image")).css(css), GlobalConfig.isMobileApp && (scope.debugInfo = {
                            imageHeight: css.height,
                            innerHeight: window.innerHeight,
                            clientHeight: $rootScope.viewPort.clientHeight
                        });
                    }
                }
                scope.setZoomImage = function(ind) {
                    var length = scope.lot.imagesList.length;
                    scope.selectedImageInd = (1 * ind + length) % length, waitForImageToLoad(), setThumbScrollPosition();
                }, scope.prevImage = function() {
                    scope.setZoomImage(scope.selectedImageInd - 1);
                }, scope.nextImage = function() {
                    scope.setZoomImage(scope.selectedImageInd + 1);
                }, scope.$watch("loadedImageInfo.loaded", function() {
                    if (scope.loadedImageInfo.loaded) if ("limit" == scope.options.imageMode) {
                        {
                            scope.loadedImageInfo.size.width;
                        }
                        scope.enableImageModeSwitch = !1, scope.cursorZoomClass = null, setThumbScrollPosition();
                    } else scope.enableImageModeSwitch = !0;
                }), init();
            },
            templateUrl: PathsService.appTemplatePath("catalogs/lotPage/common/images/lotPageZoom")
        };
    });
}), define("portal/js/modules/catalogs/lotPage/lotPageImagesDirective", [ "./lotPageModule" ], function(module) {
    module.directive("bsLotPageImages", function($rootScope, $state, $uibModal, PathsService, ArraysService, CloudinaryService, ViewPortService) {
        return {
            restrict: "E",
            replace: !0,
            scope: {
                lot: "="
            },
            link: function(scope) {
                function zoomInScene(lot, imageInd) {
                    $state.go(".zoom", {
                        imageInd: imageInd
                    });
                }
                function zoomInModal(lot, imageInd) {
                    $uibModal.open({
                        templateUrl: PathsService.appTemplatePath("catalogs/lotPage/pc/lotZoomModal"),
                        size: "huge",
                        controller: function($scope) {
                            $scope.data = {
                                item: lot,
                                imageInd: imageInd
                            };
                        }
                    });
                }
                scope.mainImagewidth = Math.min(ViewPortService.clientWidth() - 30, 600), scope.zoomImage = function(lot, imageInd) {
                    $rootScope.viewPort.pcMedia ? zoomInModal(lot, imageInd) : zoomInScene(lot, imageInd);
                };
            },
            templateUrl: PathsService.appTemplatePath("catalogs/lotPage/common/images/lotPageImages")
        };
    });
}), define("portal/js/modules/catalogs/lotPage/inquiryFormController", [ "./lotPageModule" ], function(module) {
    module.controller("InquiryFormController", [ "$scope", "$rootScope", "$timeout", "$window", "StringsService", "I18nService", "PortalInfoService", "PopupsService", function($scope, $rootScope, $timeout, $window, StringsService, I18nService, PortalInfoService) {
        $scope.init = function() {
            $scope.options.buttons = [ {
                text: "send",
                action: $scope.submitInquiryForm
            }, {
                text: "close",
                type: "warning",
                isCloseButton: !0
            } ];
            var item = $scope.options.data.item;
            $scope.inquiryData = {
                subject: I18nService.getText("inquiry_form_subject_content", {
                    lotIndex: item.itemIndex,
                    lotName: item.lotTitle
                })
            };
        }, $scope.submitInquiryForm = function() {
            $scope.inquiryForm.submit();
        }, $scope.sendInquiry = function() {
            var item = $scope.options.data.item;
            return PortalInfoService.sendLotInquiryRequest(item.id, item.lotTitle, $scope.inquiryData.content).then(function() {
                $timeout(function() {
                    $rootScope.$broadcast("catalog.inquirySent", item);
                }, 500), $scope.closePopup();
            });
        };
    } ]);
}), define("portal/js/modules/catalogs/lotPage/lotTags", [ "./lotPageModule" ], function(module) {
    module.directive("bsLotTags", function($rootScope, PathsService, PortalNavigationService, CatalogsService, ArraysService, I18nService) {
        return {
            restrict: "E",
            replace: !0,
            scope: {
                lot: "="
            },
            link: function(scope) {
                var tags = scope.lot.tags || [];
                scope.tags = [];
                for (var i = 0; i < tags.length; i++) {
                    var tag = tags[i].trim();
                    I18nService.searchTextByKey("tag_" + tag) && (tag.match(/_all$/) && (tag = tag.split("_")[0]), 
                    scope.tags.push(tag));
                }
            },
            templateUrl: PathsService.appTemplatePath("catalogs/lotPage/common/navigation/lotTags")
        };
    });
}), define("portal/js/modules/catalogs/lotPage/index", [ "./lotPageModule", "./lotPageController", "./lotPageNavigationDirective", "./lotPageNavLinkDirective", "./lotPageZoomDirective", "./lotPageImagesDirective", "./inquiryFormController", "./lotTags" ], function() {}), 
define("portal/js/modules/catalogs/index", [ "./catalogsModule", "./catalogsService", "./catalogAccountService", "./lotElements/index", "./list/index", "./search/index", "./lotPage/index" ], function() {}), 
define("portal/js/modules/auctions/auctionsModule", [ "angular" ], function(ng) {
    return ng.module("app.auctions", [ "app.auctions.home", "app.auctions.auctionInfo", "app.auctions.lists", "app.auctions.catalog", "app.auctions.lotPageElements" ]);
}), define("portal/js/modules/auctions/home/homeModule", [ "angular" ], function(ng) {
    return ng.module("app.auctions.home", []);
}), define("portal/js/modules/auctions/home/homeController", [ "./homeModule" ], function(module) {
    module.controller("HomeController", [ "$scope", "$rootScope", "$timeout", "$window", "ArraysService", "I18nService", "PathsService", "ViewPortService", "OsInfoService", "LocalStorageService", "PopupsService", "SettingsService", "SessionsService", "PortalInfoService", "SearchService", "AuctionsListsService", "PortalNavigationService", function($scope, $rootScope, $timeout, $window, ArraysService, I18nService, PathsService, ViewPortService, OsInfoService, LocalStorageService, PopupsService, SettingsService, SessionsService, PortalInfoService, SearchService, AuctionsListsService, PortalNavigationService) {
        function setUpperMessage() {
            var textImageName = "bidspirit", serverFilesBase = $rootScope.serverFilesBase, regionPart = -1 == [ "RU", "RO" ].indexOf($rootScope.currentRegion) ? "il" : $rootScope.currentRegion.toLowerCase(), textKey = "home_upper_message_" + regionPart;
            $rootScope.judaicaOnly ? (textImageName = "judaica", textKey = "home_upper_message_judaica") : "CARS" == $rootScope.contentType ? (textImageName = "cars-" + regionPart, 
            textKey = "home_upper_message_cars_" + regionPart) : "REAL_ESTATE" == $rootScope.contentType && (textImageName = "houses-" + regionPart, 
            textKey = "home_upper_message_real_estate_" + regionPart, GlobalConfig.isMobileApp && (serverFilesBase = "https://bidspirit-portal.global.ssl.fastly.net/"));
            var textImagePath = serverFilesBase + GlobalConfig.appName + "/images/home/text/" + textImageName + ".png";
            $scope.upperMessage = I18nService.getTextWithRegion(textKey, {
                logo: '<img class="logo-text ' + textImageName + '" src="' + textImagePath + '" alt="' + textImageName + '" >'
            });
        }
        function adjustUpperPartHeight() {
            $scope.screenHeightClass = "normal", $rootScope.inIframe ? $scope.screenHeightClass = "in-iframe" : ViewPortService.clientHeight() < 650 && ($scope.screenHeightClass = "narrow-screen"), 
            $scope.featuresAsLinks = ViewPortService.clientWidth() >= 1200;
        }
        function scrollToAuctions(sectionName) {
            $timeout.cancel(mScrollTimer), $scope.auctionsToScrollTo[sectionName] = !1, $timeout(function() {
                OsInfoService.isMobile() && ($scope.auctionScrollOffset = -80, $rootScope.currentUser && ($scope.auctionScrollOffset -= 30)), 
                $scope.autoScrollEnabled = !0, $scope.auctionsToScrollTo[sectionName] = !0;
            }, 100);
        }
        function scrollToAuctionsIfNotFirstVisits() {
            if ($timeout.cancel(mScrollTimer), OsInfoService.isMobile()) {
                if ($rootScope.lastAuctionClick && "app.home" == $rootScope.lastAuctionClick.state) return;
                var homeVisits = LocalStorageService.load("homeVisits") || 0;
                homeVisits > 2 && (scrollToAuctions("coming_auctions"), mScrollTimer = $timeout(function() {
                    scrollToAuctions("coming_auctions");
                }, 500)), (homeVisits + "").length > 3 && (homeVisits = "1"), LocalStorageService.store("homeVisits", 1 * homeVisits + 1);
            }
        }
        function loadAuctions() {
            $scope.data = AuctionsListsService.getAuctionsListsData(PortalInfoService.getAuctions(), {
                specialSectionForMinorAuctions: !0,
                specialSectionForPostSale: !0
            }), $scope.data.shops = PortalInfoService.getShops();
        }
        function init() {
            setUpperMessage(), adjustUpperPartHeight(), loadAuctions(), $scope.recentAuctionsVisible = $scope.data.recentAuctions.length > 0 && !OsInfoService.isMobile(), 
            $scope.futureAuctionsVisible = $scope.data.futureAuctions.length > 0 && !OsInfoService.isMobile() && "ART" == $rootScope.contentType, 
            $scope.futureAuctionsButtonVisible = OsInfoService.isMobile() && $scope.data.futureAuctions.length > 0 && "ART" == $rootScope.contentType, 
            $scope.resultsButtonVisible = !0, $scope.onRegionClick = PortalNavigationService.gotoRegion, 
            $scope.showDemoVideo = PortalNavigationService.showDemoVideo, "CARS" == $scope.contentType && "RO" != $scope.currentRegion && ($scope.shouldDisplayVideoLink = !0, 
            $scope.showDemoVideo = PortalNavigationService.showDemoVideo);
        }
        function onLinkClicked(e, linkInfo) {
            "auctions" == linkInfo.menu && scrollToAuctions(linkInfo.link);
        }
        $scope.auctionsToScrollTo = {
            direct_sale: !1,
            coming_auctions: !1
        };
        var mScrollTimer = null;
        $scope.doSearch = function() {
            SearchService.gotoSearchScene($scope.data.searchToken);
        }, $scope.showAllFutureAuctions = function() {
            PopupsService.showFutureAuctionsPopup();
        }, $scope.showFutureAuctions = function() {
            $scope.futureAuctionsVisible = !0, $scope.futureAuctionsButtonVisible = !1, $scope.scrollToFutureAuctions = !1, 
            $timeout(function() {
                $scope.scrollToFutureAuctions = !0;
            }, 100);
        }, $scope.regionLink = function(region) {
            return $rootScope.searchAgentRequest ? PathsService.getPortalUrl($rootScope.contentType, region) : null;
        }, init(), scrollToAuctionsIfNotFirstVisits(), $scope.$on("portalInfo.infoUpdated", loadAuctions), 
        $scope.$on("linkClicked", onLinkClicked), $window.addEventListener("resize", adjustUpperPartHeight);
    } ]);
}), define("portal/js/modules/auctions/home/index", [ "./homeModule", "./homeController" ], function() {}), 
define("portal/js/modules/auctions/catalog/auctionCatalogModule", [ "angular" ], function(ng) {
    return ng.module("app.auctions.catalog", []);
}), define("portal/js/modules/auctions/catalog/auctionCatalogController", [ "./auctionCatalogModule" ], function(module) {
    module.controller("AuctionCatalogController", [ "$rootScope", "$scope", "$timeout", "$state", "$stateParams", "AnalyticsService", "ArraysService", "LocalStorageService", "I18nService", "DomUtilsService", "PortalNavigationService", "CatalogUtilsService", "StructuredDataService", "PortalInfoService", "PortalAuthService", "CatalogsService", "CatalogAccountService", function($rootScope, $scope, $timeout, $state, $stateParams, AnalyticsService, ArraysService, LocalStorageService, I18nService, DomUtilsService, PortalNavigationService, CatalogUtilsService, StructuredDataService, PortalInfoService, PortalAuthService, CatalogsService, CatalogAccountService) {
        function udpateDocumentInfo() {
            var auction = $scope.auction;
            document.title = "Bidspirit";
            var description = "";
            if (auction.house) {
                var houseName = I18nService.getLangField(auction.house.details.name);
                document.title += " - " + houseName, description = houseName + " - ";
            }
            var auctionStructuredData = StructuredDataService.getAuctionStructuredData(auction);
            description += auctionStructuredData.name, StructuredDataService.setDescriptionMetaTags(description), 
            StructuredDataService.setImageMetaTags(auctionStructuredData.image), DomUtilsService.setMetaTag("name", "twitter:card", "product"), 
            StructuredDataService.setTwitterData(1, I18nService.getText("auction_date"), CatalogUtilsService.getAuctionTimeDisplay(auction, !1));
        }
        function shouldInitiallyShowUnsoldLotsOnly() {
            return $rootScope.$previousState && "app.home" == $rootScope.$previousState.name && PortalInfoService.isAuctionInPostSaleMode($scope.auction);
        }
        function checkSaleState() {
            "PENDING" == $scope.auction.state ? $state.go("app.home") : $scope.postSaleMode = PortalInfoService.isAuctionInPostSaleMode($scope.auction);
        }
        function init() {
            var navState = CatalogsService.getNavState();
            CatalogsService.isLastPageRelevantToCurrentCatalog() ? ($scope.auction = PortalInfoService.getAuction($stateParams.catalogKey), 
            $scope.auction ? (udpateDocumentInfo(), checkSaleState(), $scope.loadNavStateInfo(navState), 
            $scope.showFakeLoader()) : $state.go("app.home")) : (window.scrollTo(0, 0), PortalInfoService.loadAuction($stateParams.catalogKey).then(function(auction) {
                auction ? ($scope.auction = auction, udpateDocumentInfo(), checkSaleState(), CatalogsService.getAuctionItems(auction).then(function(items) {
                    CatalogsService.resetNavState(auction, items), shouldInitiallyShowUnsoldLotsOnly() ? CatalogAccountService.loadForAuction(auction).then(function() {
                        navState.filterData.soldState = "unsold", CatalogsService.setVisibleItems(CatalogsService.filterListWithSoldState(items, navState.filterData.soldState)), 
                        $scope.loadNavStateInfo(navState);
                    }) : ($scope.loadNavStateInfo(navState), CatalogsService.updatePageItems(), CatalogAccountService.loadForAuction(auction));
                }), trackEvents()) : $state.go("app.home");
            }));
        }
        function trackEvents() {
            var auction = $scope.auction, house = auction ? auction.house : null;
            if (auction && house) {
                var eventCategory = "ENDED" == auction.state ? "pastCatalogAction" : "catalogAction";
                AnalyticsService.trackDailyUniqueEvent(eventCategory, "viewItemsListOfAuction", "Catalog viewed in hose:" + house.code + ", auction:" + auction.date + " " + auction.time), 
                AnalyticsService.trackEvent(eventCategory, "viewItemsListOfHouse", "Catalog viewed in house:" + house.code, {
                    appSiteTrackInfo: {
                        dailyUnique: !0,
                        house: house,
                        api: "system/logs/saveEnterPortalPage.api",
                        params: {
                            email: $rootScope.currentUser ? $rootScope.currentUser.email : ""
                        }
                    }
                });
            }
        }
        init();
    } ]);
}), define("portal/js/modules/auctions/catalog/index", [ "./auctionCatalogModule", "./auctionCatalogController" ], function() {}), 
define("portal/js/modules/auctions/auctionInfo/auctionInfoModule", [ "angular" ], function(ng) {
    return ng.module("app.auctions.auctionInfo", []);
}), define("portal/js/modules/auctions/auctionInfo/auctionInfoDirective", [ "./auctionInfoModule" ], function(module) {
    module.directive("bsAuctionInfo", function($rootScope, $state, I18nService, SettingsService, StringsService, PortalNavigationService, AppSiteWinodwsService, DialogsService, PopupsService, PathsService, PortalAuthService) {
        return {
            restrict: "E",
            replace: !0,
            scope: {
                auction: "=",
                lot: "="
            },
            link: function(scope, element) {
                function shouldShowRegistrationPromotion() {
                    return scope.houseApprovalStateLoaded ? auction.house.auctionBasedUserApproval && scope.lot ? !1 : !0 : !1;
                }
                function checkShouldShowRegistrationPromotion() {
                    scope.shouldShowRegistrationPromotion = shouldShowRegistrationPromotion();
                }
                function checkApprovalStateLoaded() {
                    if (auction && auction.house) {
                        var approvalState = PortalAuthService.getHouseApprovalState(auction.house.id);
                        "UNKNOWN" != approvalState && (scope.houseApprovalStateLoaded = !0, checkShouldShowRegistrationPromotion());
                    }
                }
                scope.currentLang = $rootScope.currentLang, angular.element(element[0].querySelector(".auction-texts")).css({
                    width: element[0].offsetWidth - 220 + "px"
                });
                var auction = scope.auction;
                scope.displayHoursKey = "display_hours", scope.showDisplayHours = function() {
                    DialogsService.showAlert({
                        title: scope.displayHoursKey,
                        message: I18nService.getLangField(auction.displayHours)
                    });
                }, scope.showCollectionHours = function() {
                    DialogsService.showAlert({
                        title: "catalog_collection_hours",
                        message: I18nService.getLangField(auction.collectionHours)
                    });
                }, scope.showHouseTerms = function() {
                    PopupsService.showHouseTerms(auction.house);
                }, scope.openDemoWindow = function() {
                    AppSiteWinodwsService.showDemoForAuction(auction);
                }, scope.gotoAbsenteeBidsFaq = function() {
                    $state.go($state.go("app.faq", {
                        code: "faq_bidding_absenteebid"
                    }));
                }, $rootScope.$on("account.dataLoaded", checkApprovalStateLoaded), scope.details = auction.longDetails ? auction.longDetails[scope.currentLang] : null, 
                scope.shouldShowDisplayHours = "ENDED" != auction.state && auction.displayHours && !StringsService.isBlank(auction.displayHours[scope.currentLang]), 
                scope.shouldShowCollectionHours = "ENDED" == auction.state && auction.collectionHours && !StringsService.isBlank(auction.collectionHours[scope.currentLang]) && SettingsService.timeSince(auction.startTimeMillis) < 12096e5, 
                scope.openWindow = PortalNavigationService.openWindow, scope.shouldShowDemoLink = !0, 
                "CARS" == $rootScope.contentType && (scope.displayHoursKey = "cars_display_hours"), 
                checkApprovalStateLoaded();
            },
            templateUrl: PathsService.appTemplatePath("catalogs/elements/auction/auctionInfo")
        };
    });
}), define("portal/js/modules/auctions/auctionInfo/registrationPromotionDirective", [ "./auctionInfoModule" ], function(module) {
    module.directive("bsHouseRegisrationPromotion", function($rootScope, I18nService, PathsService, LogService, PopupsService, AppSiteWinodwsService, PortalTextsService, PortalInfoService, PortalAuthService, AccountService, CatalogAccountService, CatalogsService, UserDetailsService, AuctionParticipationService) {
        return {
            restrict: "E",
            replace: !0,
            scope: {
                auction: "=",
                house: "=",
                lot: "="
            },
            link: function(scope) {
                function updateState() {
                    scope.auction && (house = scope.auction.house, scope.requireCreditCard = !0, scope.postSaleMode = PortalInfoService.isAuctionInPostSaleMode(scope.auction), 
                    scope.approvedToParticipateInAuction = AuctionParticipationService.isApprovedToParticipateInAuction(scope.auction), 
                    checkBidApprovalRequested()), house && (scope.userState = PortalAuthService.getHouseApprovalState(house.id));
                }
                function checkBidApprovalRequested() {
                    scope.bidRequests = null, scope.auction && scope.auction.house && scope.auction.house.auctionBasedUserApproval && !scope.approvedToParticipateInAuction && (scope.bidRequests = CatalogAccountService.getCurrentCachedCatalogBidRequests(scope.auction.intKey));
                }
                scope.requestInProgress = !1, scope.bidRequests = null;
                var house = scope.house;
                scope.openAuctionSite = function() {
                    AppSiteWinodwsService.openAuctionSiteWindow(scope.auction);
                }, updateState(), scope.setAuthScene = function(authScene) {
                    PortalAuthService.showAuthModalOrScene(authScene);
                }, scope.bidRequestLine = "ART" == $rootScope.contentType ? "to_bid_on_item_art" : "promotion_not_registered_to_auction_direct", 
                scope.requestApproval = function() {
                    "COMPLETE" != $rootScope.currentUser.registrationStage ? PortalAuthService.showAuthModalOrScene("warning") : UserDetailsService.checkIfEnglishDetailsNeeded(house).then(function() {
                        house.requestUserStateIdForApproval || scope.requireCreditCard ? AccountService.showApprovalPopup(house, "houseApproval", scope.lot) : scope.requestInProgress || (scope.requestInProgress = !0, 
                        AccountService.requestApprovalFromHouse(house).success(function() {
                            scope.requestInProgress = !1;
                        }).error(function() {
                            scope.requestInProgress = !1, $rootScope.showGeneralError();
                        }), LogService.logEvent({
                            requestApproval: house.code,
                            element: "RegisrationPromotion"
                        }));
                    });
                }, scope.requestBidApproval = function() {
                    var lot = scope.lot || CatalogsService.getCachedCatalogItems(scope.auction)[0];
                    "COMPLETE" != $rootScope.currentUser.registrationStage ? PortalAuthService.showAuthModalOrScene("warning") : scope.requireCreditCard ? AccountService.showApprovalPopup(house, "bidApproval", lot) : scope.requestInProgress || (scope.requestInProgress = !0, 
                    AccountService.requestBidApprovalForLot(lot).error(function() {
                        scope.requestInProgress = !1, $rootScope.showGeneralError();
                    }));
                }, scope.showHelpPopup = PopupsService.showHelpPopup, scope.text = function(key) {
                    var text = null;
                    return scope.auction && scope.auction.absenteeBidsOnly && (text = I18nService.searchTextByKey(key + "_absentee_only")), 
                    text || !scope.auction || !scope.postSaleMode && "ART" == $rootScope.contentType || (text = I18nService.searchTextByKey(key + "_direct")), 
                    text || (text = I18nService.getText(key)), text;
                }, scope.contentType = $rootScope.contentType, scope.houseParams = PortalTextsService.getHouseTextParams(house), 
                scope.$on("auth.authStateChanged", updateState), scope.$on("auth.newSessionUser", updateState), 
                scope.$on("auth.houseApprovalChanged", updateState), scope.$on("auctionParticipation.approvalStateChanged", updateState), 
                $rootScope.$on("account.dataLoaded", updateState), scope.$watch("auction", updateState);
            },
            templateUrl: PathsService.appTemplatePath("catalogs/elements/auction/registrationPromotion")
        };
    });
}), define("portal/js/modules/auctions/auctionInfo/auctionStructuredDataDirective", [ "./auctionInfoModule" ], function(module) {
    module.directive("bsAuctionStructuredData", function(StructuredDataService) {
        return {
            restrict: "E",
            replace: !0,
            scope: {
                auction: "="
            },
            link: function(scope, element) {
                var auction = scope.auction;
                if (!auction.unknownExactDate && !auction.hideTime && "PENDING" != auction.state && auction.catalogInfo) {
                    var html = '<script type="application/ld+json">' + JSON.stringify(StructuredDataService.getAuctionStructuredData(scope.auction), null, 2) + "</script>";
                    element.html(html);
                }
            }
        };
    });
}), define("portal/js/modules/auctions/auctionInfo/auctionStartAlertButtonDirective", [ "./auctionInfoModule" ], function(module) {
    module.directive("bsAuctionStartAlertButton", function($rootScope, $timeout, $uibModal, PathsService, AnalyticsService, ClicksLockerService, DomUtilsService, PortalInfoService, UserAlertsService) {
        return {
            restrict: "E",
            replace: !0,
            scope: {
                auction: "="
            },
            link: function(scope, element) {
                function setClickLocked(isLocked) {
                    scope.auction && ClicksLockerService.setClicskLocked("auction" + scope.auction.id, isLocked);
                }
                function setJustChanged(justChanged) {
                    scope.justChanged = justChanged, justChanged ? element.addClass("just-changed") : element.removeClass("just-changed");
                }
                function updateFlagOn() {
                    scope.isFlagOn = UserAlertsService.isAuctionStartAlertOn(scope.auction), element.removeClass("on off"), 
                    element.addClass(scope.isFlagOn ? "on" : "off");
                }
                function setToast(message) {
                    message ? (toastElement.removeClass("ng-hide"), DomUtilsService.displayToast({
                        element: toastElement,
                        messageKey: message,
                        delay: 8e3
                    })) : toastElement.addClass("ng-hide");
                }
                function checkEditable() {
                    UserAlertsService.isAuctionStartAlertEditable(scope.auction) ? (scope.showTooltip = "true", 
                    element.removeClass("fixed")) : (element.addClass("fixed"), scope.showTooltip = !1);
                }
                function handleFlagUpdate() {
                    var prevFlagOn = scope.isFlagOn;
                    updateFlagOn();
                    var timeSinceInit = new Date().getTime() - initTime;
                    prevFlagOn != scope.isFlagOn && timeSinceInit > 200 && (setToast(scope.isFlagOn ? "auction_start_alert_set_toast" : null), 
                    setJustChanged(!0));
                }
                function onNewSessionUser() {
                    initTime = new Date().getTime(), handleFlagUpdate();
                }
                function init() {
                    initTime = new Date().getTime();
                    var auction = scope.auction;
                    setClickLocked(!1), setJustChanged(!1), auction && "ENDED" != auction.state ? (scope.onTitle = "auction_start_alert_cancel", 
                    scope.offTitle = "auction_start_alert_set", scope.$on("auth.newSessionUser", onNewSessionUser), 
                    scope.$watch(function() {
                        return $rootScope.currentUser ? $rootScope.currentUser.auctionsToNotifyStart : void 0;
                    }, handleFlagUpdate, !0), checkEditable(), updateFlagOn()) : element.css({
                        display: "none"
                    });
                }
                var initTime = null, toastElement = angular.element(element[0].querySelectorAll(".toast")[0]);
                setJustChanged(!1), scope.onMouseOut = function() {
                    setJustChanged(!1), setClickLocked(!1);
                }, scope.onMouseOver = function() {
                    setJustChanged(!1), setClickLocked(!0), checkEditable();
                }, scope.toggleAlert = function() {
                    UserAlertsService.setAuctionStartAlert(scope.auction, !scope.isFlagOn), $rootScope.viewPort.mobileMedia && (setClickLocked(!0), 
                    $timeout(function() {
                        setClickLocked(!1);
                    }, 500));
                }, init();
            },
            templateUrl: PathsService.appTemplatePath("alerts/common/alertFlag")
        };
    });
}), define("portal/js/modules/auctions/auctionInfo/mailingListPromotionDirective", [ "./auctionInfoModule" ], function(module) {
    module.directive("bsMailingListPromotion", function($rootScope, I18nService, PathsService, AppSiteWinodwsService, PortalTextsService, PortalInfoService, PortalAuthService, AccountService) {
        return {
            restrict: "E",
            replace: !0,
            scope: {
                house: "="
            },
            link: function(scope) {
                function checkVisible() {
                    scope.visible = PortalAuthService.isMailingListApprovalRequired(scope.house.id);
                }
                scope.requestInProgress = !1, scope.house && (scope.confirm = function() {
                    scope.requestInProgress = !0, AccountService.confirmMailingList(scope.house).then(function() {
                        scope.requestInProgress = !1, PortalAuthService.setMailingListApproved(scope.house.id, !0), 
                        scope.visible = !1;
                    });
                }, checkVisible(), scope.$on("auth.houseApprovalChanged", checkVisible), scope.$on("auth.mailingListApprovalChanged", checkVisible));
            },
            templateUrl: PathsService.appTemplatePath("account/mailingList/mailingListPromotion")
        };
    });
}), define("portal/js/modules/auctions/auctionInfo/auctionParticipationInfoDirective", [ "./auctionInfoModule" ], function(module) {
    module.directive("bsAuctionParticipationInfo", function($rootScope, $timeout, $compile, PathsService, I18nService, DomUtilsService, I18nService, AccountService, PopupsService, AuctionParticipationService, UserDetailsService, PortalAuthService, PortalNavigationService, CatalogAccountService) {
        return mRecentRequestInfo = {}, {
            restrict: "E",
            replace: !0,
            scope: {
                auction: "=",
                lot: "="
            },
            link: function(scope) {
                function init() {
                    scope.loaded = !1, CatalogAccountService.loadForAuction(scope.auction).then(function() {
                        scope.auctionParticipationRequested = AuctionParticipationService.isAuctionParticipationRequested(scope.auction), 
                        scope.approvedToParticipate = AuctionParticipationService.isApprovedToParticipateInAuction(scope.auction), 
                        scope.loaded = !0;
                    }), timeSinceLastRequest() < 12e4 && (scope.scrollToParticipationInfo = !0), mRecentRequestInfo = {};
                }
                function timeSinceLastRequest() {
                    return scope.lot && mRecentRequestInfo.lotId == scope.lot.id ? new Date().getTime() - mRecentRequestInfo.time : 0/0;
                }
                scope.auction.house;
                scope.requestParticipation = function() {
                    AuctionParticipationService.requestParticipation(scope.auction, scope.lot), scope.lot && (mRecentRequestInfo = {
                        lotId: scope.lot.id,
                        time: new Date().getTime()
                    });
                }, scope.showParticipationInstructions = function() {
                    AuctionParticipationService.showAuctionParticipationInstructions(scope.auction);
                }, init(), $rootScope.$on("auctionParticipation.approvalStateChanged", init), $rootScope.$on("auth.newSessionUser", init);
            },
            templateUrl: PathsService.appTemplatePath("catalogs/elements/auction/auctionParticipationInfo")
        };
    });
}), define("portal/js/modules/auctions/auctionInfo/participationInstructionsController", [ "./auctionInfoModule" ], function(module) {
    module.controller("ParticipationInstructionsController", [ "$scope", "$rootScope", "PathsService", "I18nService", "DomUtilsService", "PortalNavigationService", function($scope, $rootScope, PathsService, I18nService, DomUtilsService, PortalNavigationService) {
        $scope.init = function() {
            $scope.lot = $scope.options.data.lot, $scope.options.buttons = [ {
                text: "close",
                isCloseButton: !0,
                type: "link"
            } ], $scope.lot ? ($scope.auction = $scope.lot.auction, $scope.lot.carInfo && (documentPath = $scope.lot.carInfo.documents[" "]), 
            $scope.lot.realEstateInfo && (documentPath = $scope.lot.realEstateInfo.documents[" "])) : $scope.auction = $scope.options.data.auction;
            var house = $scope.auction.house;
            if ($scope.houseDetails = house.details, !$scope.documentPath) {
                var documents = $scope.auction.documents;
                $scope.documentPath = documents.registration;
            }
            $scope.houseName = I18nService.getHouseName(house, "full");
            var email = $scope.auction.supportEmail || $scope.houseDetails.email;
            $scope.houseEmail = DomUtilsService.link("mailto:" + email, email), $scope.housePhone = DomUtilsService.noWrap($scope.auction.supportPhone || $scope.houseDetails.phone, "ltr"), 
            $scope.fax = DomUtilsService.noWrap($scope.auction.faxNumber || $scope.houseDetails.faxNumber, "ltr"), 
            $scope.contactPerson = $scope.auction.supportContactPerson || $scope.houseDetails.supportContactPerson, 
            $scope.downloadDocument = function() {
                PortalNavigationService.openWindow(PathsService.documentUrl($scope.documentPath));
            };
        };
    } ]);
}), define("portal/js/modules/auctions/auctionInfo/confirmTermsController", [ "./auctionInfoModule" ], function(module) {
    module.controller("ConfirmTermsController", [ "$scope", "$rootScope", "$window", "$timeout", "StringsService", "I18nService", "AnalyticsService", "PortalAuthService", "PortalInfoService", "PopupsService", "AccountService", "CatalogAccountService", "UserAlertsService", function($scope, $rootScope, $window, $timeout, StringsService, I18nService, AnalyticsService, PortalAuthService, PortalInfoService) {
        function initDisplayTerms() {
            mAgreeButton.disabled = !0, $scope.termsHtml = "<br><div class='center-block loader-animation'>", 
            PortalInfoService.getHouseTerms($scope.house).then(function(termsHtml) {
                termsHtml.response ? $rootScope.showGeneralError() : ($scope.termsHtml = termsHtml, 
                mAgreeButton.disabled = !1);
            });
        }
        function onConfirmed() {
            $scope.options.data.onTermsConfirmed(), $scope.closePopup();
        }
        var mCloseButton, mAgreeButton;
        $scope.init = function() {
            mCloseButton = {
                text: "confrim_bid_dont_agree",
                type: "warning",
                isCloseButton: !0
            }, mAgreeButton = {
                text: "confrim_bid_agree",
                action: onConfirmed
            }, $scope.options.buttons = [ mCloseButton, mAgreeButton ], $scope.house = $scope.options.data.house, 
            initDisplayTerms(), $scope.initialized = !0;
        };
    } ]);
}), define("portal/js/modules/auctions/auctionInfo/setAuctionCreditCardController", [ "./auctionInfoModule" ], function(module) {
    module.controller("SetAuctionCreditCardController", [ "$scope", "$rootScope", "$window", "$timeout", "DialogsService", "I18nService", "AnalyticsService", "DomUtilsService", "AuctionParticipationService", "PortalInfoService", "PopupsService", "AccountService", "CatalogAccountService", function($scope, $rootScope, $window, $timeout, DialogsService, I18nService, AnalyticsService, DomUtilsService, AuctionParticipationService, PortalInfoService, PopupsService) {
        function resetForm() {
            $scope.formData.selectedCard = null, $scope.formData.houseTermsConfirmed = !1, updateDisplayOptions();
        }
        function loadCreditCardInfo() {
            AuctionParticipationService.getAuctionCreditCardInfo($scope.auction.id).then(function(response) {
                $scope.creditCardsInfo = response.data.availableCards, $scope.creditCardsInfo = [];
            });
        }
        function setAuctionCreditCard() {
            return $scope.formData.houseTermsConfirmed ? $scope.formData.selectedCard ? (mSubmitButton.disabled = !0, 
            void AuctionParticipationService.setAuctionCreditCard($scope.auction, $scope.formData.selectedCard).then(function() {
                $scope.options.data.onCreditCardSet(), $scope.closePopup();
            })) : void DialogsService.showAlert({
                message: "credit_card_not_selected"
            }) : void DialogsService.showAlert({
                message: I18nService.getText("auction_house_terms_confirmation_needed", {
                    house: $scope.houseName
                })
            });
        }
        function onNewCardSaved() {
            AuctionParticipationService.getAuctionCreditCardInfo($scope.auction.id).then(function(response) {
                var auctionCard = response.data.auctionCreditCard;
                auctionCard.validInAuction ? ($scope.formData.selectedCard = auctionCard.creditCardId, 
                setAuctionCreditCard()) : (resetForm(), DialogsService.showAlert({
                    message: "card_not_valid_in_auction_date"
                }));
            });
        }
        function updateDisplayOptions() {
            var titleKey;
            $scope.formData.houseTermsConfirmed ? (titleKey = "credit_card_title", $scope.showCardSelection = !0, 
            0 == $scope.creditCardsInfo.length || "another" == $scope.formData.selectedCard ? (mSubmitButton.hidden = !0, 
            $scope.showCardForm = !0) : (mSubmitButton.hidden = !1, $scope.showCardForm = !1)) : (titleKey = "participation_request_terms_confirmation", 
            mSubmitButton.hidden = !1, $scope.showCardSelection = !1), $scope.options.title = I18nService.getText(titleKey);
        }
        var mCloseButton, mSubmitButton;
        $scope.formData = {
            selectedCard: "",
            houseTermsConfirmed: !1
        }, $scope.init = function() {
            mCloseButton = {
                text: "cancel",
                type: "link",
                isCloseButton: !0
            }, mSubmitButton = {
                text: "ok",
                action: setAuctionCreditCard
            }, $scope.options.buttons = [ mCloseButton, mSubmitButton ], $scope.auction = $scope.options.data.auction, 
            $scope.house = $scope.auction.house, $scope.houseName = I18nService.getHouseName($scope.house, "full"), 
            $scope.phone = DomUtilsService.noWrap($scope.house.details.phone, "ltr"), $scope.contactPerson = $scope.auction.supportContactPerson || $scope.house.details.supportContactPerson, 
            loadCreditCardInfo(), $scope.initialized = !0, $scope.$watch("formData.selectedCard", updateDisplayOptions), 
            $scope.$watch("formData.houseTermsConfirmed", updateDisplayOptions), $scope.$on("creditCard.saved", onNewCardSaved);
        }, $scope.showHouseTerms = function() {
            PopupsService.showHouseTerms($scope.house);
        };
    } ]);
}), define("portal/js/modules/auctions/auctionInfo/auctionParticipationService", [ "./auctionInfoModule" ], function(module) {
    module.factory("AuctionParticipationService", function($rootScope, $uibModal, $q, ArraysService, I18nService, ApiService, CometService, PathsService, DialogsService, PortalInfoService, PortalAuthService, PopupsService, UserDetailsService, AccountService, CatalogAccountService) {
        function requestParticipation(auction, lot) {
            CatalogAccountService.loadForAuction(auction).then(function() {
                function sendParticipationRequestForAuction() {
                    sendParticipationRequest(auction, lot ? lot.idInApp : null);
                }
                if (!isApprovedToParticipateInAuction(auction) && !isAuctionParticipationRequested(auction)) {
                    var house = auction.house;
                    $rootScope.currentUser && $rootScope.currentUser.blocked && !CatalogAccountService.isBlockIgnoredInHouse() ? AccountService.showBlockedUserMessage(auction) : UserDetailsService.checkIfEnglishDetailsNeeded(house).then(function() {
                        AccountService.validateRegisteredInHouseAndThen(house, {}, function() {
                            CatalogAccountService.isRejectedInCurrentHouse() || $rootScope.currentUser.problematic && !CatalogAccountService.isBlockIgnoredInHouse() ? AccountService.showBlockedUserMessage(auction) : auction.requireCreditCard ? showSetAuctionCreditCardPopup(auction, sendParticipationRequestForAuction) : house.hasTerms ? showHouseTermConfirmation(house, sendParticipationRequestForAuction) : sendParticipationRequestForAuction();
                        });
                    });
                }
            });
        }
        function showSetAuctionCreditCardPopup(auction, onCreditCardSet) {
            PopupsService.showPopup({
                contentInclude: "catalogs/elements/auction/setAuctionCreditCard",
                code: "setAuctionCreditCard",
                bodyClass: "no-scroll",
                singleModal: !0,
                title: I18nService.getText("participation_request_terms_confirmation", {
                    house: I18nService.getHouseName(auction.house, "full")
                }),
                data: {
                    auction: auction,
                    hideTopBackButton: !0,
                    footerClass: "narrow",
                    onCreditCardSet: onCreditCardSet
                }
            });
        }
        function sendParticipationRequest(auction, lotId) {
            ApiService.callApi("/account/requestToParticipateInAuction", {
                auctionKey: auction.intKey,
                lotIdOfRequestPage: lotId
            }).then(function(response) {
                if (response.data.errorKey) switch (response.data.errorKey) {
                  case "USER_BLOCKED":
                    AccountService.showBlockedUserMessage(auction);
                    break;

                  default:
                    PopupsService.showHouseConnectivityErrorPopup(auction.house);
                } else auction.autoApproveBidRequests || (setAuctionParticipationRequested(auction), 
                showAuctionParticipationInstructions(auction));
            });
        }
        function isAuctionOfCachedInfo(auction) {
            return CatalogAccountService.isAuctionOfCachedInfo(auction);
        }
        function getCachedAccountInfo() {
            return CatalogAccountService.getCachedAccountInfo();
        }
        function showHouseTermConfirmation(house, onTermsConfirmed) {
            PopupsService.showPopup({
                contentInclude: "catalogs/elements/auction/confirmTerms",
                code: "confirmTerms",
                size: "lg",
                singleModal: !0,
                title: I18nService.getHouseTermsTitle(house),
                data: {
                    house: house,
                    hideTopBackButton: !0,
                    onTermsConfirmed: onTermsConfirmed
                }
            });
        }
        function showAuctionParticipationInstructions(auction, lot) {
            PopupsService.showPopup({
                contentInclude: "catalogs/elements/auction/participationInstructions",
                code: "participationInstructions",
                title: I18nService.getText("promotion_pending_cars", {
                    houseName: I18nService.getLangField(auction.house.details.name)
                }),
                data: {
                    lot: lot,
                    auction: auction,
                    footerClass: "narrow",
                    hideTopBackButton: !0
                }
            });
        }
        function setAuctionCreditCard(auction, creditCardId) {
            return ApiService.callApi("/billing/setAuctionCreditCard", {
                auctionId: auction.id,
                creditCardId: creditCardId
            });
        }
        function getAuctionCreditCardInfo(auctionId) {
            return ApiService.callApi("/billing/getAuctionCreditCardInfo", {
                auctionId: auctionId
            });
        }
        function isApprovedToParticipateInAuction(auction) {
            return isAuctionOfCachedInfo(auction) ? getCachedAccountInfo().approvedToParticipateInAuction : void 0;
        }
        function checkedApprovedToParticipateInCurrentAuction() {
            var auction = getCachedAccountInfo().auction, cachedUserInfo = getCachedAccountInfo().userInfo, absenteeBids = cachedUserInfo.absenteeBids;
            if (absenteeBids && absenteeBids.length > 0) return !0;
            var approvedAuctions = cachedUserInfo.approvedAuctions;
            return approvedAuctions && approvedAuctions[auction.auctionIdInApp] > 0 ? !0 : !1;
        }
        function setApprovedToParticipateInAuction(auction, itemsLimit) {
            if (isAuctionOfCachedInfo(auction)) {
                var userInfo = getCachedAccountInfo().userInfo;
                userInfo.approvedAuctions || (userInfo.approvedAuctions = {}), userInfo.approvedAuctions[auction.auctionIdInApp] = itemsLimit, 
                checkAuctionApprovalChanged();
            }
        }
        function setAuctionParticipationRequested(auction) {
            isAuctionOfCachedInfo(auction) && !isAuctionParticipationRequested(auction) && (getCachedAccountInfo().userInfo.auctionParticipationRequested = !0, 
            boradcastApprovalStateChanged());
        }
        function isAuctionParticipationRequested(auction) {
            if (isAuctionOfCachedInfo(auction)) {
                var bidRequests = CatalogAccountService.getCurrentCachedCatalogBidRequests(auction.intKey) || [];
                return getCachedAccountInfo().userInfo.auctionParticipationRequested || bidRequests.length > 0;
            }
            return !1;
        }
        function handleAuctionParticipationRequested(data) {
            var auction = getCachedAccountInfo().auction;
            auction && auction.auctionIdInApp == data.auctionId && CatalogAccountService.isCurrentUserIdInApp(data.userId) && setAuctionParticipationRequested(auction);
        }
        function handleAuctionApprovalUpdated(data) {
            var auction = getCachedAccountInfo().auction;
            auction && auction.auctionIdInApp == data.auctionApproval.auctionId && CatalogAccountService.isCurrentUserIdInApp(data.auctionApproval.userId) && setApprovedToParticipateInAuction(auction, data.auctionApproval.itemsLimit);
        }
        function checkAuctionApprovalChanged() {
            var auction = getCachedAccountInfo().auction;
            if (auction) {
                var wasApproved = isApprovedToParticipateInAuction(auction);
                setParticipationState(), wasApproved != isApprovedToParticipateInAuction(auction) && boradcastApprovalStateChanged();
            }
        }
        function boradcastApprovalStateChanged() {
            $rootScope.$broadcast("auctionParticipation.approvalStateChanged", {
                auctionId: getCachedAccountInfo().auction.id
            });
        }
        function setParticipationState() {
            var cachedInfo = getCachedAccountInfo();
            cachedInfo.approvedToParticipateInAuction = cachedInfo && cachedInfo.auction ? checkedApprovedToParticipateInCurrentAuction() : !1;
        }
        function init() {
            CometService.scope.$on("cometEvent", function(e, event) {
                if (getCachedAccountInfo() && getCachedAccountInfo().houseCode == event.houseCode) switch (event.name) {
                  case "Account.auctionParticipationRequested":
                    handleAuctionParticipationRequested(event.arg);
                    break;

                  case "Account.updateAuctionApproval":
                    handleAuctionApprovalUpdated(event.arg);
                }
            }), PathsService.getQueryParam("requestAuctionParticipation") && PortalInfoService.loadAuction(PathsService.getQueryParam("requestAuctionParticipation")).then(function(auction) {
                auction && "RUNNING" == auction.state && ($rootScope.currentUser ? requestParticipation(auction) : PortalAuthService.loginWithAppSiteSession(auction.house).then(function() {
                    requestParticipation(auction);
                }), $rootScope.initialStateOverridden = !0);
            });
        }
        return $rootScope.$on("account.dataLoaded", setParticipationState), $rootScope.$on("catalogAccount.cachedInfoChanged", checkAuctionApprovalChanged), 
        {
            showSetAuctionCreditCardPopup: showSetAuctionCreditCardPopup,
            getAuctionCreditCardInfo: getAuctionCreditCardInfo,
            showAuctionParticipationInstructions: showAuctionParticipationInstructions,
            requestParticipation: requestParticipation,
            setAuctionCreditCard: setAuctionCreditCard,
            isApprovedToParticipateInAuction: isApprovedToParticipateInAuction,
            setApprovedToParticipateInAuction: setApprovedToParticipateInAuction,
            setAuctionParticipationRequested: setAuctionParticipationRequested,
            isAuctionParticipationRequested: isAuctionParticipationRequested,
            init: init
        };
    });
}), define("portal/js/modules/auctions/auctionInfo/index", [ "./auctionInfoModule", "./auctionInfoDirective", "./registrationPromotionDirective", "./auctionStructuredDataDirective", "./auctionStartAlertButtonDirective", "./mailingListPromotionDirective", "./auctionParticipationInfoDirective", "./participationInstructionsController", "./confirmTermsController", "./setAuctionCreditCardController", "./auctionParticipationService" ], function() {}), 
define("portal/js/modules/auctions/lists/auctionsListsModule", [ "angular" ], function(ng) {
    return ng.module("app.auctions.lists", []);
}), define("portal/js/modules/auctions/lists/auctionsListDirective", [ "./auctionsListsModule" ], function(module) {
    module.directive("bsAuctionsList", function($timeout, $rootScope, $state, PathsService, CloudinaryService, SessionsService, ArraysService, DateUtilsService, SettingsService, ViewPortService, ClicksLockerService, OsInfoService, PortalAuthService, AccountService, AppSiteWinodwsService, PortalInfoService, AuctionsListsService) {
        return {
            restrict: "E",
            replace: !0,
            scope: {
                shop: "=",
                auctions: "=",
                shops: "=",
                view: "=",
                houseNameAsLink: "="
            },
            link: function(scope) {
                function getAuctionToScrollTo() {
                    return $rootScope.$previousState && $rootScope.lastAuctionClick && $rootScope.lastAuctionClick.state == $state.current.name && $rootScope.lastAuctionClick.catalogKey == $rootScope.$previousState.args.catalogKey ? $rootScope.lastAuctionClick.catalogKey : void 0;
                }
                function setClickedRecently(auction) {
                    auction.clickedRecently = !0, $timeout(function() {
                        auction.clickedRecently = !1;
                    }, 2e3);
                }
                function getImageSize() {
                    return "400x400";
                }
                function initDisplayInfo() {
                    scope.screenView = AuctionsListsService.getScreenViewClass(), scope.imageSize = getImageSize(), 
                    scope.today = DateUtilsService.formatToServerDate(new Date()), angular.forEach(scope.auctions, function(auction) {
                        var minutes = PortalInfoService.getMinutesUntilAuction(auction);
                        auction.minutesUntilStart = minutes;
                        var displayInfo = {};
                        displayInfo.buttonClass = getAuctionButtonClass(auction), displayInfo.buttonText = getAuctionButtonText(auction), 
                        auction.displayInfo = displayInfo;
                    });
                }
                function getAuctionButtonClass(auction) {
                    switch (auction.state) {
                      case "PENDING":
                        return "disabled";

                      case "READY":
                        return auction.timedAuction && auction.minutesUntilStart < 30 ? "darkBlue" : auction.externalUrl || auction.catalogInfo ? "orange" : "disabled";

                      case "RUNNING":
                        return "live darkBlue";

                      case "ENDED":
                        return "yellow";
                    }
                    return "orange";
                }
                function getAuctionButtonText(auction) {
                    switch (auction.state) {
                      case "PENDING":
                        return "catalog_not_ready";

                      case "READY":
                        return auction.timedAuction && auction.minutesUntilStart < 30 ? "home_auction_to_the_auction" : auction.externalUrl || auction.catalogInfo ? "to_catalog" : "catalog_not_ready";

                      case "RUNNING":
                        return "home_auction_enter";

                      case "ENDED":
                        return PortalInfoService.isAuctionInPostSaleMode(auction) ? "catalog_buy_now" : $rootScope.showPastAuctionsResult ? "to_auction_results" : "to_catalog";
                    }
                    return "to_catalog";
                }
                scope.currentLang = $rootScope.currentLang, scope.shop && (scope.withShopEntry = !0), 
                scope.scrollTo = getAuctionToScrollTo(), scope.scrollTo || window.scrollTo(0, 0), 
                scope.devMode = $rootScope.devMode, scope.viewPort = $rootScope.viewPort, scope.isAuctionClickable = function(auction) {
                    return "PENDING" == auction.state ? !1 : auction.house.hostingServerName && !auction.catalogInfo ? !1 : !0;
                }, scope.isAuctionHouseLink = function(auction) {
                    return scope.houseNameAsLink && auction.house.orderInd ? !0 : !1;
                }, scope.onAuctionClick = function(auction) {
                    if (!ClicksLockerService.isClicksLocked("auction" + auction.id) && (setClickedRecently(auction), 
                    scope.isAuctionClickable(auction))) {
                        var house = auction.house;
                        $rootScope.lastAuctionClick = {
                            state: $state.current.name,
                            catalogKey: auction.intKey
                        }, house.hostingServerName ? "RUNNING" == auction.state ? AppSiteWinodwsService.openAuctionSiteWindow(auction) : auction.singleItemIdInApp ? $state.go("app.lotPage", {
                            source: "catalog",
                            ownerType: "auction",
                            catalogKey: auction.intKey,
                            lotKey: auction.singleItemIdInApp
                        }) : $state.go("app.auctionCatalog", {
                            catalogKey: auction.intKey,
                            page: 1
                        }) : auction.externalUrl && (OsInfoService.isMobile() ? window.open(auction.externalUrl, "_system") : window.open(auction.externalUrl, "_blank"));
                    }
                }, scope.isLinkbutton = function(auction) {
                    if (!auction.catalogInfo) return !1;
                    switch (auction.state) {
                      case "PENDING":
                        return !1;

                      case "READY":
                        return !auction.externalUrl && !auction.catalogInfo || auction.timedAuction ? !1 : !0;

                      case "RUNNING":
                        return !1;

                      case "ENDED":
                        return !0;
                    }
                }, scope.$watch("auctions", initDisplayInfo), scope.$on("portalInfo.newRunningAuction", initDisplayInfo), 
                scope.$on("auctionsInfo.auctionStateChanged", initDisplayInfo);
            },
            templateUrl: PathsService.appTemplatePath("auctions/lists/auctionsList")
        };
    });
}), define("portal/js/modules/auctions/lists/auctionsResultsController", [ "./auctionsListsModule" ], function(module) {
    module.controller("AuctionsResultsController", [ "$scope", "$rootScope", "$timeout", "$state", "$stateParams", "ArraysService", "I18nService", "SessionsService", "PortalInfoService", function($scope, $rootScope, $timeout, $state, $stateParams, ArraysService, I18nService, SessionsService, PortalInfoService) {
        function setAuctions() {
            $scope.pastAuctions = ArraysService.filterWithFunction(PortalInfoService.getAuctions(), function(auction) {
                return auction.catalogInfo && "ENDED" == auction.state ? !0 : !1;
            }), ArraysService.inverse($scope.pastAuctions), $scope.displayedAuctions = $scope.data.currentHouse ? getHouseAuctions($scope.data.currentHouse) : $scope.pastAuctions, 
            setPagesData();
        }
        function setPagesData() {
            $scope.pagesData = {
                itemsCount: $scope.displayedAuctions.length,
                currentPage: $stateParams.page,
                itemsPerPage: "dev" == GlobalConfig.envName ? 5 : 20
            }, $scope.pageAuctions = [];
            for (var i = 0; i < $scope.pagesData.itemsPerPage; i++) {
                var auctionInd = $scope.pagesData.itemsPerPage * ($scope.pagesData.currentPage - 1) + i, auction = $scope.displayedAuctions[auctionInd];
                auction && $scope.pageAuctions.push(auction);
            }
        }
        function setHouses() {
            var houses = PortalInfoService.getAllHouses().slice();
            $scope.houses = [];
            for (var i = 0; i < houses.length; i++) {
                var house = houses[i];
                getHouseAuctions(house).length > 0 && $scope.houses.push(house);
            }
        }
        function getHouseAuctions(house) {
            return ArraysService.filteredBy($scope.pastAuctions, "houseId", house.id);
        }
        function init() {
            $scope.displayeAuctionsLoader = !0, $timeout(function() {
                $scope.displayeAuctionsLoader = !1;
            }, 200), $scope.data.currentHouse = PortalInfoService.getHouseByCode($stateParams.house), 
            $scope.data.selectedHouseCode = $scope.data.currentHouse ? $scope.data.currentHouse.code : "all", 
            setAuctions(), setHouses();
        }
        $scope.data = {
            selectedHouseCode: "all"
        }, $scope.showHouseAuctions = function(houseCode) {
            $scope.data.selectedHouseCode != houseCode && $state.go("app.results", {
                house: houseCode,
                page: 1
            });
        }, init();
    } ]);
}), define("portal/js/modules/auctions/lists/auctionBadgeDirective", [ "./auctionsListsModule" ], function(module) {
    module.directive("auctionBadge", function(PathsService, I18nService) {
        return {
            restrict: "E",
            replace: !0,
            scope: {
                auction: "=",
                isToday: "="
            },
            link: function(scope, element) {
                scope.isToday ? (scope.shouldShow = !0, scope.text = I18nService.getText("auction_today") + "!", 
                element.addClass("today")) : (scope.text = I18nService.getLangField(scope.auction.badge), 
                scope.text && scope.auction.textColors.badge && "ENDED" != scope.auction.state && (scope.shouldShow = !0, 
                element.css({
                    "background-color": scope.auction.textColors.badge
                })));
            },
            templateUrl: PathsService.appTemplatePath("auctions/lists/auctionBadge")
        };
    });
}), define("portal/js/modules/auctions/lists/auctionsListsService", [ "./auctionsListsModule" ], function(module) {
    module.factory("AuctionsListsService", function($timeout, $state, $rootScope, ArraysService, DateUtilsService, LocalStorageService, PathsService, PortalInfoService, SessionsService, SettingsService) {
        function shouldShowInMinorSection(auction, hoursTillAuction) {
            return auction.minorAuction ? hoursTillAuction < auction.hoursBeforeAuctionToDisableMinorBehavior ? !1 : !0 : !1;
        }
        function addToHouseAuctionsCount(houseAuctionsCountBySection, section, auction, maxAllowed) {
            var sectionCount = houseAuctionsCountBySection[section] || {}, addedAuctionNumbersForHouse = sectionCount[auction.houseId];
            addedAuctionNumbersForHouse || (addedAuctionNumbersForHouse = [], sectionCount[auction.houseId] = addedAuctionNumbersForHouse);
            var auctionNumber = auction.number || "no_number", isOtherPartOfAddedAuction = -1 != addedAuctionNumbersForHouse.indexOf(auctionNumber);
            return isOtherPartOfAddedAuction || addedAuctionNumbersForHouse.length < maxAllowed ? (isOtherPartOfAddedAuction || addedAuctionNumbersForHouse.push(auctionNumber), 
            !0) : !1;
        }
        function getAuctionsListsData(auctions, options) {
            var data = {
                nextAuctions: [],
                additionalAuctions: [],
                recentAuctions: [],
                futureAuctions: [],
                postSaleAuctions: []
            }, daysToFutureAuctions = SettingsService.get("daysToFutureAuctions");
            "ART" != $rootScope.contentType && (daysToFutureAuctions = 3e3);
            var recentAuctionsToShow = SettingsService.get("recentAuctionsToShow") || 10;
            if (auctions) {
                for (var houseAuctionsCountBySection = {
                    next: {},
                    future: {}
                }, i = 0; i < auctions.length; i++) {
                    var auction = auctions[i], hoursTillAuction = Math.round(PortalInfoService.getMinutesUntilAuction(auction) / 60), catalogReady = auction.catalogInfo && "PENDING" != auction.state;
                    auctionsList = null, auction.hoursTillAuction = hoursTillAuction;
                    var isNonPastAuction = hoursTillAuction > -24;
                    if ("ENDED" == auction.state) catalogReady && (auctionsList = options.specialSectionForPostSale && PortalInfoService.isAuctionInPostSaleMode(auction) ? data.postSaleAuctions : data.recentAuctions); else if ((catalogReady || 24 * daysToFutureAuctions > hoursTillAuction) && isNonPastAuction) if (options.specialSectionForMinorAuctions && shouldShowInMinorSection(auction, hoursTillAuction)) auctionsList = data.additionalAuctions; else {
                        var added = addToHouseAuctionsCount(houseAuctionsCountBySection, "next", auction, auction.house.maxUpcomingAuctions || 1);
                        (options.showAllFutureAuctions || added) && (auctionsList = data.nextAuctions);
                    }
                    if (isNonPastAuction && !auctionsList) {
                        var added = addToHouseAuctionsCount(houseAuctionsCountBySection, "future", auction, auction.house.maxFutureAuctions || 1);
                        (options.showAllFutureAuctions || added) && (auctionsList = data.futureAuctions);
                    }
                    auctionsList && auctionsList.push(auction);
                }
                return ArraysService.inverse(data.recentAuctions), ArraysService.inverse(data.postSaleAuctions), 
                options.showAllPastAuctions || (data.recentAuctions = data.recentAuctions.slice(0, recentAuctionsToShow)), 
                data;
            }
        }
        function getScreenViewClass() {
            return $rootScope.viewPort.isWideDevice ? "wide" : "narrow";
        }
        return {
            getAuctionsListsData: getAuctionsListsData,
            getScreenViewClass: getScreenViewClass
        };
    });
}), define("portal/js/modules/auctions/lists/auctionsFilters", [ "./auctionsListsModule" ], function(module) {
    return module.filter("auctionTime", [ "CatalogUtilsService", function(CatalogUtilsService) {
        return function(auction, dateOnly) {
            return CatalogUtilsService.getAuctionTimeDisplay(auction, dateOnly);
        };
    } ]).filter("auctionHref", [ "PathsService", function(PathsService) {
        return function(auction) {
            return PathsService.getAuctionHref(auction);
        };
    } ]);
}), define("portal/js/modules/auctions/lists/index", [ "./auctionsListsModule", "./auctionsListDirective", "./auctionsResultsController", "./auctionBadgeDirective", "./auctionsListsService", "./auctionsFilters" ], function() {}), 
define("portal/js/modules/auctions/lotPageElements/lotPageElementsModule", [ "angular" ], function(ng) {
    return ng.module("app.auctions.lotPageElements", []);
}), define("portal/js/modules/auctions/lotPageElements/lotBidFormDirective", [ "./lotPageElementsModule" ], function(module) {
    module.directive("bsLotBidForm", function($timeout, $rootScope, $state, PathsService, DialogsService, I18nService, DomUtilsService, LogService, ArraysService, PopupsService, PortalTextsService, PortalAuthService, PortalInfoService, AppSiteWinodwsService, CatalogUtilsService, CatalogUtilsService, BidRulesService, AccountService, CatalogAccountService, AuctionParticipationService, UserDetailsService) {
        return mRecentBidInfo = {}, {
            restrict: "E",
            replace: !0,
            scope: {
                lot: "="
            },
            link: function(scope, element) {
                function showBidConfirmation(price) {
                    var displayTerms = (scope.lot.realEstateInfo || scope.lot.carInfo) && scope.lot.auction.house.hasTerms;
                    PopupsService.showPopup({
                        contentInclude: "catalogs/elements/auction/confirmBid",
                        code: "confirmBid",
                        size: displayTerms ? "lg" : null,
                        title: I18nService.getText("direct" == scope.mode ? "confirm_purchase" : "confirm_bid"),
                        data: {
                            lot: scope.lot,
                            bidPrice: price,
                            displayTerms: displayTerms,
                            hideTopBackButton: !0
                        }
                    });
                }
                function handleError(errorResponse) {
                    var house = scope.lot.house;
                    "LOT_CLOSED_FOR_BIDDING" == errorResponse.errorKey ? $rootScope.showGeneralError("bid_error_closed_for_bidding") : "AUCTION_CLOSED_FOR_BIDDING" == errorResponse.errorKey ? ($rootScope.showGeneralError("bid_error_closed_for_bidding"), 
                    scope.lot.auction.absenteeBidsEnabled = !1, init()) : "USER_NOT_FOUND" == errorResponse.errorKey ? (PortalAuthService.setCurrentHouseAccountState(house.id, "NOT_REGISTERED"), 
                    AccountService.showApprovalPopup(house, "houseApproval", scope.lot)) : "USER_NOT_APPROVED" == errorResponse.errorKey ? (PortalAuthService.setCurrentHouseAccountState(house.id, errorResponse.approvalState), 
                    AccountService.showApprovalPopup(house, "houseApproval", scope.lot)) : PopupsService.showHouseConnectivityErrorPopup(house);
                }
                function focusOnInput() {
                    var input = element[0].querySelector(".input-bg input");
                    input && (input.focus(), $timeout(function() {
                        input.focus();
                    }, 120));
                }
                function initLabels() {
                    scope.bidLabel = CatalogUtilsService.getBidLabel(scope.lot, {
                        showSalePriceForAdmin: !0
                    }), scope.absenteeBidLabelForPastLot = CatalogUtilsService.getAbsenteeBidLabelForPastLot(scope.lot), 
                    "ENDED" != scope.lot.auction.state && scope.lot.auction.startTimeMillis > new Date().getTime() && (scope.timeLeft = I18nService.getText("auction_starts_in") + " " + I18nService.getDurationDisplay(scope.lot.auction.startTimeMillis)), 
                    scope.editLabel = scope.lot.auction.showLeadingBids ? "your_max_bid" : "leave_max_bid";
                }
                function handleMinBidPriceDisplay() {
                    if (scope.lot.auction.showLeadingBids) {
                        var minPrice = BidRulesService.newPreBidMinPrice(scope.lot);
                        scope.minPrice = I18nService.sumInCurrency(minPrice, currency), scope.showMinPrice = scope.isFocused || scope.isSelfLeading && !scope.lot.leadingBid.underReserved ? !1 : !0;
                    } else scope.minPrice = null, scope.showMinPrice = !1;
                }
                function shouldBeInAuctionParticipationMode(auction) {
                    return auction.house.auctionBasedUserApproval ? auction.house.bidRequestPerItem ? !1 : AuctionParticipationService.isApprovedToParticipateInAuction(auction) && auction.absenteeBidsEnabled ? !1 : !0 : !1;
                }
                function handleLeadingBidDisplay() {
                    if (scope.lot.auction.showLeadingBids) if (scope.lot.leadingBid) {
                        var leadingBidInfo = CatalogUtilsService.getLeadingBidInfo(scope.lot);
                        scope.leadingBidMessage = I18nService.getText(leadingBidInfo.message, {
                            price: leadingBidInfo.messagePrice
                        }), leadingBidInfo.isPastItem ? scope.lot.selfAbsenteeBid && scope.lot.leadingBid.underReserved ? scope.bidInfoClass = "outbidded" : scope.leadingBidLine = null : (scope.leadingBidLine = I18nService.getText(leadingBidInfo.label) + ": " + leadingBidInfo.displayPrice, 
                        scope.leadingBidType = leadingBidInfo.leadingBidType, scope.isSelfLeading = leadingBidInfo.isSelfLeading, 
                        scope.isSelfLeading ? (scope.lot.leadingBid.underReserved || (scope.leadingBidMessage = I18nService.getText("leading_bid_you")), 
                        scope.showMinPrice = !1, angular.element(element[0].querySelector(".high-bidder-message")).removeClass("blink")) : scope.lot.selfAbsenteeBid && DomUtilsService.blink(element[0].querySelector(".high-bidder-message"), 2e3, 1500), 
                        PortalAuthService.isWaitingForApprovalInHouse(scope.lot.auction.houseId) || scope.setEditMode({
                            focus: !1
                        }));
                    } else scope.leadingBidLine = null; else scope.leadingBidLine = null;
                }
                function initMode() {
                    var lot = scope.lot, auction = lot.auction;
                    scope.bidInfoClass = null, lot.viewOnly ? scope.mode = "viewOnly" : lot.purchase ? (scope.mode = "sold", 
                    lot.selfPurchase ? scope.bidInfoClass = "self-sold" : lot.leadingBid && lot.purchase && lot.selfAbsenteeBid && (scope.bidInfoClass = "outbidded")) : "READY" == auction.state ? !auction.house.auctionBasedUserApproval && 0 == auction.absenteeBidsEnabled || auction.catalogOnly ? scope.mode = "disabled" : (lot.selfAbsenteeBid ? scope.mode = "existing" : lot.bidRequest ? (scope.bidInfoClass = "bid-request", 
                    scope.mode = "bidRequest") : PortalAuthService.isWaitingForApprovalInHouse(auction.houseId) ? scope.mode = "disabled" : auction.autoApproveBidRequests && !auction.house.hasTerms ? (LogService.logError("No house terms found"), 
                    scope.mode = "disabled") : scope.mode = shouldBeInAuctionParticipationMode(auction) ? "auctionParticipation" : "new", 
                    scope.bidsDiabledOnHolyDay = auction.house.disableBidsOnHolyDays && PortalInfoService.getPortalInfo().isHolyDay ? !0 : !1) : "RUNNING" == auction.state ? scope.mode = 0 == auction.absenteeBidsEnabled ? "disabled" : "running" : "ENDED" == auction.state && (scope.mode = PortalInfoService.isAuctionInPostSaleMode(auction) ? lot.postSaleDisabled ? "disabled" : PortalAuthService.isWaitingForApprovalInHouse(auction.houseId) ? "disabled" : "direct" : "ended");
                }
                function saveRecentBidInfo() {
                    mRecentBidInfo = {
                        lotId: scope.lot.id,
                        price: scope.model.selectedBidPrice,
                        time: new Date().getTime()
                    };
                }
                function timeSinceLastBid() {
                    return mRecentBidInfo && mRecentBidInfo.lotId == scope.lot.id ? new Date().getTime() - mRecentBidInfo.time : 0/0;
                }
                function checkIfShouldShowRecentBidInputValue() {
                    return mRecentBidInfo.lotId != scope.lot.id ? !1 : timeSinceLastBid() > 12e4 ? !1 : "running" == scope.mode || "disabled" == scope.mode ? !1 : scope.lot.selfAbsenteeBid && scope.lot.selfAbsenteeBid.price == mRecentBidInfo.price ? !1 : !0;
                }
                function loadRecentBidInputValue() {
                    checkIfShouldShowRecentBidInputValue() && (scope.model.selectedBidPrice = mRecentBidInfo.price, 
                    "new" == scope.mode || scope.lot.purchase || scope.lot.bidRequest || (scope.mode = "edit")), 
                    timeSinceLastBid() < 12e4 && (scope.scrollToForm = !0);
                }
                function blinkBidLimitMessage() {
                    DomUtilsService.blink(element[0].querySelector(".bid-limit"), 2e3, 500);
                }
                function handleBidLimitDisplay() {
                    scope.bidLimit = CatalogAccountService.getBidLimitForLot(scope.lot), scope.bidLimitMessage = null == scope.bidLimit ? null : scope.bidLimit > 0 ? I18nService.getText("you_have_bid_limit", {
                        limit: I18nService.sumInCurrency(scope.bidLimit, currency)
                    }) : I18nService.getText("bid_limit_reached");
                }
                function setBidIncrements() {
                    var minPrice = BidRulesService.newPreBidMinPrice(scope.lot);
                    scope.allowedBidPrices = BidRulesService.getNextBidPrices(scope.lot, minPrice, 200), 
                    scope.model.selectedBidPrice = scope.lot.selfAbsenteeBid ? Math.max(minPrice, scope.lot.selfAbsenteeBid.price) : minPrice;
                }
                function init() {
                    initMode(), initLabels(), loadRecentBidInputValue(), handleLeadingBidDisplay(), 
                    handleMinBidPriceDisplay(), handleBidLimitDisplay(), setBidIncrements(), tryToBidAgainIfJustApproved();
                }
                function tryToBidAgainIfJustApproved() {
                    "APPROVED" == PortalAuthService.getHouseApprovalState(scope.lot.houseId) && timeSinceLastBid() < 3e4 && !scope.lot.selfAbsenteeBid && !scope.lot.bidRequest && !mRecentBidInfo.bidConfirmationDisplayed && scope.tryToPlaceBid();
                }
                var currency = scope.lot.auction.catalogInfo.currency;
                scope.model = {}, scope.viewPort = $rootScope.viewPort, scope.contentType = $rootScope.contentType, 
                scope.tryToPlaceBid = function() {
                    $rootScope.currentUser && $rootScope.currentUser.blocked && !CatalogAccountService.isBlockIgnoredInHouse() ? AccountService.showBlockedUserMessage(scope.lot.auction) : UserDetailsService.checkIfEnglishDetailsNeeded(scope.lot.house).then(function() {
                        saveRecentBidInfo(), mRecentBidInfo.bidConfirmationDisplayed = !1, AccountService.validateRegisteredInHouseAndThen(scope.lot.house, {}, function() {
                            if (price = scope.model.selectedBidPrice, validationResponse = BidRulesService.validBid(scope.lot, price, scope.bidLimit), 
                            validationResponse.error) if ("bidlimit" == validationResponse.error) blinkBidLimitMessage(); else {
                                validationResponse.textParams.minPrice = I18nService.sumInCurrency(validationResponse.minPrice, currency);
                                var message = I18nService.getText("bid_error_" + validationResponse.error, validationResponse.textParams);
                                PopupsService.showErrorPopup(message);
                            } else showBidConfirmation(validationResponse.parsedPrice), mRecentBidInfo.bidConfirmationDisplayed = !0;
                        }, scope.lot);
                    });
                }, scope.showCommissionText = function() {
                    PopupsService.showCommissionText(scope.lot);
                }, scope.removeBidIfConfirmed = function() {
                    var lot = scope.lot, bid = lot.selfAbsenteeBid;
                    return bid ? DialogsService.showConfirm({
                        message: "bid_confirm_remove",
                        title: "notice",
                        params: {
                            lotIndex: lot.itemIndex,
                            price: I18nService.sumInCurrency(bid.price, currency)
                        }
                    }).then(function(confirmed) {
                        confirmed && (mRecentBidInfo.lotId = null, AccountService.removeAbsenteeBid(lot.auction.houseId, lot).success(function(response) {
                            response.success ? (scope.mode = "new", lot.bidRequest = null, scope.bidLabel = null, 
                            lot.house.auctionBasedUserApproval && (AuctionParticipationService.setApprovedToParticipateInAuction(lot.auction, response.itemsLimit), 
                            ArraysService.removeByKey(CatalogAccountService.getCurrentCachedCatalogBidRequests(lot.ownerKey), "lotIdInApp", lot.idInApp))) : handleError(response);
                        }).error(handleError));
                    }) : void 0;
                }, scope.openAuctionSite = function() {
                    AppSiteWinodwsService.openAuctionSiteWindow(scope.lot.auction);
                }, scope.setEditMode = function(options) {
                    scope.mode = "edit", scope.bidLabel = null, options.focus && focusOnInput();
                }, scope.cancelEdit = function() {
                    scope.mode = "existing", scope.bidLabel = CatalogUtilsService.getBidLabel(scope.lot);
                }, scope.gotoHousePage = function() {
                    $state.go("app.house", {
                        houseCode: scope.lot.house.code
                    });
                }, scope.getDisabledMessage = function() {
                    var disabledMessageKey, houseParams = PortalTextsService.getHouseTextParams(scope.lot.house);
                    if (scope.lot.auction.catalogOnly) disabledMessageKey = "bid_form_catalog_only"; else if (scope.lot.postSaleDisabled && "ENDED" == scope.lot.auction.state) disabledMessageKey = "direct_sale_not_available"; else if (PortalAuthService.isWaitingForApprovalInHouse(scope.lot.auction.houseId)) disabledMessageKey = "approval_not_approved"; else if (!scope.lot.auction.absenteeBidsEnabled) {
                        if ("ART" != $rootScope.contentType) return null;
                        disabledMessageKey = "bid_form_disabled";
                    }
                    return I18nService.getText(disabledMessageKey, houseParams);
                }, scope.onMinPriceClick = function() {
                    scope.showMinPrice = !1, focusOnInput();
                }, init(), scope.$watch("lot.lastBidUpdate", init), scope.$on("account.dataLoaded", init), 
                scope.$on("auth.houseApprovalChanged", init), scope.$on("account.dataLoaded", init), 
                $rootScope.$on("auctionParticipation.approvalStateChanged", init);
            },
            templateUrl: PathsService.appTemplatePath("catalogs/elements/auction/bidForm")
        };
    });
}), define("portal/js/modules/auctions/lotPageElements/confirmBidController", [ "./lotPageElementsModule" ], function(module) {
    module.controller("ConfirmBidController", [ "$scope", "$rootScope", "$window", "$timeout", "StringsService", "I18nService", "AnalyticsService", "PortalAuthService", "PortalInfoService", "PopupsService", "AuctionParticipationService", "AccountService", "UserAlertsService", function($scope, $rootScope, $window, $timeout, StringsService, I18nService, AnalyticsService, PortalAuthService, PortalInfoService, PopupsService, AuctionParticipationService, AccountService, UserAlertsService) {
        function initDisplayTerms() {
            $scope.displayTerms = $scope.options.data.displayTerms, $scope.termsTitle = I18nService.getHouseTermsTitle($scope.house), 
            $scope.displayTerms && (mSubmitButton.disabled = !0, $scope.termsHtml = "<div class='loader-animation'></div>", 
            PortalInfoService.getHouseTerms($scope.lot.house).then(function(termsHtml) {
                $scope.termsHtml = termsHtml, mSubmitButton.disabled = !1;
            }));
        }
        function handleError(errorResponse) {
            var house = $scope.lot.house, errorKey = errorResponse.errorKey;
            "ALREADY_SOLD" == errorKey ? $rootScope.showGeneralError("bid_error_already_sold") : "OUT_OF_AUCTION" == errorKey ? $rootScope.showGeneralError("direct_sale_not_available") : "LOT_CLOSED_FOR_BIDDING" == errorKey ? $rootScope.showGeneralError("bid_error_closed_for_bidding") : "LIMIT_EXCEEDED" == errorKey ? $rootScope.showGeneralError("bid_limit_reached") : "AUCTION_CLOSED_FOR_BIDDING" == errorKey ? ($rootScope.showGeneralError("bid_error_closed_for_bidding"), 
            scope.lot.auction.absenteeBidsEnabled = !1) : "USER_BLOCKED" == errorKey ? AccountService.showBlockedUserMessage($scope.lot.auction) : "USER_NOT_APPROVED" == errorKey ? (PortalAuthService.setCurrentHouseAccountState(house.id, errorResponse.approvalState), 
            AccountService.showApprovalPopup(house, "houseApproval", $scope.lot)) : $rootScope.showGeneralError();
        }
        var mCloseButton, mSubmitButton;
        $scope.init = function() {
            mCloseButton = {
                text: "confrim_bid_dont_agree",
                type: "warning",
                isCloseButton: !0
            }, mSubmitButton = {
                text: "confrim_bid_agree",
                action: $scope.submitBid
            }, $scope.options.buttons = [ mCloseButton, mSubmitButton ], $scope.lot = $scope.options.data.lot, 
            $scope.house = $scope.lot.house, $scope.bidPrice = $scope.options.data.bidPrice, 
            $scope.itemAlertData = {
                on: $scope.lot.itemAlertOn
            }, $scope.alertEnabled = UserAlertsService.isItemAlertEnabled($scope.lot), $scope.postSaleMode = PortalInfoService.isAuctionInPostSaleMode($scope.lot.auction), 
            initDisplayTerms(), $scope.initialized = !0;
        }, $scope.submitBid = function() {
            return $scope.house ? AccountService.placeAbsenteeBid($scope.house.id, $scope.lot, $scope.bidPrice).success(function(response) {
                response.errorKey ? handleError(response) : (PortalAuthService.setCurrentHouseAccountState($scope.house.id, "APPROVED"), 
                $scope.itemAlertData.on != $scope.lot.itemAlertOn && UserAlertsService.setItemAlertAfterDelay($scope.lot, $scope.itemAlertData.on, 300), 
                $scope.house.auctionBasedUserApproval && AuctionParticipationService.setApprovedToParticipateInAuction($scope.lot.auction, response.itemsLimit), 
                $scope.closePopup(), response.bidRequest && $timeout(function() {
                    AuctionParticipationService.showAuctionParticipationInstructions($scope.lot.auction, $scope.lot);
                }, 100));
            }).error(function(response) {
                handleError(response);
            }) : void 0;
        }, $scope.showCommissionText = function() {
            PopupsService.showCommissionText($scope.lot);
        }, $scope.showTerms = function() {
            PopupsService.showHouseTerms($scope.lot.house);
        };
    } ]);
}), define("portal/js/modules/auctions/lotPageElements/lotAlertFlagDirective", [ "./lotPageElementsModule" ], function(module) {
    module.directive("bsLotAlertFlag", function($rootScope, $timeout, PathsService, OsInfoService, UserAlertsService, DomUtilsService) {
        return {
            restrict: "E",
            replace: !0,
            scope: {
                lot: "="
            },
            link: function(scope, element) {
                function setFlagOn(isFlagOn) {
                    scope.isFlagOn = isFlagOn, element.removeClass("on off"), element.addClass(isFlagOn ? "on" : "off");
                }
                function setJustChanged(justChanged) {
                    scope.justChanged = justChanged, justChanged ? element.addClass("just-changed") : element.removeClass("just-changed");
                }
                function onAlertUpdate(oldVal, newVal) {
                    setFlagOn(scope.lot.itemAlertOn), setJustChanged(!0), OsInfoService.isMobile() && (clearJustSetTimer = $timeout(function() {
                        setJustChanged(!1);
                    }, 2e3)), oldVal != newVal && new Date().getTime() - initTime > 3e3 && setToast(scope.isFlagOn ? "item_alert_added" : "item_alert_removed");
                }
                function onNewSessionUser() {
                    initTime = new Date().getTime();
                }
                function setToast(message) {
                    message ? (toastElement.removeClass("ng-hide"), DomUtilsService.displayToast({
                        element: toastElement,
                        messageKey: message,
                        delay: 8e3
                    })) : toastElement.addClass("ng-hide");
                }
                var clearJustSetTimer = null, initTime = new Date().getTime(), toastElement = angular.element(element[0].querySelectorAll(".toast")[0]);
                UserAlertsService.isItemAlertEnabled(scope.lot) ? (scope.toggleAlert = function() {
                    var newAlertIsOn = scope.lot.itemAlertOn ? !1 : !0;
                    $timeout.cancel(clearJustSetTimer), UserAlertsService.setItemAlert(scope.lot, newAlertIsOn);
                }, scope.onMouseOut = function() {
                    setJustChanged(!1);
                }, scope.onMouseOver = function() {
                    setJustChanged(!1);
                }, scope.$watch("lot.itemAlertOn", onAlertUpdate), scope.$on("auth.newSessionUser", onNewSessionUser)) : element.css({
                    display: "none"
                });
            },
            templateUrl: PathsService.appTemplatePath("alerts/common/alertFlag")
        };
    });
}), define("portal/js/modules/auctions/lotPageElements/leadingBidDirective", [ "./lotPageElementsModule" ], function(module) {
    module.directive("leadingBid", function(PathsService, CatalogUtilsService, I18nService, DomUtilsService) {
        return {
            restrict: "E",
            replace: !0,
            scope: {
                lot: "=",
                source: "="
            },
            link: function(scope, element) {
                scope.$watch("lot.lastBidUpdate", function() {
                    var info = CatalogUtilsService.getLeadingBidInfo(scope.lot);
                    info.hidden ? scope.leadingBidHidden = !0 : (element.addClass(info.leadingBidType), 
                    DomUtilsService.setSubElementText(element, ".message", I18nService.getText(info.message, {
                        price: info.messagePrice
                    })), DomUtilsService.setSubElementText(element, ".lead-type", I18nService.getText(info.label) + ":"), 
                    DomUtilsService.setSubElementText(element, ".price", info.displayPrice));
                });
            },
            templateUrl: PathsService.appTemplatePath("catalogs/elements/auction/leadingBid")
        };
    });
}), define("portal/js/modules/auctions/lotPageElements/pastLotAbsenteeDirective", [ "./lotPageElementsModule" ], function(module) {
    module.directive("pastLotAbsentee", function(PathsService, CatalogUtilsService) {
        return {
            restrict: "E",
            replace: !0,
            scope: {
                lot: "="
            },
            link: function(scope) {
                scope.$watch("lot.lastBidUpdate", function() {
                    var lot = scope.lot;
                    lot.leadingBid ? scope.label = null : (scope.label = CatalogUtilsService.getAbsenteeBidLabelForPastLot(scope.lot), 
                    scope.label && (scope.type = lot.purchase && lot.selfAbsenteeBid.userIdInApp == lot.purchase.userIdInApp ? "self" : "outbidded"));
                });
            },
            template: '<div class="past-lot-absentee" ng-show="label" ng-class="type" ><div class="message">{{label}}</div></div>'
        };
    });
}), define("portal/js/modules/auctions/lotPageElements/lotViewOnlyDirective", [ "./lotPageElementsModule" ], function(module) {
    module.directive("bsLotViewOnly", function($timeout, $rootScope, $state, PathsService, I18nService, StringsService) {
        return mRecentBidInfo = {}, {
            restrict: "E",
            replace: !0,
            scope: {
                lot: "=",
                fullMessage: "@",
                oneLine: "@"
            },
            link: function(scope) {
                var lot = scope.lot;
                lot.viewOnly && (scope.visible = !0, "ENDED" == lot.auction.state ? "true" == scope.fullMessage && (scope.message = I18nService.getText("catalog_item_view_only_past")) : "true" == scope.fullMessage ? (scope.message = I18nService.getLangField(lot.auction.viewOnlyInfo), 
                "true" == scope.oneLine && (scope.message = StringsService.stripTags(scope.message))) : scope.message = I18nService.getText("catalog_item_view_only"));
            },
            templateUrl: PathsService.appTemplatePath("catalogs/elements/auction/lotViewOnlyInfo")
        };
    });
}), define("portal/js/modules/auctions/lotPageElements/index", [ "./lotPageElementsModule", "./lotBidFormDirective", "./confirmBidController", "./lotAlertFlagDirective", "./leadingBidDirective", "./pastLotAbsenteeDirective", "./lotViewOnlyDirective" ], function() {}), 
define("portal/js/modules/auctions/index", [ "./auctionsModule", "./home/index", "./catalog/index", "./auctionInfo/index", "./lists/index", "./lotPageElements/index" ], function() {}), 
define("portal/js/modules/houses/housesModule", [ "angular" ], function(ng) {
    return ng.module("app.houses", []);
}), define("portal/js/modules/houses/housesListController", [ "./housesModule" ], function(module) {
    module.controller("HousesListController", [ "$scope", "$rootScope", "ArraysService", "I18nService", "PortalInfoService", function($scope, $rootScope, ArraysService, I18nService, PortalInfoService) {
        $scope.houses = PortalInfoService.getAllHouses().slice(), $rootScope.judaicaOnly && ($scope.houses = ArraysService.filterWithFunction($scope.houses, function(house) {
            return house.judaicaOnly || house.hasJudaicaAuctions;
        })), $scope.updateFilter = function() {
            $scope.visibleHouses = [];
            for (var i = 0; i < $scope.houses.length; i++) {
                var house = $scope.houses[i];
                $scope.token && -1 == I18nService.getLangField(house.details.name).toLowerCase().indexOf($scope.token.toLowerCase()) || $scope.visibleHouses.push(house);
            }
        }, ArraysService.sort($scope.houses, "orderInd", !1, "emptyLast"), "ART" == $scope.contentType ? ($scope.titleKey = "auction_houses_title", 
        $scope.messageKey = "auction_houses_message") : ($scope.titleKey = "sellers_list", 
        $scope.messageKey = "law_offices_message"), document.title = I18nService.getTextWithRegion($scope.titleKey), 
        $scope.updateFilter();
    } ]);
}), define("portal/js/modules/houses/housePageController", [ "./housesModule" ], function(module) {
    module.controller("HousePageController", [ "$scope", "$rootScope", "$stateParams", "ViewPortService", "I18nService", "AnalyticsService", "PortalTextsService", "PopupsService", "PortalInfoService", "AuctionsListsService", "PortalAuthService", function($scope, $rootScope, $stateParams, ViewPortService, I18nService, AnalyticsService, PortalTextsService, PopupsService, PortalInfoService, AuctionsListsService, PortalAuthService) {
        function loadAccountInfo() {
            $rootScope.currentUser && PortalAuthService.loadAccountStateForHouse($scope.house.id);
        }
        function setAuctions() {
            $scope.data = AuctionsListsService.getAuctionsListsData(PortalInfoService.getHouseAuctions($scope.house.id), {
                showAllFutureAuctions: !0,
                showAllPastAuctions: !0
            });
        }
        function init() {
            $scope.house = PortalInfoService.getHouseByCode($stateParams.houseCode), $scope.house && ($scope.contactKey = "LAWYERS" == $rootScope.houseType ? "law_office_contact" : "auction_house_contact", 
            $scope.termsTitle = I18nService.getHouseTermsTitle($scope.house), $scope.housePic = ViewPortService.clientWidth() > 1024 && $scope.house.resources ? $scope.house.resources.picForHousePage : "", 
            loadAccountInfo(), AnalyticsService.trackDailyUniqueEvent("houseAction", "visitHousePage", "visit house page " + $scope.house.code), 
            document.title = I18nService.getLangField($scope.house.details.name), $scope.$on("auth.newSessionUser", loadAccountInfo), 
            $scope.$on("portalInfo.infoUpdated", setAuctions), $scope.screenView = AuctionsListsService.getScreenViewClass(), 
            setAuctions(), $scope.shop = PortalInfoService.getHouseShop($scope.house.id), "true" == $stateParams.showUpcomingAuctions && ($scope.scrollToUpcomingAuctions = !0));
        }
        $scope.openTerms = function() {
            PopupsService.showHouseTerms($scope.house);
        }, init();
    } ]);
}), define("portal/js/modules/houses/houseAlertsPromotionDirective", [ "./housesModule" ], function(module) {
    module.directive("bsHouseAlertsPromotion", function($rootScope, ArraysService, PathsService) {
        return {
            restrict: "E",
            replace: !0,
            scope: {
                house: "="
            },
            link: function(scope) {
                function checkShouldDisplay() {
                    if (!$rootScope.currentUser) return !1;
                    var alertsPreferences = $rootScope.currentUser.alertsPreferences[$rootScope.contentType];
                    if (!alertsPreferences) return !0;
                    if ("SOME_HOUSES_ALERTS" != alertsPreferences.housesAlertChoice) return !1;
                    var houseConfigedToBeAlerted = !ArraysService.contains(alertsPreferences.housesToAlert, scope.house.code);
                    return houseConfigedToBeAlerted;
                }
                function updateDisplay() {
                    scope.shouldDisplay = checkShouldDisplay();
                }
                scope.promostionMessageKey = "ART" == $rootScope.contentType ? "alerts_promotion_configure_house" : "alerts_promotion_configure_law_firm", 
                updateDisplay(), scope.$on("auth.newSessionUser", updateDisplay);
            },
            templateUrl: PathsService.appTemplatePath("houses/houseAlertsPromotion")
        };
    });
}), define("portal/js/modules/houses/houseContactInfoDirective", [ "./housesModule" ], function(module) {
    module.directive("bsHouseContactInfo", function($rootScope, PortalTextsService, PathsService) {
        return {
            restrict: "E",
            replace: !0,
            scope: {
                house: "=",
                hideWebsite: "=",
                hideAddress: "=",
                caption: "="
            },
            link: function(scope) {
                scope.houseTextParams = PortalTextsService.getHouseTextParams(scope.house);
            },
            templateUrl: PathsService.appTemplatePath("houses/houseContactInfo")
        };
    });
}), define("portal/js/modules/houses/index", [ "./housesModule", "./housesListController", "./housePageController", "./houseAlertsPromotionDirective", "./houseContactInfoDirective" ], function() {}), 
define("portal/js/modules/shops/shopsModule", [ "angular" ], function(ng) {
    return ng.module("app.shops", [ "app.shops.catalog", "app.shops.lotPageElements" ]);
}), define("portal/js/modules/shops/shopsMainController", [ "./shopsModule" ], function(module) {
    module.controller("ShopsMainController", [ "$scope", "$rootScope", "ArraysService", "I18nService", "PortalInfoService", function($scope, $rootScope, ArraysService, I18nService, PortalInfoService) {
        function init() {
            $scope.shops = PortalInfoService.getShops().slice(), document.title = I18nService.getTextWithRegion("shops");
        }
        init();
    } ]);
}), define("portal/js/modules/shops/shopInfoDirective", [ "./shopsModule" ], function(module) {
    module.directive("bsShopInfo", function($rootScope, $state, PopupsService, PathsService, PortalTextsService) {
        return {
            restrict: "E",
            replace: !0,
            scope: {
                shop: "=",
                minimalView: "="
            },
            link: function(scope, element) {
                scope.currentLang = $rootScope.currentLang, angular.element(element[0].querySelector(".shop-texts")).css({
                    width: element[0].offsetWidth - 220 + "px"
                }), scope.houseTextParams = PortalTextsService.getHouseTextParams(scope.shop.house), 
                scope.showHouseTerms = function() {
                    PopupsService.showHouseTerms(scope.shop.house);
                }, scope.showHouseContantInfo = function() {
                    PopupsService.showHouseContantInfo(scope.shop.house);
                }, scope.onNameClick = function() {
                    "app.shopCatalog" == $state.current.name ? $state.go("app.house", {
                        houseCode: scope.shop.houseCode,
                        showUpcomingAuctions: !1
                    }) : $state.go("app.shopCatalog", {
                        catalogKey: scope.shop.intKey,
                        page: 1
                    });
                };
            },
            templateUrl: PathsService.appTemplatePath("catalogs/elements/shop/shopInfo")
        };
    });
}), define("portal/js/modules/shops/catalogs/shopCatalogModule", [ "angular" ], function(ng) {
    return ng.module("app.shops.catalog", []);
}), define("portal/js/modules/shops/catalogs/shopCatalogController", [ "./shopCatalogModule" ], function(module) {
    module.controller("ShopCatalogController", [ "$rootScope", "$scope", "$timeout", "$state", "$stateParams", "AnalyticsService", "ArraysService", "LocalStorageService", "I18nService", "DomUtilsService", "PortalNavigationService", "CatalogUtilsService", "StructuredDataService", "PortalInfoService", "CatalogsService", "CatalogAccountService", function($rootScope, $scope, $timeout, $state, $stateParams, AnalyticsService, ArraysService, LocalStorageService, I18nService, DomUtilsService, PortalNavigationService, CatalogUtilsService, StructuredDataService, PortalInfoService, CatalogsService, CatalogAccountService) {
        function udpateDocumentInfo() {
            var shop = $scope.shop;
            document.title = "Bidspirit";
            var description = "";
            if (shop.house) {
                var houseName = I18nService.getLangField(shop.house.details.name);
                document.title += " - " + houseName, description = houseName + " - ";
            }
            description += I18nService.getLangField(shop.sentence), StructuredDataService.setDescriptionMetaTags(description), 
            StructuredDataService.setImageMetaTags(CatalogUtilsService.getCatalogOwnerTopImage(shop));
        }
        function init() {
            var navState = CatalogsService.getNavState();
            CatalogsService.isLastPageRelevantToCurrentCatalog() ? ($scope.loadNavStateInfo(navState), 
            $scope.showFakeLoader(), $scope.shop = PortalInfoService.getShop($stateParams.catalogKey), 
            udpateDocumentInfo()) : (window.scrollTo(0, 0), PortalInfoService.loadShop($stateParams.catalogKey).then(function(shop) {
                shop ? ($scope.shop = shop, udpateDocumentInfo(), CatalogsService.getShopItems($scope.shop).then(function(items) {
                    CatalogsService.resetNavState($scope.shop, items), navState.filterData.soldState = "unsold", 
                    $scope.loadNavStateInfo(navState), CatalogsService.updatePageItems(), CatalogAccountService.loadForShop($scope.shop).then(function() {
                        CatalogsService.setVisibleItems(CatalogsService.filterListWithSoldState(items, navState.filterData.soldState));
                    });
                }), trackEvents()) : $state.go("app.home");
            }));
        }
        function trackEvents() {
            var shop = $scope.shop, house = shop ? shop.house : null;
            shop && house && AnalyticsService.trackDailyUniqueEvent("shopAction", "viewItemsListOfShop", "Shop catalog viewed in hose:" + house.code, {
                appSiteTrackInfo: {
                    dailyUnique: !0,
                    house: house,
                    api: "system/logs/saveEnterPortalPage.api",
                    params: {
                        email: $rootScope.currentUser ? $rootScope.currentUser.email : ""
                    }
                }
            });
        }
        init();
    } ]);
}), define("portal/js/modules/shops/catalogs/index", [ "./shopCatalogModule", "./shopCatalogController" ], function() {}), 
define("portal/js/modules/shops/shopsListDirective", [ "./shopsModule" ], function(module) {
    module.directive("bsShopsList", function($timeout, $rootScope, $state, PathsService, CloudinaryService, SessionsService, ArraysService) {
        return {
            restrict: "E",
            replace: !0,
            scope: {
                shops: "="
            },
            link: function(scope) {
                function getShopToScrollTo() {
                    return $rootScope.$previousState && $rootScope.lastAuctionClick && $rootScope.lastAuctionClick.state == $state.current.name && $rootScope.lastAuctionClick.catalogKey == $rootScope.$previousState.args.catalogKey ? $rootScope.lastAuctionClick.catalogKey : void 0;
                }
                scope.currentLang = $rootScope.currentLang, ArraysService.sort(scope.shops, "orderInd", !1, "emptyLast"), 
                scope.scrollTo = getShopToScrollTo(), scope.scrollTo || window.scrollTo(0, 0), scope.devMode = $rootScope.devMode, 
                scope.qaEnv = $rootScope.qaEnv, scope.viewPort = $rootScope.viewPort, scope.screenView = scope.viewPort.isWideDevice ? "wide" : "narrow";
            },
            templateUrl: PathsService.appTemplatePath("shops/list/shopsList")
        };
    });
}), define("portal/js/modules/shops/lotPageElements/lotPageElementsModule", [ "angular" ], function(ng) {
    return ng.module("app.shops.lotPageElements", []);
}), define("portal/js/modules/shops/lotPageElements/shopPurchaseFormDirective", [ "./lotPageElementsModule" ], function(module) {
    module.directive("bsShopPurchaseForm", function($timeout, $rootScope, $state, PathsService, DialogsService, I18nService, DomUtilsService, PopupsService, PortalTextsService, PortalAuthService, PortalInfoService, AppSiteWinodwsService, CatalogsService, CatalogUtilsService, BidRulesService, AccountService, CatalogAccountService, UserDetailsService) {
        return {
            restrict: "E",
            replace: !0,
            scope: {
                lot: "="
            },
            link: function(scope) {
                function checkSold() {
                    scope.lot.purchase && ($rootScope.currentUser && scope.lot.selfPurchase ? (scope.selfSold = !0, 
                    scope.soldLabel = "lot_self_sold_bid") : scope.soldLabel = "sold_for");
                }
                scope.viewPort = $rootScope.viewPort;
                scope.lot.shop.house;
                scope.showPurchaseConfirmation = function() {
                    PortalAuthService.validateCompleteUserProfile() && UserDetailsService.checkIfEnglishDetailsNeeded(scope.lot.house).then(function() {
                        PopupsService.showPopup({
                            contentInclude: "catalogs/elements/shop/confirmShopPurchase",
                            code: "confirmPurchase",
                            title: I18nService.getText("confirm_purchase"),
                            data: {
                                lot: scope.lot,
                                hideTopBackButton: !0
                            }
                        });
                    });
                }, scope.gotoHousePage = function() {
                    $state.go("app.house", {
                        houseCode: scope.lot.shop.house.code
                    });
                }, checkSold(), scope.$on("auth.newSessionUser", checkSold), scope.$watch("lot.purchase", checkSold);
            },
            templateUrl: PathsService.appTemplatePath("catalogs/elements/shop/shopPurchaseForm")
        };
    });
}), define("portal/js/modules/shops/lotPageElements/confirmShopPurchaseController", [ "./lotPageElementsModule" ], function(module) {
    module.controller("ConfirmShopPurchaseController", [ "$scope", "$rootScope", "$window", "$timeout", "StringsService", "I18nService", "AnalyticsService", "PortalAuthService", "PortalInfoService", "PopupsService", "AccountService", "UserAlertsService", function($scope, $rootScope, $window, $timeout, StringsService, I18nService, AnalyticsService, PortalAuthService, PortalInfoService, PopupsService, AccountService) {
        function handleError(errorResponse) {
            $scope.lot.shop.house;
            "ALREADY_SOLD" == errorResponse.errorKey ? $rootScope.showGeneralError("bid_error_already_sold") : "USER_NOT_APPROVED" == errorResponse.errorKey ? handlePurchaseRejected() : $rootScope.showGeneralError();
        }
        function handlePurchaseRejected() {
            $scope.purchaseRejected = !0, $scope.options.buttons = [ {
                text: "close",
                isCloseButton: !0
            } ];
        }
        $scope.init = function() {
            $scope.options.buttons = [ {
                text: "confrim_bid_dont_agree",
                type: "warning",
                isCloseButton: !0
            }, {
                text: "confrim_bid_agree",
                action: $scope.submitPurchase
            } ], $scope.lot = $scope.options.data.lot, $scope.house = $scope.lot.shop.house, 
            $scope.initialized = !0;
        }, $scope.submitPurchase = function() {
            return AccountService.purchaseShopItem($scope.house.id, $scope.lot).success(function(response) {
                response.errorKey ? handleError(response) : (AnalyticsService.trackEvent("shopAction", "purchaseInHouse", "shop purchase in house " + $scope.house.code), 
                $scope.purchaseAccepted = !0, $scope.options.buttons = [ {
                    text: "close",
                    isCloseButton: !0
                } ]);
            }).error(function(response) {
                handleError(response);
            });
        }, $scope.showTerms = function() {
            PopupsService.showHouseTerms($scope.lot.shop.house);
        };
    } ]);
}), define("portal/js/modules/shops/lotPageElements/index", [ "./lotPageElementsModule", "./shopPurchaseFormDirective", "./confirmShopPurchaseController" ], function() {}), 
define("portal/js/modules/shops/index", [ "./shopsModule", "./shopsMainController", "./shopInfoDirective", "./catalogs/index", "./shopsListDirective", "./lotPageElements/index" ], function() {}), 
define("portal/js/modules/account/accountModule", [ "angular" ], function(ng) {
    return ng.module("app.account", []);
}), define("portal/js/modules/account/accountService", [ "./accountModule" ], function(module) {
    module.factory("AccountService", function($q, $rootScope, $uibModal, $uibModalStack, $state, $timeout, AnalyticsService, ArraysService, ApiService, PathsService, DialogsService, CatalogUtilsService, I18nService, LogService, PopupsService, PortalAuthService, CatalogsService, PortalInfoService) {
        function requestApprovalFromHouse(house, userStateId) {
            return ApiService.callApi("/account/requestApprovalFromHouse", {
                houseId: house.id,
                userStateId: userStateId
            }).success(function(response) {
                PortalAuthService.setCurrentHouseAccountState(house.id, response.approvalState), 
                AnalyticsService.trackEvent("houseAction", "requestApprovalFromHouse", "request approval from house " + house.code), 
                mWaitingActionAfterHouseApprovalRequest.houseId || showConfirmMailingList(house);
            });
        }
        function addBidsInfoToItems(auction, bids, bidFieldName) {
            if (bids) for (var i = 0; i < bids.length; i++) {
                var bid = bids[i], item = CatalogsService.getCachedItem(auction, bid.lotIdInApp);
                setBidInfoForItem(item, bidFieldName, bid);
            }
        }
        function updateLeadingBid(item, bid) {
            item && item.auction && "ENDED" == item.auction.state && !item.purchase && bid && !bid.underReserved ? setBidInfoForItem(item, "leadingBid", null) : setBidInfoForItem(item, "leadingBid", bid);
        }
        function setBidInfoForItem(item, bidFieldName, bid) {
            if (item) {
                var oldBid = item[bidFieldName];
                oldBid && bid && oldBid.price == bid.price && oldBid.userIdInApp == bid.userIdInApp && oldBid.underReserved == bid.underReserved || (item[bidFieldName] = bid, 
                item.lastBidUpdate = new Date().getTime());
            }
            mAppItemsBids[bidFieldName] || (mAppItemsBids[bidFieldName] = {}), bid ? (bid.actionPrice && !bid.price && (bid.price = bid.actionPrice), 
            mAppItemsBids[bidFieldName][bid.auctionIdInApp + "_" + bid.lotIdInApp + "_" + bidFieldName] = bid) : oldBid && (mAppItemsBids[bidFieldName][oldBid.auctionIdInApp + "_" + oldBid.lotIdInApp + "_" + bidFieldName] = null);
        }
        function getItemBidByAppIds(auctionIdInApp, lotIdInApp, bidFieldName) {
            return mAppItemsBids[bidFieldName] ? mAppItemsBids[bidFieldName][auctionIdInApp + "_" + lotIdInApp + "_" + bidFieldName] : null;
        }
        function getAppItemsBidsByField(bidFieldName) {
            var bids = [];
            for (var bidKey in mAppItemsBids[bidFieldName]) {
                var bid = mAppItemsBids[bidFieldName][bidKey];
                bid && bids.push(bid);
            }
            return bids;
        }
        function addItemAlertToItems(auction, itemIds) {
            if (itemIds) for (var i = 0; i < itemIds.length; i++) {
                var item = CatalogsService.getCachedItem(auction, itemIds[i]);
                item ? updateItemLocalAlertStatus(item, !0) : LogService.logError("failed to get item for alert.  lot id " + itemIds[i]);
            }
        }
        function checkIfActionWaitingAfterHouseApprovalRequest() {
            var approvalState = PortalAuthService.getHouseApprovalState(mWaitingActionAfterHouseApprovalRequest.houseId);
            ("APPROVED" == approvalState || "PENDING" == approvalState || "INCOMPLETE_PROFILE" == approvalState || "NEW_SHOP_USER" == approvalState) && new Date().getTime() - mWaitingActionAfterHouseApprovalRequest.time < 3e4 && $timeout(mWaitingActionAfterHouseApprovalRequest.action, 200);
        }
        function validateRegisteredInHouseAndThen(house, args, actionFn, lot) {
            function shouldShowApprovalPopup(approvalState) {
                switch (approvalState) {
                  case "APPROVED":
                  case "PENDING":
                    return !1;

                  case "NOT_REGISTERED":
                    return house.auctionBasedUserApproval && !house.requestUserStateIdForApproval ? !1 : !0;

                  case "INCOMPLETE_PROFILE":
                  case "NEW_SHOP_USER":
                  case "REJECTED":
                    return !0;

                  default:
                    return !1;
                }
            }
            function handleApprovalState(approvalState) {
                shouldShowApprovalPopup(approvalState) ? (mWaitingActionAfterHouseApprovalRequest = {
                    houseId: house.id,
                    time: new Date().getTime(),
                    action: actionFn
                }, showApprovalPopup(house, "houseApproval", lot, actionFn)) : actionFn();
            }
            var user = $rootScope.currentUser;
            if (user) if ("COMPLETE" != user.registrationStage) PortalAuthService.showAuthModalOrScene("warning", null, args); else {
                var approvalState = PortalAuthService.getHouseApprovalState(house.id);
                "UNKNOWN" != approvalState ? handleApprovalState(approvalState) : PortalAuthService.loadAccountStateForHouse(house.id).then(function(approvalState) {
                    handleApprovalState(approvalState);
                }, function() {
                    PopupsService.showHouseConnectivityErrorPopup(house);
                });
            } else PortalAuthService.showAuthModalOrScene("login", null, args);
        }
        function showApprovalPopup(house, approvalType, lot) {
            $rootScope.viewPort.mobileMedia ? showApprovalScene(house, approvalType, lot) : showApprovalModalPopup(house, approvalType, lot);
        }
        function showApprovalScene(house, approvalType, lot) {
            $state.go("app." + approvalType, {
                houseId: house.id,
                fromLot: lot ? lot.id : ""
            });
        }
        function showApprovalModalPopup(house, approvalType, lot) {
            closeApprovalPopup(), $uibModal.open({
                templateUrl: PathsService.appTemplatePath("account/" + approvalType + "/" + approvalType + "Popup"),
                windowClass: "modal auth-modal-popup",
                controller: function($scope) {
                    $scope.houseId = house.id, $scope.lot = lot;
                }
            });
        }
        function confirmMailingList(house) {
            return ApiService.callApi("/account/confirmMailingList", {
                houseId: house.id
            });
        }
        function showConfirmMailingList(house) {
            $uibModal.open({
                templateUrl: PathsService.appTemplatePath("account/mailingList/confirmMailingList"),
                controller: function($scope) {
                    $scope.message = 0 == house.code.indexOf("galileasing") ? "confirm_mailing_list_galileasing" : "confirm_mailing_list_question", 
                    $scope.house = I18nService.getLangField(house.details.name), $scope.confirm = function() {
                        confirmMailingList(house).then($scope.$close);
                    };
                }
            });
        }
        function closeApprovalPopup() {
            $uibModalStack.dismissAll();
        }
        function handleFailure(response) {
            response.errorMessage && LogService.logError(response.errorMessage);
        }
        function getPurchaseFromAbsenteeBid(bid) {
            return angular.extend({
                actionPrice: bid.price
            }, bid);
        }
        function placeAbsenteeBid(houseId, lot, price) {
            var house = PortalInfoService.getHouse(houseId);
            return ApiService.callApi("/account/placeAbsenteeBid", {
                houseId: houseId,
                lotId: lot.id,
                price: price
            }).success(function(response) {
                if (response.success) {
                    if (response.absenteeBid && (handleSelfAbsenteeBidUpdate(lot, response.absenteeBid), 
                    AnalyticsService.trackEvent("catalogAction", "bidInHouse", "absentee bid in house " + house.code)), 
                    response.purchase) {
                        AnalyticsService.trackEvent("catalogAction", "directPurchaseInHouse", "direct purchase in house " + house.code);
                        var purchase = getPurchaseFromAbsenteeBid(response.purchase);
                        setBidInfoForItem(lot, "selfPurchase", purchase), setBidInfoForItem(lot, "purchase", response.purchase);
                    }
                    response.bidRequest && (AnalyticsService.trackEvent("houseAction", "requestApprovalFromHouse", "request approval from house " + house.code), 
                    lot.bidRequest = response.bidRequest), updateLeadingBid(lot, response.leadingBid);
                } else handleFailure(response);
            });
        }
        function purchaseShopItem(houseId, lot) {
            return ApiService.callApi("/account/purchaseShopItem", {
                houseId: houseId,
                lotId: lot.id,
                price: lot.shopPrice
            }).success(function(response) {
                lot.purchase = lot.selfPurchase = response.purchase;
            });
        }
        function handleSelfAbsenteeBidUpdate(lot, bid) {
            if (bid && bid.sold) {
                var purchase = getPurchaseFromAbsenteeBid(bid);
                setBidInfoForItem(lot, "selfPurchase", purchase), setBidInfoForItem(lot, "purchase", purchase);
            } else setBidInfoForItem(lot, "selfAbsenteeBid", bid);
        }
        function removeAbsenteeBid(houseId, lot) {
            return ApiService.callApi("/account/removeAbsenteeBid", {
                houseId: houseId,
                lotId: lot.id
            }).success(function(response) {
                response.success ? handleSelfAbsenteeBidUpdate(lot, null) : handleFailure(response);
            });
        }
        function setFavoriteItem(house, lot, isOn) {
            return isOn && AnalyticsService.trackEvent("catalogAction", "favoriteInHouse", "favorite in house " + house.code), 
            ApiService.callApi("/account/setFavoriteItem", {
                houseId: house.id,
                lotId: lot.id,
                isOn: isOn
            }).then(function() {
                lot.isFavorite = isOn, CatalogsService.updateCachedItem(lot, "isFavorite");
            });
        }
        function addFavoriteFlagToItems(catalogOwner, itemIds) {
            if (itemIds) for (var i = 0; i < itemIds.length; i++) {
                var item = CatalogsService.getCachedItem(catalogOwner, itemIds[i]);
                item ? item.isFavorite = !0 : LogService.logError("Failed set favorite to item id " + itemIds[i] + " - item not found");
            }
        }
        function setItemAlert(lot, isOn) {
            return ApiService.callApi("/account/setItemAlert", {
                houseId: lot.house.id,
                lotId: lot.id,
                isOn: isOn
            }).then(function() {
                updateItemLocalAlertStatus(lot, isOn);
            });
        }
        function updateItemLocalAlertStatus(lot, isOn) {
            lot.itemAlertOn = isOn, CatalogsService.updateCachedItem(lot, "itemAlertOn");
        }
        function getAccountSceneInfo(accountScene) {
            var sceneInfo = mAccountSceneInfo[accountScene] || {}, now = new Date().getTime(), sceneExpiration = GlobalConfig.devEnv ? 3e5 : 3e5;
            return now - sceneInfo.lastAccess > sceneExpiration && (sceneInfo = {}), mAccountSceneInfo[accountScene] = sceneInfo, 
            sceneInfo.lastAccess = now, sceneInfo;
        }
        function resetItemsAppBidsCache() {
            mAppItemsBids = {};
        }
        function searchSelfAccountActions(actionType, house, isOn, searchToken, time, limit, page, withSummary) {
            var deferred = $q.defer();
            return ApiService.callApi("/account/searchSelfAccountActions", {
                region: $rootScope.currentRegion,
                houseId: house ? house.id : null,
                isOn: isOn,
                actionType: actionType,
                searchToken: searchToken,
                time: time,
                withSummary: withSummary,
                limit: limit,
                skip: (page - 1) * limit
            }).then(function(response) {
                for (var actions = response.data.actions, items = response.data.items, allAuctionsFound = CatalogsService.setItemsCatalogInfo(items), sortedItems = [], itemsMap = ArraysService.listToMapById(items), i = 0; i < actions.length; i++) {
                    var action = actions[i], lot = itemsMap[action.lotId];
                    lot && lot.house && (lot.action = action, sortedItems.push(lot));
                }
                addAccountDataToItems(response.data, itemsMap), response.data.sortedItems = sortedItems, 
                allAuctionsFound ? deferred.resolve(response.data) : PortalInfoService.loadForRegion($rootScope.currentRegion, !0).then(function() {
                    CatalogsService.setItemsCatalogInfo(items), deferred.resolve(response.data);
                });
            }), deferred.promise;
        }
        function addAccountDataToItems(accountData, itemsMap) {
            var favoriteLotsIds = accountData.favoriteLots, lotsToAlert = accountData.lotsToAlert, leadingBids = accountData.leadingBids, purchases = accountData.purchases, absenteeBids = accountData.absenteeBids;
            if (favoriteLotsIds) for (var i = 0; i < favoriteLotsIds.length; i++) itemsMap[favoriteLotsIds[i]].isFavorite = !0;
            if (lotsToAlert) for (var i = 0; i < lotsToAlert.length; i++) itemsMap[lotsToAlert[i]].itemAlertOn = !0;
            if (purchases) for (var i = 0; i < purchases.length; i++) {
                var purchase = purchases[i], item = itemsMap[purchase.lotId];
                item.purchase = purchase, setBidInfoForItem(item, "purchase", purchase), $rootScope.currentUser && purchase.userId == $rootScope.currentUser.id && setBidInfoForItem(item, "selfPurchase", purchase);
            }
            if (absenteeBids) for (var i = 0; i < absenteeBids.length; i++) {
                var absenteeBid = absenteeBids[i];
                setBidInfoForItem(itemsMap[absenteeBid.lotId], "selfAbsenteeBid", absenteeBid);
            }
            if (leadingBids) for (var i = 0; i < leadingBids.length; i++) {
                var leadingBid = leadingBids[i];
                updateLeadingBid(itemsMap[leadingBid.lotId], leadingBid);
            }
        }
        function showBlockedUserMessage(auction) {
            var house = auction.house;
            DialogsService.showAlert({
                title: "blocked_user",
                message: "blocked_user_message",
                params: {
                    houseName: I18nService.getHouseName(house, "full"),
                    email: house.details.email,
                    phone: house.details.phone
                }
            });
        }
        var mAccountSceneInfo = {}, mWaitingActionAfterHouseApprovalRequest = {}, mScope = $rootScope.$new(), mAppItemsBids = {};
        return $rootScope.$on("auth.houseApprovalChanged", checkIfActionWaitingAfterHouseApprovalRequest), 
        {
            addBidsInfoToItems: addBidsInfoToItems,
            setBidInfoForItem: setBidInfoForItem,
            requestApprovalFromHouse: requestApprovalFromHouse,
            closeApprovalPopup: closeApprovalPopup,
            showApprovalPopup: showApprovalPopup,
            validateRegisteredInHouseAndThen: validateRegisteredInHouseAndThen,
            placeAbsenteeBid: placeAbsenteeBid,
            removeAbsenteeBid: removeAbsenteeBid,
            purchaseShopItem: purchaseShopItem,
            addFavoriteFlagToItems: addFavoriteFlagToItems,
            setFavoriteItem: setFavoriteItem,
            getAccountSceneInfo: getAccountSceneInfo,
            setItemAlert: setItemAlert,
            addItemAlertToItems: addItemAlertToItems,
            updateLeadingBid: updateLeadingBid,
            handleSelfAbsenteeBidUpdate: handleSelfAbsenteeBidUpdate,
            resetItemsAppBidsCache: resetItemsAppBidsCache,
            getItemBidByAppIds: getItemBidByAppIds,
            getAppItemsBidsByField: getAppItemsBidsByField,
            searchSelfAccountActions: searchSelfAccountActions,
            addAccountDataToItems: addAccountDataToItems,
            confirmMailingList: confirmMailingList,
            showConfirmMailingList: showConfirmMailingList,
            showBlockedUserMessage: showBlockedUserMessage,
            scope: mScope
        };
    });
}), define("portal/js/modules/account/houseApprovalDirective", [ "./accountModule" ], function(module) {
    module.directive("bsHouseApproval", function($state, $stateParams, $rootScope, PathsService, I18nService, LogService, CatalogsService, PortalInfoService, PortalTextsService, AccountService, PortalAuthService) {
        return {
            restrict: "E",
            replace: !0,
            scope: {
                houseId: "=",
                inPopup: "="
            },
            link: function(scope) {
                function getText(textKey) {
                    var textParams = PortalTextsService.getHouseTextParams(scope.house);
                    return I18nService.getText(textKey, textParams);
                }
                function init() {
                    var firstParagraphKey, secondParagraphKey;
                    switch (scope.approvalState) {
                      case "NOT_REGISTERED":
                        scope.house.auctionBasedUserApproval || (firstParagraphKey = "approval_not_approved");
                        break;

                      case "INCOMPLETE_PROFILE":
                      case "NEW_SHOP_USER":
                      case "PENDING":
                        firstParagraphKey = "approval_not_approved", secondParagraphKey = "approval_pending";
                        break;

                      case "REJECTED":
                        firstParagraphKey = "approval_rejected";
                    }
                    scope.firstParagraph = getText(firstParagraphKey), secondParagraphKey && (scope.secondParagraph = getText(secondParagraphKey)), 
                    scope.requireStateId = scope.house.requestUserStateIdForApproval;
                }
                function validateApprovalRequest() {
                    if (scope.formData.error = null, scope.requireStateId) {
                        var field = "approval_request_user_id_label", stateId = scope.formData.userStateId;
                        stateId ? (stateId + "").match(/^[\d\s\-]{6,15}$/) || (scope.formData.error = I18nService.getText("error_bad_pattern", {
                            field: field
                        })) : scope.formData.error = I18nService.getText("error_mandatory", {
                            field: field
                        });
                    }
                    return null == scope.formData.error;
                }
                scope.formData = {}, scope.currentLang = $rootScope.currentLang, scope.showOkButton = null != $stateParams.fromLot;
                var houseId = scope.houseId;
                houseId || (houseId = $stateParams.houseId), scope.house = PortalInfoService.getHouse(houseId), 
                scope.house && (scope.requestApproval = function() {
                    return "COMPLETE" != $rootScope.currentUser.registrationStage ? PortalAuthService.showAuthModalPopup("warning") : validateApprovalRequest() ? AccountService.requestApprovalFromHouse(scope.house, scope.formData.userStateId).success(function() {
                        LogService.logEvent({
                            requestApproval: scope.house.code,
                            element: "HouseApproval"
                        }), scope.dismiss();
                    }).error(function() {
                        $rootScope.showGeneralError();
                    }) : void 0;
                }, scope.dismiss = function() {
                    scope.inPopup ? AccountService.closeApprovalPopup() : $stateParams.fromLot ? CatalogsService.backToLastVisitedLot() : CatalogsService.backToLastVisitedCatalog();
                }, PortalAuthService.loadAccountStateForHouse(scope.house.id).then(function() {
                    scope.approvalState = PortalAuthService.getHouseApprovalState(scope.house.id), init();
                }));
            },
            templateUrl: PathsService.appTemplatePath("account/houseApproval/houseApproval")
        };
    });
}), define("portal/js/modules/account/accountActionsController", [ "./accountModule" ], function(module) {
    module.controller("AccountActionsController", [ "$rootScope", "$scope", "$filter", "$state", "$stateParams", "$timeout", "ArraysService", "I18nService", "StringsService", "OsInfoService", "PopupsService", "PortalInfoService", "AccountService", "CatalogUtilsService", "AppSiteWinodwsService", "CatalogsService", function($rootScope, $scope, $filter, $state, $stateParams, $timeout, ArraysService, I18nService, StringsService, OsInfoService, PopupsService, PortalInfoService, AccountService, CatalogUtilsService, AppSiteWinodwsService, CatalogsService) {
        function scrollToLastClickedLot() {
            var lotToScrollTo = $scope.data.sceneInfo.lastClickedLot;
            lotToScrollTo && ($scope.scrollTo = lotToScrollTo.id, $scope.data.sceneInfo.lastClickedLot = null);
        }
        function setHousesBadges(items) {
            angular.forEach(items, function(item) {
                item.houseBadge = CatalogUtilsService.getHouseBadgeForLot(item);
            });
        }
        function digestLotAction(lot) {
            switch ($scope.actionType) {
              case "FAVORITE_ITEM":
                lot.isFavorite = !0;
                break;

              case "PURCHASE":
                AccountService.setBidInfoForItem(lot, "selfPurchase", lot.action), AccountService.setBidInfoForItem(lot, "purchase", lot.action);
                break;

              case "ABSENTEE_BID":
                AccountService.setBidInfoForItem(lot, "selfAbsenteeBid", lot.action);
            }
        }
        function setPageItems() {
            $scope.actionType || init();
            var withSummary = 1 == $scope.pagesData.currentPage ? !0 : !1, onFlag = "FAVORITE_ITEM" == $scope.actionType ? !0 : null;
            AccountService.searchSelfAccountActions($scope.actionType, $scope.data.sceneInfo.house, onFlag, $scope.data.sceneInfo.token, $scope.data.sceneInfo.time, $scope.pagesData.itemsPerPage, $scope.pagesData.currentPage, withSummary).then(function(data) {
                withSummary && ($scope.pagesData.itemsCount = data.count, $scope.data.sceneInfo.relevantHouses = PortalInfoService.getHousesByIds(data.houses)), 
                $scope.pagesData.pageItems = data.sortedItems, $scope.noItems = 0 == data.items.length ? !0 : !1;
                for (var i = 0; i < data.items.length; i++) digestLotAction(data.items[i]);
                setHousesBadges(data.items), $scope.data.sceneInfo.pagesData = $scope.pagesData, 
                $scope.loadState = "loaded", setResultMessage($scope.data.sceneInfo.token, $scope.pagesData.itemsCount);
            });
        }
        function setResultMessage(phrase, count) {
            var messageKey;
            phrase ? (messageKey = "search_results", mLastSearchPhrase = phrase, $scope.showClearSearch = !0) : (messageKey = "catalog_results_count", 
            $scope.showClearSearch = !1), $scope.resultMessage = I18nService.getText(messageKey, {
                count: count,
                token: phrase
            });
        }
        function initInstallAppPromotion() {
            !PortalInfoService.isMobileAppSupported() || GlobalConfig.isMobileApp || $scope.currentUser.userDevices && 0 != $scope.currentUser.userDevices.length || (OsInfoService.isMobile() ? (OsInfoService.isIos() || OsInfoService.isAndroid()) && ($scope.showInstallAppPromostion = !0) : $scope.showInstallAppPromostion = !0);
        }
        function initScroll() {
            new Date().getTime() - $scope.data.sceneInfo.lastClickedLotTime < 6e4 ? scrollToLastClickedLot() : window.scroll(0, 0);
        }
        function initActionType() {
            switch ($scope.catalogSource = $stateParams.actionType, $stateParams.actionType) {
              case "favorites":
                $scope.sceneTitle = "favorites", $scope.actionType = "FAVORITE_ITEM", $scope.notFoundMessage = "favorites_not_found", 
                $scope.searchMessage = "favorites_search", $scope.timeFormVisible = !0, $scope.data.sceneInfo.time = $scope.data.sceneInfo.time || "FUTURE";
                break;

              case "purchases":
                $scope.sceneTitle = "purchases", $scope.actionType = "PURCHASE", $scope.notFoundMessage = "purchases_not_found", 
                $scope.searchMessage = "purchases_search", $scope.timeFormVisible = !1, $scope.data.sceneInfo.time = null;
                break;

              case "absenteeBids":
                $scope.sceneTitle = "absentee_bids", $scope.actionType = "ABSENTEE_BID", $scope.notFoundMessage = "no_bids_found", 
                $scope.searchMessage = "absentee_search", $scope.timeFormVisible = !0, $scope.data.sceneInfo.time = $scope.data.sceneInfo.time || "FUTURE";
            }
        }
        function init() {
            $scope.currentUser ? ($scope.loadState = "loading", $scope.data.sceneInfo = AccountService.getAccountSceneInfo($stateParams.actionType), 
            initActionType(), $scope.scrollToPagination = !1, $scope.mobileElementsDimensions = CatalogsService.getMobileElementsDimensions(), 
            $scope.pagesData = $scope.data.sceneInfo.pagesData || {
                itemsPerPage: $rootScope.viewPort.pcMedia ? 50 : 20,
                currentPage: 1
            }, $scope.data.sceneInfo.pagesData = $scope.pagesData, "dev" == GlobalConfig.envName && ($scope.pagesData.itemsPerPage = 5), 
            setPageItems(), initInstallAppPromotion(), initScroll()) : $state.go("app.home");
        }
        $scope.data = {}, $scope.onPageChange = function() {
            $scope.scrollToPagination = !0, $scope.loadState = "loading", setPageItems(), $timeout(function() {
                $scope.loadState = "loaded", $scope.scrollToPagination = !1;
            }, 300);
        }, $scope.clearSearch = function() {
            $scope.data.sceneInfo.token = null, 1 == $scope.pagesData.currentPage, setPageItems();
        }, $scope.doSearch = function() {
            $scope.loadState = "loading", $scope.pagesData.currentPage = 1, setPageItems();
        }, $scope.onHouseSelected = function(houseCode) {
            $scope.loadState = "loading", $scope.pagesData.currentPage = 1, $scope.data.sceneInfo.house = houseCode ? PortalInfoService.getHouseByCode(houseCode) : null, 
            setPageItems();
        }, $scope.setSearchTime = function(time) {
            $scope.loadState = "loading", $scope.pagesData.currentPage = 1, $scope.data.sceneInfo.time = time, 
            setPageItems();
        }, $scope.gotoLot = function(lot) {
            lot.onFavoriteFlag || 0 != lot.published && ($scope.data.sceneInfo.lastClickedLot = lot, 
            $scope.data.sceneInfo.lastClickedLotInd = ArraysService.getIndById($scope.data.sceneInfo.items, lot.id), 
            $scope.data.sceneInfo.lastClickedLotTime = new Date().getTime(), CatalogsService.gotoLotPage(lot, $scope.catalogSource));
        }, $scope.showInstallPopup = function() {
            PopupsService.showInstallAppPopup();
        }, init();
    } ]);
}), define("portal/js/modules/account/bidApprovalDirective", [ "./accountModule" ], function(module) {
    module.directive("bsBidApproval", function($state, $stateParams, $rootScope, PathsService, I18nService, LogService, CatalogsService, PortalInfoService, PortalTextsService, AccountService, PortalAuthService, PopupsService) {
        return {
            restrict: "E",
            replace: !0,
            scope: {
                lot: "=",
                inPopup: "="
            },
            link: function(scope) {
                function init() {
                    scope.auction.requireCreditCard && !$rootScope.currentUser.hasValidCreditCard ? (scope.requireCreditCard = !0, 
                    scope.confirmText = "bid_approval_credit_card_needed", scope.title = "bid_approval_details_needed") : scope.confirmText = "bid_approval_confirm_terms", 
                    scope.$on("creditCard.cancelled", scope.dismiss);
                }
                scope.formData = {}, scope.currentLang = $rootScope.currentLang, scope.lot || (scope.lot = CatalogsService.getCachedItemById($stateParams.fromLot)), 
                scope.auction = scope.lot.auction, scope.auction && (scope.showHouseTerms = function() {
                    PopupsService.showHouseTerms(scope.lot.house);
                }, scope.dismiss = function() {
                    scope.inPopup ? AccountService.closeApprovalPopup() : $stateParams.fromLot && CatalogsService.backToLastVisitedCatalog();
                }, init());
            },
            templateUrl: PathsService.appTemplatePath("account/bidApproval/bidApproval")
        };
    });
}), define("portal/js/modules/account/index", [ "./accountModule", "./accountService", "./houseApprovalDirective", "./accountActionsController", "./bidApprovalDirective" ], function() {}), 
define("portal/js/modules/nudges/nudgesModule", [ "angular" ], function(ng) {
    return ng.module("app.nudges", []);
}), define("portal/js/modules/nudges/nudgeNavbarPopupDirective", [ "./nudgesModule" ], function(module) {
    module.directive("bsNudgeNavbarPopup", function($rootScope, $timeout, PathsService, NudgesService) {
        return {
            restrict: "E",
            replace: !0,
            scope: {
                house: "="
            },
            link: function(scope) {
                function setNudgeType(nudgeType) {
                    $rootScope.nudgePopupVisible = !0, scope.isVisible = !0, scope.nudgeType = nudgeType, 
                    NudgesService.setNudgedRecently();
                }
                function updateDisplay() {
                    switch (scope.hide(), scope.featureToNudate = NudgesService.getNextFeatureToNudgeUser(), 
                    scope.featureToNudate) {
                      case "NEW_CATALOG_ALERT":
                        setNudgeType("housesAlerts");
                    }
                }
                scope.hide = function() {
                    scope.isVisible = !1, $rootScope.nudgePopupVisible = !1;
                }, scope.onClick = function() {
                    scope.hide(), NudgesService.rememberNudgedFeature(scope.featureToNudate);
                }, scope.$on("auth.menuVisible", function(e, menuVisible) {
                    menuVisible && scope.hide();
                }), updateDisplay(), scope.$on("auth.newSessionUser", updateDisplay);
            },
            templateUrl: PathsService.appTemplatePath("nudges/navbar/nudgeNavbarPopup")
        };
    });
}), define("portal/js/modules/nudges/mobilePushService", [ "./nudgesModule" ], function(module) {
    module.factory("MobilePushService", function($rootScope, $uibModal, ArraysService, SettingsService, LogService, LocalStorageService, ApiService, PathsService, AnalyticsService, PopupsService, PortalInfoService, AppSiteWinodwsService) {
        function init() {
            window.device && (mDeviceId = device.uuid, mPlatform = device.platform ? device.platform.toLowerCase() : "Unknown", 
            $rootScope.$on("auth.newSessionUser", onSessionUserChanged), $rootScope.debug("mobile push init with id " + mDeviceId + ", platform: " + mPlatform), 
            addDeviceToCurrentUser());
        }
        function registerForPushNotification() {
            mDeviceId && (mPushPlugin && ($rootScope.debug("Unregistering...:"), mPushPlugin.unregister()), 
            $rootScope.debug("Registering...:"), mPushPlugin = PushNotification.init({
                android: {
                    senderID: SettingsService.get("gcmSender")
                },
                ios: {
                    alert: "true",
                    badge: "true",
                    sound: "true"
                },
                windows: {}
            }), mPushPlugin.on("registration", updateDevicePushRegistration), mPushPlugin.on("notification", handlePushEvent), 
            mPushPlugin.on("error", handleError));
        }
        function shouldRegisterForPush() {
            if (!mPlatform) return !1;
            if (LocalStorageService.load("lastPushRegistrationId")) return !0;
            var user = $rootScope.currentUser;
            if (!user) return !1;
            var requestState = user.pushNotificationRequestState;
            return requestState && "NOT_REQUESTED" != requestState ? !0 : !1;
        }
        function registerForPushIfNeeded() {
            shouldRegisterForPush() && registerForPushNotification();
        }
        function handleError(error) {
            debugResult(error, "Push registration error"), LogService.logError(JSON.stringify(error));
        }
        function debugResult(result, message) {
            $rootScope.debug((message ? message + ": " : "") + JSON.stringify(result));
        }
        function showAuctionStartAlert(auction) {
            $uibModal.open({
                templateUrl: PathsService.appTemplatePath("alerts/popups/auctionStartPopup"),
                size: "lg",
                controller: function($scope) {
                    $scope.auction = angular.copy(auction), $scope.message = auction.catalogOnly || auction.absenteeBidsOnly ? "push_auction_start_message_no_live" : "push_auction_start_message", 
                    $scope.auction.state = "RUNNING", $scope.openAuctionSite = function() {
                        AppSiteWinodwsService.openAuctionSiteWindow($scope.auction), $scope.$close();
                    }, $scope.dismiss = function() {
                        $scope.$close();
                    };
                }
            });
        }
        function showItemAlert(auction, itemAlertMessage) {
            $uibModal.open({
                templateUrl: PathsService.appTemplatePath("alerts/popups/itemAlertPopup"),
                size: "lg",
                controller: function($scope) {
                    $scope.auction = angular.copy(auction), $scope.auction.state = "RUNNING", $scope.itemAlertMessage = itemAlertMessage, 
                    $scope.openAuctionSite = function() {
                        AppSiteWinodwsService.openAuctionSiteWindow($scope.auction), $scope.$close();
                    };
                }
            });
        }
        function handlePushEvent(event) {
            $rootScope.debug("Push event:" + JSON.stringify(event));
            var auction = PortalInfoService.getAuction(event.additionalData.auctionId), code = event.additionalData.code;
            if (auction && auction.house) switch (AnalyticsService.trackEvent("appAction", "pushEvent", "eventCode:" + code + ", house:" + auction.house.code + ", auction:" + auction.date + " " + auction.time), 
            code) {
              case "auctionStart":
                showAuctionStartAlert(auction);
                break;

              case "itemAlert":
                showItemAlert(auction, event.message);
            }
            mPushPlugin.finish(function() {
                $rootScope.debug("push event finished");
            });
        }
        function updateDevicePushRegistration(event) {
            debugResult(event, "Device registration");
            var registrationId = event.registrationId;
            mDeviceId && $rootScope.currentUser && (registrationId != mLastPushRegistrationId || "REQUESTED" != $rootScope.currentUser.pushNotificationRequestState) && (mLastPushRegistrationId = registrationId, 
            LocalStorageService.store("lastPushRegistrationId", registrationId), ApiService.callApi("/users/updateDevicePushRegistration", {
                deviceId: mDeviceId,
                platform: mPlatform,
                registrationId: registrationId
            }).then(function() {
                $rootScope.currentUser.pushNotificationRequestState = "REQUESTED";
            }));
        }
        function dummyDeviceRegistrationForDev() {
            mDeviceId = "zzz2", addDeviceToCurrentUser(), updateDevicePushRegistration({
                registrationId: "zzz"
            });
        }
        function addDeviceToCurrentUser() {
            var user = $rootScope.currentUser;
            if (user && mDeviceId) {
                debugResult({
                    device: mDeviceId,
                    userDevices: user.userDevices
                });
                var devicedRegisterdForUser = ArraysService.contains(user.userDevices, mDeviceId);
                devicedRegisterdForUser || ApiService.callApi("/users/addDeviceToUser", {
                    deviceId: mDeviceId
                }).then(function() {
                    user.userDevices ? user.userDevices.push(mDeviceId) : user.userDevices = [ mDeviceId ];
                });
            }
            registerForPushIfNeeded();
        }
        function onSessionUserChanged() {
            var user = $rootScope.currentUser;
            user ? addDeviceToCurrentUser() : mDeviceId && mLastPushRegistrationId && (mLastPushRegistrationId = null);
        }
        var mDeviceId, mLastPushRegistrationId, mPlatform, mPushPlugin;
        return {
            init: init,
            handlePushEvent: handlePushEvent,
            registerForPushNotification: registerForPushNotification,
            registerForPushIfNeeded: registerForPushIfNeeded,
            dummyDeviceRegistrationForDev: dummyDeviceRegistrationForDev
        };
    });
}), define("portal/js/modules/nudges/nudgesService", [ "./nudgesModule" ], function(module) {
    module.factory("NudgesService", function($rootScope, $timeout, $state, StringsService, PathsService, ApiService, SessionsService, LocalStorageService, PortalInfoService, PopupsService, PortalAuthService, SettingsService, OsInfoService) {
        function rememberNudgedFeature(feature) {
            return ApiService.callApi("/users/rememberNudgedFeature", {
                feature: feature
            }).then(function() {
                PortalInfoService.loadForRegion($rootScope.currentRegion, !0);
            });
        }
        function shouldNudgeUserOnFeature(feature) {
            if (nudgedRecently) return !1;
            var user = $rootScope.currentUser;
            if (!user) return !1;
            if (GlobalConfig.isMobileApp) return !1;
            if ("COMPLETE" != user.registrationStage) return !1;
            var daysSinceLastNudge = getDaysSinceLastUserNudge(user, feature), daysToWait = 30;
            return daysSinceLastNudge && daysToWait > daysSinceLastNudge ? !1 : checkIfNudgeNeededForUser(user, feature);
        }
        function getDaysSinceLastUserNudge(user, feature) {
            var featuresInfo = user.featuresInfo;
            return featuresInfo && featuresInfo[feature] ? SettingsService.timeSince(featuresInfo[feature].lastNudge) / 864e5 : null;
        }
        function checkIfNudgeNeededForUser(user, feature) {
            switch (feature) {
              case "NEW_CATALOG_ALERT":
                return -1 != PathsService.getCurrentUiHref().indexOf("shop") ? !1 : checkIfShouldNudgeOnNewCatalogsAlert(user);

              case "INSTALL_APP_MOBILE":
                return checkIfShouldNudgeOnInstallMobileApp(user);
            }
            return !1;
        }
        function checkIfShouldNudgeOnNewCatalogsAlert(user) {
            var alertsPreferences = user.alertsPreferences[$rootScope.contentType];
            return alertsPreferences && alertsPreferences.housesAlertChoice ? !1 : !0;
        }
        function checkIfShouldNudgeOnInstallMobileApp(user) {
            return PortalInfoService.isMobileAppSupported() ? user.userDevices && user.userDevices.length ? !1 : !0 : !1;
        }
        function getNextFeatureToNudgeUser() {
            var feature = "NEW_CATALOG_ALERT";
            return shouldNudgeUserOnFeature(feature) ? feature : void 0;
        }
        function setNudgedRecently() {
            nudgedRecently = !0;
        }
        function daysSinceLastBrowserNudge(feature) {
            var timeSinceLastNudge = LocalStorageService.load("nudge_" + feature);
            return timeSinceLastNudge ? (new Date().getTime() - timeSinceLastNudge) / 864e5 : void 0;
        }
        function getNextFeatureToNudgeNonUser() {
            if (!checkIfNeedsToNudgeNonUser()) return null;
            var feature = "NEW_CATALOG_ALERT", daysSinceLastNudge = daysSinceLastBrowserNudge(feature);
            return !daysSinceLastNudge || daysSinceLastNudge > SettingsService.get("daysToWaitCatalogsAlertRenudge", 30) ? feature : void 0;
        }
        function checkIfNeedsToNudgeNonUser() {
            return PortalAuthService.isAuthPopupOn() ? !1 : $rootScope.currentUser ? !1 : $rootScope.searchAgentRequest ? !1 : $rootScope.viewPort.mobileMedia ? !1 : LocalStorageService.isEnabled() ? LocalStorageService.load("lastLogin") ? !1 : !0 : !1;
        }
        function showNudgeForNonUser() {
            var feature = getNextFeatureToNudgeNonUser();
            if ("NEW_CATALOG_ALERT" == feature) {
                switch (feature) {
                  case "NEW_CATALOG_ALERT":
                    showHouseAlert();
                }
                nudgedRecently = !0, LocalStorageService.store("nudge_" + feature, new Date().getTime());
            }
        }
        function showHouseAlert() {
            PopupsService.showPopup({
                contentInclude: "nudges/modal/housesAlertsModal",
                code: "nudge",
                size: "sm",
                showRegisterForm: function() {
                    PortalAuthService.showAuthModalOrScene("register");
                }
            });
        }
        function checkIfShouldNugeOnMobileAppInstall() {
            shouldNudgeUserOnFeature("INSTALL_APP_MOBILE") && $rootScope.viewPort.mobileMedia && OsInfoService.isAppSupportedOnPlatform() && $timeout(function() {
                $state.go("app.installMobileApp");
            }, 1e3);
        }
        function init() {
            $timeout(showNudgeForNonUser, 3e4), $rootScope.$on("auth.newSessionUser", checkIfShouldNugeOnMobileAppInstall), 
            checkIfShouldNugeOnMobileAppInstall();
        }
        var nudgedRecently = !1;
        return init(), {
            getNextFeatureToNudgeUser: getNextFeatureToNudgeUser,
            rememberNudgedFeature: rememberNudgedFeature,
            setNudgedRecently: setNudgedRecently,
            showHouseAlert: showHouseAlert
        };
    });
}), define("portal/js/modules/nudges/installAppNudgeController", [ "./nudgesModule" ], function(module) {
    module.controller("InstallAppNudgeController", [ "$scope", "$rootScope", "NudgesService", "PortalNavigationService", function($scope, $rootScope, NudgesService, PortalNavigationService) {
        $scope.continueOnBrowser = function() {
            NudgesService.rememberNudgedFeature("INSTALL_APP_MOBILE"), PortalNavigationService.goBack();
        }, $scope.gotoStorePage = function() {
            PortalNavigationService.openAppStorePage();
        };
    } ]);
}), define("portal/js/modules/nudges/index", [ "./nudgesModule", "./nudgeNavbarPopupDirective", "./mobilePushService", "./nudgesService", "./installAppNudgeController" ], function() {}), 
define("portal/js/modules/promotions/promotionsModule", [ "angular" ], function(ng) {
    return ng.module("app.ads", []);
}), define("portal/js/modules/promotions/promotionsService", [ "./promotionsModule" ], function(module) {
    module.factory("AdsService", function($rootScope, $q, PathsService, I18nService, AnalyticsService, ApiService, ArraysService, CloudinaryService, OsInfoService, StringsService, PortalInfoService) {
        function getAdsInfo() {
            var defered = $q.defer();
            return mCachedAdsInfo ? defered.resolve(mCachedAdsInfo) : ApiService.callApi("/promotions/getPromotionsInfo", {
                region: $rootScope.currentRegion,
                contentType: $rootScope.contentType
            }).success(function(adsInfo) {
                mCachedAdsInfo = adsInfo, defered.resolve(mCachedAdsInfo);
            }), defered.promise;
        }
        function getAdInfoForPosition(position) {
            if (mCachedAdsInfo) {
                var adInfo = mCachedAdsInfo.adsInfo[position];
                if (adInfo) if ("HOUSE_AD" == adInfo.adType) {
                    var houseAd = mCachedAdsInfo.houseAds[adInfo.code];
                    if (!houseAd) return null;
                    houseAd.house = PortalInfoService.getHouse(houseAd.houseId), houseAd.auction = PortalInfoService.getAuction(houseAd.auctionId), 
                    adInfo.houseAd = houseAd;
                } else if ("BANNER" == adInfo.adType) {
                    if (adInfo.imagePath = adInfo.resources[OsInfoService.isMobile() ? "mobileImage" : "pcImage"], 
                    !adInfo.imagePath || !adInfo.targetUrl) return null;
                } else if (!("IMAGE_AND_TEXT_AD" != adInfo.adType || adInfo.resources.image && adInfo.targetUrl)) return null;
                return adInfo;
            }
        }
        function init() {
            getAdsInfo().then(function() {
                $rootScope.adsInfoLoaded = !0;
            });
        }
        var mCachedAdsInfo = null;
        return {
            getAdInfoForPosition: getAdInfoForPosition,
            init: init
        };
    });
}), define("portal/js/modules/promotions/promotionInstanceDirective", [ "./promotionsModule", "morpheus" ], function(module) {
    module.directive("promotionInstance", function($state, $rootScope, $timeout, PathsService, AnalyticsService, LogService, AppSiteWinodwsService, PortalNavigationService, PopupsService, AdsService) {
        return {
            restrict: "E",
            replace: !0,
            scope: {
                position: "@"
            },
            link: function(scope) {
                function renameAdToPromotion() {
                    switch (scope.promotionInfo = scope.adInfo, scope.promotionType = scope.adInfo.adType, 
                    scope.adInfo.adType) {
                      case "HOUSE_AD":
                        var houseAd = scope.adInfo.houseAd;
                        houseAd && (scope.promotionType = "HOUSE_PROMOTION", scope.promotionInfo.imagePath = houseAd.imagePath, 
                        scope.promotionInfo.text = houseAd.text, scope.promotionInfo.title = houseAd.title);
                    }
                }
                function init() {
                    scope.adInfo = AdsService.getAdInfoForPosition(scope.position), scope.adInfo && renameAdToPromotion();
                }
                scope.onClick = function() {
                    try {
                        switch (scope.adInfo.adType) {
                          case "HOUSE_AD":
                            var houseAd = scope.adInfo.houseAd;
                            if (houseAd) switch (houseAd.adType) {
                              case "FEATURED_AUCTION":
                                var auction = houseAd.auction;
                                "RUNNING" == auction.state ? AppSiteWinodwsService.openAuctionSiteWindow(auction) : $state.go("app.auctionCatalog", {
                                    catalogKey: auction.intKey,
                                    page: 1
                                });
                                break;

                              case "EXTERNAL_AD":
                                houseAd.externalUrl.match(/.{3,}\.bidspirit\.com/) ? AppSiteWinodwsService.openBidspiritSiteUrl(houseAd.externalUrl, houseAd.house.id) : PortalNavigationService.openWindow(houseAd.externalUrl);
                            }
                            break;

                          case "MOBILE_APP_PROMOTION":
                            PopupsService.showInstallAppPopup();
                            break;

                          case "IMAGE_AND_TEXT_AD":
                          case "BANNER":
                            PortalNavigationService.openWindow(scope.adInfo.targetUrl);
                        }
                        AnalyticsService.trackEvent("adAction", "clickOnAd_" + scope.adInfo.adType + "_" + scope.position, "code:" + scope.adInfo.code), 
                        LogService.logMessage("HOUSE_AD_CLICK clickOnAd_" + scope.adInfo.adType + "_" + scope.position + ", code:" + scope.adInfo.code);
                    } catch (e) {
                        LogService.logError("Failed on ad click", e);
                    }
                }, $rootScope.$watch("adsInfoLoaded", init);
            },
            templateUrl: PathsService.appTemplatePath("ads/promotionInstance")
        };
    });
}), define("portal/js/modules/promotions/index", [ "./promotionsModule", "./promotionsService", "./promotionInstanceDirective" ], function() {}), 
define("portal/js/modules/support/supportModule", [ "angular" ], function(ng) {
    return ng.module("app.support", []);
}), define("portal/js/modules/support/supportController", [ "./supportModule" ], function(module) {
    module.controller("SupportController", [ "$rootScope", "$scope", "$uibModal", "$state", "$timeout", "$stateParams", "I18nService", "PathsService", "ArraysService", "StringsService", "DialogsService", "LocalStorageService", "DomUtilsService", "SupportService", "PortalAuthService", function($rootScope, $scope, $uibModal, $state, $timeout, $stateParams, I18nService, PathsService, ArraysService, StringsService, DialogsService, LocalStorageService, DomUtilsService, SupportService, PortalAuthService) {
        function setPageCases() {
            if (!$scope.loading) {
                var pagesData = $scope.pagesData;
                return $scope.loading = !0, $scope.supportDataLoaded = !1, SupportService.searchSupportCases({
                    region: $rootScope.currentRegion,
                    assignee: "me" == $scope.filter.casesType ? $rootScope.currentUser.email : "",
                    token: $scope.searchToken,
                    casesType: getVisibleCaseTypes(),
                    sortField: $scope.filter.sortField,
                    direction: $scope.filter.isDescSort ? "DESC" : "ASC",
                    nonClosedOnly: $scope.filter.nonClosedOnly,
                    skip: pagesData.itemsPerPage * (pagesData.currentPage - 1),
                    limit: pagesData.itemsPerPage
                }).then(function(response) {
                    $scope.supportDataLoaded = !0, $scope.cases = response.cases, displayData.cases = response.cases, 
                    displayData.filter = $scope.filter, SupportService.setLastCasesDisplayData(displayData), 
                    $scope.pagesData.itemsCount = response.count, $scope.loading = !1, LocalStorageService.store("lastSupportCaseFilter", JSON.stringify($scope.filter)), 
                    $scope.scrollTo = SupportService.getRecentCaseId();
                });
            }
        }
        function loadLastSupportFilter() {
            try {
                $scope.filter = JSON.parse(LocalStorageService.load("lastSupportCaseFilter"));
            } catch (e) {
                $scope.filter = {};
            }
            $scope.filter = angular.extend({
                casesType: "all",
                unclosedOnly: !0,
                sortField: "openTime",
                isDescSort: !1
            }, $scope.filter), $stateParams.searchToken && ($scope.filter.casesType = "all");
        }
        function getVisibleCaseTypes() {
            switch ($scope.filter.casesType) {
              case "sell":
                return [ "ITEM_FOR_SALE" ];

              case "pending":
                return [ "NEW_AUCTION_HOUSE" ];

              case "features":
                return [ "FEATURE_REQUEST" ];

              case "finance":
                return [ "FINANCE" ];

              case "support":
                return [ "CONTACT_REQUEST", "ADMIN_PROBLEM", "UI_PROBLEM" ];

              default:
                return null;
            }
        }
        function loadDisplayData() {
            displayData = SupportService.getLastCasesDisplayData(), displayData ? ($scope.pagesData = displayData.pagesData, 
            $scope.cases = displayData.cases, $scope.filter = displayData.filter, $scope.loading = !1, 
            $timeout(function() {
                $scope.supportDataLoaded = !0, $scope.scrollTo = SupportService.getRecentCaseId();
            }, 100)) : ($scope.pagesData = {
                itemsPerPage: "dev" == GlobalConfig.envName ? 5 : 20,
                currentPage: 1
            }, displayData = {
                pagesData: $scope.pagesData,
                cases: null
            }, loadLastSupportFilter(), $scope.loading = !1, $scope.loadSupportCases());
        }
        function loadIfHasUser() {
            if (!$scope.loading && !$scope.supportDataLoaded) {
                var user = PortalAuthService.validateUserLoggedIn();
                user && ($scope.loading = !0, SupportService.setSupportFavIcon(), loadDisplayData());
            }
        }
        function init() {
            loadIfHasUser(), $timeout(function() {
                loadIfHasUser();
            }, 2e3), $rootScope.$on("auth.newSessionUser", loadIfHasUser);
        }
        $scope.loading = !1;
        var displayData = null;
        $scope.caseTypeSelections = [ "me", "support", "sell", "pending", "features", "finance", "all" ], 
        $scope.cases = [], $scope.searchToken = $stateParams.searchToken || "", $scope.loadSupportCases = function() {
            $rootScope.currentUser && !$scope.loading && SupportService.validateAllowedToViewSupport() && ($scope.pagesData.currentPage = 1, 
            setPageCases());
        }, $scope.onPageChange = function() {
            setPageCases();
        }, $scope.clearSearch = function() {
            $scope.searchToken = "", $scope.loadSupportCases();
        }, $scope.getCaseTypeFilterName = function(caseType) {
            switch (caseType) {
              case "pending":
                return "pending_auction_houses";

              case "me":
                return "assigned_to_me";

              case "sell":
                return "items_for_sell";

              case "features":
                return "features_request";

              default:
                return caseType;
            }
        }, $scope.showOpenSupportCaseForm = function() {
            SupportService.showActionForm({
                title: "support_case_action_open",
                supportCase: {},
                action: {
                    actionType: "OPEN"
                },
                saveFunction: function(actionToSave) {
                    return SupportService.createSupportCase($rootScope.currentRegion, $rootScope.contentType, $rootScope.currentLang, actionToSave.newCaseType, actionToSave.subject).then(function(response) {
                        var supportCase = response.data;
                        actionToSave.caseId = supportCase.id, actionToSave.lang = $rootScope.currentLang, 
                        actionToSave.userEmail = $rootScope.currentUser.email, SupportService.saveSupportAction(actionToSave).then(function() {
                            SupportService.getSupportCase(supportCase.id).then(function(loadedCase) {
                                $scope.cases.push(loadedCase);
                            });
                        });
                    });
                }
            });
        }, $scope.getSupportCaseDescrition = function(supportCase) {
            var actions = supportCase.actions, description = StringsService.trimToWord(supportCase.originalAction.displayText, 300);
            return actions.length > 1 && (description += "\n.\n.\n" + supportCase.lastUserDisplay + ":\n" + StringsService.trimToWord(supportCase.lastAction.displayText, 300)), 
            description;
        }, $scope.displaySupportCase = function(supportCase) {
            $state.go("app.supportCase", {
                caseId: supportCase.id
            });
        }, $scope.setSortField = function(sortField) {
            $scope.filter.sortField == sortField ? $scope.filter.isDescSort = !$scope.filter.isDescSort : ($scope.filter.sortField = sortField, 
            $scope.filter.isDescSort = !0), $scope.loadSupportCases();
        }, $scope.toggleStarred = function(supportCase) {
            supportCase.starred = !supportCase.starred, SupportService.setSupportCaseStarred(supportCase.id, supportCase.starred);
        }, init();
    } ]);
}), define("portal/js/modules/support/supportService", [ "./supportModule" ], function(module) {
    module.factory("SupportService", function($rootScope, $q, $uibModal, $timeout, $state, I18nService, OsInfoService, DialogsService, PathsService, ApiService, SessionsService, StringsService, DomUtilsService, ArraysService, PortalInfoService) {
        function getSupportCases(unclosedOnly) {
            var deffered = $q.defer();
            return ApiService.callApi("/support/getSupportCases", {
                unclosedOnly: unclosedOnly
            }).then(function(response) {
                for (var supportCases = response.data, i = 0; i < supportCases.length; i++) processCase(supportCases[i]);
                deffered.resolve(supportCases);
            }, function(errorData) {
                console.error("Failed to load support cases"), console.error(errorData), deffered.resolve([]);
            }), deffered.promise;
        }
        function getLastCasesDisplayData() {
            return lastCasesDisplayData;
        }
        function setLastCasesDisplayData(casesDisplayData) {
            lastCasesDisplayData = casesDisplayData;
        }
        function searchSupportCases(options) {
            var deffered = $q.defer();
            return ApiService.callApi("/support/searchSupportCases", options).then(function(response) {
                for (var supportCases = response.data.cases, i = 0; i < supportCases.length; i++) processCase(supportCases[i]);
                deffered.resolve(response.data);
            }), deffered.promise;
        }
        function getSupportCase(caseId) {
            var deffered = $q.defer();
            return ApiService.callApi("/support/getSupportCase", {
                caseId: caseId
            }).then(function(response) {
                var supportCase = response.data;
                processCase(supportCase), deffered.resolve(supportCase);
            }), deffered.promise;
        }
        function processCase(supportCase) {
            if (supportCase) {
                for (var i = 0; i < supportCase.actions.length; i++) processAction(supportCase.actions[i]);
                supportCase.lastAction = supportCase.actions[0] || {}, supportCase.originalAction = supportCase.actions[supportCase.actions.length - 1], 
                supportCase.openerDisplay = getUserDisplay(supportCase.opener, !OsInfoService.isMobile()), 
                supportCase.assigneeDisplay = getUserDisplay(supportCase.currentAssignee, !1), supportCase.lastUserDisplay = getUserDisplay(supportCase.lastAction.user, !1), 
                supportCase.handledByAssignee = supportCase.lastAction.userEmail == supportCase.currentAssigneeEmail;
            }
        }
        function getUserDisplay(user, withEmail) {
            if (!user || !user.email) return "";
            var text = "";
            return user.firstName && (text = user.firstName + " " + user.lastName), (withEmail || !text) && (text = '<span dir="ltr">' + user.email + "</span> " + (text ? "(" + text + ")" : "")), 
            text;
        }
        function processAction(action) {
            action.description = StringsService.stripDangerousTags(action.description), action.displayText = StringsService.stripTags(action.description).replace(/\.\s+/g, ".\n").replace(/\n\n/g, "\n"), 
            action.notes = getActionNotes(action), action.userDisplay = getUserDisplay(action.user, !OsInfoService.isMobile());
        }
        function getActionNotes(action) {
            var notes = "";
            if (action.isDraft) return "[" + I18nService.getText("draft") + "]";
            if (action.forwardedHouseCode) {
                var house = action.forwardedHouse || PortalInfoService.getHouseByCode(action.forwardedHouseCode), houseName = house ? I18nService.getLangField(house.details.name) : action.forwardedHouseCode;
                notes += " " + I18nService.getText("support_notes_forwarded_to_house", {
                    house: houseName
                }) + "<br>";
            }
            return action.previousCaseType && (notes += " " + I18nService.getText("support_notes_type_changed", {
                newCaseType: '<b>"' + I18nService.getText("support_case_type_" + action.newCaseType) + '"</b>'
            }) + "<br>"), action.recipients && (notes += " " + I18nService.getText("support_notes_message_sent", {
                recipients: action.recipients
            }) + "<br>"), action.closeSupportCase && (notes += " " + I18nService.getText("support_notes_closed") + "<br>"), 
            notes.replace(/<br>$/, "");
        }
        function getPossibleAssignees() {
            var deffered = $q.defer();
            return cache.assignees ? deffered.resolve(cache.assignees) : ApiService.callApi("/support/getPossibleAssignees").then(function(response) {
                cache.assignees = response.data, deffered.resolve(cache.assignees);
            }), deffered.promise;
        }
        function createSupportCase(region, contentType, lang, caseType, subject) {
            return ApiService.callApi("/support/createSupportCase", {
                region: region,
                contentType: contentType,
                lang: lang,
                caseType: caseType,
                subject: subject
            });
        }
        function updateCachedDisplayData(supportCase) {
            lastCasesDisplayData && (processCase(supportCase), ArraysService.addOrReplaceById(lastCasesDisplayData.cases, supportCase));
        }
        function saveSupportAction(action) {
            var deffered = $q.defer();
            return ApiService.callApi("/support/saveSupportAction", action, "POST").then(function(response) {
                var action = response.data;
                processAction(action), deffered.resolve(action);
            }), deffered.promise;
        }
        function removeSupportCase(caseId) {
            return ApiService.callApi("/support/removeSupportCase", {
                caseId: caseId
            });
        }
        function setSupportFavIcon() {
            DomUtilsService.setFavIcon("../common/images/system/greenFavicon.png");
        }
        function showActionForm(data) {
            $uibModal.open({
                templateUrl: PathsService.appTemplatePath("support/supportCaseAction"),
                size: "lg",
                controller: function($scope) {
                    $scope.data = data;
                }
            });
        }
        function removeSupportCaseAction(caseActionId) {
            return ApiService.callApi("/support/removeSupportCaseAction", {
                caseActionId: caseActionId
            });
        }
        function setSupportCaseStarred(caseId, starred) {
            return ApiService.callApi("/support/setSupportCaseStarred", {
                caseId: caseId,
                starred: starred
            });
        }
        function validateAllowedToViewSupport() {
            if (!$rootScope.currentUser) return !1;
            var role = $rootScope.currentUser.role;
            return "ADMIN" == role || "SYSTEM" == role ? !0 : (DialogsService.showAlert("you are not allowed to enter this section, please login as admin").then(function() {
                $state.go("app.home");
            }), !1);
        }
        function setRecentCase(supportCase) {
            recentCaseInfo.id = supportCase.id, recentCaseInfo.time = new Date().getTime();
        }
        function getRecentCaseId() {
            return new Date().getTime() - recentCaseInfo.time < 1e4 ? recentCaseInfo.id : void 0;
        }
        var cache = {}, recentCaseInfo = {}, lastCasesDisplayData = null;
        return {
            getSupportCases: getSupportCases,
            searchSupportCases: searchSupportCases,
            getSupportCase: getSupportCase,
            getPossibleAssignees: getPossibleAssignees,
            createSupportCase: createSupportCase,
            removeSupportCase: removeSupportCase,
            showActionForm: showActionForm,
            saveSupportAction: saveSupportAction,
            removeSupportCaseAction: removeSupportCaseAction,
            updateCachedDisplayData: updateCachedDisplayData,
            setSupportCaseStarred: setSupportCaseStarred,
            setSupportFavIcon: setSupportFavIcon,
            validateAllowedToViewSupport: validateAllowedToViewSupport,
            getRecentCaseId: getRecentCaseId,
            setRecentCase: setRecentCase,
            setLastCasesDisplayData: setLastCasesDisplayData,
            getLastCasesDisplayData: getLastCasesDisplayData
        };
    });
}), define("portal/js/modules/support/supportCaseController", [ "./supportModule" ], function(module) {
    module.controller("SupportCaseController", [ "$rootScope", "$scope", "$uibModal", "$state", "$stateParams", "I18nService", "PathsService", "ArraysService", "StringsService", "DialogsService", "SupportService", "PortalInfoService", "PortalAuthService", function($rootScope, $scope, $uibModal, $state, $stateParams, I18nService, PathsService, ArraysService, StringsService, DialogsService, SupportService, PortalInfoService, PortalAuthService) {
        function setLastVisitedLot() {
            var lot = $scope.supportCase.lastVisitedLot;
            lot && (lot.house = PortalInfoService.getHouse(lot.houseId), lot.auctionId && (lot.auction = PortalInfoService.getAuction(lot.ownerKey)), 
            lot.shopId && (lot.shop = PortalInfoService.getShop(lot.ownerKey)), $scope.lastVisitedLot = lot);
        }
        function init() {
            var user = PortalAuthService.validateUserLoggedIn();
            user ? (SupportService.setSupportFavIcon(), $scope.loadSupportCase()) : $rootScope.$on("auth.newSessionUser", $scope.loadSupportCase);
        }
        $scope.removeSupportCase = function() {
            return DialogsService.showConfirm({
                message: "support_confirm_remove_case",
                title: "notice"
            }).then(function(confirmed) {
                return confirmed ? SupportService.removeSupportCase($scope.supportCase.id).then(function() {
                    $state.go("app.support");
                }) : void 0;
            });
        }, $scope.loadSupportCase = function() {
            $scope.supportCase = null, SupportService.validateAllowedToViewSupport() && SupportService.getSupportCase($stateParams.caseId).then(function(supportCase) {
                $scope.supportCase = supportCase, $scope.supportCase ? $scope.supportCase.lastVisitedLot && setLastVisitedLot() : $state.go("app.support");
            });
        }, $scope.showActionForm = function(action) {
            "SEND_EMAIL" == action.actionType && (action.recipients = $scope.supportCase.openerEmail), 
            SupportService.showActionForm({
                action: action,
                supportCase: $scope.supportCase,
                saveFunction: function(actionToSave) {
                    return action.userEmail || (actionToSave.userEmail = $rootScope.currentUser.email), 
                    SupportService.saveSupportAction(actionToSave).then(function(action) {
                        actionToSave.newCaseType && ($scope.supportCase.caseType = actionToSave.newCaseType);
                        var existingAction = ArraysService.getById($scope.supportCase.actions, action.id);
                        existingAction ? angular.extend(existingAction, action) : $scope.supportCase.actions.unshift(action), 
                        SupportService.updateCachedDisplayData($scope.supportCase);
                    });
                }
            });
        }, $scope.addAction = function(actionType) {
            $scope.showActionForm({
                caseId: $scope.supportCase.id,
                actionType: actionType
            });
        }, init(), $scope.$on("$destroy", function() {
            SupportService.setRecentCase($scope.supportCase);
        });
    } ]);
}), define("portal/js/modules/support/supportCaseActionController", [ "./supportModule" ], function(module) {
    module.controller("SupportCaseActionController", [ "$rootScope", "$scope", "$uibModal", "$state", "$stateParams", "$timeout", "$interval", "I18nService", "PathsService", "ArraysService", "StringsService", "DialogsService", "SupportService", "PortalAuthService", "DomUtilsService", function($rootScope, $scope, $uibModal, $state, $stateParams, $timeout, $interval, I18nService, PathsService, ArraysService, StringsService, DialogsService, SupportService, PortalAuthService, DomUtilsService) {
        function init() {
            if ($scope.uploadedAttachments = [], $scope.data.action.attachments || ($scope.data.action.attachments = []), 
            $scope.data.newAdminRecipient = "", $scope.data.action.id) $scope.data.action.isDraft && ($scope.editMode = !0); else {
                switch ($scope.data.action.closeSupportCase = !1, $scope.data.action.sendLotInquiry = !1, 
                $scope.data.action.forwardAsUserEmail = !1, $scope.data.action.description = "", 
                $scope.data.action.newCaseType = $scope.data.supportCase.caseType, $scope.data.action.isDraft = !0, 
                $scope.changeCaseType = !1, $scope.data.action.actionType) {
                  case "OPEN":
                    $scope.changeCaseType = !0;
                    break;

                  case "CLOSE":
                    $scope.data.action.closeSupportCase = !0;
                    break;

                  case "FORWARD_TO_AUCTION_HOUSE":
                    guessHouseCode(), $scope.handleForwardMessage();
                    break;

                  case "SEND_EMAIL":
                    addSignatureToDescription();
                }
                $scope.editMode = !0;
            }
            SupportService.getPossibleAssignees().then(function(assignees) {
                $scope.assignees = assignees;
            }), "OPEN" != $scope.data.action.actionType && $timeout(function() {
                $scope.focusOnDesc = !0;
            }, 300), savedDescription = $scope.data.action.description, saveDraftInterval = $interval(autoSaveDraft, 1e4), 
            setTextKeys(), setActionsHistory(), setDescriptionView();
        }
        function setDescriptionView() {
            $scope.data.descriptionView = ($scope.data.action.description || "").replace(/\s*(\r|\n|<br>)\s*/gi, "~~~").replace(/\s+/g, " ").replace(/(~~~)+/g, "<br>");
        }
        function guessHouseCode() {
            for (var actions = $scope.data.supportCase.actions, i = 0; i < actions.length; i++) {
                var action = actions[i];
                action.forwardedHouseCode && ($scope.guessedHouseCode = action.forwardedHouseCode);
            }
            $scope.guessedHouseCode || $scope.data.supportCase.lastVisitedLot && ($scope.guessedHouseCode = $scope.data.supportCase.lastVisitedLot.house.code), 
            $scope.data.action.forwardedHouseCode = $scope.guessedHouseCode;
        }
        function setActionsHistory() {
            if ($scope.historyToShow = [], $scope.data.supportCase.originalAction) {
                $scope.historyToShow.push($scope.data.sourceAction || $scope.data.supportCase.originalAction);
                var actions = $scope.data.supportCase.actions;
                $scope.actionsHistory = [];
                for (var i = actions.length - 1; i >= 0; i--) {
                    var action = actions[i];
                    action.isDraft || $scope.actionsHistory.push(action);
                }
            }
        }
        function setTextKeys() {
            switch ($scope.saveLabel = "save", $scope.descriptionLabel = "description", $scope.data.action.actionType) {
              case "CLOSE":
              case "ASSIGN":
                $scope.descriptionLabel = "support_case_note";
                break;

              case "FORWARD_TO_AUCTION_HOUSE":
              case "SEND_EMAIL":
                $scope.saveLabel = "send", $scope.descriptionLabel = "contact_message_body";
            }
        }
        function addSignatureToDescription() {
            var signature = I18nService.getLangField($rootScope.currentUser.signature, {
                lang: $scope.data.supportCase.lang
            });
            signature && ($scope.data.action.description += "<br><br>" + signature.replace(/\n/g, "<br>"));
        }
        function autoSaveDraft() {
            "OPEN" != $scope.data.action.actionType && savedDescription != $scope.data.action.description && !$scope.savingDraft && $scope.data.action.isDraft && ($scope.savingDraft = !0, 
            SupportService.saveSupportAction($scope.data.action).then(function(action) {
                $scope.data.action.id || $scope.data.supportCase.actions.unshift($scope.data.action), 
                angular.extend($scope.data.action, action), $scope.savingDraft = !1, savedDescription = $scope.data.action.description;
            }));
        }
        $scope.CASE_TYPES = [ "CONTACT_REQUEST", "ITEM_FOR_SALE", "NEW_AUCTION_HOUSE", "ADMIN_PROBLEM", "UI_PROBLEM", "FEATURE_REQUEST", "FINANCE" ];
        var savedDescription = null, saveDraftInterval = null;
        $scope.showAllHistory = function() {
            $scope.historyToShow = $scope.actionsHistory;
        }, $scope.handleForwardMessage = function() {
            var sourceAction = $scope.data.sourceAction || $scope.data.supportCase.originalAction;
            if ($scope.data.action.forwardAsUserEmail || $scope.data.action.sendLotInquiry) {
                var description = "";
                $scope.data.supportCase.openerName && (description += I18nService.getText("name") + ":&nbsp;" + $scope.data.supportCase.openerName + "<br><br>"), 
                description += sourceAction.description, $scope.descriptionHidden = !0, $scope.attachmentsHidden = !0, 
                $scope.data.supportCase.openerPhone && (description += "<br><br>" + I18nService.getText("phone") + ":&nbsp;" + $scope.data.supportCase.openerPhone), 
                $scope.data.action.description = description;
            } else {
                $scope.descriptionHidden = !1, $scope.attachmentsHidden = !1;
                {
                    var description = "", prefixText = "ITEM_FOR_SALE" == $scope.data.supportCase.caseType ? "support_forward_item_for_sale" : "support_forward_contact_request";
                    ({
                        userName: $scope.data.supportCase.openerName,
                        userEmail: $scope.data.supportCase.openerEmail
                    });
                }
                description += I18nService.getText(prefixText, {
                    userName: $scope.data.supportCase.openerName,
                    userEmail: $scope.data.supportCase.openerEmail
                }), sourceAction.description && (description += "<br><br>" + StringsService.stripTags(sourceAction.description)), 
                $scope.data.includeUserContactInfo && (description += "<br><br>" + I18nService.getText("support_forward_user_email", {
                    userName: $scope.data.supportCase.openerName,
                    userEmail: $scope.data.supportCase.openerEmail
                }), $scope.data.supportCase.openerPhone && (description += "<br>" + I18nService.getText("phone") + ":&nbsp;" + $scope.data.supportCase.openerPhone)), 
                $scope.data.action.description = description, $scope.uploadedAttachments = [];
                for (var j = 0; j < $scope.data.supportCase.actions.length; j++) {
                    var action = $scope.data.supportCase.actions[j];
                    if (action.attachments) for (var i = 0; i < action.attachments.length; i++) {
                        var url = action.attachments[i];
                        ArraysService.getByKey($scope.uploadedAttachments, "url", url) || $scope.uploadedAttachments.push({
                            url: url
                        });
                    }
                }
                addSignatureToDescription();
            }
        }, $scope.addAction = function(action) {
            $scope.$close();
            var data = {
                action: {
                    caseId: $scope.data.supportCase.id,
                    actionType: action
                },
                supportCase: $scope.data.supportCase,
                sourceAction: $scope.data.action,
                saveFunction: $scope.data.saveFunction
            };
            SupportService.showActionForm(data);
        }, $scope.onHouseSelected = function(house) {
            $scope.data.action.forwardedHouseCode = house;
        }, $scope.isImage = function(url) {
            return StringsService.isImage(url);
        }, $scope.addAttachmentFromResponse = function(response) {
            for (var uploadedAttachments = response.data, i = 0; i < uploadedAttachments.length; i++) {
                var fileUrl = uploadedAttachments[i], pendingAttachment = ArraysService.getByKey($scope.uploadedAttachments, "pending", !0);
                $scope.isImage(fileUrl) ? !function(image, imageSrc) {
                    image.pending = !1, DomUtilsService.loadImage(imageSrc, 1e3, 100).then(function() {
                        image.url = imageSrc;
                    });
                }(pendingAttachment, fileUrl) : (pendingAttachment.pending = !1, pendingAttachment.url = fileUrl);
            }
        }, $scope.handleError = function(error) {
            console.error(error);
        }, $scope.getAttachmentImageUrl = function(attachment) {
            return attachment.pending ? "url(" + PathsService.commonImagePath("system/pagePreLoader.gif") + ")" : $scope.isImage(attachment.url) ? "url(" + attachment.url + ")" : "none";
        }, $scope.removeAttachment = function(attachment) {
            ArraysService.remove($scope.uploadedAttachments, attachment);
        }, $scope.allowMultiple = !0, $scope.addPendingAttachment = function(info) {
            for (var i = 0; i < info.length; i++) $scope.uploadedAttachments.push({
                pending: !0
            });
        }, $scope.removeAction = function() {
            var actionId = $scope.data.action.id;
            DialogsService.showConfirm({
                message: "support_case_confirm_remove_action"
            }).then(function(confirmed) {
                confirmed && SupportService.removeSupportCaseAction(actionId).then(function() {
                    $scope.actionRemoved = !0, ArraysService.removeById($scope.data.supportCase.actions, actionId), 
                    $scope.$close();
                });
            });
        }, $scope.showAdminRecipientss = function() {
            $scope.adminRecipients = $scope.assignees.slice();
        }, $scope.addAdminRecipients = function() {
            var newRecipient = $scope.data.newAdminRecipient, action = $scope.data.action;
            newRecipient && -1 == action.recipients.indexOf(newRecipient) && (action.recipients += ", " + newRecipient), 
            $scope.data.newAdminRecipient = "", $scope.adminRecipients = null;
        }, $scope.handleSendEmailChanged = function() {
            if ($scope.data.sendEmail) {
                for (var otherAssignees = [], actions = $scope.data.supportCase.actions, i = 0; i < actions.length; i++) {
                    var action = actions[i];
                    action.assigneeEmail && ArraysService.addOrReplace(otherAssignees, action.assigneeEmail), 
                    ArraysService.getByKey($scope.assignees, "email", action.userEmail) && ArraysService.addOrReplace(otherAssignees, action.userEmail);
                }
                ArraysService.remove(otherAssignees, $rootScope.currentUser.email), $scope.data.action.recipients = otherAssignees + "";
            } else $scope.data.action.recipients = "";
        }, $scope.save = function() {
            var action = $scope.data.action;
            if ("OPEN" == action.actionType && !action.newCaseType) return void DialogsService.showAlert(I18nService.getText("error_mandatory", {
                field: "support_case_type"
            }));
            if ("FORWARD_TO_AUCTION_HOUSE" == action.actionType && !action.forwardedHouseCode) return void DialogsService.showAlert(I18nService.getText("support_error_select_house"));
            action.newCaseType == $scope.data.supportCase.caseType ? action.newCaseType = null : action.previousCaseType = $scope.data.supportCase.caseType, 
            action.sendLotInquiry && (action.description = $scope.data.supportCase.originalAction.description);
            for (var i = 0; i < $scope.uploadedAttachments.length; i++) {
                var attachment = $scope.uploadedAttachments[i];
                attachment.pending || $scope.data.action.attachments.push(attachment.url);
            }
            return $scope.data.supportCase.currentAssigneeEmail || $scope.data.action.assigneeEmail || "OPEN" == $scope.data.action.actionType || ($scope.data.action.assigneeEmail = $rootScope.currentUser.email), 
            $scope.data.action.isDraft = !1, $scope.data.saveFunction($scope.data.action).then(function() {
                $scope.$close();
            });
        }, $scope.$on("$destroy", function() {
            $scope.actionRemoved || autoSaveDraft(), $interval.cancel(saveDraftInterval);
        }), init();
    } ]);
}), define("portal/js/modules/support/index", [ "./supportModule", "./supportController", "./supportService", "./supportCaseController", "./supportCaseActionController" ], function() {}), 
define("portal/js/modules/components/componentsModule", [ "angular" ], function(ng) {
    return ng.module("app.components", []);
}), define("portal/js/modules/components/houseCarouselDirective", [ "./componentsModule" ], function(module) {
    module.directive("bsHousesCarousel", function($window, $timeout, $interval, $rootScope, PathsService, PortalInfoService, ArraysService, CloudinaryService, OsInfoService, ViewPortService) {
        return {
            restrict: "E",
            replace: !0,
            scope: {},
            link: function(scope, element) {
                function getHouseImageUrl(house) {
                    if (OsInfoService.isMobile()) return null;
                    if ($rootScope.judaicaOnly) return PathsService.getStaticFilesBase() + "/images/judaica/home-banner.jpg";
                    if ("CARS" == $rootScope.contentType) return PathsService.getStaticFilesBase() + "/images/cars/home-banner.jpg";
                    if ("REAL_ESTATE" == $rootScope.contentType) return PathsService.getStaticFilesBase() + "/images/houses/home-banner.jpg";
                    var picResource = house.resources ? house.resources.hallPicture : "";
                    return CloudinaryService.getUrl(picResource, {
                        quality: 10,
                        size: ViewPortService.clientWidth() + "x600",
                        mode: "fill",
                        exactSize: !0
                    });
                }
                function shouldAddHouseToCarousel(house) {
                    return getHouseImageUrl(house) ? $rootScope.judaicaOnly && !house.judaicaOnly ? !1 : !0 : !1;
                }
                function initBgPics() {
                    scope.bgPics.length = 0, $interval.cancel(mTimer), scope.houses = [];
                    for (var houses = PortalInfoService.getAllHouses(), i = 0; i < houses.length; i++) {
                        var house = houses[i];
                        shouldAddHouseToCarousel(house) && scope.houses.push(house);
                    }
                    ArraysService.shuffle(scope.houses), angular.forEach(scope.houses, function(house) {
                        scope.bgPics.push(getHouseImageUrl(house));
                    }), scope.elementHeight = element[0].offsetHeight, mTimer = $interval(changePic, PIC_SWITCH_INTERVAL);
                }
                function changePic() {
                    scope.elementHeight = element[0].offsetHeight, 0 != scope.bgPics.length && scope.animationOn && (scope.currentPicInd = (scope.currentPicInd + 1) % scope.bgPics.length);
                }
                var mTimer = null, mAnimationDisabled = !1;
                if (PIC_SWITCH_INTERVAL = 15e3, scope.bgPics = [], scope.currentPicInd = 0, scope.elementHeight = element[0].offsetHeight, 
                scope.isMobile = OsInfoService.isMobile(), (OsInfoService.isMobile() || $rootScope.judaicaOnly || "ART" != $rootScope.contentType) && (mAnimationDisabled = !0), 
                scope.animationOn = !mAnimationDisabled, $timeout(function() {
                    $interval.cancel(mTimer);
                }, 3e5), element.on("$destroy", function() {
                    $interval.cancel(mTimer);
                }), !mAnimationDisabled) {
                    {
                        angular.element($window);
                    }
                    scope.$on("viewPort.orientationChange", initBgPics);
                }
                scope.$on("auth.upperNavPopupDisplay", function(event, isOn) {
                    isOn && (scope.animationOn = !1);
                }), initBgPics();
            },
            templateUrl: PathsService.appTemplatePath("components/carousel/housesCarousel")
        };
    });
}), define("portal/js/modules/components/contentLoaderDirective", [ "./componentsModule" ], function(module) {
    module.directive("bsContentLoader", function(PathsService) {
        return {
            restrict: "E",
            scope: {
                loaded: "="
            },
            link: function(scope, element) {
                scope.$watch("loaded", function(loaded) {
                    loaded && element.attr("done", !0);
                });
            },
            templateUrl: PathsService.appTemplatePath("components/contentLoader")
        };
    });
}), define("portal/js/modules/components/pageFooterDirective", [ "./componentsModule" ], function(module) {
    module.directive("bsPageFooter", function($rootScope, $state, $uibModal, $timeout, $transitions, I18nService, ArraysService, PopupsService, PathsService, OsInfoService, ViewPortService, PortalInfoService, PortalNavigationService) {
        return {
            restrict: "E",
            link: function(scope, element) {
                function setWidth() {
                    element.css({
                        width: ViewPortService.getMaxWidth() + "px"
                    });
                }
                function setRegionTexts() {
                    switch ($rootScope.currentRegion) {
                      case "IL":
                        scope.fbPage = "CARS" == scope.contentType ? "/BidspiritCars/" : "pages/Bidspirit-Israel/280735812128712", 
                        scope.twitterPage = "BidspiritIsrael";
                        break;

                      case "RU":
                        scope.fbPage = "bidspirit.russia", scope.twitterPage = "BidspiritRussia";
                        break;

                      default:
                        scope.fbPage = "bidspirit", scope.twitterPage = "bidspirit";
                    }
                    switch ($rootScope.contentType) {
                      case "CARS":
                        scope.sellText = "home_footer_sell_car";
                        break;

                      case "REAL_ESTATE":
                        scope.sellText = "home_footer_sell_real_estate";
                        break;

                      default:
                        scope.sellText = "home_footer_sell";
                    }
                }
                function handleContactUsDisplay() {
                    switch ($state.current.name) {
                      case "app.contact":
                      case "app.about":
                      case "app.prdouct":
                      case "app.popupScene":
                        scope.shouldHideContactUs = !0;
                        break;

                      default:
                        scope.shouldHideContactUs = !1;
                    }
                }
                function initDisplay() {
                    scope.visible = !PortalNavigationService.shouldHideMenus(), handleContactUsDisplay(), 
                    setRegionTexts();
                }
                function refresh() {
                    scope.visible = !1, $timeout(initDisplay, 100);
                }
                scope.qaEnv = $rootScope.qaEnv, scope.contentType = $rootScope.contentType, GlobalConfig.isMobileApp && OsInfoService.isAndroid() && setWidth(), 
                scope.showInfoPopup = function(code) {
                    PopupsService.showLegalDocPopup(code);
                }, scope.gotoContactForSale = function() {
                    $state.go("app.contactForSale"), window.scroll(0, 0);
                }, scope.linkTarget = PortalNavigationService.getNewWindowTarget(), scope.$on("i18n.languageChanged", refresh), 
                $transitions.onSuccess({}, refresh), initDisplay();
            },
            templateUrl: PathsService.appTemplatePath("components/pageFooter")
        };
    });
}), define("portal/js/modules/components/popupsService", [ "./componentsModule" ], function(module) {
    var mPopupSceneOptions = {}, mOpenedModals = {};
    module.factory("PopupsService", function($rootScope, $state, $stateParams, $uibModal, $uibModalStack, $timeout, $compile, PathsService, I18nService, DialogsService, OsInfoService, AnalyticsService, PortalInfoService, PortalTextsService) {
        function showLegalDocPopup(code) {
            PortalInfoService.getLegalDoc(code).success(function(docContent) {
                showInfoPopup({
                    contentHtml: docContent.val,
                    code: code
                });
            });
        }
        function showPopupAsModal(options) {
            options.isModal = !0, options.singleModal && mOpenedModals[options.code] || (mOpenedModals[options.code] = (mOpenedModals[options.code] || 0) + 1, 
            $uibModal.open({
                templateUrl: PathsService.appTemplatePath("components/popups/popupModal"),
                size: options.size,
                backdrop: options.unclosable ? "static" : !0,
                controller: function($scope) {
                    $scope.options = options, $scope.closePopup = function() {
                        $scope.$close();
                    };
                }
            }).closed.then(function() {
                mOpenedModals[options.code]--;
            }));
        }
        function showInfoPopup(options) {
            options.buttons = [ {
                text: "ok",
                isCloseButton: !0
            } ], showPopup(options);
        }
        function showPopup(options) {
            $rootScope.viewPort.mobileMedia ? (showPopupAsScene(options), window.scroll(0, 0)) : showPopupAsModal(options);
        }
        function showPopupAsScene(options) {
            mPopupSceneOptions[options.code] = options, options.isModal = !1, options.originalState = {
                name: $state.$current.name,
                args: angular.copy($stateParams)
            }, options.contentUrl ? $http.get(options.contentUrl).then(function(response) {
                var content = response.content;
                options.contentUrl = "", options.contentHtml = content, $state.go("app.popupScene", {
                    code: options.code
                });
            }) : $state.go("app.popupScene", {
                code: options.code
            });
        }
        function showErrorPopup(message, title) {
            showInfoPopup({
                contentHtml: message,
                title: title || I18nService.getText("notice"),
                code: "error",
                size: "sm"
            });
        }
        function showHouseTerms(house) {
            PortalInfoService.getHouseTermsUrl(house.id, I18nService.getCurrentLang()).success(function(url) {
                showInfoPopup({
                    contentUrl: url.val,
                    backText: "back",
                    code: "houseTerms"
                });
            });
        }
        function showHelpPopup(screenCode) {
            PortalInfoService.getHelpScreensInfo("popup_" + screenCode).success(function(helpScreensInfo) {
                var screen = helpScreensInfo.screens[0];
                showInfoPopup({
                    title: I18nService.getLangField(screen.title),
                    contentHtml: I18nService.getLangField(screen.info),
                    backText: "back",
                    code: "help_popup " + screenCode
                });
            });
        }
        function showHouseContantInfo(house) {
            var scope = $rootScope.$new(!0);
            scope.house = house;
            var element = $compile('<div><bs-house-contact-info  house = "house" > </bs-house-contact-info></div>')(scope);
            $timeout(function() {
                showInfoPopup({
                    title: I18nService.getText("shop_info_title", {
                        houseName: I18nService.getLangField(house.details.name)
                    }),
                    contentHtml: element.html(),
                    backText: "back",
                    code: "houseContactInfo"
                }), scope.$destroy();
            }, 100);
        }
        function showHouseConnectivityErrorPopup(house) {
            DialogsService.showAlert({
                title: "notice",
                message: "my_account_unknown_error",
                params: PortalTextsService.getHouseConnectivityErrorParams(house)
            });
        }
        function showFutureAuctionsPopup() {
            showPopup({
                contentInclude: "info/allFutureAuctions",
                code: "allFutureAuctions",
                title: I18nService.getText("all_future_auctions"),
                data: {
                    auctions: PortalInfoService.getAllFutureAuctions(),
                    hideTopBackButton: !0,
                    onAuctionClick: function(auction) {
                        "PENDING" == auction.state ? $state.go("app.house", {
                            houseCode: auction.house.code
                        }) : $state.go("app.auctionCatalog", {
                            catalogKey: auction.intKey,
                            page: 1
                        }), $uibModalStack.dismissAll();
                    }
                }
            });
        }
        function showCommissionText(lot) {
            DialogsService.showAlert({
                title: "auction_house_commission",
                message: I18nService.getLangField(lot.auction.commissionText)
            });
        }
        function showInstallAppPopup(titleKey, messageKey) {
            var eventData = "platform_";
            OsInfoService.isIos() ? (platforms = [ "ios" ], eventData += "ios") : OsInfoService.isAndroid() ? (platforms = [ "android" ], 
            eventData += "andorid") : (eventData += OsInfoService.isMobile() ? "other_mobile" : "pc", 
            platforms = [ "ios", "android" ]), AnalyticsService.trackDailyUniqueEvent("appAction", "showInstallApp", eventData), 
            showPopup({
                contentInclude: "alerts/popups/installAppPopup",
                platforms: platforms,
                messageTitle: titleKey || "app_install_default_title",
                message: messageKey || "app_install_default_message",
                code: "appInstallAlerts",
                mobileDevice: OsInfoService.isMobile(),
                logAppPageLink: function(platform) {
                    AnalyticsService.trackDailyUniqueEvent("appAction", "clickAppPageLink", eventData + "_click_link_" + platform);
                },
                buttons: [ {
                    text: "close",
                    type: "warning",
                    isCloseButton: !0
                } ]
            });
        }
        return {
            showPopup: showPopup,
            showInfoPopup: showInfoPopup,
            showLegalDocPopup: showLegalDocPopup,
            showErrorPopup: showErrorPopup,
            showHouseTerms: showHouseTerms,
            showHouseContantInfo: showHouseContantInfo,
            showHouseConnectivityErrorPopup: showHouseConnectivityErrorPopup,
            showInstallAppPopup: showInstallAppPopup,
            showFutureAuctionsPopup: showFutureAuctionsPopup,
            showCommissionText: showCommissionText,
            showHelpPopup: showHelpPopup
        };
    }), module.controller("PopupAsSceneController", [ "$scope", "$state", "$stateParams", function($scope, $state, $stateParams) {
        mPopupSceneOptions && mPopupSceneOptions[$stateParams.code] ? ($scope.options = mPopupSceneOptions[$stateParams.code], 
        $scope.closePopup = function() {
            var originalState = $scope.options.originalState;
            $state.go(originalState.name, originalState.args);
        }) : $state.go("app.home");
    } ]);
}), define("portal/js/modules/components/structuredDataService", [ "./componentsModule" ], function(module) {
    var mDefaultData;
    module.factory("StructuredDataService", function($rootScope, SettingsService, StringsService, I18nService, PathsService, DomUtilsService, CloudinaryService, CatalogUtilsService) {
        function getAuctionName(auction) {
            var auctionName = "";
            return auction.number && (auctionName = I18nService.getText("auction_label_number_public", {
                number: auction.number
            }), auction.part && (auctionName += " " + I18nService.getText("auction_part_" + auction.part)), 
            auctionName += " - "), auctionName += I18nService.getLangField(auction.name);
        }
        function getAuctionIsoTime(auction) {
            if (!auction.time) return "";
            var time = (1 * auction.time.split(":")[0], auction.date + "T" + auction.time), tz = 1 * SettingsService.get("regionTimezoneDiff");
            return time += tz >= 0 ? "+" : "-", time += StringsService.pad(tz, 2, "0") + ":00";
        }
        function getAuctionStructuredData(auction) {
            var structuredData = {};
            return structuredData = {
                "@context": "http://schema.org",
                "@type": "SaleEvent",
                name: getAuctionName(auction),
                url: PathsService.getAuctionHref(auction),
                location: {
                    "@type": "Place",
                    name: auction.house ? I18nService.getLangField(auction.house.details.name) : "",
                    address: I18nService.getLangField(auction.address)
                }
            }, structuredData.image = auction.resources && auction.resources.openGraphImage ? CloudinaryService.getUrl(auction.resources.openGraphImage) : CatalogUtilsService.getCatalogOwnerTopImage(auction), 
            !auction.time || auction.hideTime || auction.unknownExactDate || (structuredData.startDate = getAuctionIsoTime(auction)), 
            structuredData;
        }
        function setDescriptionMetaTags(description) {
            DomUtilsService.setMetaTag("name", "description", description), DomUtilsService.setMetaTag("property", "og:description", description), 
            DomUtilsService.setMetaTag("name", "twitter:description", description);
        }
        function setImageMetaTags(image, width, height) {
            image.match(/\.[a-z]{1,4}$/) || (image += ".jpg"), DomUtilsService.setMetaTag("property", "og:image", image), 
            DomUtilsService.setTagProp("meta", "property", "og:image", "itemprop", "image"), 
            DomUtilsService.setMetaTag("name", "twitter:image", image), DomUtilsService.setMetaTag("property", "og:image:width", width), 
            DomUtilsService.setMetaTag("property", "og:image:height", height);
        }
        function setTwitterData(index, data, label) {
            DomUtilsService.setMetaTag("name", "twitter:data" + index, data), DomUtilsService.setMetaTag("name", "twitter:label" + index, label);
        }
        function setPriceStructuredDataMetaTags(lot, currency) {
            var price = lot.startPrice;
            price ? setTwitterData(1, I18nService.getText("start_price"), I18nService.sumInCurrency(price, currency)) : lot.estimatedPrice && (price = lot.estimatedPrice.split(/\s|\-/)[0].replace(/[^\d]/g, ""), 
            setTwitterData(1, I18nService.getText("estimated_price"), lot.estimatedPrice)), 
            price && (DomUtilsService.setMetaTag("property", "og:price:amount", price + ".00"), 
            DomUtilsService.setMetaTag("property", "og:price:currency", I18nService.isoCurrency(currency)));
        }
        function resetStructuredDataMetaTags() {
            if (setImageMetaTags(PathsService.bidspiritLogo), DomUtilsService.removeMetaTag("property", "og:price:amount"), 
            DomUtilsService.removeMetaTag("property", "og:price:currency"), DomUtilsService.removeMetaTag("name", "twitter:data1"), 
            DomUtilsService.removeMetaTag("name", "twitter:label1"), DomUtilsService.removeMetaTag("name", "twitter:data2"), 
            DomUtilsService.removeMetaTag("name", "twitter:label2"), !mDefaultData) try {
                mDefaultData = {
                    title: document.head.querySelector("[name=default-title]").content,
                    description: document.head.querySelector("[name=default-description]").content
                };
            } catch (e) {
                mDefaultData = {
                    title: "Bidspirit auctions",
                    description: "The best auctions platform"
                };
            }
            document.title = mDefaultData.title, setDescriptionMetaTags(mDefaultData.description), 
            DomUtilsService.setMetaTag("property", "og:type", "article"), DomUtilsService.setMetaTag("name", "twitter:card", "summary"), 
            setTimeout(function() {
                var canonicalUrl = (window.location + "").replace(/[\&\?]searchAgentRequest=true/, "").replace(/[\&\?]sessionId[^\&\#]+/, "").replace(/[\&\?]s=[^\&\#]+/, "").replace(/[\&\?]_escaped_fragment_=/, "ui").replace(/\%2F/gi, "/");
                DomUtilsService.setMetaTag("bidspirit-property", "originalUrl", window.location + ""), 
                DomUtilsService.setMetaTag("property", "og:url", canonicalUrl), DomUtilsService.setMetaTag("property", "og:title", document.title + ""), 
                DomUtilsService.setMetaTag("name", "twitter:title", document.title + ""), DomUtilsService.setTagProp("link", "rel", "canonical", "href", canonicalUrl);
            }, 20);
        }
        function getPriceStructuredDataTag(price, currency) {
            var suffix, tagHtml = price.replace(new RegExp(currency + " ", "ig"), currency), rangeSepInd = tagHtml.search(/\s|\-/);
            -1 == rangeSepInd ? suffix = "" : (tagHtml = price.substr(0, rangeSepInd + 1), suffix = price.substr(rangeSepInd + 1));
            var priceNumber, currencyInd = tagHtml.indexOf(currency);
            return priceNumber = -1 == currencyInd ? tagHtml : 0 == currencyInd ? tagHtml.substr(currencyInd + currency.length) : price.substr(0, currencyInd), 
            tagHtml = tagHtml.replace(currency, '<meta itemprop="priceCurrency" content="' + I18nService.isoCurrency(currency) + '" />' + currency), 
            tagHtml = tagHtml.replace(priceNumber, '<meta  itemprop="price" content="' + priceNumber.replace(/[^\d]/g, "") + '" />' + priceNumber), 
            tagHtml + suffix;
        }
        return {
            getAuctionStructuredData: getAuctionStructuredData,
            getPriceStructuredDataTag: getPriceStructuredDataTag,
            setPriceStructuredDataMetaTags: setPriceStructuredDataMetaTags,
            setDescriptionMetaTags: setDescriptionMetaTags,
            setImageMetaTags: setImageMetaTags,
            setTwitterData: setTwitterData,
            resetStructuredDataMetaTags: resetStructuredDataMetaTags
        };
    });
}), define("portal/js/modules/components/upperPartDirective", [ "./componentsModule" ], function(module) {
    module.directive("upperPart", function($rootScope, ViewPortService, OsInfoService) {
        return {
            restrict: "C",
            link: function(scope, element) {
                function setWidth() {
                    element.css({
                        width: ViewPortService.getMaxWidth() + "px"
                    });
                }
                GlobalConfig.isMobileApp && OsInfoService.isAndroid() && setWidth();
            }
        };
    });
}), define("portal/js/modules/components/housesDropdownDirective", [ "./componentsModule" ], function(module) {
    module.directive("housesDropdown", function($rootScope, PathsService, PortalInfoService, ArraysService) {
        return {
            restrict: "E",
            scope: {
                onHouseSelected: "=",
                initialHouseCode: "@",
                disableAllHouses: "=",
                maxLength: "@",
                houses: "=?"
            },
            link: function(scope) {
                function shouldShowHouse(house) {
                    return $rootScope.devMode ? !0 : house.hidden ? !1 : !0;
                }
                function setHouses() {
                    scope.houses || (scope.houses = PortalInfoService.getAllHouses().slice()), scope.houses = ArraysService.filterWithFunction(scope.houses, shouldShowHouse);
                }
                function init() {
                    setHouses(), scope.initialHouseCode && scope.setSelectedHouse(scope.initialHouseCode, !0), 
                    scope.allHousesLabel = "ART" == $rootScope.contentType ? "auctions_results_all_houses" : "all_sellers";
                }
                scope.viewPort = $rootScope.viewPort, scope.maxLength = 1 * scope.maxLength || 30, 
                scope.data = {
                    selectedHouseCode: "all"
                }, scope.setSelectedHouse = function(houseCode, callbackDisabled) {
                    scope.selectedHouse = PortalInfoService.getHouseByCode(houseCode), scope.data.selectedHouseCode = houseCode, 
                    scope.onHouseSelected && !callbackDisabled && scope.onHouseSelected(houseCode);
                }, scope.onDropDownChange = function() {
                    scope.setSelectedHouse(scope.data.selectedHouseCode);
                }, init();
            },
            templateUrl: PathsService.appTemplatePath("components/housesDropdown")
        };
    });
}), define("portal/js/modules/components/upperSpaceHoldersDirective", [ "./componentsModule" ], function(module) {
    module.directive("bsUpperSpaceHolders", function($window, $timeout, $interval, $rootScope, PathsService) {
        return {
            restrict: "E",
            replace: !0,
            scope: {},
            link: function() {},
            templateUrl: PathsService.appTemplatePath("components/upperSpaceHolders")
        };
    });
}), function(root, factory) {
    "object" == typeof exports && "object" == typeof module ? module.exports = factory() : "function" == typeof define && define.amd ? define("pusher", [], factory) : "object" == typeof exports ? exports.Pusher = factory() : root.Pusher = factory();
}(this, function() {
    return function(modules) {
        function __webpack_require__(moduleId) {
            if (installedModules[moduleId]) return installedModules[moduleId].exports;
            var module = installedModules[moduleId] = {
                exports: {},
                id: moduleId,
                loaded: !1
            };
            return modules[moduleId].call(module.exports, module, module.exports, __webpack_require__), 
            module.loaded = !0, module.exports;
        }
        var installedModules = {};
        return __webpack_require__.m = modules, __webpack_require__.c = installedModules, 
        __webpack_require__.p = "", __webpack_require__(0);
    }([ function(module, exports, __webpack_require__) {
        var pusher_1 = __webpack_require__(1);
        module.exports = pusher_1["default"];
    }, function(module, exports, __webpack_require__) {
        function checkAppKey(key) {
            if (null === key || void 0 === key) throw "You must pass your app key when you instantiate Pusher.";
        }
        var runtime_1 = __webpack_require__(2), Collections = __webpack_require__(9), dispatcher_1 = __webpack_require__(23), timeline_1 = __webpack_require__(38), level_1 = __webpack_require__(39), StrategyBuilder = __webpack_require__(40), timers_1 = __webpack_require__(12), defaults_1 = __webpack_require__(5), DefaultConfig = __webpack_require__(62), logger_1 = __webpack_require__(8), factory_1 = __webpack_require__(42), Pusher = function() {
            function Pusher(app_key, options) {
                var _this = this;
                checkAppKey(app_key), options = options || {}, this.key = app_key, this.config = Collections.extend(DefaultConfig.getGlobalConfig(), options.cluster ? DefaultConfig.getClusterConfig(options.cluster) : {}, options), 
                this.channels = factory_1["default"].createChannels(), this.global_emitter = new dispatcher_1["default"](), 
                this.sessionID = Math.floor(1e9 * Math.random()), this.timeline = new timeline_1["default"](this.key, this.sessionID, {
                    cluster: this.config.cluster,
                    features: Pusher.getClientFeatures(),
                    params: this.config.timelineParams || {},
                    limit: 50,
                    level: level_1["default"].INFO,
                    version: defaults_1["default"].VERSION
                }), this.config.disableStats || (this.timelineSender = factory_1["default"].createTimelineSender(this.timeline, {
                    host: this.config.statsHost,
                    path: "/timeline/v2/" + runtime_1["default"].TimelineTransport.name
                }));
                var getStrategy = function(options) {
                    var config = Collections.extend({}, _this.config, options);
                    return StrategyBuilder.build(runtime_1["default"].getDefaultStrategy(config), config);
                };
                this.connection = factory_1["default"].createConnectionManager(this.key, Collections.extend({
                    getStrategy: getStrategy,
                    timeline: this.timeline,
                    activityTimeout: this.config.activity_timeout,
                    pongTimeout: this.config.pong_timeout,
                    unavailableTimeout: this.config.unavailable_timeout
                }, this.config, {
                    encrypted: this.isEncrypted()
                })), this.connection.bind("connected", function() {
                    _this.subscribeAll(), _this.timelineSender && _this.timelineSender.send(_this.connection.isEncrypted());
                }), this.connection.bind("message", function(params) {
                    var internal = 0 === params.event.indexOf("pusher_internal:");
                    if (params.channel) {
                        var channel = _this.channel(params.channel);
                        channel && channel.handleEvent(params.event, params.data);
                    }
                    internal || _this.global_emitter.emit(params.event, params.data);
                }), this.connection.bind("disconnected", function() {
                    _this.channels.disconnect();
                }), this.connection.bind("error", function(err) {
                    logger_1["default"].warn("Error", err);
                }), Pusher.instances.push(this), this.timeline.info({
                    instances: Pusher.instances.length
                }), Pusher.isReady && this.connect();
            }
            return Pusher.ready = function() {
                Pusher.isReady = !0;
                for (var i = 0, l = Pusher.instances.length; l > i; i++) Pusher.instances[i].connect();
            }, Pusher.log = function(message) {
                Pusher.logToConsole && window.console && window.console.log && window.console.log(message);
            }, Pusher.getClientFeatures = function() {
                return Collections.keys(Collections.filterObject({
                    ws: runtime_1["default"].Transports.ws
                }, function(t) {
                    return t.isSupported({});
                }));
            }, Pusher.prototype.channel = function(name) {
                return this.channels.find(name);
            }, Pusher.prototype.allChannels = function() {
                return this.channels.all();
            }, Pusher.prototype.connect = function() {
                if (this.connection.connect(), this.timelineSender && !this.timelineSenderTimer) {
                    var encrypted = this.connection.isEncrypted(), timelineSender = this.timelineSender;
                    this.timelineSenderTimer = new timers_1.PeriodicTimer(6e4, function() {
                        timelineSender.send(encrypted);
                    });
                }
            }, Pusher.prototype.disconnect = function() {
                this.connection.disconnect(), this.timelineSenderTimer && (this.timelineSenderTimer.ensureAborted(), 
                this.timelineSenderTimer = null);
            }, Pusher.prototype.bind = function(event_name, callback) {
                return this.global_emitter.bind(event_name, callback), this;
            }, Pusher.prototype.unbind = function(event_name, callback) {
                return this.global_emitter.unbind(event_name, callback), this;
            }, Pusher.prototype.bind_all = function(callback) {
                return this.global_emitter.bind_all(callback), this;
            }, Pusher.prototype.subscribeAll = function() {
                var channelName;
                for (channelName in this.channels.channels) this.channels.channels.hasOwnProperty(channelName) && this.subscribe(channelName);
            }, Pusher.prototype.subscribe = function(channel_name) {
                var channel = this.channels.add(channel_name, this);
                return "connected" === this.connection.state && channel.subscribe(), channel;
            }, Pusher.prototype.unsubscribe = function(channel_name) {
                var channel = this.channels.remove(channel_name);
                channel && "connected" === this.connection.state && channel.unsubscribe();
            }, Pusher.prototype.send_event = function(event_name, data, channel) {
                return this.connection.send_event(event_name, data, channel);
            }, Pusher.prototype.isEncrypted = function() {
                return "https:" === runtime_1["default"].getProtocol() ? !0 : Boolean(this.config.encrypted);
            }, Pusher.instances = [], Pusher.isReady = !1, Pusher.logToConsole = !1, Pusher.Runtime = runtime_1["default"], 
            Pusher.ScriptReceivers = runtime_1["default"].ScriptReceivers, Pusher.DependenciesReceivers = runtime_1["default"].DependenciesReceivers, 
            Pusher.auth_callbacks = runtime_1["default"].auth_callbacks, Pusher;
        }();
        exports.__esModule = !0, exports["default"] = Pusher, runtime_1["default"].setup(Pusher);
    }, function(module, exports, __webpack_require__) {
        var dependencies_1 = __webpack_require__(3), xhr_auth_1 = __webpack_require__(7), jsonp_auth_1 = __webpack_require__(14), script_request_1 = __webpack_require__(15), jsonp_request_1 = __webpack_require__(16), script_receiver_factory_1 = __webpack_require__(4), jsonp_timeline_1 = __webpack_require__(17), transports_1 = __webpack_require__(18), net_info_1 = __webpack_require__(25), default_strategy_1 = __webpack_require__(26), transport_connection_initializer_1 = __webpack_require__(27), http_1 = __webpack_require__(28), Runtime = {
            nextAuthCallbackID: 1,
            auth_callbacks: {},
            ScriptReceivers: script_receiver_factory_1.ScriptReceivers,
            DependenciesReceivers: dependencies_1.DependenciesReceivers,
            getDefaultStrategy: default_strategy_1["default"],
            Transports: transports_1["default"],
            transportConnectionInitializer: transport_connection_initializer_1["default"],
            HTTPFactory: http_1["default"],
            TimelineTransport: jsonp_timeline_1["default"],
            getXHRAPI: function() {
                return window.XMLHttpRequest;
            },
            getWebSocketAPI: function() {
                return window.WebSocket || window.MozWebSocket;
            },
            setup: function(PusherClass) {
                var _this = this;
                window.Pusher = PusherClass;
                var initializeOnDocumentBody = function() {
                    _this.onDocumentBody(PusherClass.ready);
                };
                window.JSON ? initializeOnDocumentBody() : dependencies_1.Dependencies.load("json2", {}, initializeOnDocumentBody);
            },
            getDocument: function() {
                return document;
            },
            getProtocol: function() {
                return this.getDocument().location.protocol;
            },
            getAuthorizers: function() {
                return {
                    ajax: xhr_auth_1["default"],
                    jsonp: jsonp_auth_1["default"]
                };
            },
            onDocumentBody: function(callback) {
                var _this = this;
                document.body ? callback() : setTimeout(function() {
                    _this.onDocumentBody(callback);
                }, 0);
            },
            createJSONPRequest: function(url, data) {
                return new jsonp_request_1["default"](url, data);
            },
            createScriptRequest: function(src) {
                return new script_request_1["default"](src);
            },
            getLocalStorage: function() {
                try {
                    return window.localStorage;
                } catch (e) {
                    return void 0;
                }
            },
            createXHR: function() {
                return this.getXHRAPI() ? this.createXMLHttpRequest() : this.createMicrosoftXHR();
            },
            createXMLHttpRequest: function() {
                var Constructor = this.getXHRAPI();
                return new Constructor();
            },
            createMicrosoftXHR: function() {
                return new ActiveXObject("Microsoft.XMLHTTP");
            },
            getNetwork: function() {
                return net_info_1.Network;
            },
            createWebSocket: function(url) {
                var Constructor = this.getWebSocketAPI();
                return new Constructor(url);
            },
            createSocketRequest: function(method, url) {
                if (this.isXHRSupported()) return this.HTTPFactory.createXHR(method, url);
                if (this.isXDRSupported(0 === url.indexOf("https:"))) return this.HTTPFactory.createXDR(method, url);
                throw "Cross-origin HTTP requests are not supported";
            },
            isXHRSupported: function() {
                var Constructor = this.getXHRAPI();
                return Boolean(Constructor) && void 0 !== new Constructor().withCredentials;
            },
            isXDRSupported: function(encrypted) {
                var protocol = encrypted ? "https:" : "http:", documentProtocol = this.getProtocol();
                return Boolean(window.XDomainRequest) && documentProtocol === protocol;
            },
            addUnloadListener: function(listener) {
                void 0 !== window.addEventListener ? window.addEventListener("unload", listener, !1) : void 0 !== window.attachEvent && window.attachEvent("onunload", listener);
            },
            removeUnloadListener: function(listener) {
                void 0 !== window.addEventListener ? window.removeEventListener("unload", listener, !1) : void 0 !== window.detachEvent && window.detachEvent("onunload", listener);
            }
        };
        exports.__esModule = !0, exports["default"] = Runtime;
    }, function(module, exports, __webpack_require__) {
        var script_receiver_factory_1 = __webpack_require__(4), defaults_1 = __webpack_require__(5), dependency_loader_1 = __webpack_require__(6);
        exports.DependenciesReceivers = new script_receiver_factory_1.ScriptReceiverFactory("_pusher_dependencies", "Pusher.DependenciesReceivers"), 
        exports.Dependencies = new dependency_loader_1["default"]({
            cdn_http: defaults_1["default"].cdn_http,
            cdn_https: defaults_1["default"].cdn_https,
            version: defaults_1["default"].VERSION,
            suffix: defaults_1["default"].dependency_suffix,
            receivers: exports.DependenciesReceivers
        });
    }, function(module, exports) {
        var ScriptReceiverFactory = function() {
            function ScriptReceiverFactory(prefix, name) {
                this.lastId = 0, this.prefix = prefix, this.name = name;
            }
            return ScriptReceiverFactory.prototype.create = function(callback) {
                this.lastId++;
                var number = this.lastId, id = this.prefix + number, name = this.name + "[" + number + "]", called = !1, callbackWrapper = function() {
                    called || (callback.apply(null, arguments), called = !0);
                };
                return this[number] = callbackWrapper, {
                    number: number,
                    id: id,
                    name: name,
                    callback: callbackWrapper
                };
            }, ScriptReceiverFactory.prototype.remove = function(receiver) {
                delete this[receiver.number];
            }, ScriptReceiverFactory;
        }();
        exports.ScriptReceiverFactory = ScriptReceiverFactory, exports.ScriptReceivers = new ScriptReceiverFactory("_pusher_script_", "Pusher.ScriptReceivers");
    }, function(module, exports) {
        var Defaults = {
            VERSION: "3.2.1",
            PROTOCOL: 7,
            host: "ws.pusherapp.com",
            ws_port: 80,
            wss_port: 443,
            sockjs_host: "sockjs.pusher.com",
            sockjs_http_port: 80,
            sockjs_https_port: 443,
            sockjs_path: "/pusher",
            stats_host: "stats.pusher.com",
            channel_auth_endpoint: "/pusher/auth",
            channel_auth_transport: "ajax",
            activity_timeout: 12e4,
            pong_timeout: 3e4,
            unavailable_timeout: 1e4,
            cdn_http: "http://js.pusher.com",
            cdn_https: "https://js.pusher.com",
            dependency_suffix: ""
        };
        exports.__esModule = !0, exports["default"] = Defaults;
    }, function(module, exports, __webpack_require__) {
        var script_receiver_factory_1 = __webpack_require__(4), runtime_1 = __webpack_require__(2), DependencyLoader = function() {
            function DependencyLoader(options) {
                this.options = options, this.receivers = options.receivers || script_receiver_factory_1.ScriptReceivers, 
                this.loading = {};
            }
            return DependencyLoader.prototype.load = function(name, options, callback) {
                var self = this;
                if (self.loading[name] && self.loading[name].length > 0) self.loading[name].push(callback); else {
                    self.loading[name] = [ callback ];
                    var request = runtime_1["default"].createScriptRequest(self.getPath(name, options)), receiver = self.receivers.create(function(error) {
                        if (self.receivers.remove(receiver), self.loading[name]) {
                            var callbacks = self.loading[name];
                            delete self.loading[name];
                            for (var successCallback = function(wasSuccessful) {
                                wasSuccessful || request.cleanup();
                            }, i = 0; i < callbacks.length; i++) callbacks[i](error, successCallback);
                        }
                    });
                    request.send(receiver);
                }
            }, DependencyLoader.prototype.getRoot = function(options) {
                var cdn, protocol = runtime_1["default"].getDocument().location.protocol;
                return cdn = options && options.encrypted || "https:" === protocol ? this.options.cdn_https : this.options.cdn_http, 
                cdn.replace(/\/*$/, "") + "/" + this.options.version;
            }, DependencyLoader.prototype.getPath = function(name, options) {
                return this.getRoot(options) + "/" + name + this.options.suffix + ".js";
            }, DependencyLoader;
        }();
        exports.__esModule = !0, exports["default"] = DependencyLoader;
    }, function(module, exports, __webpack_require__) {
        var logger_1 = __webpack_require__(8), runtime_1 = __webpack_require__(2), ajax = function(context, socketId, callback) {
            var xhr, self = this;
            xhr = runtime_1["default"].createXHR(), xhr.open("POST", self.options.authEndpoint, !0), 
            xhr.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
            for (var headerName in this.authOptions.headers) xhr.setRequestHeader(headerName, this.authOptions.headers[headerName]);
            return xhr.onreadystatechange = function() {
                if (4 === xhr.readyState) if (200 === xhr.status) {
                    var data, parsed = !1;
                    try {
                        data = JSON.parse(xhr.responseText), parsed = !0;
                    } catch (e) {
                        callback(!0, "JSON returned from webapp was invalid, yet status code was 200. Data was: " + xhr.responseText);
                    }
                    parsed && callback(!1, data);
                } else logger_1["default"].warn("Couldn't get auth info from your webapp", xhr.status), 
                callback(!0, xhr.status);
            }, xhr.send(this.composeQuery(socketId)), xhr;
        };
        exports.__esModule = !0, exports["default"] = ajax;
    }, function(module, exports, __webpack_require__) {
        var collections_1 = __webpack_require__(9), pusher_1 = __webpack_require__(1), Logger = {
            debug: function() {
                for (var args = [], _i = 0; _i < arguments.length; _i++) args[_i - 0] = arguments[_i];
                pusher_1["default"].log && pusher_1["default"].log(collections_1.stringify.apply(this, arguments));
            },
            warn: function() {
                for (var args = [], _i = 0; _i < arguments.length; _i++) args[_i - 0] = arguments[_i];
                var message = collections_1.stringify.apply(this, arguments);
                window.console && (window.console.warn ? window.console.warn(message) : window.console.log && window.console.log(message)), 
                pusher_1["default"].log && pusher_1["default"].log(message);
            }
        };
        exports.__esModule = !0, exports["default"] = Logger;
    }, function(module, exports, __webpack_require__) {
        function extend(target) {
            for (var sources = [], _i = 1; _i < arguments.length; _i++) sources[_i - 1] = arguments[_i];
            for (var i = 0; i < sources.length; i++) {
                var extensions = sources[i];
                for (var property in extensions) target[property] = extensions[property] && extensions[property].constructor && extensions[property].constructor === Object ? extend(target[property] || {}, extensions[property]) : extensions[property];
            }
            return target;
        }
        function stringify() {
            for (var m = [ "Pusher" ], i = 0; i < arguments.length; i++) m.push("string" == typeof arguments[i] ? arguments[i] : safeJSONStringify(arguments[i]));
            return m.join(" : ");
        }
        function arrayIndexOf(array, item) {
            var nativeIndexOf = Array.prototype.indexOf;
            if (null === array) return -1;
            if (nativeIndexOf && array.indexOf === nativeIndexOf) return array.indexOf(item);
            for (var i = 0, l = array.length; l > i; i++) if (array[i] === item) return i;
            return -1;
        }
        function objectApply(object, f) {
            for (var key in object) Object.prototype.hasOwnProperty.call(object, key) && f(object[key], key, object);
        }
        function keys(object) {
            var keys = [];
            return objectApply(object, function(_, key) {
                keys.push(key);
            }), keys;
        }
        function values(object) {
            var values = [];
            return objectApply(object, function(value) {
                values.push(value);
            }), values;
        }
        function apply(array, f, context) {
            for (var i = 0; i < array.length; i++) f.call(context || window, array[i], i, array);
        }
        function map(array, f) {
            for (var result = [], i = 0; i < array.length; i++) result.push(f(array[i], i, array, result));
            return result;
        }
        function mapObject(object, f) {
            var result = {};
            return objectApply(object, function(value, key) {
                result[key] = f(value);
            }), result;
        }
        function filter(array, test) {
            test = test || function(value) {
                return !!value;
            };
            for (var result = [], i = 0; i < array.length; i++) test(array[i], i, array, result) && result.push(array[i]);
            return result;
        }
        function filterObject(object, test) {
            var result = {};
            return objectApply(object, function(value, key) {
                (test && test(value, key, object, result) || Boolean(value)) && (result[key] = value);
            }), result;
        }
        function flatten(object) {
            var result = [];
            return objectApply(object, function(value, key) {
                result.push([ key, value ]);
            }), result;
        }
        function any(array, test) {
            for (var i = 0; i < array.length; i++) if (test(array[i], i, array)) return !0;
            return !1;
        }
        function all(array, test) {
            for (var i = 0; i < array.length; i++) if (!test(array[i], i, array)) return !1;
            return !0;
        }
        function encodeParamsObject(data) {
            return mapObject(data, function(value) {
                return "object" == typeof value && (value = safeJSONStringify(value)), encodeURIComponent(base64_1["default"](value.toString()));
            });
        }
        function buildQueryString(data) {
            var params = filterObject(data, function(value) {
                return void 0 !== value;
            }), query = map(flatten(encodeParamsObject(params)), util_1["default"].method("join", "=")).join("&");
            return query;
        }
        function decycleObject(object) {
            var objects = [], paths = [];
            return function derez(value, path) {
                var i, name, nu;
                switch (typeof value) {
                  case "object":
                    if (!value) return null;
                    for (i = 0; i < objects.length; i += 1) if (objects[i] === value) return {
                        $ref: paths[i]
                    };
                    if (objects.push(value), paths.push(path), "[object Array]" === Object.prototype.toString.apply(value)) for (nu = [], 
                    i = 0; i < value.length; i += 1) nu[i] = derez(value[i], path + "[" + i + "]"); else {
                        nu = {};
                        for (name in value) Object.prototype.hasOwnProperty.call(value, name) && (nu[name] = derez(value[name], path + "[" + JSON.stringify(name) + "]"));
                    }
                    return nu;

                  case "number":
                  case "string":
                  case "boolean":
                    return value;
                }
            }(object, "$");
        }
        function safeJSONStringify(source) {
            try {
                return JSON.stringify(source);
            } catch (e) {
                return JSON.stringify(decycleObject(source));
            }
        }
        var base64_1 = __webpack_require__(10), util_1 = __webpack_require__(11);
        exports.extend = extend, exports.stringify = stringify, exports.arrayIndexOf = arrayIndexOf, 
        exports.objectApply = objectApply, exports.keys = keys, exports.values = values, 
        exports.apply = apply, exports.map = map, exports.mapObject = mapObject, exports.filter = filter, 
        exports.filterObject = filterObject, exports.flatten = flatten, exports.any = any, 
        exports.all = all, exports.encodeParamsObject = encodeParamsObject, exports.buildQueryString = buildQueryString, 
        exports.decycleObject = decycleObject, exports.safeJSONStringify = safeJSONStringify;
    }, function(module, exports) {
        function encode(s) {
            return btoa(utob(s));
        }
        exports.__esModule = !0, exports["default"] = encode;
        for (var fromCharCode = String.fromCharCode, b64chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", b64tab = {}, i = 0, l = b64chars.length; l > i; i++) b64tab[b64chars.charAt(i)] = i;
        var cb_utob = function(c) {
            var cc = c.charCodeAt(0);
            return 128 > cc ? c : 2048 > cc ? fromCharCode(192 | cc >>> 6) + fromCharCode(128 | 63 & cc) : fromCharCode(224 | cc >>> 12 & 15) + fromCharCode(128 | cc >>> 6 & 63) + fromCharCode(128 | 63 & cc);
        }, utob = function(u) {
            return u.replace(/[^\x00-\x7F]/g, cb_utob);
        }, cb_encode = function(ccc) {
            var padlen = [ 0, 2, 1 ][ccc.length % 3], ord = ccc.charCodeAt(0) << 16 | (ccc.length > 1 ? ccc.charCodeAt(1) : 0) << 8 | (ccc.length > 2 ? ccc.charCodeAt(2) : 0), chars = [ b64chars.charAt(ord >>> 18), b64chars.charAt(ord >>> 12 & 63), padlen >= 2 ? "=" : b64chars.charAt(ord >>> 6 & 63), padlen >= 1 ? "=" : b64chars.charAt(63 & ord) ];
            return chars.join("");
        }, btoa = window.btoa || function(b) {
            return b.replace(/[\s\S]{1,3}/g, cb_encode);
        };
    }, function(module, exports, __webpack_require__) {
        var timers_1 = __webpack_require__(12), Util = {
            now: function() {
                return Date.now ? Date.now() : new Date().valueOf();
            },
            defer: function(callback) {
                return new timers_1.OneOffTimer(0, callback);
            },
            method: function(name) {
                for (var args = [], _i = 1; _i < arguments.length; _i++) args[_i - 1] = arguments[_i];
                var boundArguments = Array.prototype.slice.call(arguments, 1);
                return function(object) {
                    return object[name].apply(object, boundArguments.concat(arguments));
                };
            }
        };
        exports.__esModule = !0, exports["default"] = Util;
    }, function(module, exports, __webpack_require__) {
        function clearTimeout(timer) {
            window.clearTimeout(timer);
        }
        function clearInterval(timer) {
            window.clearInterval(timer);
        }
        var __extends = this && this.__extends || function(d, b) {
            function __() {
                this.constructor = d;
            }
            for (var p in b) b.hasOwnProperty(p) && (d[p] = b[p]);
            d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, new __());
        }, abstract_timer_1 = __webpack_require__(13), OneOffTimer = function(_super) {
            function OneOffTimer(delay, callback) {
                _super.call(this, setTimeout, clearTimeout, delay, function() {
                    return callback(), null;
                });
            }
            return __extends(OneOffTimer, _super), OneOffTimer;
        }(abstract_timer_1["default"]);
        exports.OneOffTimer = OneOffTimer;
        var PeriodicTimer = function(_super) {
            function PeriodicTimer(delay, callback) {
                _super.call(this, setInterval, clearInterval, delay, function(timer) {
                    return callback(), timer;
                });
            }
            return __extends(PeriodicTimer, _super), PeriodicTimer;
        }(abstract_timer_1["default"]);
        exports.PeriodicTimer = PeriodicTimer;
    }, function(module, exports) {
        var Timer = function() {
            function Timer(set, clear, delay, callback) {
                var _this = this;
                this.clear = clear, this.timer = set(function() {
                    _this.timer && (_this.timer = callback(_this.timer));
                }, delay);
            }
            return Timer.prototype.isRunning = function() {
                return null !== this.timer;
            }, Timer.prototype.ensureAborted = function() {
                this.timer && (this.clear(this.timer), this.timer = null);
            }, Timer;
        }();
        exports.__esModule = !0, exports["default"] = Timer;
    }, function(module, exports, __webpack_require__) {
        var logger_1 = __webpack_require__(8), jsonp = function(context, socketId, callback) {
            void 0 !== this.authOptions.headers && logger_1["default"].warn("Warn", "To send headers with the auth request, you must use AJAX, rather than JSONP.");
            var callbackName = context.nextAuthCallbackID.toString();
            context.nextAuthCallbackID++;
            var document = context.getDocument(), script = document.createElement("script");
            context.auth_callbacks[callbackName] = function(data) {
                callback(!1, data);
            };
            var callback_name = "Pusher.auth_callbacks['" + callbackName + "']";
            script.src = this.options.authEndpoint + "?callback=" + encodeURIComponent(callback_name) + "&" + this.composeQuery(socketId);
            var head = document.getElementsByTagName("head")[0] || document.documentElement;
            head.insertBefore(script, head.firstChild);
        };
        exports.__esModule = !0, exports["default"] = jsonp;
    }, function(module, exports) {
        var ScriptRequest = function() {
            function ScriptRequest(src) {
                this.src = src;
            }
            return ScriptRequest.prototype.send = function(receiver) {
                var self = this, errorString = "Error loading " + self.src;
                self.script = document.createElement("script"), self.script.id = receiver.id, self.script.src = self.src, 
                self.script.type = "text/javascript", self.script.charset = "UTF-8", self.script.addEventListener ? (self.script.onerror = function() {
                    receiver.callback(errorString);
                }, self.script.onload = function() {
                    receiver.callback(null);
                }) : self.script.onreadystatechange = function() {
                    ("loaded" === self.script.readyState || "complete" === self.script.readyState) && receiver.callback(null);
                }, void 0 === self.script.async && document.attachEvent && /opera/i.test(navigator.userAgent) ? (self.errorScript = document.createElement("script"), 
                self.errorScript.id = receiver.id + "_error", self.errorScript.text = receiver.name + "('" + errorString + "');", 
                self.script.async = self.errorScript.async = !1) : self.script.async = !0;
                var head = document.getElementsByTagName("head")[0];
                head.insertBefore(self.script, head.firstChild), self.errorScript && head.insertBefore(self.errorScript, self.script.nextSibling);
            }, ScriptRequest.prototype.cleanup = function() {
                this.script && (this.script.onload = this.script.onerror = null, this.script.onreadystatechange = null), 
                this.script && this.script.parentNode && this.script.parentNode.removeChild(this.script), 
                this.errorScript && this.errorScript.parentNode && this.errorScript.parentNode.removeChild(this.errorScript), 
                this.script = null, this.errorScript = null;
            }, ScriptRequest;
        }();
        exports.__esModule = !0, exports["default"] = ScriptRequest;
    }, function(module, exports, __webpack_require__) {
        var Collections = __webpack_require__(9), runtime_1 = __webpack_require__(2), JSONPRequest = function() {
            function JSONPRequest(url, data) {
                this.url = url, this.data = data;
            }
            return JSONPRequest.prototype.send = function(receiver) {
                if (!this.request) {
                    var query = Collections.buildQueryString(this.data), url = this.url + "/" + receiver.number + "?" + query;
                    this.request = runtime_1["default"].createScriptRequest(url), this.request.send(receiver);
                }
            }, JSONPRequest.prototype.cleanup = function() {
                this.request && this.request.cleanup();
            }, JSONPRequest;
        }();
        exports.__esModule = !0, exports["default"] = JSONPRequest;
    }, function(module, exports, __webpack_require__) {
        var runtime_1 = __webpack_require__(2), script_receiver_factory_1 = __webpack_require__(4), getAgent = function(sender, encrypted) {
            return function(data, callback) {
                var scheme = "http" + (encrypted ? "s" : "") + "://", url = scheme + (sender.host || sender.options.host) + sender.options.path, request = runtime_1["default"].createJSONPRequest(url, data), receiver = runtime_1["default"].ScriptReceivers.create(function(error, result) {
                    script_receiver_factory_1.ScriptReceivers.remove(receiver), request.cleanup(), result && result.host && (sender.host = result.host), 
                    callback && callback(error, result);
                });
                request.send(receiver);
            };
        }, jsonp = {
            name: "jsonp",
            getAgent: getAgent
        };
        exports.__esModule = !0, exports["default"] = jsonp;
    }, function(module, exports, __webpack_require__) {
        var transports_1 = __webpack_require__(19), transport_1 = __webpack_require__(21), URLSchemes = __webpack_require__(20), runtime_1 = __webpack_require__(2), dependencies_1 = __webpack_require__(3), Collections = __webpack_require__(9), SockJSTransport = new transport_1["default"]({
            file: "sockjs",
            urls: URLSchemes.sockjs,
            handlesActivityChecks: !0,
            supportsPing: !1,
            isSupported: function() {
                return !0;
            },
            isInitialized: function() {
                return void 0 !== window.SockJS;
            },
            getSocket: function(url, options) {
                return new window.SockJS(url, null, {
                    js_path: dependencies_1.Dependencies.getPath("sockjs", {
                        encrypted: options.encrypted
                    }),
                    ignore_null_origin: options.ignoreNullOrigin
                });
            },
            beforeOpen: function(socket, path) {
                socket.send(JSON.stringify({
                    path: path
                }));
            }
        }), xdrConfiguration = {
            isSupported: function(environment) {
                var yes = runtime_1["default"].isXDRSupported(environment.encrypted);
                return yes;
            }
        }, XDRStreamingTransport = new transport_1["default"](Collections.extend({}, transports_1.streamingConfiguration, xdrConfiguration)), XDRPollingTransport = new transport_1["default"](Collections.extend({}, transports_1.pollingConfiguration, xdrConfiguration));
        transports_1["default"].xdr_streaming = XDRStreamingTransport, transports_1["default"].xdr_polling = XDRPollingTransport, 
        transports_1["default"].sockjs = SockJSTransport, exports.__esModule = !0, exports["default"] = transports_1["default"];
    }, function(module, exports, __webpack_require__) {
        var URLSchemes = __webpack_require__(20), transport_1 = __webpack_require__(21), Collections = __webpack_require__(9), runtime_1 = __webpack_require__(2), WSTransport = new transport_1["default"]({
            urls: URLSchemes.ws,
            handlesActivityChecks: !1,
            supportsPing: !1,
            isInitialized: function() {
                return Boolean(runtime_1["default"].getWebSocketAPI());
            },
            isSupported: function() {
                return Boolean(runtime_1["default"].getWebSocketAPI());
            },
            getSocket: function(url) {
                return runtime_1["default"].createWebSocket(url);
            }
        }), httpConfiguration = {
            urls: URLSchemes.http,
            handlesActivityChecks: !1,
            supportsPing: !0,
            isInitialized: function() {
                return !0;
            }
        };
        exports.streamingConfiguration = Collections.extend({
            getSocket: function(url) {
                return runtime_1["default"].HTTPFactory.createStreamingSocket(url);
            }
        }, httpConfiguration), exports.pollingConfiguration = Collections.extend({
            getSocket: function(url) {
                return runtime_1["default"].HTTPFactory.createPollingSocket(url);
            }
        }, httpConfiguration);
        var xhrConfiguration = {
            isSupported: function() {
                return runtime_1["default"].isXHRSupported();
            }
        }, XHRStreamingTransport = new transport_1["default"](Collections.extend({}, exports.streamingConfiguration, xhrConfiguration)), XHRPollingTransport = new transport_1["default"](Collections.extend({}, exports.pollingConfiguration, xhrConfiguration)), Transports = {
            ws: WSTransport,
            xhr_streaming: XHRStreamingTransport,
            xhr_polling: XHRPollingTransport
        };
        exports.__esModule = !0, exports["default"] = Transports;
    }, function(module, exports, __webpack_require__) {
        function getGenericURL(baseScheme, params, path) {
            var scheme = baseScheme + (params.encrypted ? "s" : ""), host = params.encrypted ? params.hostEncrypted : params.hostUnencrypted;
            return scheme + "://" + host + path;
        }
        function getGenericPath(key, queryString) {
            var path = "/app/" + key, query = "?protocol=" + defaults_1["default"].PROTOCOL + "&client=js&version=" + defaults_1["default"].VERSION + (queryString ? "&" + queryString : "");
            return path + query;
        }
        var defaults_1 = __webpack_require__(5);
        exports.ws = {
            getInitial: function(key, params) {
                return getGenericURL("ws", params, getGenericPath(key, "flash=false"));
            }
        }, exports.http = {
            getInitial: function(key, params) {
                var path = (params.httpPath || "/pusher") + getGenericPath(key);
                return getGenericURL("http", params, path);
            }
        }, exports.sockjs = {
            getInitial: function(key, params) {
                return getGenericURL("http", params, params.httpPath || "/pusher");
            },
            getPath: function(key) {
                return getGenericPath(key);
            }
        };
    }, function(module, exports, __webpack_require__) {
        var transport_connection_1 = __webpack_require__(22), Transport = function() {
            function Transport(hooks) {
                this.hooks = hooks;
            }
            return Transport.prototype.isSupported = function(environment) {
                return this.hooks.isSupported(environment);
            }, Transport.prototype.createConnection = function(name, priority, key, options) {
                return new transport_connection_1["default"](this.hooks, name, priority, key, options);
            }, Transport;
        }();
        exports.__esModule = !0, exports["default"] = Transport;
    }, function(module, exports, __webpack_require__) {
        var __extends = this && this.__extends || function(d, b) {
            function __() {
                this.constructor = d;
            }
            for (var p in b) b.hasOwnProperty(p) && (d[p] = b[p]);
            d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, new __());
        }, util_1 = __webpack_require__(11), Collections = __webpack_require__(9), dispatcher_1 = __webpack_require__(23), logger_1 = __webpack_require__(8), runtime_1 = __webpack_require__(2), TransportConnection = function(_super) {
            function TransportConnection(hooks, name, priority, key, options) {
                _super.call(this), this.initialize = runtime_1["default"].transportConnectionInitializer, 
                this.hooks = hooks, this.name = name, this.priority = priority, this.key = key, 
                this.options = options, this.state = "new", this.timeline = options.timeline, this.activityTimeout = options.activityTimeout, 
                this.id = this.timeline.generateUniqueID();
            }
            return __extends(TransportConnection, _super), TransportConnection.prototype.handlesActivityChecks = function() {
                return Boolean(this.hooks.handlesActivityChecks);
            }, TransportConnection.prototype.supportsPing = function() {
                return Boolean(this.hooks.supportsPing);
            }, TransportConnection.prototype.connect = function() {
                var _this = this;
                if (this.socket || "initialized" !== this.state) return !1;
                var url = this.hooks.urls.getInitial(this.key, this.options);
                try {
                    this.socket = this.hooks.getSocket(url, this.options);
                } catch (e) {
                    return util_1["default"].defer(function() {
                        _this.onError(e), _this.changeState("closed");
                    }), !1;
                }
                return this.bindListeners(), logger_1["default"].debug("Connecting", {
                    transport: this.name,
                    url: url
                }), this.changeState("connecting"), !0;
            }, TransportConnection.prototype.close = function() {
                return this.socket ? (this.socket.close(), !0) : !1;
            }, TransportConnection.prototype.send = function(data) {
                var _this = this;
                return "open" === this.state ? (util_1["default"].defer(function() {
                    _this.socket && _this.socket.send(data);
                }), !0) : !1;
            }, TransportConnection.prototype.ping = function() {
                "open" === this.state && this.supportsPing() && this.socket.ping();
            }, TransportConnection.prototype.onOpen = function() {
                this.hooks.beforeOpen && this.hooks.beforeOpen(this.socket, this.hooks.urls.getPath(this.key, this.options)), 
                this.changeState("open"), this.socket.onopen = void 0;
            }, TransportConnection.prototype.onError = function(error) {
                this.emit("error", {
                    type: "WebSocketError",
                    error: error
                }), this.timeline.error(this.buildTimelineMessage({
                    error: error.toString()
                }));
            }, TransportConnection.prototype.onClose = function(closeEvent) {
                closeEvent ? this.changeState("closed", {
                    code: closeEvent.code,
                    reason: closeEvent.reason,
                    wasClean: closeEvent.wasClean
                }) : this.changeState("closed"), this.unbindListeners(), this.socket = void 0;
            }, TransportConnection.prototype.onMessage = function(message) {
                this.emit("message", message);
            }, TransportConnection.prototype.onActivity = function() {
                this.emit("activity");
            }, TransportConnection.prototype.bindListeners = function() {
                var _this = this;
                this.socket.onopen = function() {
                    _this.onOpen();
                }, this.socket.onerror = function(error) {
                    _this.onError(error);
                }, this.socket.onclose = function(closeEvent) {
                    _this.onClose(closeEvent);
                }, this.socket.onmessage = function(message) {
                    _this.onMessage(message);
                }, this.supportsPing() && (this.socket.onactivity = function() {
                    _this.onActivity();
                });
            }, TransportConnection.prototype.unbindListeners = function() {
                this.socket && (this.socket.onopen = void 0, this.socket.onerror = void 0, this.socket.onclose = void 0, 
                this.socket.onmessage = void 0, this.supportsPing() && (this.socket.onactivity = void 0));
            }, TransportConnection.prototype.changeState = function(state, params) {
                this.state = state, this.timeline.info(this.buildTimelineMessage({
                    state: state,
                    params: params
                })), this.emit(state, params);
            }, TransportConnection.prototype.buildTimelineMessage = function(message) {
                return Collections.extend({
                    cid: this.id
                }, message);
            }, TransportConnection;
        }(dispatcher_1["default"]);
        exports.__esModule = !0, exports["default"] = TransportConnection;
    }, function(module, exports, __webpack_require__) {
        var callback_registry_1 = __webpack_require__(24), Dispatcher = function() {
            function Dispatcher(failThrough) {
                this.callbacks = new callback_registry_1["default"](), this.global_callbacks = [], 
                this.failThrough = failThrough;
            }
            return Dispatcher.prototype.bind = function(eventName, callback, context) {
                return this.callbacks.add(eventName, callback, context), this;
            }, Dispatcher.prototype.bind_all = function(callback) {
                return this.global_callbacks.push(callback), this;
            }, Dispatcher.prototype.unbind = function(eventName, callback, context) {
                return this.callbacks.remove(eventName, callback, context), this;
            }, Dispatcher.prototype.unbind_all = function(eventName, callback) {
                return this.callbacks.remove(eventName, callback), this;
            }, Dispatcher.prototype.emit = function(eventName, data) {
                var i;
                for (i = 0; i < this.global_callbacks.length; i++) this.global_callbacks[i](eventName, data);
                var callbacks = this.callbacks.get(eventName);
                if (callbacks && callbacks.length > 0) for (i = 0; i < callbacks.length; i++) callbacks[i].fn.call(callbacks[i].context || window, data); else this.failThrough && this.failThrough(eventName, data);
                return this;
            }, Dispatcher;
        }();
        exports.__esModule = !0, exports["default"] = Dispatcher;
    }, function(module, exports, __webpack_require__) {
        function prefix(name) {
            return "_" + name;
        }
        var Collections = __webpack_require__(9), CallbackRegistry = function() {
            function CallbackRegistry() {
                this._callbacks = {};
            }
            return CallbackRegistry.prototype.get = function(name) {
                return this._callbacks[prefix(name)];
            }, CallbackRegistry.prototype.add = function(name, callback, context) {
                var prefixedEventName = prefix(name);
                this._callbacks[prefixedEventName] = this._callbacks[prefixedEventName] || [], this._callbacks[prefixedEventName].push({
                    fn: callback,
                    context: context
                });
            }, CallbackRegistry.prototype.remove = function(name, callback, context) {
                if (!name && !callback && !context) return void (this._callbacks = {});
                var names = name ? [ prefix(name) ] : Collections.keys(this._callbacks);
                callback || context ? this.removeCallback(names, callback, context) : this.removeAllCallbacks(names);
            }, CallbackRegistry.prototype.removeCallback = function(names, callback, context) {
                Collections.apply(names, function(name) {
                    this._callbacks[name] = Collections.filter(this._callbacks[name] || [], function(binding) {
                        return callback && callback !== binding.fn || context && context !== binding.context;
                    }), 0 === this._callbacks[name].length && delete this._callbacks[name];
                }, this);
            }, CallbackRegistry.prototype.removeAllCallbacks = function(names) {
                Collections.apply(names, function(name) {
                    delete this._callbacks[name];
                }, this);
            }, CallbackRegistry;
        }();
        exports.__esModule = !0, exports["default"] = CallbackRegistry;
    }, function(module, exports, __webpack_require__) {
        var __extends = this && this.__extends || function(d, b) {
            function __() {
                this.constructor = d;
            }
            for (var p in b) b.hasOwnProperty(p) && (d[p] = b[p]);
            d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, new __());
        }, dispatcher_1 = __webpack_require__(23), NetInfo = function(_super) {
            function NetInfo() {
                _super.call(this);
                var self = this;
                void 0 !== window.addEventListener && (window.addEventListener("online", function() {
                    self.emit("online");
                }, !1), window.addEventListener("offline", function() {
                    self.emit("offline");
                }, !1));
            }
            return __extends(NetInfo, _super), NetInfo.prototype.isOnline = function() {
                return void 0 === window.navigator.onLine ? !0 : window.navigator.onLine;
            }, NetInfo;
        }(dispatcher_1["default"]);
        exports.NetInfo = NetInfo, exports.Network = new NetInfo();
    }, function(module, exports) {
        var getDefaultStrategy = function(config) {
            var wsStrategy;
            return wsStrategy = config.encrypted ? [ ":best_connected_ever", ":ws_loop", [ ":delayed", 2e3, [ ":http_fallback_loop" ] ] ] : [ ":best_connected_ever", ":ws_loop", [ ":delayed", 2e3, [ ":wss_loop" ] ], [ ":delayed", 5e3, [ ":http_fallback_loop" ] ] ], 
            [ [ ":def", "ws_options", {
                hostUnencrypted: config.wsHost + ":" + config.wsPort,
                hostEncrypted: config.wsHost + ":" + config.wssPort
            } ], [ ":def", "wss_options", [ ":extend", ":ws_options", {
                encrypted: !0
            } ] ], [ ":def", "sockjs_options", {
                hostUnencrypted: config.httpHost + ":" + config.httpPort,
                hostEncrypted: config.httpHost + ":" + config.httpsPort,
                httpPath: config.httpPath
            } ], [ ":def", "timeouts", {
                loop: !0,
                timeout: 15e3,
                timeoutLimit: 6e4
            } ], [ ":def", "ws_manager", [ ":transport_manager", {
                lives: 2,
                minPingDelay: 1e4,
                maxPingDelay: config.activity_timeout
            } ] ], [ ":def", "streaming_manager", [ ":transport_manager", {
                lives: 2,
                minPingDelay: 1e4,
                maxPingDelay: config.activity_timeout
            } ] ], [ ":def_transport", "ws", "ws", 3, ":ws_options", ":ws_manager" ], [ ":def_transport", "wss", "ws", 3, ":wss_options", ":ws_manager" ], [ ":def_transport", "sockjs", "sockjs", 1, ":sockjs_options" ], [ ":def_transport", "xhr_streaming", "xhr_streaming", 1, ":sockjs_options", ":streaming_manager" ], [ ":def_transport", "xdr_streaming", "xdr_streaming", 1, ":sockjs_options", ":streaming_manager" ], [ ":def_transport", "xhr_polling", "xhr_polling", 1, ":sockjs_options" ], [ ":def_transport", "xdr_polling", "xdr_polling", 1, ":sockjs_options" ], [ ":def", "ws_loop", [ ":sequential", ":timeouts", ":ws" ] ], [ ":def", "wss_loop", [ ":sequential", ":timeouts", ":wss" ] ], [ ":def", "sockjs_loop", [ ":sequential", ":timeouts", ":sockjs" ] ], [ ":def", "streaming_loop", [ ":sequential", ":timeouts", [ ":if", [ ":is_supported", ":xhr_streaming" ], ":xhr_streaming", ":xdr_streaming" ] ] ], [ ":def", "polling_loop", [ ":sequential", ":timeouts", [ ":if", [ ":is_supported", ":xhr_polling" ], ":xhr_polling", ":xdr_polling" ] ] ], [ ":def", "http_loop", [ ":if", [ ":is_supported", ":streaming_loop" ], [ ":best_connected_ever", ":streaming_loop", [ ":delayed", 4e3, [ ":polling_loop" ] ] ], [ ":polling_loop" ] ] ], [ ":def", "http_fallback_loop", [ ":if", [ ":is_supported", ":http_loop" ], [ ":http_loop" ], [ ":sockjs_loop" ] ] ], [ ":def", "strategy", [ ":cached", 18e5, [ ":first_connected", [ ":if", [ ":is_supported", ":ws" ], wsStrategy, ":http_fallback_loop" ] ] ] ] ];
        };
        exports.__esModule = !0, exports["default"] = getDefaultStrategy;
    }, function(module, exports, __webpack_require__) {
        function default_1() {
            var self = this;
            self.timeline.info(self.buildTimelineMessage({
                transport: self.name + (self.options.encrypted ? "s" : "")
            })), self.hooks.isInitialized() ? self.changeState("initialized") : self.hooks.file ? (self.changeState("initializing"), 
            dependencies_1.Dependencies.load(self.hooks.file, {
                encrypted: self.options.encrypted
            }, function(error, callback) {
                self.hooks.isInitialized() ? (self.changeState("initialized"), callback(!0)) : (error && self.onError(error), 
                self.onClose(), callback(!1));
            })) : self.onClose();
        }
        var dependencies_1 = __webpack_require__(3);
        exports.__esModule = !0, exports["default"] = default_1;
    }, function(module, exports, __webpack_require__) {
        var http_xdomain_request_1 = __webpack_require__(29), http_1 = __webpack_require__(31);
        http_1["default"].createXDR = function(method, url) {
            return this.createRequest(http_xdomain_request_1["default"], method, url);
        }, exports.__esModule = !0, exports["default"] = http_1["default"];
    }, function(module, exports, __webpack_require__) {
        var Errors = __webpack_require__(30), hooks = {
            getRequest: function(socket) {
                var xdr = new window.XDomainRequest();
                return xdr.ontimeout = function() {
                    socket.emit("error", new Errors.RequestTimedOut()), socket.close();
                }, xdr.onerror = function(e) {
                    socket.emit("error", e), socket.close();
                }, xdr.onprogress = function() {
                    xdr.responseText && xdr.responseText.length > 0 && socket.onChunk(200, xdr.responseText);
                }, xdr.onload = function() {
                    xdr.responseText && xdr.responseText.length > 0 && socket.onChunk(200, xdr.responseText), 
                    socket.emit("finished", 200), socket.close();
                }, xdr;
            },
            abortRequest: function(xdr) {
                xdr.ontimeout = xdr.onerror = xdr.onprogress = xdr.onload = null, xdr.abort();
            }
        };
        exports.__esModule = !0, exports["default"] = hooks;
    }, function(module, exports) {
        var __extends = this && this.__extends || function(d, b) {
            function __() {
                this.constructor = d;
            }
            for (var p in b) b.hasOwnProperty(p) && (d[p] = b[p]);
            d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, new __());
        }, BadEventName = function(_super) {
            function BadEventName() {
                _super.apply(this, arguments);
            }
            return __extends(BadEventName, _super), BadEventName;
        }(Error);
        exports.BadEventName = BadEventName;
        var RequestTimedOut = function(_super) {
            function RequestTimedOut() {
                _super.apply(this, arguments);
            }
            return __extends(RequestTimedOut, _super), RequestTimedOut;
        }(Error);
        exports.RequestTimedOut = RequestTimedOut;
        var TransportPriorityTooLow = function(_super) {
            function TransportPriorityTooLow() {
                _super.apply(this, arguments);
            }
            return __extends(TransportPriorityTooLow, _super), TransportPriorityTooLow;
        }(Error);
        exports.TransportPriorityTooLow = TransportPriorityTooLow;
        var TransportClosed = function(_super) {
            function TransportClosed() {
                _super.apply(this, arguments);
            }
            return __extends(TransportClosed, _super), TransportClosed;
        }(Error);
        exports.TransportClosed = TransportClosed;
        var UnsupportedTransport = function(_super) {
            function UnsupportedTransport() {
                _super.apply(this, arguments);
            }
            return __extends(UnsupportedTransport, _super), UnsupportedTransport;
        }(Error);
        exports.UnsupportedTransport = UnsupportedTransport;
        var UnsupportedStrategy = function(_super) {
            function UnsupportedStrategy() {
                _super.apply(this, arguments);
            }
            return __extends(UnsupportedStrategy, _super), UnsupportedStrategy;
        }(Error);
        exports.UnsupportedStrategy = UnsupportedStrategy;
    }, function(module, exports, __webpack_require__) {
        var http_request_1 = __webpack_require__(32), http_socket_1 = __webpack_require__(33), http_streaming_socket_1 = __webpack_require__(35), http_polling_socket_1 = __webpack_require__(36), http_xhr_request_1 = __webpack_require__(37), HTTP = {
            createStreamingSocket: function(url) {
                return this.createSocket(http_streaming_socket_1["default"], url);
            },
            createPollingSocket: function(url) {
                return this.createSocket(http_polling_socket_1["default"], url);
            },
            createSocket: function(hooks, url) {
                return new http_socket_1["default"](hooks, url);
            },
            createXHR: function(method, url) {
                return this.createRequest(http_xhr_request_1["default"], method, url);
            },
            createRequest: function(hooks, method, url) {
                return new http_request_1["default"](hooks, method, url);
            }
        };
        exports.__esModule = !0, exports["default"] = HTTP;
    }, function(module, exports, __webpack_require__) {
        var __extends = this && this.__extends || function(d, b) {
            function __() {
                this.constructor = d;
            }
            for (var p in b) b.hasOwnProperty(p) && (d[p] = b[p]);
            d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, new __());
        }, runtime_1 = __webpack_require__(2), dispatcher_1 = __webpack_require__(23), MAX_BUFFER_LENGTH = 262144, HTTPRequest = function(_super) {
            function HTTPRequest(hooks, method, url) {
                _super.call(this), this.hooks = hooks, this.method = method, this.url = url;
            }
            return __extends(HTTPRequest, _super), HTTPRequest.prototype.start = function(payload) {
                var _this = this;
                this.position = 0, this.xhr = this.hooks.getRequest(this), this.unloader = function() {
                    _this.close();
                }, runtime_1["default"].addUnloadListener(this.unloader), this.xhr.open(this.method, this.url, !0), 
                this.xhr.setRequestHeader && this.xhr.setRequestHeader("Content-Type", "application/json"), 
                this.xhr.send(payload);
            }, HTTPRequest.prototype.close = function() {
                this.unloader && (runtime_1["default"].removeUnloadListener(this.unloader), this.unloader = null), 
                this.xhr && (this.hooks.abortRequest(this.xhr), this.xhr = null);
            }, HTTPRequest.prototype.onChunk = function(status, data) {
                for (;;) {
                    var chunk = this.advanceBuffer(data);
                    if (!chunk) break;
                    this.emit("chunk", {
                        status: status,
                        data: chunk
                    });
                }
                this.isBufferTooLong(data) && this.emit("buffer_too_long");
            }, HTTPRequest.prototype.advanceBuffer = function(buffer) {
                var unreadData = buffer.slice(this.position), endOfLinePosition = unreadData.indexOf("\n");
                return -1 !== endOfLinePosition ? (this.position += endOfLinePosition + 1, unreadData.slice(0, endOfLinePosition)) : null;
            }, HTTPRequest.prototype.isBufferTooLong = function(buffer) {
                return this.position === buffer.length && buffer.length > MAX_BUFFER_LENGTH;
            }, HTTPRequest;
        }(dispatcher_1["default"]);
        exports.__esModule = !0, exports["default"] = HTTPRequest;
    }, function(module, exports, __webpack_require__) {
        function getLocation(url) {
            var parts = /([^\?]*)\/*(\??.*)/.exec(url);
            return {
                base: parts[1],
                queryString: parts[2]
            };
        }
        function getSendURL(url, session) {
            return url.base + "/" + session + "/xhr_send";
        }
        function getUniqueURL(url) {
            var separator = -1 === url.indexOf("?") ? "?" : "&";
            return url + separator + "t=" + +new Date() + "&n=" + autoIncrement++;
        }
        function replaceHost(url, hostname) {
            var urlParts = /(https?:\/\/)([^\/:]+)((\/|:)?.*)/.exec(url);
            return urlParts[1] + hostname + urlParts[3];
        }
        function randomNumber(max) {
            return Math.floor(Math.random() * max);
        }
        function randomString(length) {
            for (var result = [], i = 0; length > i; i++) result.push(randomNumber(32).toString(32));
            return result.join("");
        }
        var state_1 = __webpack_require__(34), util_1 = __webpack_require__(11), runtime_1 = __webpack_require__(2), autoIncrement = 1, HTTPSocket = function() {
            function HTTPSocket(hooks, url) {
                this.hooks = hooks, this.session = randomNumber(1e3) + "/" + randomString(8), this.location = getLocation(url), 
                this.readyState = state_1["default"].CONNECTING, this.openStream();
            }
            return HTTPSocket.prototype.send = function(payload) {
                return this.sendRaw(JSON.stringify([ payload ]));
            }, HTTPSocket.prototype.ping = function() {
                this.hooks.sendHeartbeat(this);
            }, HTTPSocket.prototype.close = function(code, reason) {
                this.onClose(code, reason, !0);
            }, HTTPSocket.prototype.sendRaw = function(payload) {
                if (this.readyState !== state_1["default"].OPEN) return !1;
                try {
                    return runtime_1["default"].createSocketRequest("POST", getUniqueURL(getSendURL(this.location, this.session))).start(payload), 
                    !0;
                } catch (e) {
                    return !1;
                }
            }, HTTPSocket.prototype.reconnect = function() {
                this.closeStream(), this.openStream();
            }, HTTPSocket.prototype.onClose = function(code, reason, wasClean) {
                this.closeStream(), this.readyState = state_1["default"].CLOSED, this.onclose && this.onclose({
                    code: code,
                    reason: reason,
                    wasClean: wasClean
                });
            }, HTTPSocket.prototype.onChunk = function(chunk) {
                if (200 === chunk.status) {
                    this.readyState === state_1["default"].OPEN && this.onActivity();
                    var payload, type = chunk.data.slice(0, 1);
                    switch (type) {
                      case "o":
                        payload = JSON.parse(chunk.data.slice(1) || "{}"), this.onOpen(payload);
                        break;

                      case "a":
                        payload = JSON.parse(chunk.data.slice(1) || "[]");
                        for (var i = 0; i < payload.length; i++) this.onEvent(payload[i]);
                        break;

                      case "m":
                        payload = JSON.parse(chunk.data.slice(1) || "null"), this.onEvent(payload);
                        break;

                      case "h":
                        this.hooks.onHeartbeat(this);
                        break;

                      case "c":
                        payload = JSON.parse(chunk.data.slice(1) || "[]"), this.onClose(payload[0], payload[1], !0);
                    }
                }
            }, HTTPSocket.prototype.onOpen = function(options) {
                this.readyState === state_1["default"].CONNECTING ? (options && options.hostname && (this.location.base = replaceHost(this.location.base, options.hostname)), 
                this.readyState = state_1["default"].OPEN, this.onopen && this.onopen()) : this.onClose(1006, "Server lost session", !0);
            }, HTTPSocket.prototype.onEvent = function(event) {
                this.readyState === state_1["default"].OPEN && this.onmessage && this.onmessage({
                    data: event
                });
            }, HTTPSocket.prototype.onActivity = function() {
                this.onactivity && this.onactivity();
            }, HTTPSocket.prototype.onError = function(error) {
                this.onerror && this.onerror(error);
            }, HTTPSocket.prototype.openStream = function() {
                var _this = this;
                this.stream = runtime_1["default"].createSocketRequest("POST", getUniqueURL(this.hooks.getReceiveURL(this.location, this.session))), 
                this.stream.bind("chunk", function(chunk) {
                    _this.onChunk(chunk);
                }), this.stream.bind("finished", function(status) {
                    _this.hooks.onFinished(_this, status);
                }), this.stream.bind("buffer_too_long", function() {
                    _this.reconnect();
                });
                try {
                    this.stream.start();
                } catch (error) {
                    util_1["default"].defer(function() {
                        _this.onError(error), _this.onClose(1006, "Could not start streaming", !1);
                    });
                }
            }, HTTPSocket.prototype.closeStream = function() {
                this.stream && (this.stream.unbind_all(), this.stream.close(), this.stream = null);
            }, HTTPSocket;
        }();
        exports.__esModule = !0, exports["default"] = HTTPSocket;
    }, function(module, exports) {
        var State;
        !function(State) {
            State[State.CONNECTING = 0] = "CONNECTING", State[State.OPEN = 1] = "OPEN", State[State.CLOSED = 3] = "CLOSED";
        }(State || (State = {})), exports.__esModule = !0, exports["default"] = State;
    }, function(module, exports) {
        var hooks = {
            getReceiveURL: function(url, session) {
                return url.base + "/" + session + "/xhr_streaming" + url.queryString;
            },
            onHeartbeat: function(socket) {
                socket.sendRaw("[]");
            },
            sendHeartbeat: function(socket) {
                socket.sendRaw("[]");
            },
            onFinished: function(socket, status) {
                socket.onClose(1006, "Connection interrupted (" + status + ")", !1);
            }
        };
        exports.__esModule = !0, exports["default"] = hooks;
    }, function(module, exports) {
        var hooks = {
            getReceiveURL: function(url, session) {
                return url.base + "/" + session + "/xhr" + url.queryString;
            },
            onHeartbeat: function() {},
            sendHeartbeat: function(socket) {
                socket.sendRaw("[]");
            },
            onFinished: function(socket, status) {
                200 === status ? socket.reconnect() : socket.onClose(1006, "Connection interrupted (" + status + ")", !1);
            }
        };
        exports.__esModule = !0, exports["default"] = hooks;
    }, function(module, exports, __webpack_require__) {
        var runtime_1 = __webpack_require__(2), hooks = {
            getRequest: function(socket) {
                var Constructor = runtime_1["default"].getXHRAPI(), xhr = new Constructor();
                return xhr.onreadystatechange = xhr.onprogress = function() {
                    switch (xhr.readyState) {
                      case 3:
                        xhr.responseText && xhr.responseText.length > 0 && socket.onChunk(xhr.status, xhr.responseText);
                        break;

                      case 4:
                        xhr.responseText && xhr.responseText.length > 0 && socket.onChunk(xhr.status, xhr.responseText), 
                        socket.emit("finished", xhr.status), socket.close();
                    }
                }, xhr;
            },
            abortRequest: function(xhr) {
                xhr.onreadystatechange = null, xhr.abort();
            }
        };
        exports.__esModule = !0, exports["default"] = hooks;
    }, function(module, exports, __webpack_require__) {
        var Collections = __webpack_require__(9), util_1 = __webpack_require__(11), level_1 = __webpack_require__(39), Timeline = function() {
            function Timeline(key, session, options) {
                this.key = key, this.session = session, this.events = [], this.options = options || {}, 
                this.sent = 0, this.uniqueID = 0;
            }
            return Timeline.prototype.log = function(level, event) {
                level <= this.options.level && (this.events.push(Collections.extend({}, event, {
                    timestamp: util_1["default"].now()
                })), this.options.limit && this.events.length > this.options.limit && this.events.shift());
            }, Timeline.prototype.error = function(event) {
                this.log(level_1["default"].ERROR, event);
            }, Timeline.prototype.info = function(event) {
                this.log(level_1["default"].INFO, event);
            }, Timeline.prototype.debug = function(event) {
                this.log(level_1["default"].DEBUG, event);
            }, Timeline.prototype.isEmpty = function() {
                return 0 === this.events.length;
            }, Timeline.prototype.send = function(sendfn, callback) {
                var _this = this, data = Collections.extend({
                    session: this.session,
                    bundle: this.sent + 1,
                    key: this.key,
                    lib: "js",
                    version: this.options.version,
                    cluster: this.options.cluster,
                    features: this.options.features,
                    timeline: this.events
                }, this.options.params);
                return this.events = [], sendfn(data, function(error, result) {
                    error || _this.sent++, callback && callback(error, result);
                }), !0;
            }, Timeline.prototype.generateUniqueID = function() {
                return this.uniqueID++, this.uniqueID;
            }, Timeline;
        }();
        exports.__esModule = !0, exports["default"] = Timeline;
    }, function(module, exports) {
        var TimelineLevel;
        !function(TimelineLevel) {
            TimelineLevel[TimelineLevel.ERROR = 3] = "ERROR", TimelineLevel[TimelineLevel.INFO = 6] = "INFO", 
            TimelineLevel[TimelineLevel.DEBUG = 7] = "DEBUG";
        }(TimelineLevel || (TimelineLevel = {})), exports.__esModule = !0, exports["default"] = TimelineLevel;
    }, function(module, exports, __webpack_require__) {
        function returnWithOriginalContext(f) {
            return function(context) {
                return [ f.apply(this, arguments), context ];
            };
        }
        function isSymbol(expression) {
            return "string" == typeof expression && ":" === expression.charAt(0);
        }
        function getSymbolValue(expression, context) {
            return context[expression.slice(1)];
        }
        function evaluateListOfExpressions(expressions, context) {
            if (0 === expressions.length) return [ [], context ];
            var head = evaluate(expressions[0], context), tail = evaluateListOfExpressions(expressions.slice(1), head[1]);
            return [ [ head[0] ].concat(tail[0]), tail[1] ];
        }
        function evaluateString(expression, context) {
            if (!isSymbol(expression)) return [ expression, context ];
            var value = getSymbolValue(expression, context);
            if (void 0 === value) throw "Undefined symbol " + expression;
            return [ value, context ];
        }
        function evaluateArray(expression, context) {
            if (isSymbol(expression[0])) {
                var f = getSymbolValue(expression[0], context);
                if (expression.length > 1) {
                    if ("function" != typeof f) throw "Calling non-function " + expression[0];
                    var args = [ Collections.extend({}, context) ].concat(Collections.map(expression.slice(1), function(arg) {
                        return evaluate(arg, Collections.extend({}, context))[0];
                    }));
                    return f.apply(this, args);
                }
                return [ f, context ];
            }
            return evaluateListOfExpressions(expression, context);
        }
        function evaluate(expression, context) {
            return "string" == typeof expression ? evaluateString(expression, context) : "object" == typeof expression && expression instanceof Array && expression.length > 0 ? evaluateArray(expression, context) : [ expression, context ];
        }
        var Collections = __webpack_require__(9), util_1 = __webpack_require__(11), transport_manager_1 = __webpack_require__(41), Errors = __webpack_require__(30), transport_strategy_1 = __webpack_require__(55), sequential_strategy_1 = __webpack_require__(56), best_connected_ever_strategy_1 = __webpack_require__(57), cached_strategy_1 = __webpack_require__(58), delayed_strategy_1 = __webpack_require__(59), if_strategy_1 = __webpack_require__(60), first_connected_strategy_1 = __webpack_require__(61), runtime_1 = __webpack_require__(2), Transports = runtime_1["default"].Transports;
        exports.build = function(scheme, options) {
            var context = Collections.extend({}, globalContext, options);
            return evaluate(scheme, context)[1].strategy;
        };
        var UnsupportedStrategy = {
            isSupported: function() {
                return !1;
            },
            connect: function(_, callback) {
                var deferred = util_1["default"].defer(function() {
                    callback(new Errors.UnsupportedStrategy());
                });
                return {
                    abort: function() {
                        deferred.ensureAborted();
                    },
                    forceMinPriority: function() {}
                };
            }
        }, globalContext = {
            extend: function(context, first, second) {
                return [ Collections.extend({}, first, second), context ];
            },
            def: function(context, name, value) {
                if (void 0 !== context[name]) throw "Redefining symbol " + name;
                return context[name] = value, [ void 0, context ];
            },
            def_transport: function(context, name, type, priority, options, manager) {
                var transportClass = Transports[type];
                if (!transportClass) throw new Errors.UnsupportedTransport(type);
                var transport, enabled = !(context.enabledTransports && -1 === Collections.arrayIndexOf(context.enabledTransports, name) || context.disabledTransports && -1 !== Collections.arrayIndexOf(context.disabledTransports, name));
                transport = enabled ? new transport_strategy_1["default"](name, priority, manager ? manager.getAssistant(transportClass) : transportClass, Collections.extend({
                    key: context.key,
                    encrypted: context.encrypted,
                    timeline: context.timeline,
                    ignoreNullOrigin: context.ignoreNullOrigin
                }, options)) : UnsupportedStrategy;
                var newContext = context.def(context, name, transport)[1];
                return newContext.Transports = context.Transports || {}, newContext.Transports[name] = transport, 
                [ void 0, newContext ];
            },
            transport_manager: returnWithOriginalContext(function(_, options) {
                return new transport_manager_1["default"](options);
            }),
            sequential: returnWithOriginalContext(function(_, options) {
                var strategies = Array.prototype.slice.call(arguments, 2);
                return new sequential_strategy_1["default"](strategies, options);
            }),
            cached: returnWithOriginalContext(function(context, ttl, strategy) {
                return new cached_strategy_1["default"](strategy, context.Transports, {
                    ttl: ttl,
                    timeline: context.timeline,
                    encrypted: context.encrypted
                });
            }),
            first_connected: returnWithOriginalContext(function(_, strategy) {
                return new first_connected_strategy_1["default"](strategy);
            }),
            best_connected_ever: returnWithOriginalContext(function() {
                var strategies = Array.prototype.slice.call(arguments, 1);
                return new best_connected_ever_strategy_1["default"](strategies);
            }),
            delayed: returnWithOriginalContext(function(_, delay, strategy) {
                return new delayed_strategy_1["default"](strategy, {
                    delay: delay
                });
            }),
            "if": returnWithOriginalContext(function(_, test, trueBranch, falseBranch) {
                return new if_strategy_1["default"](test, trueBranch, falseBranch);
            }),
            is_supported: returnWithOriginalContext(function(_, strategy) {
                return function() {
                    return strategy.isSupported();
                };
            })
        };
    }, function(module, exports, __webpack_require__) {
        var factory_1 = __webpack_require__(42), TransportManager = function() {
            function TransportManager(options) {
                this.options = options || {}, this.livesLeft = this.options.lives || 1/0;
            }
            return TransportManager.prototype.getAssistant = function(transport) {
                return factory_1["default"].createAssistantToTheTransportManager(this, transport, {
                    minPingDelay: this.options.minPingDelay,
                    maxPingDelay: this.options.maxPingDelay
                });
            }, TransportManager.prototype.isAlive = function() {
                return this.livesLeft > 0;
            }, TransportManager.prototype.reportDeath = function() {
                this.livesLeft -= 1;
            }, TransportManager;
        }();
        exports.__esModule = !0, exports["default"] = TransportManager;
    }, function(module, exports, __webpack_require__) {
        var assistant_to_the_transport_manager_1 = __webpack_require__(43), handshake_1 = __webpack_require__(44), pusher_authorizer_1 = __webpack_require__(47), timeline_sender_1 = __webpack_require__(48), presence_channel_1 = __webpack_require__(49), private_channel_1 = __webpack_require__(50), channel_1 = __webpack_require__(51), connection_manager_1 = __webpack_require__(53), channels_1 = __webpack_require__(54), Factory = {
            createChannels: function() {
                return new channels_1["default"]();
            },
            createConnectionManager: function(key, options) {
                return new connection_manager_1["default"](key, options);
            },
            createChannel: function(name, pusher) {
                return new channel_1["default"](name, pusher);
            },
            createPrivateChannel: function(name, pusher) {
                return new private_channel_1["default"](name, pusher);
            },
            createPresenceChannel: function(name, pusher) {
                return new presence_channel_1["default"](name, pusher);
            },
            createTimelineSender: function(timeline, options) {
                return new timeline_sender_1["default"](timeline, options);
            },
            createAuthorizer: function(channel, options) {
                return new pusher_authorizer_1["default"](channel, options);
            },
            createHandshake: function(transport, callback) {
                return new handshake_1["default"](transport, callback);
            },
            createAssistantToTheTransportManager: function(manager, transport, options) {
                return new assistant_to_the_transport_manager_1["default"](manager, transport, options);
            }
        };
        exports.__esModule = !0, exports["default"] = Factory;
    }, function(module, exports, __webpack_require__) {
        var util_1 = __webpack_require__(11), Collections = __webpack_require__(9), AssistantToTheTransportManager = function() {
            function AssistantToTheTransportManager(manager, transport, options) {
                this.manager = manager, this.transport = transport, this.minPingDelay = options.minPingDelay, 
                this.maxPingDelay = options.maxPingDelay, this.pingDelay = void 0;
            }
            return AssistantToTheTransportManager.prototype.createConnection = function(name, priority, key, options) {
                var _this = this;
                options = Collections.extend({}, options, {
                    activityTimeout: this.pingDelay
                });
                var connection = this.transport.createConnection(name, priority, key, options), openTimestamp = null, onOpen = function() {
                    connection.unbind("open", onOpen), connection.bind("closed", onClosed), openTimestamp = util_1["default"].now();
                }, onClosed = function(closeEvent) {
                    if (connection.unbind("closed", onClosed), 1002 === closeEvent.code || 1003 === closeEvent.code) _this.manager.reportDeath(); else if (!closeEvent.wasClean && openTimestamp) {
                        var lifespan = util_1["default"].now() - openTimestamp;
                        lifespan < 2 * _this.maxPingDelay && (_this.manager.reportDeath(), _this.pingDelay = Math.max(lifespan / 2, _this.minPingDelay));
                    }
                };
                return connection.bind("open", onOpen), connection;
            }, AssistantToTheTransportManager.prototype.isSupported = function(environment) {
                return this.manager.isAlive() && this.transport.isSupported(environment);
            }, AssistantToTheTransportManager;
        }();
        exports.__esModule = !0, exports["default"] = AssistantToTheTransportManager;
    }, function(module, exports, __webpack_require__) {
        var Collections = __webpack_require__(9), Protocol = __webpack_require__(45), connection_1 = __webpack_require__(46), Handshake = function() {
            function Handshake(transport, callback) {
                this.transport = transport, this.callback = callback, this.bindListeners();
            }
            return Handshake.prototype.close = function() {
                this.unbindListeners(), this.transport.close();
            }, Handshake.prototype.bindListeners = function() {
                var _this = this;
                this.onMessage = function(m) {
                    _this.unbindListeners();
                    var result;
                    try {
                        result = Protocol.processHandshake(m);
                    } catch (e) {
                        return _this.finish("error", {
                            error: e
                        }), void _this.transport.close();
                    }
                    "connected" === result.action ? _this.finish("connected", {
                        connection: new connection_1["default"](result.id, _this.transport),
                        activityTimeout: result.activityTimeout
                    }) : (_this.finish(result.action, {
                        error: result.error
                    }), _this.transport.close());
                }, this.onClosed = function(closeEvent) {
                    _this.unbindListeners();
                    var action = Protocol.getCloseAction(closeEvent) || "backoff", error = Protocol.getCloseError(closeEvent);
                    _this.finish(action, {
                        error: error
                    });
                }, this.transport.bind("message", this.onMessage), this.transport.bind("closed", this.onClosed);
            }, Handshake.prototype.unbindListeners = function() {
                this.transport.unbind("message", this.onMessage), this.transport.unbind("closed", this.onClosed);
            }, Handshake.prototype.finish = function(action, params) {
                this.callback(Collections.extend({
                    transport: this.transport,
                    action: action
                }, params));
            }, Handshake;
        }();
        exports.__esModule = !0, exports["default"] = Handshake;
    }, function(module, exports) {
        exports.decodeMessage = function(message) {
            try {
                var params = JSON.parse(message.data);
                if ("string" == typeof params.data) try {
                    params.data = JSON.parse(params.data);
                } catch (e) {
                    if (!(e instanceof SyntaxError)) throw e;
                }
                return params;
            } catch (e) {
                throw {
                    type: "MessageParseError",
                    error: e,
                    data: message.data
                };
            }
        }, exports.encodeMessage = function(message) {
            return JSON.stringify(message);
        }, exports.processHandshake = function(message) {
            if (message = exports.decodeMessage(message), "pusher:connection_established" === message.event) {
                if (!message.data.activity_timeout) throw "No activity timeout specified in handshake";
                return {
                    action: "connected",
                    id: message.data.socket_id,
                    activityTimeout: 1e3 * message.data.activity_timeout
                };
            }
            if ("pusher:error" === message.event) return {
                action: this.getCloseAction(message.data),
                error: this.getCloseError(message.data)
            };
            throw "Invalid handshake";
        }, exports.getCloseAction = function(closeEvent) {
            return closeEvent.code < 4e3 ? closeEvent.code >= 1002 && closeEvent.code <= 1004 ? "backoff" : null : 4e3 === closeEvent.code ? "ssl_only" : closeEvent.code < 4100 ? "refused" : closeEvent.code < 4200 ? "backoff" : closeEvent.code < 4300 ? "retry" : "refused";
        }, exports.getCloseError = function(closeEvent) {
            return 1e3 !== closeEvent.code && 1001 !== closeEvent.code ? {
                type: "PusherError",
                data: {
                    code: closeEvent.code,
                    message: closeEvent.reason || closeEvent.message
                }
            } : null;
        };
    }, function(module, exports, __webpack_require__) {
        var __extends = this && this.__extends || function(d, b) {
            function __() {
                this.constructor = d;
            }
            for (var p in b) b.hasOwnProperty(p) && (d[p] = b[p]);
            d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, new __());
        }, Collections = __webpack_require__(9), dispatcher_1 = __webpack_require__(23), Protocol = __webpack_require__(45), logger_1 = __webpack_require__(8), Connection = function(_super) {
            function Connection(id, transport) {
                _super.call(this), this.id = id, this.transport = transport, this.activityTimeout = transport.activityTimeout, 
                this.bindListeners();
            }
            return __extends(Connection, _super), Connection.prototype.handlesActivityChecks = function() {
                return this.transport.handlesActivityChecks();
            }, Connection.prototype.send = function(data) {
                return this.transport.send(data);
            }, Connection.prototype.send_event = function(name, data, channel) {
                var message = {
                    event: name,
                    data: data
                };
                return channel && (message.channel = channel), logger_1["default"].debug("Event sent", message), 
                this.send(Protocol.encodeMessage(message));
            }, Connection.prototype.ping = function() {
                this.transport.supportsPing() ? this.transport.ping() : this.send_event("pusher:ping", {});
            }, Connection.prototype.close = function() {
                this.transport.close();
            }, Connection.prototype.bindListeners = function() {
                var _this = this, listeners = {
                    message: function(m) {
                        var message;
                        try {
                            message = Protocol.decodeMessage(m);
                        } catch (e) {
                            _this.emit("error", {
                                type: "MessageParseError",
                                error: e,
                                data: m.data
                            });
                        }
                        if (void 0 !== message) {
                            switch (logger_1["default"].debug("Event recd", message), message.event) {
                              case "pusher:error":
                                _this.emit("error", {
                                    type: "PusherError",
                                    data: message.data
                                });
                                break;

                              case "pusher:ping":
                                _this.emit("ping");
                                break;

                              case "pusher:pong":
                                _this.emit("pong");
                            }
                            _this.emit("message", message);
                        }
                    },
                    activity: function() {
                        _this.emit("activity");
                    },
                    error: function(error) {
                        _this.emit("error", {
                            type: "WebSocketError",
                            error: error
                        });
                    },
                    closed: function(closeEvent) {
                        unbindListeners(), closeEvent && closeEvent.code && _this.handleCloseEvent(closeEvent), 
                        _this.transport = null, _this.emit("closed");
                    }
                }, unbindListeners = function() {
                    Collections.objectApply(listeners, function(listener, event) {
                        _this.transport.unbind(event, listener);
                    });
                };
                Collections.objectApply(listeners, function(listener, event) {
                    _this.transport.bind(event, listener);
                });
            }, Connection.prototype.handleCloseEvent = function(closeEvent) {
                var action = Protocol.getCloseAction(closeEvent), error = Protocol.getCloseError(closeEvent);
                error && this.emit("error", error), action && this.emit(action);
            }, Connection;
        }(dispatcher_1["default"]);
        exports.__esModule = !0, exports["default"] = Connection;
    }, function(module, exports, __webpack_require__) {
        var runtime_1 = __webpack_require__(2), Authorizer = function() {
            function Authorizer(channel, options) {
                this.channel = channel;
                var authTransport = options.authTransport;
                if ("undefined" == typeof runtime_1["default"].getAuthorizers()[authTransport]) throw "'" + authTransport + "' is not a recognized auth transport";
                this.type = authTransport, this.options = options, this.authOptions = (options || {}).auth || {};
            }
            return Authorizer.prototype.composeQuery = function(socketId) {
                var query = "socket_id=" + encodeURIComponent(socketId) + "&channel_name=" + encodeURIComponent(this.channel.name);
                for (var i in this.authOptions.params) query += "&" + encodeURIComponent(i) + "=" + encodeURIComponent(this.authOptions.params[i]);
                return query;
            }, Authorizer.prototype.authorize = function(socketId, callback) {
                return Authorizer.authorizers = Authorizer.authorizers || runtime_1["default"].getAuthorizers(), 
                Authorizer.authorizers[this.type].call(this, runtime_1["default"], socketId, callback);
            }, Authorizer;
        }();
        exports.__esModule = !0, exports["default"] = Authorizer;
    }, function(module, exports, __webpack_require__) {
        var runtime_1 = __webpack_require__(2), TimelineSender = function() {
            function TimelineSender(timeline, options) {
                this.timeline = timeline, this.options = options || {};
            }
            return TimelineSender.prototype.send = function(encrypted, callback) {
                this.timeline.isEmpty() || this.timeline.send(runtime_1["default"].TimelineTransport.getAgent(this, encrypted), callback);
            }, TimelineSender;
        }();
        exports.__esModule = !0, exports["default"] = TimelineSender;
    }, function(module, exports, __webpack_require__) {
        var __extends = this && this.__extends || function(d, b) {
            function __() {
                this.constructor = d;
            }
            for (var p in b) b.hasOwnProperty(p) && (d[p] = b[p]);
            d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, new __());
        }, private_channel_1 = __webpack_require__(50), logger_1 = __webpack_require__(8), members_1 = __webpack_require__(52), PresenceChannel = function(_super) {
            function PresenceChannel(name, pusher) {
                _super.call(this, name, pusher), this.members = new members_1["default"]();
            }
            return __extends(PresenceChannel, _super), PresenceChannel.prototype.authorize = function(socketId, callback) {
                var _this = this;
                _super.prototype.authorize.call(this, socketId, function(error, authData) {
                    if (!error) {
                        if (void 0 === authData.channel_data) return logger_1["default"].warn("Invalid auth response for channel '" + _this.name + "', expected 'channel_data' field"), 
                        void callback("Invalid auth response");
                        var channelData = JSON.parse(authData.channel_data);
                        _this.members.setMyID(channelData.user_id);
                    }
                    callback(error, authData);
                });
            }, PresenceChannel.prototype.handleEvent = function(event, data) {
                switch (event) {
                  case "pusher_internal:subscription_succeeded":
                    this.members.onSubscription(data), this.subscribed = !0, this.emit("pusher:subscription_succeeded", this.members);
                    break;

                  case "pusher_internal:member_added":
                    var addedMember = this.members.addMember(data);
                    this.emit("pusher:member_added", addedMember);
                    break;

                  case "pusher_internal:member_removed":
                    var removedMember = this.members.removeMember(data);
                    removedMember && this.emit("pusher:member_removed", removedMember);
                    break;

                  default:
                    private_channel_1["default"].prototype.handleEvent.call(this, event, data);
                }
            }, PresenceChannel.prototype.disconnect = function() {
                this.members.reset(), _super.prototype.disconnect.call(this);
            }, PresenceChannel;
        }(private_channel_1["default"]);
        exports.__esModule = !0, exports["default"] = PresenceChannel;
    }, function(module, exports, __webpack_require__) {
        var __extends = this && this.__extends || function(d, b) {
            function __() {
                this.constructor = d;
            }
            for (var p in b) b.hasOwnProperty(p) && (d[p] = b[p]);
            d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, new __());
        }, factory_1 = __webpack_require__(42), channel_1 = __webpack_require__(51), PrivateChannel = function(_super) {
            function PrivateChannel() {
                _super.apply(this, arguments);
            }
            return __extends(PrivateChannel, _super), PrivateChannel.prototype.authorize = function(socketId, callback) {
                var authorizer = factory_1["default"].createAuthorizer(this, this.pusher.config);
                return authorizer.authorize(socketId, callback);
            }, PrivateChannel;
        }(channel_1["default"]);
        exports.__esModule = !0, exports["default"] = PrivateChannel;
    }, function(module, exports, __webpack_require__) {
        var __extends = this && this.__extends || function(d, b) {
            function __() {
                this.constructor = d;
            }
            for (var p in b) b.hasOwnProperty(p) && (d[p] = b[p]);
            d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, new __());
        }, dispatcher_1 = __webpack_require__(23), Errors = __webpack_require__(30), logger_1 = __webpack_require__(8), Channel = function(_super) {
            function Channel(name, pusher) {
                _super.call(this, function(event) {
                    logger_1["default"].debug("No callbacks on " + name + " for " + event);
                }), this.name = name, this.pusher = pusher, this.subscribed = !1;
            }
            return __extends(Channel, _super), Channel.prototype.authorize = function(socketId, callback) {
                return callback(!1, {});
            }, Channel.prototype.trigger = function(event, data) {
                if (0 !== event.indexOf("client-")) throw new Errors.BadEventName("Event '" + event + "' does not start with 'client-'");
                return this.pusher.send_event(event, data, this.name);
            }, Channel.prototype.disconnect = function() {
                this.subscribed = !1;
            }, Channel.prototype.handleEvent = function(event, data) {
                0 === event.indexOf("pusher_internal:") ? "pusher_internal:subscription_succeeded" === event && (this.subscribed = !0, 
                this.emit("pusher:subscription_succeeded", data)) : this.emit(event, data);
            }, Channel.prototype.subscribe = function() {
                var _this = this;
                this.authorize(this.pusher.connection.socket_id, function(error, data) {
                    error ? _this.handleEvent("pusher:subscription_error", data) : _this.pusher.send_event("pusher:subscribe", {
                        auth: data.auth,
                        channel_data: data.channel_data,
                        channel: _this.name
                    });
                });
            }, Channel.prototype.unsubscribe = function() {
                this.pusher.send_event("pusher:unsubscribe", {
                    channel: this.name
                });
            }, Channel;
        }(dispatcher_1["default"]);
        exports.__esModule = !0, exports["default"] = Channel;
    }, function(module, exports, __webpack_require__) {
        var Collections = __webpack_require__(9), Members = function() {
            function Members() {
                this.reset();
            }
            return Members.prototype.get = function(id) {
                return Object.prototype.hasOwnProperty.call(this.members, id) ? {
                    id: id,
                    info: this.members[id]
                } : null;
            }, Members.prototype.each = function(callback) {
                var _this = this;
                Collections.objectApply(this.members, function(member, id) {
                    callback(_this.get(id));
                });
            }, Members.prototype.setMyID = function(id) {
                this.myID = id;
            }, Members.prototype.onSubscription = function(subscriptionData) {
                this.members = subscriptionData.presence.hash, this.count = subscriptionData.presence.count, 
                this.me = this.get(this.myID);
            }, Members.prototype.addMember = function(memberData) {
                return null === this.get(memberData.user_id) && this.count++, this.members[memberData.user_id] = memberData.user_info, 
                this.get(memberData.user_id);
            }, Members.prototype.removeMember = function(memberData) {
                var member = this.get(memberData.user_id);
                return member && (delete this.members[memberData.user_id], this.count--), member;
            }, Members.prototype.reset = function() {
                this.members = {}, this.count = 0, this.myID = null, this.me = null;
            }, Members;
        }();
        exports.__esModule = !0, exports["default"] = Members;
    }, function(module, exports, __webpack_require__) {
        var __extends = this && this.__extends || function(d, b) {
            function __() {
                this.constructor = d;
            }
            for (var p in b) b.hasOwnProperty(p) && (d[p] = b[p]);
            d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, new __());
        }, dispatcher_1 = __webpack_require__(23), timers_1 = __webpack_require__(12), logger_1 = __webpack_require__(8), Collections = __webpack_require__(9), runtime_1 = __webpack_require__(2), ConnectionManager = function(_super) {
            function ConnectionManager(key, options) {
                var _this = this;
                _super.call(this), this.key = key, this.options = options || {}, this.state = "initialized", 
                this.connection = null, this.encrypted = !!options.encrypted, this.timeline = this.options.timeline, 
                this.connectionCallbacks = this.buildConnectionCallbacks(), this.errorCallbacks = this.buildErrorCallbacks(), 
                this.handshakeCallbacks = this.buildHandshakeCallbacks(this.errorCallbacks);
                var Network = runtime_1["default"].getNetwork();
                Network.bind("online", function() {
                    _this.timeline.info({
                        netinfo: "online"
                    }), ("connecting" === _this.state || "unavailable" === _this.state) && _this.retryIn(0);
                }), Network.bind("offline", function() {
                    _this.timeline.info({
                        netinfo: "offline"
                    }), _this.connection && _this.sendActivityCheck();
                }), this.updateStrategy();
            }
            return __extends(ConnectionManager, _super), ConnectionManager.prototype.connect = function() {
                if (!this.connection && !this.runner) {
                    if (!this.strategy.isSupported()) return void this.updateState("failed");
                    this.updateState("connecting"), this.startConnecting(), this.setUnavailableTimer();
                }
            }, ConnectionManager.prototype.send = function(data) {
                return this.connection ? this.connection.send(data) : !1;
            }, ConnectionManager.prototype.send_event = function(name, data, channel) {
                return this.connection ? this.connection.send_event(name, data, channel) : !1;
            }, ConnectionManager.prototype.disconnect = function() {
                this.disconnectInternally(), this.updateState("disconnected");
            }, ConnectionManager.prototype.isEncrypted = function() {
                return this.encrypted;
            }, ConnectionManager.prototype.startConnecting = function() {
                var _this = this, callback = function(error, handshake) {
                    error ? _this.runner = _this.strategy.connect(0, callback) : "error" === handshake.action ? (_this.emit("error", {
                        type: "HandshakeError",
                        error: handshake.error
                    }), _this.timeline.error({
                        handshakeError: handshake.error
                    })) : (_this.abortConnecting(), _this.handshakeCallbacks[handshake.action](handshake));
                };
                this.runner = this.strategy.connect(0, callback);
            }, ConnectionManager.prototype.abortConnecting = function() {
                this.runner && (this.runner.abort(), this.runner = null);
            }, ConnectionManager.prototype.disconnectInternally = function() {
                if (this.abortConnecting(), this.clearRetryTimer(), this.clearUnavailableTimer(), 
                this.connection) {
                    var connection = this.abandonConnection();
                    connection.close();
                }
            }, ConnectionManager.prototype.updateStrategy = function() {
                this.strategy = this.options.getStrategy({
                    key: this.key,
                    timeline: this.timeline,
                    encrypted: this.encrypted
                });
            }, ConnectionManager.prototype.retryIn = function(delay) {
                var _this = this;
                this.timeline.info({
                    action: "retry",
                    delay: delay
                }), delay > 0 && this.emit("connecting_in", Math.round(delay / 1e3)), this.retryTimer = new timers_1.OneOffTimer(delay || 0, function() {
                    _this.disconnectInternally(), _this.connect();
                });
            }, ConnectionManager.prototype.clearRetryTimer = function() {
                this.retryTimer && (this.retryTimer.ensureAborted(), this.retryTimer = null);
            }, ConnectionManager.prototype.setUnavailableTimer = function() {
                var _this = this;
                this.unavailableTimer = new timers_1.OneOffTimer(this.options.unavailableTimeout, function() {
                    _this.updateState("unavailable");
                });
            }, ConnectionManager.prototype.clearUnavailableTimer = function() {
                this.unavailableTimer && this.unavailableTimer.ensureAborted();
            }, ConnectionManager.prototype.sendActivityCheck = function() {
                var _this = this;
                this.stopActivityCheck(), this.connection.ping(), this.activityTimer = new timers_1.OneOffTimer(this.options.pongTimeout, function() {
                    _this.timeline.error({
                        pong_timed_out: _this.options.pongTimeout
                    }), _this.retryIn(0);
                });
            }, ConnectionManager.prototype.resetActivityCheck = function() {
                var _this = this;
                this.stopActivityCheck(), this.connection.handlesActivityChecks() || (this.activityTimer = new timers_1.OneOffTimer(this.activityTimeout, function() {
                    _this.sendActivityCheck();
                }));
            }, ConnectionManager.prototype.stopActivityCheck = function() {
                this.activityTimer && this.activityTimer.ensureAborted();
            }, ConnectionManager.prototype.buildConnectionCallbacks = function() {
                var _this = this;
                return {
                    message: function(message) {
                        _this.resetActivityCheck(), _this.emit("message", message);
                    },
                    ping: function() {
                        _this.send_event("pusher:pong", {});
                    },
                    activity: function() {
                        _this.resetActivityCheck();
                    },
                    error: function(error) {
                        _this.emit("error", {
                            type: "WebSocketError",
                            error: error
                        });
                    },
                    closed: function() {
                        _this.abandonConnection(), _this.shouldRetry() && _this.retryIn(1e3);
                    }
                };
            }, ConnectionManager.prototype.buildHandshakeCallbacks = function(errorCallbacks) {
                var _this = this;
                return Collections.extend({}, errorCallbacks, {
                    connected: function(handshake) {
                        _this.activityTimeout = Math.min(_this.options.activityTimeout, handshake.activityTimeout, handshake.connection.activityTimeout || 1/0), 
                        _this.clearUnavailableTimer(), _this.setConnection(handshake.connection), _this.socket_id = _this.connection.id, 
                        _this.updateState("connected", {
                            socket_id: _this.socket_id
                        });
                    }
                });
            }, ConnectionManager.prototype.buildErrorCallbacks = function() {
                var _this = this, withErrorEmitted = function(callback) {
                    return function(result) {
                        result.error && _this.emit("error", {
                            type: "WebSocketError",
                            error: result.error
                        }), callback(result);
                    };
                };
                return {
                    ssl_only: withErrorEmitted(function() {
                        _this.encrypted = !0, _this.updateStrategy(), _this.retryIn(0);
                    }),
                    refused: withErrorEmitted(function() {
                        _this.disconnect();
                    }),
                    backoff: withErrorEmitted(function() {
                        _this.retryIn(1e3);
                    }),
                    retry: withErrorEmitted(function() {
                        _this.retryIn(0);
                    })
                };
            }, ConnectionManager.prototype.setConnection = function(connection) {
                this.connection = connection;
                for (var event in this.connectionCallbacks) this.connection.bind(event, this.connectionCallbacks[event]);
                this.resetActivityCheck();
            }, ConnectionManager.prototype.abandonConnection = function() {
                if (this.connection) {
                    this.stopActivityCheck();
                    for (var event in this.connectionCallbacks) this.connection.unbind(event, this.connectionCallbacks[event]);
                    var connection = this.connection;
                    return this.connection = null, connection;
                }
            }, ConnectionManager.prototype.updateState = function(newState, data) {
                var previousState = this.state;
                if (this.state = newState, previousState !== newState) {
                    var newStateDescription = newState;
                    "connected" === newStateDescription && (newStateDescription += " with new socket ID " + data.socket_id), 
                    logger_1["default"].debug("State changed", previousState + " -> " + newStateDescription), 
                    this.timeline.info({
                        state: newState,
                        params: data
                    }), this.emit("state_change", {
                        previous: previousState,
                        current: newState
                    }), this.emit(newState, data);
                }
            }, ConnectionManager.prototype.shouldRetry = function() {
                return "connecting" === this.state || "connected" === this.state;
            }, ConnectionManager;
        }(dispatcher_1["default"]);
        exports.__esModule = !0, exports["default"] = ConnectionManager;
    }, function(module, exports, __webpack_require__) {
        function createChannel(name, pusher) {
            return 0 === name.indexOf("private-") ? factory_1["default"].createPrivateChannel(name, pusher) : 0 === name.indexOf("presence-") ? factory_1["default"].createPresenceChannel(name, pusher) : factory_1["default"].createChannel(name, pusher);
        }
        var Collections = __webpack_require__(9), factory_1 = __webpack_require__(42), Channels = function() {
            function Channels() {
                this.channels = {};
            }
            return Channels.prototype.add = function(name, pusher) {
                return this.channels[name] || (this.channels[name] = createChannel(name, pusher)), 
                this.channels[name];
            }, Channels.prototype.all = function() {
                return Collections.values(this.channels);
            }, Channels.prototype.find = function(name) {
                return this.channels[name];
            }, Channels.prototype.remove = function(name) {
                var channel = this.channels[name];
                return delete this.channels[name], channel;
            }, Channels.prototype.disconnect = function() {
                Collections.objectApply(this.channels, function(channel) {
                    channel.disconnect();
                });
            }, Channels;
        }();
        exports.__esModule = !0, exports["default"] = Channels;
    }, function(module, exports, __webpack_require__) {
        function failAttempt(error, callback) {
            return util_1["default"].defer(function() {
                callback(error);
            }), {
                abort: function() {},
                forceMinPriority: function() {}
            };
        }
        var factory_1 = __webpack_require__(42), util_1 = __webpack_require__(11), Errors = __webpack_require__(30), Collections = __webpack_require__(9), TransportStrategy = function() {
            function TransportStrategy(name, priority, transport, options) {
                this.name = name, this.priority = priority, this.transport = transport, this.options = options || {};
            }
            return TransportStrategy.prototype.isSupported = function() {
                return this.transport.isSupported({
                    encrypted: this.options.encrypted
                });
            }, TransportStrategy.prototype.connect = function(minPriority, callback) {
                var _this = this;
                if (!this.isSupported()) return failAttempt(new Errors.UnsupportedStrategy(), callback);
                if (this.priority < minPriority) return failAttempt(new Errors.TransportPriorityTooLow(), callback);
                var connected = !1, transport = this.transport.createConnection(this.name, this.priority, this.options.key, this.options), handshake = null, onInitialized = function() {
                    transport.unbind("initialized", onInitialized), transport.connect();
                }, onOpen = function() {
                    handshake = factory_1["default"].createHandshake(transport, function(result) {
                        connected = !0, unbindListeners(), callback(null, result);
                    });
                }, onError = function(error) {
                    unbindListeners(), callback(error);
                }, onClosed = function() {
                    unbindListeners();
                    var serializedTransport;
                    serializedTransport = Collections.safeJSONStringify(transport), callback(new Errors.TransportClosed(serializedTransport));
                }, unbindListeners = function() {
                    transport.unbind("initialized", onInitialized), transport.unbind("open", onOpen), 
                    transport.unbind("error", onError), transport.unbind("closed", onClosed);
                };
                return transport.bind("initialized", onInitialized), transport.bind("open", onOpen), 
                transport.bind("error", onError), transport.bind("closed", onClosed), transport.initialize(), 
                {
                    abort: function() {
                        connected || (unbindListeners(), handshake ? handshake.close() : transport.close());
                    },
                    forceMinPriority: function(p) {
                        connected || _this.priority < p && (handshake ? handshake.close() : transport.close());
                    }
                };
            }, TransportStrategy;
        }();
        exports.__esModule = !0, exports["default"] = TransportStrategy;
    }, function(module, exports, __webpack_require__) {
        var Collections = __webpack_require__(9), util_1 = __webpack_require__(11), timers_1 = __webpack_require__(12), SequentialStrategy = function() {
            function SequentialStrategy(strategies, options) {
                this.strategies = strategies, this.loop = Boolean(options.loop), this.failFast = Boolean(options.failFast), 
                this.timeout = options.timeout, this.timeoutLimit = options.timeoutLimit;
            }
            return SequentialStrategy.prototype.isSupported = function() {
                return Collections.any(this.strategies, util_1["default"].method("isSupported"));
            }, SequentialStrategy.prototype.connect = function(minPriority, callback) {
                var _this = this, strategies = this.strategies, current = 0, timeout = this.timeout, runner = null, tryNextStrategy = function(error, handshake) {
                    handshake ? callback(null, handshake) : (current += 1, _this.loop && (current %= strategies.length), 
                    current < strategies.length ? (timeout && (timeout = 2 * timeout, _this.timeoutLimit && (timeout = Math.min(timeout, _this.timeoutLimit))), 
                    runner = _this.tryStrategy(strategies[current], minPriority, {
                        timeout: timeout,
                        failFast: _this.failFast
                    }, tryNextStrategy)) : callback(!0));
                };
                return runner = this.tryStrategy(strategies[current], minPriority, {
                    timeout: timeout,
                    failFast: this.failFast
                }, tryNextStrategy), {
                    abort: function() {
                        runner.abort();
                    },
                    forceMinPriority: function(p) {
                        minPriority = p, runner && runner.forceMinPriority(p);
                    }
                };
            }, SequentialStrategy.prototype.tryStrategy = function(strategy, minPriority, options, callback) {
                var timer = null, runner = null;
                return options.timeout > 0 && (timer = new timers_1.OneOffTimer(options.timeout, function() {
                    runner.abort(), callback(!0);
                })), runner = strategy.connect(minPriority, function(error, handshake) {
                    error && timer && timer.isRunning() && !options.failFast || (timer && timer.ensureAborted(), 
                    callback(error, handshake));
                }), {
                    abort: function() {
                        timer && timer.ensureAborted(), runner.abort();
                    },
                    forceMinPriority: function(p) {
                        runner.forceMinPriority(p);
                    }
                };
            }, SequentialStrategy;
        }();
        exports.__esModule = !0, exports["default"] = SequentialStrategy;
    }, function(module, exports, __webpack_require__) {
        function connect(strategies, minPriority, callbackBuilder) {
            var runners = Collections.map(strategies, function(strategy, i, _, rs) {
                return strategy.connect(minPriority, callbackBuilder(i, rs));
            });
            return {
                abort: function() {
                    Collections.apply(runners, abortRunner);
                },
                forceMinPriority: function(p) {
                    Collections.apply(runners, function(runner) {
                        runner.forceMinPriority(p);
                    });
                }
            };
        }
        function allRunnersFailed(runners) {
            return Collections.all(runners, function(runner) {
                return Boolean(runner.error);
            });
        }
        function abortRunner(runner) {
            runner.error || runner.aborted || (runner.abort(), runner.aborted = !0);
        }
        var Collections = __webpack_require__(9), util_1 = __webpack_require__(11), BestConnectedEverStrategy = function() {
            function BestConnectedEverStrategy(strategies) {
                this.strategies = strategies;
            }
            return BestConnectedEverStrategy.prototype.isSupported = function() {
                return Collections.any(this.strategies, util_1["default"].method("isSupported"));
            }, BestConnectedEverStrategy.prototype.connect = function(minPriority, callback) {
                return connect(this.strategies, minPriority, function(i, runners) {
                    return function(error, handshake) {
                        return runners[i].error = error, error ? void (allRunnersFailed(runners) && callback(!0)) : (Collections.apply(runners, function(runner) {
                            runner.forceMinPriority(handshake.transport.priority);
                        }), void callback(null, handshake));
                    };
                });
            }, BestConnectedEverStrategy;
        }();
        exports.__esModule = !0, exports["default"] = BestConnectedEverStrategy;
    }, function(module, exports, __webpack_require__) {
        function getTransportCacheKey(encrypted) {
            return "pusherTransport" + (encrypted ? "Encrypted" : "Unencrypted");
        }
        function fetchTransportCache(encrypted) {
            var storage = runtime_1["default"].getLocalStorage();
            if (storage) try {
                var serializedCache = storage[getTransportCacheKey(encrypted)];
                if (serializedCache) return JSON.parse(serializedCache);
            } catch (e) {
                flushTransportCache(encrypted);
            }
            return null;
        }
        function storeTransportCache(encrypted, transport, latency) {
            var storage = runtime_1["default"].getLocalStorage();
            if (storage) try {
                storage[getTransportCacheKey(encrypted)] = Collections.safeJSONStringify({
                    timestamp: util_1["default"].now(),
                    transport: transport,
                    latency: latency
                });
            } catch (e) {}
        }
        function flushTransportCache(encrypted) {
            var storage = runtime_1["default"].getLocalStorage();
            if (storage) try {
                delete storage[getTransportCacheKey(encrypted)];
            } catch (e) {}
        }
        var util_1 = __webpack_require__(11), runtime_1 = __webpack_require__(2), sequential_strategy_1 = __webpack_require__(56), Collections = __webpack_require__(9), CachedStrategy = function() {
            function CachedStrategy(strategy, transports, options) {
                this.strategy = strategy, this.transports = transports, this.ttl = options.ttl || 18e5, 
                this.encrypted = options.encrypted, this.timeline = options.timeline;
            }
            return CachedStrategy.prototype.isSupported = function() {
                return this.strategy.isSupported();
            }, CachedStrategy.prototype.connect = function(minPriority, callback) {
                var encrypted = this.encrypted, info = fetchTransportCache(encrypted), strategies = [ this.strategy ];
                if (info && info.timestamp + this.ttl >= util_1["default"].now()) {
                    var transport = this.transports[info.transport];
                    transport && (this.timeline.info({
                        cached: !0,
                        transport: info.transport,
                        latency: info.latency
                    }), strategies.push(new sequential_strategy_1["default"]([ transport ], {
                        timeout: 2 * info.latency + 1e3,
                        failFast: !0
                    })));
                }
                var startTimestamp = util_1["default"].now(), runner = strategies.pop().connect(minPriority, function cb(error, handshake) {
                    error ? (flushTransportCache(encrypted), strategies.length > 0 ? (startTimestamp = util_1["default"].now(), 
                    runner = strategies.pop().connect(minPriority, cb)) : callback(error)) : (storeTransportCache(encrypted, handshake.transport.name, util_1["default"].now() - startTimestamp), 
                    callback(null, handshake));
                });
                return {
                    abort: function() {
                        runner.abort();
                    },
                    forceMinPriority: function(p) {
                        minPriority = p, runner && runner.forceMinPriority(p);
                    }
                };
            }, CachedStrategy;
        }();
        exports.__esModule = !0, exports["default"] = CachedStrategy;
    }, function(module, exports, __webpack_require__) {
        var timers_1 = __webpack_require__(12), DelayedStrategy = function() {
            function DelayedStrategy(strategy, _a) {
                var number = _a.delay;
                this.strategy = strategy, this.options = {
                    delay: number
                };
            }
            return DelayedStrategy.prototype.isSupported = function() {
                return this.strategy.isSupported();
            }, DelayedStrategy.prototype.connect = function(minPriority, callback) {
                var runner, strategy = this.strategy, timer = new timers_1.OneOffTimer(this.options.delay, function() {
                    runner = strategy.connect(minPriority, callback);
                });
                return {
                    abort: function() {
                        timer.ensureAborted(), runner && runner.abort();
                    },
                    forceMinPriority: function(p) {
                        minPriority = p, runner && runner.forceMinPriority(p);
                    }
                };
            }, DelayedStrategy;
        }();
        exports.__esModule = !0, exports["default"] = DelayedStrategy;
    }, function(module, exports) {
        var IfStrategy = function() {
            function IfStrategy(test, trueBranch, falseBranch) {
                this.test = test, this.trueBranch = trueBranch, this.falseBranch = falseBranch;
            }
            return IfStrategy.prototype.isSupported = function() {
                var branch = this.test() ? this.trueBranch : this.falseBranch;
                return branch.isSupported();
            }, IfStrategy.prototype.connect = function(minPriority, callback) {
                var branch = this.test() ? this.trueBranch : this.falseBranch;
                return branch.connect(minPriority, callback);
            }, IfStrategy;
        }();
        exports.__esModule = !0, exports["default"] = IfStrategy;
    }, function(module, exports) {
        var FirstConnectedStrategy = function() {
            function FirstConnectedStrategy(strategy) {
                this.strategy = strategy;
            }
            return FirstConnectedStrategy.prototype.isSupported = function() {
                return this.strategy.isSupported();
            }, FirstConnectedStrategy.prototype.connect = function(minPriority, callback) {
                var runner = this.strategy.connect(minPriority, function(error, handshake) {
                    handshake && runner.abort(), callback(error, handshake);
                });
                return runner;
            }, FirstConnectedStrategy;
        }();
        exports.__esModule = !0, exports["default"] = FirstConnectedStrategy;
    }, function(module, exports, __webpack_require__) {
        var defaults_1 = __webpack_require__(5);
        exports.getGlobalConfig = function() {
            return {
                wsHost: defaults_1["default"].host,
                wsPort: defaults_1["default"].ws_port,
                wssPort: defaults_1["default"].wss_port,
                httpHost: defaults_1["default"].sockjs_host,
                httpPort: defaults_1["default"].sockjs_http_port,
                httpsPort: defaults_1["default"].sockjs_https_port,
                httpPath: defaults_1["default"].sockjs_path,
                statsHost: defaults_1["default"].stats_host,
                authEndpoint: defaults_1["default"].channel_auth_endpoint,
                authTransport: defaults_1["default"].channel_auth_transport,
                activity_timeout: defaults_1["default"].activity_timeout,
                pong_timeout: defaults_1["default"].pong_timeout,
                unavailable_timeout: defaults_1["default"].unavailable_timeout
            };
        }, exports.getClusterConfig = function(clusterName) {
            return {
                wsHost: "ws-" + clusterName + ".pusher.com",
                httpHost: "sockjs-" + clusterName + ".pusher.com"
            };
        };
    } ]);
}), function(root, factory) {
    "object" == typeof exports && "object" == typeof module ? module.exports = factory() : "function" == typeof define && define.amd ? define("pubnub", [], factory) : "object" == typeof exports ? exports.PUBNUB = factory() : root.PUBNUB = factory();
}(this, function() {
    return function(modules) {
        function __webpack_require__(moduleId) {
            if (installedModules[moduleId]) return installedModules[moduleId].exports;
            var module = installedModules[moduleId] = {
                exports: {},
                id: moduleId,
                loaded: !1
            };
            return modules[moduleId].call(module.exports, module, module.exports, __webpack_require__), 
            module.loaded = !0, module.exports;
        }
        var installedModules = {};
        return __webpack_require__.m = modules, __webpack_require__.c = installedModules, 
        __webpack_require__.p = "", __webpack_require__(0);
    }([ function(module, exports, __webpack_require__) {
        function get_hmac_SHA256(data, key) {
            var hash = CryptoJS.HmacSHA256(data, key);
            return hash.toString(CryptoJS.enc.Base64);
        }
        function $(id) {
            return document.getElementById(id);
        }
        function error(message) {
            console.error(message);
        }
        function search(elements, start) {
            var list = [];
            return pubNubCore.each(elements.split(/\s+/), function(el) {
                pubNubCore.each((start || document).getElementsByTagName(el), function(node) {
                    list.push(node);
                });
            }), list;
        }
        function bind(type, el, fun) {
            pubNubCore.each(type.split(","), function(etype) {
                var rapfun = function(e) {
                    e || (e = window.event), fun(e) || (e.cancelBubble = !0, e.preventDefault && e.preventDefault(), 
                    e.stopPropagation && e.stopPropagation());
                };
                el.addEventListener ? el.addEventListener(etype, rapfun, !1) : el.attachEvent ? el.attachEvent("on" + etype, rapfun) : el["on" + etype] = rapfun;
            });
        }
        function head() {
            return search("head")[0];
        }
        function attr(node, attribute, value) {
            return value ? void node.setAttribute(attribute, value) : node && node.getAttribute && node.getAttribute(attribute);
        }
        function css(element, styles) {
            for (var style in styles) if (styles.hasOwnProperty(style)) try {
                element.style[style] = styles[style] + ("|width|height|top|left|".indexOf(style) > 0 && "number" == typeof styles[style] ? "px" : "");
            } catch (e) {
                return;
            }
        }
        function create(element) {
            return document.createElement(element);
        }
        function xdr(setup) {
            var xhr, timer, complete = 0, loaded = 0, async = !0, xhrtme = setup.timeout || pubNubCore.DEF_TIMEOUT, data = setup.data || {}, fail = setup.fail || function() {}, success = setup.success || function() {}, done = function(failed, response) {
                complete || (complete = 1, clearTimeout(timer), xhr && (xhr.onerror = xhr.onload = null, 
                xhr.abort && xhr.abort(), xhr = null), failed && fail(response));
            }, finished = function() {
                if (!loaded) {
                    var response;
                    loaded = 1, clearTimeout(timer);
                    try {
                        response = JSON.parse(xhr.responseText);
                    } catch (r) {
                        return done(1);
                    }
                    success(response);
                }
            };
            timer = pubNubCore.timeout(function() {
                done(1);
            }, xhrtme);
            try {
                xhr = "undefined" != typeof XDomainRequest && new XDomainRequest() || new XMLHttpRequest(), 
                xhr.onerror = xhr.onabort = function() {
                    done(1, xhr.responseText || {
                        error: "Network Connection Error"
                    });
                }, xhr.onload = xhr.onloadend = finished, data.pnsdk = PNSDK;
                var url = pubNubCore.build_url(setup.url, data);
                xhr.open("GET", url, async), async && (xhr.timeout = xhrtme), xhr.send();
            } catch (eee) {
                done(1, {
                    error: "XHR Failed",
                    stacktrace: eee
                });
            }
            return done;
        }
        function _is_online() {
            if (!("onLine" in navigator)) return 1;
            try {
                return navigator.onLine;
            } catch (e) {
                return !0;
            }
        }
        function sendBeacon(url) {
            return "sendBeacon" in navigator ? navigator.sendBeacon(url) : !1;
        }
        __webpack_require__(1);
        var crypto_obj = __webpack_require__(2), CryptoJS = __webpack_require__(3), packageJSON = __webpack_require__(4), pubNubCore = __webpack_require__(5), WS = __webpack_require__(8), PNSDK = "PubNub-JS-Web/" + packageJSON.version;
        window.console || (window.console = window.console || {}), console.log || (console.log = console.error = (window.opera || {}).postError || function() {});
        var db = function() {
            var store = {}, ls = !1;
            try {
                ls = window.localStorage;
            } catch (e) {
                return;
            }
            var cookieGet = function(key) {
                return -1 === document.cookie.indexOf(key) ? null : ((document.cookie || "").match(RegExp(key + "=([^;]+)")) || [])[1] || null;
            }, cookieSet = function(key, value) {
                document.cookie = key + "=" + value + "; expires=Thu, 1 Aug " + (new Date().getFullYear() + 1) + " 20:00:00 UTC; path=/";
            }, cookieTest = function() {
                try {
                    return cookieSet("pnctest", "1"), "1" === cookieGet("pnctest");
                } catch (e) {
                    return !1;
                }
            }();
            return {
                get: function(key) {
                    try {
                        return ls ? ls.getItem(key) : cookieTest ? cookieGet(key) : store[key];
                    } catch (e) {
                        return store[key];
                    }
                },
                set: function(key, value) {
                    try {
                        if (ls) return ls.setItem(key, value) && 0;
                        cookieTest && cookieSet(key, value), store[key] = value;
                    } catch (e) {
                        store[key] = value;
                    }
                }
            };
        }(), events = {
            list: {},
            unbind: function(name) {
                events.list[name] = [];
            },
            bind: function(name, fun) {
                (events.list[name] = events.list[name] || []).push(fun);
            },
            fire: function(name, data) {
                pubNubCore.each(events.list[name] || [], function(fun) {
                    fun(data);
                });
            }
        }, CREATE_PUBNUB = function(setup) {
            var leave_on_unload = setup.leave_on_unload || 0;
            setup.xdr = xdr, setup.db = db, setup.error = setup.error || error, setup._is_online = _is_online, 
            setup.hmac_SHA256 = get_hmac_SHA256, setup.crypto_obj = crypto_obj(), setup.sendBeacon = sendBeacon, 
            setup.params = {
                pnsdk: PNSDK
            };
            var SELF = function(setup) {
                return CREATE_PUBNUB(setup);
            }, PN = pubNubCore.PN_API(setup);
            for (var prop in PN) PN.hasOwnProperty(prop) && (SELF[prop] = PN[prop]);
            return SELF.css = css, SELF.$ = $, SELF.create = create, SELF.bind = bind, SELF.head = head, 
            SELF.search = search, SELF.attr = attr, SELF.events = events, SELF.init = SELF, 
            SELF.secure = SELF, SELF.crypto_obj = crypto_obj(), SELF.WS = WS, SELF.PNmessage = pubNubCore.PNmessage, 
            SELF.supplant = pubNubCore.supplant, bind("beforeunload", window, function() {
                return leave_on_unload && SELF["each-channel"](function(ch) {
                    SELF.LEAVE(ch.name, 0);
                }), !0;
            }), SELF.ready(), setup.notest ? SELF : (bind("offline", window, SELF.offline), 
            bind("offline", document, SELF.offline), SELF);
        };
        CREATE_PUBNUB.init = CREATE_PUBNUB, CREATE_PUBNUB.secure = CREATE_PUBNUB, CREATE_PUBNUB.crypto_obj = crypto_obj(), 
        CREATE_PUBNUB.WS = WS, CREATE_PUBNUB.db = db, CREATE_PUBNUB.PNmessage = pubNubCore.PNmessage, 
        CREATE_PUBNUB.uuid = pubNubCore.uuid, CREATE_PUBNUB.css = css, CREATE_PUBNUB.$ = $, 
        CREATE_PUBNUB.create = $, CREATE_PUBNUB.bind = bind, CREATE_PUBNUB.head = head, 
        CREATE_PUBNUB.search = search, CREATE_PUBNUB.attr = attr, CREATE_PUBNUB.events = events, 
        CREATE_PUBNUB.map = pubNubCore.map, CREATE_PUBNUB.each = pubNubCore.each, CREATE_PUBNUB.grep = pubNubCore.grep, 
        CREATE_PUBNUB.supplant = pubNubCore.supplant, CREATE_PUBNUB.now = pubNubCore.now, 
        CREATE_PUBNUB.unique = pubNubCore.unique, CREATE_PUBNUB.updater = pubNubCore.updater, 
        window.jQuery && (window.jQuery.PUBNUB = CREATE_PUBNUB), module.exports = CREATE_PUBNUB;
    }, function(module, exports) {
        (function() {
            window.JSON && window.JSON.stringify || function() {
                function toJSON() {
                    try {
                        return this.valueOf();
                    } catch (e) {
                        return null;
                    }
                }
                function quote(string) {
                    return escapable.lastIndex = 0, escapable.test(string) ? '"' + string.replace(escapable, function(a) {
                        var c = meta[a];
                        return "string" == typeof c ? c : "\\u" + ("0000" + a.charCodeAt(0).toString(16)).slice(-4);
                    }) + '"' : '"' + string + '"';
                }
                function str(key, holder) {
                    var i, k, v, length, partial, mind = gap, value = holder[key];
                    switch (value && "object" == typeof value && (value = toJSON.call(value, key)), 
                    "function" == typeof rep && (value = rep.call(holder, key, value)), typeof value) {
                      case "string":
                        return quote(value);

                      case "number":
                        return isFinite(value) ? String(value) : "null";

                      case "boolean":
                      case "null":
                        return String(value);

                      case "object":
                        if (!value) return "null";
                        if (gap += indent, partial = [], "[object Array]" === Object.prototype.toString.apply(value)) {
                            for (length = value.length, i = 0; length > i; i += 1) partial[i] = str(i, value) || "null";
                            return v = 0 === partial.length ? "[]" : gap ? "[\n" + gap + partial.join(",\n" + gap) + "\n" + mind + "]" : "[" + partial.join(",") + "]", 
                            gap = mind, v;
                        }
                        if (rep && "object" == typeof rep) for (length = rep.length, i = 0; length > i; i += 1) k = rep[i], 
                        "string" == typeof k && (v = str(k, value), v && partial.push(quote(k) + (gap ? ": " : ":") + v)); else for (k in value) Object.hasOwnProperty.call(value, k) && (v = str(k, value), 
                        v && partial.push(quote(k) + (gap ? ": " : ":") + v));
                        return v = 0 === partial.length ? "{}" : gap ? "{\n" + gap + partial.join(",\n" + gap) + "\n" + mind + "}" : "{" + partial.join(",") + "}", 
                        gap = mind, v;
                    }
                }
                window.JSON || (window.JSON = {});
                var cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g, escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g, gap, indent, meta = {
                    "\b": "\\b",
                    "	": "\\t",
                    "\n": "\\n",
                    "\f": "\\f",
                    "\r": "\\r",
                    '"': '\\"',
                    "\\": "\\\\"
                }, rep;
                "function" != typeof JSON.stringify && (JSON.stringify = function(value, replacer, space) {
                    var i;
                    if (gap = "", indent = "", "number" == typeof space) for (i = 0; space > i; i += 1) indent += " "; else "string" == typeof space && (indent = space);
                    if (rep = replacer, replacer && "function" != typeof replacer && ("object" != typeof replacer || "number" != typeof replacer.length)) throw new Error("JSON.stringify");
                    return str("", {
                        "": value
                    });
                }), "function" != typeof JSON.parse && (JSON.parse = function(text) {
                    return eval("(" + text + ")");
                });
            }();
        }).call(window);
    }, function(module, exports, __webpack_require__) {
        function crypto_obj() {
            function SHA256(s) {
                return CryptoJS.SHA256(s).toString(CryptoJS.enc.Hex);
            }
            function parse_options(options) {
                return options = options || {}, options.hasOwnProperty("encryptKey") || (options.encryptKey = defaultOptions.encryptKey), 
                options.hasOwnProperty("keyEncoding") || (options.keyEncoding = defaultOptions.keyEncoding), 
                options.hasOwnProperty("keyLength") || (options.keyLength = defaultOptions.keyLength), 
                options.hasOwnProperty("mode") || (options.mode = defaultOptions.mode), -1 == allowedKeyEncodings.indexOf(options.keyEncoding.toLowerCase()) && (options.keyEncoding = defaultOptions.keyEncoding), 
                -1 == allowedKeyLengths.indexOf(parseInt(options.keyLength, 10)) && (options.keyLength = defaultOptions.keyLength), 
                -1 == allowedModes.indexOf(options.mode.toLowerCase()) && (options.mode = defaultOptions.mode), 
                options;
            }
            function decode_key(key, options) {
                return "base64" === options.keyEncoding ? CryptoJS.enc.Base64.parse(key) : "hex" === options.keyEncoding ? CryptoJS.enc.Hex.parse(key) : key;
            }
            function get_padded_key(key, options) {
                return key = decode_key(key, options), options.encryptKey ? CryptoJS.enc.Utf8.parse(SHA256(key).slice(0, 32)) : key;
            }
            function get_mode(options) {
                return "ecb" === options.mode ? CryptoJS.mode.ECB : CryptoJS.mode.CBC;
            }
            function get_iv(options) {
                return "cbc" === options.mode ? CryptoJS.enc.Utf8.parse(iv) : null;
            }
            var iv = "0123456789012345", allowedKeyEncodings = [ "hex", "utf8", "base64", "binary" ], allowedKeyLengths = [ 128, 256 ], allowedModes = [ "ecb", "cbc" ], defaultOptions = {
                encryptKey: !0,
                keyEncoding: "utf8",
                keyLength: 256,
                mode: "cbc"
            };
            return {
                encrypt: function(data, key, options) {
                    if (!key) return data;
                    options = parse_options(options);
                    var iv = get_iv(options), mode = get_mode(options), cipher_key = get_padded_key(key, options), hex_message = JSON.stringify(data), encryptedHexArray = CryptoJS.AES.encrypt(hex_message, cipher_key, {
                        iv: iv,
                        mode: mode
                    }).ciphertext, base_64_encrypted = encryptedHexArray.toString(CryptoJS.enc.Base64);
                    return base_64_encrypted || data;
                },
                decrypt: function(data, key, options) {
                    if (!key) return data;
                    options = parse_options(options);
                    var iv = get_iv(options), mode = get_mode(options), cipher_key = get_padded_key(key, options);
                    try {
                        var binary_enc = CryptoJS.enc.Base64.parse(data), json_plain = CryptoJS.AES.decrypt({
                            ciphertext: binary_enc
                        }, cipher_key, {
                            iv: iv,
                            mode: mode
                        }).toString(CryptoJS.enc.Utf8), plaintext = JSON.parse(json_plain);
                        return plaintext;
                    } catch (e) {
                        return void 0;
                    }
                }
            };
        }
        var CryptoJS = __webpack_require__(3);
        module.exports = crypto_obj;
    }, function(module) {
        var CryptoJS = CryptoJS || function(h, s) {
            var f = {}, g = f.lib = {}, q = function() {}, m = g.Base = {
                extend: function(a) {
                    q.prototype = this;
                    var c = new q();
                    return a && c.mixIn(a), c.hasOwnProperty("init") || (c.init = function() {
                        c.$super.init.apply(this, arguments);
                    }), c.init.prototype = c, c.$super = this, c;
                },
                create: function() {
                    var a = this.extend();
                    return a.init.apply(a, arguments), a;
                },
                init: function() {},
                mixIn: function(a) {
                    for (var c in a) a.hasOwnProperty(c) && (this[c] = a[c]);
                    a.hasOwnProperty("toString") && (this.toString = a.toString);
                },
                clone: function() {
                    return this.init.prototype.extend(this);
                }
            }, r = g.WordArray = m.extend({
                init: function(a, c) {
                    a = this.words = a || [], this.sigBytes = c != s ? c : 4 * a.length;
                },
                toString: function(a) {
                    return (a || k).stringify(this);
                },
                concat: function(a) {
                    var c = this.words, d = a.words, b = this.sigBytes;
                    if (a = a.sigBytes, this.clamp(), b % 4) for (var e = 0; a > e; e++) c[b + e >>> 2] |= (d[e >>> 2] >>> 24 - 8 * (e % 4) & 255) << 24 - 8 * ((b + e) % 4); else if (65535 < d.length) for (e = 0; a > e; e += 4) c[b + e >>> 2] = d[e >>> 2]; else c.push.apply(c, d);
                    return this.sigBytes += a, this;
                },
                clamp: function() {
                    var a = this.words, c = this.sigBytes;
                    a[c >>> 2] &= 4294967295 << 32 - 8 * (c % 4), a.length = h.ceil(c / 4);
                },
                clone: function() {
                    var a = m.clone.call(this);
                    return a.words = this.words.slice(0), a;
                },
                random: function(a) {
                    for (var c = [], d = 0; a > d; d += 4) c.push(4294967296 * h.random() | 0);
                    return new r.init(c, a);
                }
            }), l = f.enc = {}, k = l.Hex = {
                stringify: function(a) {
                    var c = a.words;
                    a = a.sigBytes;
                    for (var d = [], b = 0; a > b; b++) {
                        var e = c[b >>> 2] >>> 24 - 8 * (b % 4) & 255;
                        d.push((e >>> 4).toString(16)), d.push((15 & e).toString(16));
                    }
                    return d.join("");
                },
                parse: function(a) {
                    for (var c = a.length, d = [], b = 0; c > b; b += 2) d[b >>> 3] |= parseInt(a.substr(b, 2), 16) << 24 - 4 * (b % 8);
                    return new r.init(d, c / 2);
                }
            }, n = l.Latin1 = {
                stringify: function(a) {
                    var c = a.words;
                    a = a.sigBytes;
                    for (var d = [], b = 0; a > b; b++) d.push(String.fromCharCode(c[b >>> 2] >>> 24 - 8 * (b % 4) & 255));
                    return d.join("");
                },
                parse: function(a) {
                    for (var c = a.length, d = [], b = 0; c > b; b++) d[b >>> 2] |= (255 & a.charCodeAt(b)) << 24 - 8 * (b % 4);
                    return new r.init(d, c);
                }
            }, j = l.Utf8 = {
                stringify: function(a) {
                    try {
                        return decodeURIComponent(escape(n.stringify(a)));
                    } catch (c) {
                        throw Error("Malformed UTF-8 data");
                    }
                },
                parse: function(a) {
                    return n.parse(unescape(encodeURIComponent(a)));
                }
            }, u = g.BufferedBlockAlgorithm = m.extend({
                reset: function() {
                    this._data = new r.init(), this._nDataBytes = 0;
                },
                _append: function(a) {
                    "string" == typeof a && (a = j.parse(a)), this._data.concat(a), this._nDataBytes += a.sigBytes;
                },
                _process: function(a) {
                    var c = this._data, d = c.words, b = c.sigBytes, e = this.blockSize, f = b / (4 * e), f = a ? h.ceil(f) : h.max((0 | f) - this._minBufferSize, 0);
                    if (a = f * e, b = h.min(4 * a, b), a) {
                        for (var g = 0; a > g; g += e) this._doProcessBlock(d, g);
                        g = d.splice(0, a), c.sigBytes -= b;
                    }
                    return new r.init(g, b);
                },
                clone: function() {
                    var a = m.clone.call(this);
                    return a._data = this._data.clone(), a;
                },
                _minBufferSize: 0
            });
            g.Hasher = u.extend({
                cfg: m.extend(),
                init: function(a) {
                    this.cfg = this.cfg.extend(a), this.reset();
                },
                reset: function() {
                    u.reset.call(this), this._doReset();
                },
                update: function(a) {
                    return this._append(a), this._process(), this;
                },
                finalize: function(a) {
                    return a && this._append(a), this._doFinalize();
                },
                blockSize: 16,
                _createHelper: function(a) {
                    return function(c, d) {
                        return new a.init(d).finalize(c);
                    };
                },
                _createHmacHelper: function(a) {
                    return function(c, d) {
                        return new t.HMAC.init(a, d).finalize(c);
                    };
                }
            });
            var t = f.algo = {};
            return f;
        }(Math);
        !function(h) {
            for (var s = CryptoJS, f = s.lib, g = f.WordArray, q = f.Hasher, f = s.algo, m = [], r = [], l = function(a) {
                return 4294967296 * (a - (0 | a)) | 0;
            }, k = 2, n = 0; 64 > n; ) {
                var j;
                a: {
                    j = k;
                    for (var u = h.sqrt(j), t = 2; u >= t; t++) if (!(j % t)) {
                        j = !1;
                        break a;
                    }
                    j = !0;
                }
                j && (8 > n && (m[n] = l(h.pow(k, .5))), r[n] = l(h.pow(k, 1 / 3)), n++), k++;
            }
            var a = [], f = f.SHA256 = q.extend({
                _doReset: function() {
                    this._hash = new g.init(m.slice(0));
                },
                _doProcessBlock: function(c, d) {
                    for (var b = this._hash.words, e = b[0], f = b[1], g = b[2], j = b[3], h = b[4], m = b[5], n = b[6], q = b[7], p = 0; 64 > p; p++) {
                        if (16 > p) a[p] = 0 | c[d + p]; else {
                            var k = a[p - 15], l = a[p - 2];
                            a[p] = ((k << 25 | k >>> 7) ^ (k << 14 | k >>> 18) ^ k >>> 3) + a[p - 7] + ((l << 15 | l >>> 17) ^ (l << 13 | l >>> 19) ^ l >>> 10) + a[p - 16];
                        }
                        k = q + ((h << 26 | h >>> 6) ^ (h << 21 | h >>> 11) ^ (h << 7 | h >>> 25)) + (h & m ^ ~h & n) + r[p] + a[p], 
                        l = ((e << 30 | e >>> 2) ^ (e << 19 | e >>> 13) ^ (e << 10 | e >>> 22)) + (e & f ^ e & g ^ f & g), 
                        q = n, n = m, m = h, h = j + k | 0, j = g, g = f, f = e, e = k + l | 0;
                    }
                    b[0] = b[0] + e | 0, b[1] = b[1] + f | 0, b[2] = b[2] + g | 0, b[3] = b[3] + j | 0, 
                    b[4] = b[4] + h | 0, b[5] = b[5] + m | 0, b[6] = b[6] + n | 0, b[7] = b[7] + q | 0;
                },
                _doFinalize: function() {
                    var a = this._data, d = a.words, b = 8 * this._nDataBytes, e = 8 * a.sigBytes;
                    return d[e >>> 5] |= 128 << 24 - e % 32, d[(e + 64 >>> 9 << 4) + 14] = h.floor(b / 4294967296), 
                    d[(e + 64 >>> 9 << 4) + 15] = b, a.sigBytes = 4 * d.length, this._process(), this._hash;
                },
                clone: function() {
                    var a = q.clone.call(this);
                    return a._hash = this._hash.clone(), a;
                }
            });
            s.SHA256 = q._createHelper(f), s.HmacSHA256 = q._createHmacHelper(f);
        }(Math), function() {
            var h = CryptoJS, s = h.enc.Utf8;
            h.algo.HMAC = h.lib.Base.extend({
                init: function(f, g) {
                    f = this._hasher = new f.init(), "string" == typeof g && (g = s.parse(g));
                    var h = f.blockSize, m = 4 * h;
                    g.sigBytes > m && (g = f.finalize(g)), g.clamp();
                    for (var r = this._oKey = g.clone(), l = this._iKey = g.clone(), k = r.words, n = l.words, j = 0; h > j; j++) k[j] ^= 1549556828, 
                    n[j] ^= 909522486;
                    r.sigBytes = l.sigBytes = m, this.reset();
                },
                reset: function() {
                    var f = this._hasher;
                    f.reset(), f.update(this._iKey);
                },
                update: function(f) {
                    return this._hasher.update(f), this;
                },
                finalize: function(f) {
                    var g = this._hasher;
                    return f = g.finalize(f), g.reset(), g.finalize(this._oKey.clone().concat(f));
                }
            });
        }(), function() {
            var u = CryptoJS, p = u.lib.WordArray;
            u.enc.Base64 = {
                stringify: function(d) {
                    var l = d.words, p = d.sigBytes, t = this._map;
                    d.clamp(), d = [];
                    for (var r = 0; p > r; r += 3) for (var w = (l[r >>> 2] >>> 24 - 8 * (r % 4) & 255) << 16 | (l[r + 1 >>> 2] >>> 24 - 8 * ((r + 1) % 4) & 255) << 8 | l[r + 2 >>> 2] >>> 24 - 8 * ((r + 2) % 4) & 255, v = 0; 4 > v && p > r + .75 * v; v++) d.push(t.charAt(w >>> 6 * (3 - v) & 63));
                    if (l = t.charAt(64)) for (;d.length % 4; ) d.push(l);
                    return d.join("");
                },
                parse: function(d) {
                    var l = d.length, s = this._map, t = s.charAt(64);
                    t && (t = d.indexOf(t), -1 != t && (l = t));
                    for (var t = [], r = 0, w = 0; l > w; w++) if (w % 4) {
                        var v = s.indexOf(d.charAt(w - 1)) << 2 * (w % 4), b = s.indexOf(d.charAt(w)) >>> 6 - 2 * (w % 4);
                        t[r >>> 2] |= (v | b) << 24 - 8 * (r % 4), r++;
                    }
                    return p.create(t, r);
                },
                _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="
            };
        }(), function(u) {
            function p(b, n, a, c, e, j, k) {
                return b = b + (n & a | ~n & c) + e + k, (b << j | b >>> 32 - j) + n;
            }
            function d(b, n, a, c, e, j, k) {
                return b = b + (n & c | a & ~c) + e + k, (b << j | b >>> 32 - j) + n;
            }
            function l(b, n, a, c, e, j, k) {
                return b = b + (n ^ a ^ c) + e + k, (b << j | b >>> 32 - j) + n;
            }
            function s(b, n, a, c, e, j, k) {
                return b = b + (a ^ (n | ~c)) + e + k, (b << j | b >>> 32 - j) + n;
            }
            for (var t = CryptoJS, r = t.lib, w = r.WordArray, v = r.Hasher, r = t.algo, b = [], x = 0; 64 > x; x++) b[x] = 4294967296 * u.abs(u.sin(x + 1)) | 0;
            r = r.MD5 = v.extend({
                _doReset: function() {
                    this._hash = new w.init([ 1732584193, 4023233417, 2562383102, 271733878 ]);
                },
                _doProcessBlock: function(q, n) {
                    for (var a = 0; 16 > a; a++) {
                        var c = n + a, e = q[c];
                        q[c] = 16711935 & (e << 8 | e >>> 24) | 4278255360 & (e << 24 | e >>> 8);
                    }
                    var a = this._hash.words, c = q[n + 0], e = q[n + 1], j = q[n + 2], k = q[n + 3], z = q[n + 4], r = q[n + 5], t = q[n + 6], w = q[n + 7], v = q[n + 8], A = q[n + 9], B = q[n + 10], C = q[n + 11], u = q[n + 12], D = q[n + 13], E = q[n + 14], x = q[n + 15], f = a[0], m = a[1], g = a[2], h = a[3], f = p(f, m, g, h, c, 7, b[0]), h = p(h, f, m, g, e, 12, b[1]), g = p(g, h, f, m, j, 17, b[2]), m = p(m, g, h, f, k, 22, b[3]), f = p(f, m, g, h, z, 7, b[4]), h = p(h, f, m, g, r, 12, b[5]), g = p(g, h, f, m, t, 17, b[6]), m = p(m, g, h, f, w, 22, b[7]), f = p(f, m, g, h, v, 7, b[8]), h = p(h, f, m, g, A, 12, b[9]), g = p(g, h, f, m, B, 17, b[10]), m = p(m, g, h, f, C, 22, b[11]), f = p(f, m, g, h, u, 7, b[12]), h = p(h, f, m, g, D, 12, b[13]), g = p(g, h, f, m, E, 17, b[14]), m = p(m, g, h, f, x, 22, b[15]), f = d(f, m, g, h, e, 5, b[16]), h = d(h, f, m, g, t, 9, b[17]), g = d(g, h, f, m, C, 14, b[18]), m = d(m, g, h, f, c, 20, b[19]), f = d(f, m, g, h, r, 5, b[20]), h = d(h, f, m, g, B, 9, b[21]), g = d(g, h, f, m, x, 14, b[22]), m = d(m, g, h, f, z, 20, b[23]), f = d(f, m, g, h, A, 5, b[24]), h = d(h, f, m, g, E, 9, b[25]), g = d(g, h, f, m, k, 14, b[26]), m = d(m, g, h, f, v, 20, b[27]), f = d(f, m, g, h, D, 5, b[28]), h = d(h, f, m, g, j, 9, b[29]), g = d(g, h, f, m, w, 14, b[30]), m = d(m, g, h, f, u, 20, b[31]), f = l(f, m, g, h, r, 4, b[32]), h = l(h, f, m, g, v, 11, b[33]), g = l(g, h, f, m, C, 16, b[34]), m = l(m, g, h, f, E, 23, b[35]), f = l(f, m, g, h, e, 4, b[36]), h = l(h, f, m, g, z, 11, b[37]), g = l(g, h, f, m, w, 16, b[38]), m = l(m, g, h, f, B, 23, b[39]), f = l(f, m, g, h, D, 4, b[40]), h = l(h, f, m, g, c, 11, b[41]), g = l(g, h, f, m, k, 16, b[42]), m = l(m, g, h, f, t, 23, b[43]), f = l(f, m, g, h, A, 4, b[44]), h = l(h, f, m, g, u, 11, b[45]), g = l(g, h, f, m, x, 16, b[46]), m = l(m, g, h, f, j, 23, b[47]), f = s(f, m, g, h, c, 6, b[48]), h = s(h, f, m, g, w, 10, b[49]), g = s(g, h, f, m, E, 15, b[50]), m = s(m, g, h, f, r, 21, b[51]), f = s(f, m, g, h, u, 6, b[52]), h = s(h, f, m, g, k, 10, b[53]), g = s(g, h, f, m, B, 15, b[54]), m = s(m, g, h, f, e, 21, b[55]), f = s(f, m, g, h, v, 6, b[56]), h = s(h, f, m, g, x, 10, b[57]), g = s(g, h, f, m, t, 15, b[58]), m = s(m, g, h, f, D, 21, b[59]), f = s(f, m, g, h, z, 6, b[60]), h = s(h, f, m, g, C, 10, b[61]), g = s(g, h, f, m, j, 15, b[62]), m = s(m, g, h, f, A, 21, b[63]);
                    a[0] = a[0] + f | 0, a[1] = a[1] + m | 0, a[2] = a[2] + g | 0, a[3] = a[3] + h | 0;
                },
                _doFinalize: function() {
                    var b = this._data, n = b.words, a = 8 * this._nDataBytes, c = 8 * b.sigBytes;
                    n[c >>> 5] |= 128 << 24 - c % 32;
                    var e = u.floor(a / 4294967296);
                    for (n[(c + 64 >>> 9 << 4) + 15] = 16711935 & (e << 8 | e >>> 24) | 4278255360 & (e << 24 | e >>> 8), 
                    n[(c + 64 >>> 9 << 4) + 14] = 16711935 & (a << 8 | a >>> 24) | 4278255360 & (a << 24 | a >>> 8), 
                    b.sigBytes = 4 * (n.length + 1), this._process(), b = this._hash, n = b.words, a = 0; 4 > a; a++) c = n[a], 
                    n[a] = 16711935 & (c << 8 | c >>> 24) | 4278255360 & (c << 24 | c >>> 8);
                    return b;
                },
                clone: function() {
                    var b = v.clone.call(this);
                    return b._hash = this._hash.clone(), b;
                }
            }), t.MD5 = v._createHelper(r), t.HmacMD5 = v._createHmacHelper(r);
        }(Math), function() {
            var u = CryptoJS, p = u.lib, d = p.Base, l = p.WordArray, p = u.algo, s = p.EvpKDF = d.extend({
                cfg: d.extend({
                    keySize: 4,
                    hasher: p.MD5,
                    iterations: 1
                }),
                init: function(d) {
                    this.cfg = this.cfg.extend(d);
                },
                compute: function(d, r) {
                    for (var p = this.cfg, s = p.hasher.create(), b = l.create(), u = b.words, q = p.keySize, p = p.iterations; u.length < q; ) {
                        n && s.update(n);
                        var n = s.update(d).finalize(r);
                        s.reset();
                        for (var a = 1; p > a; a++) n = s.finalize(n), s.reset();
                        b.concat(n);
                    }
                    return b.sigBytes = 4 * q, b;
                }
            });
            u.EvpKDF = function(d, l, p) {
                return s.create(p).compute(d, l);
            };
        }(), CryptoJS.lib.Cipher || function(u) {
            var p = CryptoJS, d = p.lib, l = d.Base, s = d.WordArray, t = d.BufferedBlockAlgorithm, r = p.enc.Base64, w = p.algo.EvpKDF, v = d.Cipher = t.extend({
                cfg: l.extend(),
                createEncryptor: function(e, a) {
                    return this.create(this._ENC_XFORM_MODE, e, a);
                },
                createDecryptor: function(e, a) {
                    return this.create(this._DEC_XFORM_MODE, e, a);
                },
                init: function(e, a, b) {
                    this.cfg = this.cfg.extend(b), this._xformMode = e, this._key = a, this.reset();
                },
                reset: function() {
                    t.reset.call(this), this._doReset();
                },
                process: function(e) {
                    return this._append(e), this._process();
                },
                finalize: function(e) {
                    return e && this._append(e), this._doFinalize();
                },
                keySize: 4,
                ivSize: 4,
                _ENC_XFORM_MODE: 1,
                _DEC_XFORM_MODE: 2,
                _createHelper: function(e) {
                    return {
                        encrypt: function(b, k, d) {
                            return ("string" == typeof k ? c : a).encrypt(e, b, k, d);
                        },
                        decrypt: function(b, k, d) {
                            return ("string" == typeof k ? c : a).decrypt(e, b, k, d);
                        }
                    };
                }
            });
            d.StreamCipher = v.extend({
                _doFinalize: function() {
                    return this._process(!0);
                },
                blockSize: 1
            });
            var b = p.mode = {}, x = function(e, a, b) {
                var c = this._iv;
                c ? this._iv = u : c = this._prevBlock;
                for (var d = 0; b > d; d++) e[a + d] ^= c[d];
            }, q = (d.BlockCipherMode = l.extend({
                createEncryptor: function(e, a) {
                    return this.Encryptor.create(e, a);
                },
                createDecryptor: function(e, a) {
                    return this.Decryptor.create(e, a);
                },
                init: function(e, a) {
                    this._cipher = e, this._iv = a;
                }
            })).extend();
            q.Encryptor = q.extend({
                processBlock: function(e, a) {
                    var b = this._cipher, c = b.blockSize;
                    x.call(this, e, a, c), b.encryptBlock(e, a), this._prevBlock = e.slice(a, a + c);
                }
            }), q.Decryptor = q.extend({
                processBlock: function(e, a) {
                    var b = this._cipher, c = b.blockSize, d = e.slice(a, a + c);
                    b.decryptBlock(e, a), x.call(this, e, a, c), this._prevBlock = d;
                }
            }), b = b.CBC = q, q = (p.pad = {}).Pkcs7 = {
                pad: function(a, b) {
                    for (var c = 4 * b, c = c - a.sigBytes % c, d = c << 24 | c << 16 | c << 8 | c, l = [], n = 0; c > n; n += 4) l.push(d);
                    c = s.create(l, c), a.concat(c);
                },
                unpad: function(a) {
                    a.sigBytes -= 255 & a.words[a.sigBytes - 1 >>> 2];
                }
            }, d.BlockCipher = v.extend({
                cfg: v.cfg.extend({
                    mode: b,
                    padding: q
                }),
                reset: function() {
                    v.reset.call(this);
                    var a = this.cfg, b = a.iv, a = a.mode;
                    if (this._xformMode == this._ENC_XFORM_MODE) var c = a.createEncryptor; else c = a.createDecryptor, 
                    this._minBufferSize = 1;
                    this._mode = c.call(a, this, b && b.words);
                },
                _doProcessBlock: function(a, b) {
                    this._mode.processBlock(a, b);
                },
                _doFinalize: function() {
                    var a = this.cfg.padding;
                    if (this._xformMode == this._ENC_XFORM_MODE) {
                        a.pad(this._data, this.blockSize);
                        var b = this._process(!0);
                    } else b = this._process(!0), a.unpad(b);
                    return b;
                },
                blockSize: 4
            });
            var n = d.CipherParams = l.extend({
                init: function(a) {
                    this.mixIn(a);
                },
                toString: function(a) {
                    return (a || this.formatter).stringify(this);
                }
            }), b = (p.format = {}).OpenSSL = {
                stringify: function(a) {
                    var b = a.ciphertext;
                    return a = a.salt, (a ? s.create([ 1398893684, 1701076831 ]).concat(a).concat(b) : b).toString(r);
                },
                parse: function(a) {
                    a = r.parse(a);
                    var b = a.words;
                    if (1398893684 == b[0] && 1701076831 == b[1]) {
                        var c = s.create(b.slice(2, 4));
                        b.splice(0, 4), a.sigBytes -= 16;
                    }
                    return n.create({
                        ciphertext: a,
                        salt: c
                    });
                }
            }, a = d.SerializableCipher = l.extend({
                cfg: l.extend({
                    format: b
                }),
                encrypt: function(a, b, c, d) {
                    d = this.cfg.extend(d);
                    var l = a.createEncryptor(c, d);
                    return b = l.finalize(b), l = l.cfg, n.create({
                        ciphertext: b,
                        key: c,
                        iv: l.iv,
                        algorithm: a,
                        mode: l.mode,
                        padding: l.padding,
                        blockSize: a.blockSize,
                        formatter: d.format
                    });
                },
                decrypt: function(a, b, c, d) {
                    return d = this.cfg.extend(d), b = this._parse(b, d.format), a.createDecryptor(c, d).finalize(b.ciphertext);
                },
                _parse: function(a, b) {
                    return "string" == typeof a ? b.parse(a, this) : a;
                }
            }), p = (p.kdf = {}).OpenSSL = {
                execute: function(a, b, c, d) {
                    return d || (d = s.random(8)), a = w.create({
                        keySize: b + c
                    }).compute(a, d), c = s.create(a.words.slice(b), 4 * c), a.sigBytes = 4 * b, n.create({
                        key: a,
                        iv: c,
                        salt: d
                    });
                }
            }, c = d.PasswordBasedCipher = a.extend({
                cfg: a.cfg.extend({
                    kdf: p
                }),
                encrypt: function(b, c, d, l) {
                    return l = this.cfg.extend(l), d = l.kdf.execute(d, b.keySize, b.ivSize), l.iv = d.iv, 
                    b = a.encrypt.call(this, b, c, d.key, l), b.mixIn(d), b;
                },
                decrypt: function(b, c, d, l) {
                    return l = this.cfg.extend(l), c = this._parse(c, l.format), d = l.kdf.execute(d, b.keySize, b.ivSize, c.salt), 
                    l.iv = d.iv, a.decrypt.call(this, b, c, d.key, l);
                }
            });
        }(), function() {
            for (var u = CryptoJS, p = u.lib.BlockCipher, d = u.algo, l = [], s = [], t = [], r = [], w = [], v = [], b = [], x = [], q = [], n = [], a = [], c = 0; 256 > c; c++) a[c] = 128 > c ? c << 1 : c << 1 ^ 283;
            for (var e = 0, j = 0, c = 0; 256 > c; c++) {
                var k = j ^ j << 1 ^ j << 2 ^ j << 3 ^ j << 4, k = k >>> 8 ^ 255 & k ^ 99;
                l[e] = k, s[k] = e;
                var z = a[e], F = a[z], G = a[F], y = 257 * a[k] ^ 16843008 * k;
                t[e] = y << 24 | y >>> 8, r[e] = y << 16 | y >>> 16, w[e] = y << 8 | y >>> 24, v[e] = y, 
                y = 16843009 * G ^ 65537 * F ^ 257 * z ^ 16843008 * e, b[k] = y << 24 | y >>> 8, 
                x[k] = y << 16 | y >>> 16, q[k] = y << 8 | y >>> 24, n[k] = y, e ? (e = z ^ a[a[a[G ^ z]]], 
                j ^= a[a[j]]) : e = j = 1;
            }
            var H = [ 0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54 ], d = d.AES = p.extend({
                _doReset: function() {
                    for (var a = this._key, c = a.words, d = a.sigBytes / 4, a = 4 * ((this._nRounds = d + 6) + 1), e = this._keySchedule = [], j = 0; a > j; j++) if (d > j) e[j] = c[j]; else {
                        var k = e[j - 1];
                        j % d ? d > 6 && 4 == j % d && (k = l[k >>> 24] << 24 | l[k >>> 16 & 255] << 16 | l[k >>> 8 & 255] << 8 | l[255 & k]) : (k = k << 8 | k >>> 24, 
                        k = l[k >>> 24] << 24 | l[k >>> 16 & 255] << 16 | l[k >>> 8 & 255] << 8 | l[255 & k], 
                        k ^= H[j / d | 0] << 24), e[j] = e[j - d] ^ k;
                    }
                    for (c = this._invKeySchedule = [], d = 0; a > d; d++) j = a - d, k = d % 4 ? e[j] : e[j - 4], 
                    c[d] = 4 > d || 4 >= j ? k : b[l[k >>> 24]] ^ x[l[k >>> 16 & 255]] ^ q[l[k >>> 8 & 255]] ^ n[l[255 & k]];
                },
                encryptBlock: function(a, b) {
                    this._doCryptBlock(a, b, this._keySchedule, t, r, w, v, l);
                },
                decryptBlock: function(a, c) {
                    var d = a[c + 1];
                    a[c + 1] = a[c + 3], a[c + 3] = d, this._doCryptBlock(a, c, this._invKeySchedule, b, x, q, n, s), 
                    d = a[c + 1], a[c + 1] = a[c + 3], a[c + 3] = d;
                },
                _doCryptBlock: function(a, b, c, d, e, j, l, f) {
                    for (var m = this._nRounds, g = a[b] ^ c[0], h = a[b + 1] ^ c[1], k = a[b + 2] ^ c[2], n = a[b + 3] ^ c[3], p = 4, r = 1; m > r; r++) var q = d[g >>> 24] ^ e[h >>> 16 & 255] ^ j[k >>> 8 & 255] ^ l[255 & n] ^ c[p++], s = d[h >>> 24] ^ e[k >>> 16 & 255] ^ j[n >>> 8 & 255] ^ l[255 & g] ^ c[p++], t = d[k >>> 24] ^ e[n >>> 16 & 255] ^ j[g >>> 8 & 255] ^ l[255 & h] ^ c[p++], n = d[n >>> 24] ^ e[g >>> 16 & 255] ^ j[h >>> 8 & 255] ^ l[255 & k] ^ c[p++], g = q, h = s, k = t;
                    q = (f[g >>> 24] << 24 | f[h >>> 16 & 255] << 16 | f[k >>> 8 & 255] << 8 | f[255 & n]) ^ c[p++], 
                    s = (f[h >>> 24] << 24 | f[k >>> 16 & 255] << 16 | f[n >>> 8 & 255] << 8 | f[255 & g]) ^ c[p++], 
                    t = (f[k >>> 24] << 24 | f[n >>> 16 & 255] << 16 | f[g >>> 8 & 255] << 8 | f[255 & h]) ^ c[p++], 
                    n = (f[n >>> 24] << 24 | f[g >>> 16 & 255] << 16 | f[h >>> 8 & 255] << 8 | f[255 & k]) ^ c[p++], 
                    a[b] = q, a[b + 1] = s, a[b + 2] = t, a[b + 3] = n;
                },
                keySize: 8
            });
            u.AES = p._createHelper(d);
        }(), CryptoJS.mode.ECB = function() {
            var ECB = CryptoJS.lib.BlockCipherMode.extend();
            return ECB.Encryptor = ECB.extend({
                processBlock: function(words, offset) {
                    this._cipher.encryptBlock(words, offset);
                }
            }), ECB.Decryptor = ECB.extend({
                processBlock: function(words, offset) {
                    this._cipher.decryptBlock(words, offset);
                }
            }), ECB;
        }(), module.exports = CryptoJS;
    }, function(module) {
        module.exports = {
            name: "pubnub",
            preferGlobal: !1,
            version: "3.15.2",
            author: "PubNub <support@pubnub.com>",
            description: "Publish & Subscribe Real-time Messaging with PubNub",
            contributors: [ {
                name: "Stephen Blum",
                email: "stephen@pubnub.com"
            } ],
            bin: {},
            scripts: {
                test: "grunt test --force"
            },
            main: "./node.js/pubnub.js",
            browser: "./modern/dist/pubnub.js",
            repository: {
                type: "git",
                url: "git://github.com/pubnub/javascript.git"
            },
            keywords: [ "cloud", "publish", "subscribe", "websockets", "comet", "bosh", "xmpp", "real-time", "messaging" ],
            dependencies: {
                agentkeepalive: "~0.2",
                lodash: "^4.1.0"
            },
            noAnalyze: !1,
            devDependencies: {
                chai: "^3.5.0",
                eslint: "2.4.0",
                "eslint-config-airbnb": "^6.0.2",
                "eslint-plugin-flowtype": "^2.1.0",
                "eslint-plugin-mocha": "^2.0.0",
                "eslint-plugin-react": "^4.1.0",
                "flow-bin": "^0.22.0",
                grunt: "^0.4.5",
                "grunt-contrib-clean": "^1.0.0",
                "grunt-contrib-copy": "^0.8.2",
                "grunt-contrib-uglify": "^0.11.1",
                "grunt-env": "^0.4.4",
                "grunt-eslint": "^18.0.0",
                "grunt-flow": "^1.0.3",
                "grunt-karma": "^0.12.1",
                "grunt-mocha-istanbul": "^3.0.1",
                "grunt-text-replace": "^0.4.0",
                "grunt-webpack": "^1.0.11",
                "imports-loader": "^0.6.5",
                isparta: "^4.0.0",
                "json-loader": "^0.5.4",
                karma: "^0.13.21",
                "karma-chai": "^0.1.0",
                "karma-mocha": "^0.2.1",
                "karma-phantomjs-launcher": "^1.0.0",
                "karma-spec-reporter": "0.0.24",
                "load-grunt-tasks": "^3.4.0",
                mocha: "^2.4.5",
                nock: "^1.1.0",
                "node-uuid": "^1.4.7",
                nodeunit: "^0.9.0",
                "phantomjs-prebuilt": "^2.1.4",
                proxyquire: "^1.7.4",
                sinon: "^1.17.2",
                "uglify-js": "^2.6.1",
                underscore: "^1.7.0",
                webpack: "^1.12.13",
                "webpack-dev-server": "^1.14.1"
            },
            bundleDependencies: [],
            license: "MIT",
            engine: {
                node: ">=0.8"
            },
            files: [ "core", "node.js", "modern", "CHANGELOG", "FUTURE.md", "LICENSE", "README.md" ]
        };
    }, function(module, exports, __webpack_require__) {
        function unique() {
            return "x" + ++NOW + +new Date();
        }
        function generate_channel_list(channels, nopresence) {
            var list = [];
            return utils.each(channels, function(channel, status) {
                nopresence ? channel.search("-pnpres") < 0 && status.subscribed && list.push(channel) : status.subscribed && list.push(channel);
            }), list.sort();
        }
        function generate_channel_group_list(channel_groups, nopresence) {
            var list = [];
            return utils.each(channel_groups, function(channel_group, status) {
                nopresence ? channel_group.search("-pnpres") < 0 && status.subscribed && list.push(channel_group) : status.subscribed && list.push(channel_group);
            }), list.sort();
        }
        function ready() {
            READY || (READY = 1, utils.each(READY_BUFFER, function(connect) {
                connect();
            }));
        }
        function PNmessage(args) {
            var msg = args || {
                apns: {}
            };
            return msg.getPubnubMessage = function() {
                var m = {};
                if (Object.keys(msg.apns).length) {
                    m.pn_apns = {
                        aps: {
                            alert: msg.apns.alert,
                            badge: msg.apns.badge
                        }
                    };
                    for (var k in msg.apns) m.pn_apns[k] = msg.apns[k];
                    var exclude1 = [ "badge", "alert" ];
                    for (var k in exclude1) delete m.pn_apns[exclude1[k]];
                }
                msg.gcm && (m.pn_gcm = {
                    data: msg.gcm
                });
                for (var k in msg) m[k] = msg[k];
                var exclude = [ "apns", "gcm", "publish", "channel", "callback", "error" ];
                for (var k in exclude) delete m[exclude[k]];
                return m;
            }, msg.publish = function() {
                var m = msg.getPubnubMessage();
                msg.pubnub && msg.channel && msg.pubnub.publish({
                    message: m,
                    channel: msg.channel,
                    callback: msg.callback,
                    error: msg.error
                });
            }, msg;
        }
        function PN_API(setup) {
            function _get_url_params(data) {
                return data || (data = {}), utils.each(params, function(key, value) {
                    key in data || (data[key] = value);
                }), data;
            }
            function _object_to_key_list(o) {
                var l = [];
                return utils.each(o, function(key) {
                    l.push(key);
                }), l;
            }
            function _object_to_key_list_sorted(o) {
                return _object_to_key_list(o).sort();
            }
            function _get_pam_sign_input_from_params(params) {
                var si = "", l = _object_to_key_list_sorted(params);
                for (var i in l) {
                    var k = l[i];
                    si += k + "=" + utils.pamEncode(params[k]), i != l.length - 1 && (si += "&");
                }
                return si;
            }
            function validate_presence_heartbeat(heartbeat, cur_heartbeat, error) {
                var err = !1;
                if ("undefined" == typeof heartbeat) return cur_heartbeat;
                if ("number" == typeof heartbeat) err = heartbeat > PRESENCE_HB_THRESHOLD || 0 == heartbeat ? !1 : !0; else {
                    if ("boolean" == typeof heartbeat) return heartbeat ? PRESENCE_HB_DEFAULT : 0;
                    err = !0;
                }
                return err ? (error && error("Presence Heartbeat value invalid. Valid range ( x > " + PRESENCE_HB_THRESHOLD + " or x = 0). Current Value : " + (cur_heartbeat || PRESENCE_HB_THRESHOLD)), 
                cur_heartbeat || PRESENCE_HB_THRESHOLD) : heartbeat;
            }
            function encrypt(input, key) {
                return crypto_obj.encrypt(input, key || CIPHER_KEY) || input;
            }
            function decrypt(input, key) {
                return crypto_obj.decrypt(input, key || CIPHER_KEY) || crypto_obj.decrypt(input, CIPHER_KEY) || input;
            }
            function _presence_heartbeat() {
                return clearTimeout(PRESENCE_HB_TIMEOUT), !PRESENCE_HB_INTERVAL || PRESENCE_HB_INTERVAL >= 500 || 1 > PRESENCE_HB_INTERVAL || !generate_channel_list(CHANNELS, !0).length && !generate_channel_group_list(CHANNEL_GROUPS, !0).length ? void (PRESENCE_HB_RUNNING = !1) : (PRESENCE_HB_RUNNING = !0, 
                void SELF.presence_heartbeat({
                    callback: function() {
                        PRESENCE_HB_TIMEOUT = utils.timeout(_presence_heartbeat, PRESENCE_HB_INTERVAL * SECOND);
                    },
                    error: function(e) {
                        error && error("Presence Heartbeat unable to reach Pubnub servers." + JSON.stringify(e)), 
                        PRESENCE_HB_TIMEOUT = utils.timeout(_presence_heartbeat, PRESENCE_HB_INTERVAL * SECOND);
                    }
                }));
            }
            function start_presence_heartbeat() {
                !PRESENCE_HB_RUNNING && _presence_heartbeat();
            }
            function publish(next) {
                if (NO_WAIT_FOR_PENDING) {
                    if (!PUB_QUEUE.length) return;
                } else {
                    if (next && (PUB_QUEUE.sending = 0), PUB_QUEUE.sending || !PUB_QUEUE.length) return;
                    PUB_QUEUE.sending = 1;
                }
                xdr(PUB_QUEUE.shift());
            }
            function each_channel_group(callback) {
                var count = 0;
                return utils.each(generate_channel_group_list(CHANNEL_GROUPS), function(channel_group) {
                    var chang = CHANNEL_GROUPS[channel_group];
                    chang && (count++, (callback || function() {})(chang));
                }), count;
            }
            function each_channel(callback) {
                var count = 0;
                return utils.each(generate_channel_list(CHANNELS), function(channel) {
                    var chan = CHANNELS[channel];
                    chan && (count++, (callback || function() {})(chan));
                }), count;
            }
            function _invoke_callback(response, callback, err) {
                if ("object" == typeof response) {
                    if (response.error) {
                        var callback_data = {};
                        return response.message && (callback_data.message = response.message), response.payload && (callback_data.payload = response.payload), 
                        void (err && err(callback_data));
                    }
                    if (response.payload) return void (response.next_page ? callback && callback(response.payload, response.next_page) : callback && callback(response.payload));
                }
                callback && callback(response);
            }
            function _invoke_error(response, err) {
                if ("object" == typeof response && response.error) {
                    var callback_data = {};
                    return response.message && (callback_data.message = response.message), response.payload && (callback_data.payload = response.payload), 
                    void (err && err(callback_data));
                }
                err && err(response);
            }
            function CR(args, callback, url1, data) {
                var callback = args.callback || callback, err = args.error || error, jsonp = jsonp_cb();
                data = data || {}, data.auth || (data.auth = args.auth_key || AUTH_KEY);
                var url = [ STD_ORIGIN, "v1", "channel-registration", "sub-key", SUBSCRIBE_KEY ];
                url.push.apply(url, url1), jsonp && (data.callback = jsonp), xdr({
                    callback: jsonp,
                    data: _get_url_params(data),
                    success: function(response) {
                        _invoke_callback(response, callback, err);
                    },
                    fail: function(response) {
                        _invoke_error(response, err);
                    },
                    url: url
                });
            }
            function _poll_online() {
                _is_online() || _reset_offline(1, {
                    error: "Offline. Please check your network settings."
                }), _poll_timer && clearTimeout(_poll_timer), _poll_timer = utils.timeout(_poll_online, SECOND);
            }
            function _poll_online2() {
                TIME_CHECK && SELF.time(function(success) {
                    detect_time_detla(function() {}, success), success || _reset_offline(1, {
                        error: "Heartbeat failed to connect to Pubnub Servers.Please check your network settings."
                    }), _poll_timer2 && clearTimeout(_poll_timer2), _poll_timer2 = utils.timeout(_poll_online2, KEEPALIVE);
                });
            }
            function _reset_offline(err, msg) {
                SUB_RECEIVER && SUB_RECEIVER(err, msg), SUB_RECEIVER = null, clearTimeout(_poll_timer), 
                clearTimeout(_poll_timer2);
            }
            function detect_latency(tt) {
                var adjusted_time = utils.rnow() - TIME_DRIFT;
                return adjusted_time - tt / 1e4;
            }
            function detect_time_detla(cb, time) {
                function calculate(time) {
                    if (time) {
                        var ptime = time / 1e4, latency = (utils.rnow() - stime) / 2;
                        TIME_DRIFT = utils.rnow() - (ptime + latency), cb && cb(TIME_DRIFT);
                    }
                }
                var stime = utils.rnow();
                time && calculate(time) || SELF.time(calculate);
            }
            var _poll_timer, _poll_timer2, SUB_WINDOWING = +setup.windowing || DEF_WINDOWING, SUB_TIMEOUT = (+setup.timeout || DEF_SUB_TIMEOUT) * SECOND, KEEPALIVE = (+setup.keepalive || DEF_KEEPALIVE) * SECOND, TIME_CHECK = setup.timecheck || 0, NOLEAVE = setup.noleave || 0, PUBLISH_KEY = setup.publish_key, SUBSCRIBE_KEY = setup.subscribe_key, AUTH_KEY = setup.auth_key || "", SECRET_KEY = setup.secret_key || "", hmac_SHA256 = setup.hmac_SHA256, SSL = setup.ssl ? "s" : "", ORIGIN = "http" + SSL + "://" + (setup.origin || "pubsub.pubnub.com"), STD_ORIGIN = nextorigin(ORIGIN), SUB_ORIGIN = nextorigin(ORIGIN), CONNECT = function() {}, PUB_QUEUE = [], CLOAK = !0, TIME_DRIFT = 0, SUB_CALLBACK = 0, SUB_CHANNEL = 0, SUB_RECEIVER = 0, SUB_RESTORE = setup.restore || 0, TIMETOKEN = 0, RESUMED = !1, CHANNELS = {}, CHANNEL_GROUPS = {}, STATE = {}, PRESENCE_HB_TIMEOUT = null, PRESENCE_HB = validate_presence_heartbeat(setup.heartbeat || setup.pnexpires || 0, setup.error), PRESENCE_HB_INTERVAL = setup.heartbeat_interval || PRESENCE_HB / 2 - 1, PRESENCE_HB_RUNNING = !1, NO_WAIT_FOR_PENDING = setup.no_wait_for_pending, COMPATIBLE_35 = setup["compatible_3.5"] || !1, xdr = setup.xdr, params = setup.params || {}, error = setup.error || function() {}, _is_online = setup._is_online || function() {
                return 1;
            }, jsonp_cb = setup.jsonp_cb || function() {
                return 0;
            }, db = setup.db || {
                get: function() {},
                set: function() {}
            }, CIPHER_KEY = setup.cipher_key, UUID = setup.uuid || !setup.unique_uuid && db && db.get(SUBSCRIBE_KEY + "uuid") || "", USE_INSTANCEID = setup.instance_id || !1, INSTANCEID = "", shutdown = setup.shutdown, use_send_beacon = "undefined" != typeof setup.use_send_beacon ? setup.use_send_beacon : !0, sendBeacon = use_send_beacon ? setup.sendBeacon : null;
            2 === PRESENCE_HB && (PRESENCE_HB_INTERVAL = 1);
            var crypto_obj = setup.crypto_obj || {
                encrypt: function(a) {
                    return a;
                },
                decrypt: function(b) {
                    return b;
                }
            }, SELF = {
                LEAVE: function(channel, blocking, auth_key, callback, error) {
                    var url, params, data = {
                        uuid: UUID,
                        auth: auth_key || AUTH_KEY
                    }, origin = nextorigin(ORIGIN), callback = callback || function() {}, err = error || function() {}, jsonp = jsonp_cb();
                    if (channel.indexOf(PRESENCE_SUFFIX) > 0) return !0;
                    if (COMPATIBLE_35) {
                        if (!SSL) return !1;
                        if ("0" == jsonp) return !1;
                    }
                    if (NOLEAVE) return !1;
                    if ("0" != jsonp && (data.callback = jsonp), USE_INSTANCEID && (data.instanceid = INSTANCEID), 
                    url = [ origin, "v2", "presence", "sub_key", SUBSCRIBE_KEY, "channel", utils.encode(channel), "leave" ], 
                    params = _get_url_params(data), sendBeacon) {
                        var url_string = utils.buildURL(url, params);
                        if (sendBeacon(url_string)) return callback && callback({
                            status: 200,
                            action: "leave",
                            message: "OK",
                            service: "Presence"
                        }), !0;
                    }
                    return xdr({
                        blocking: blocking || SSL,
                        callback: jsonp,
                        data: params,
                        success: function(response) {
                            _invoke_callback(response, callback, err);
                        },
                        fail: function(response) {
                            _invoke_error(response, err);
                        },
                        url: url
                    }), !0;
                },
                LEAVE_GROUP: function(channel_group, blocking, auth_key, callback, error) {
                    var url, params, data = {
                        uuid: UUID,
                        auth: auth_key || AUTH_KEY
                    }, origin = nextorigin(ORIGIN), callback = callback || function() {}, err = error || function() {}, jsonp = jsonp_cb();
                    if (channel_group.indexOf(PRESENCE_SUFFIX) > 0) return !0;
                    if (COMPATIBLE_35) {
                        if (!SSL) return !1;
                        if ("0" == jsonp) return !1;
                    }
                    if (NOLEAVE) return !1;
                    if ("0" != jsonp && (data.callback = jsonp), channel_group && channel_group.length > 0 && (data["channel-group"] = channel_group), 
                    USE_INSTANCEID && (data.instanceid = INSTANCEID), url = [ origin, "v2", "presence", "sub_key", SUBSCRIBE_KEY, "channel", utils.encode(","), "leave" ], 
                    params = _get_url_params(data), sendBeacon) {
                        var url_string = utils.buildURL(url, params);
                        if (sendBeacon(url_string)) return callback && callback({
                            status: 200,
                            action: "leave",
                            message: "OK",
                            service: "Presence"
                        }), !0;
                    }
                    return xdr({
                        blocking: blocking || SSL,
                        callback: jsonp,
                        data: params,
                        success: function(response) {
                            _invoke_callback(response, callback, err);
                        },
                        fail: function(response) {
                            _invoke_error(response, err);
                        },
                        url: url
                    }), !0;
                },
                set_resumed: function(resumed) {
                    RESUMED = resumed;
                },
                get_cipher_key: function() {
                    return CIPHER_KEY;
                },
                set_cipher_key: function(key) {
                    CIPHER_KEY = key;
                },
                raw_encrypt: function(input, key) {
                    return encrypt(input, key);
                },
                raw_decrypt: function(input, key) {
                    return decrypt(input, key);
                },
                get_heartbeat: function() {
                    return PRESENCE_HB;
                },
                set_heartbeat: function(heartbeat, heartbeat_interval) {
                    PRESENCE_HB = validate_presence_heartbeat(heartbeat, PRESENCE_HB, error), PRESENCE_HB_INTERVAL = heartbeat_interval || PRESENCE_HB / 2 - 1, 
                    2 == PRESENCE_HB && (PRESENCE_HB_INTERVAL = 1), CONNECT(), _presence_heartbeat();
                },
                get_heartbeat_interval: function() {
                    return PRESENCE_HB_INTERVAL;
                },
                set_heartbeat_interval: function(heartbeat_interval) {
                    PRESENCE_HB_INTERVAL = heartbeat_interval, _presence_heartbeat();
                },
                get_version: function() {
                    return SDK_VER;
                },
                getGcmMessageObject: function(obj) {
                    return {
                        data: obj
                    };
                },
                getApnsMessageObject: function(obj) {
                    var x = {
                        aps: {
                            badge: 1,
                            alert: ""
                        }
                    };
                    for (var k in obj) k[x] = obj[k];
                    return x;
                },
                _add_param: function(key, val) {
                    params[key] = val;
                },
                channel_group: function(args, callback) {
                    var namespace, channel_group, ns_ch = args.channel_group, callback = callback || args.callback, channels = args.channels || args.channel, cloak = args.cloak, url = [], data = {}, mode = args.mode || "add";
                    if (ns_ch) {
                        var ns_ch_a = ns_ch.split(":");
                        ns_ch_a.length > 1 ? (namespace = "*" === ns_ch_a[0] ? null : ns_ch_a[0], channel_group = ns_ch_a[1]) : channel_group = ns_ch_a[0];
                    }
                    namespace && url.push("namespace") && url.push(utils.encode(namespace)), url.push("channel-group"), 
                    channel_group && "*" !== channel_group && url.push(channel_group), channels ? (utils.isArray(channels) && (channels = channels.join(",")), 
                    data[mode] = channels, data.cloak = CLOAK ? "true" : "false") : "remove" === mode && url.push("remove"), 
                    "undefined" != typeof cloak && (data.cloak = cloak ? "true" : "false"), CR(args, callback, url, data);
                },
                channel_group_list_groups: function(args, callback) {
                    var namespace;
                    namespace = args.namespace || args.ns || args.channel_group || null, namespace && (args.channel_group = namespace + ":*"), 
                    SELF.channel_group(args, callback);
                },
                channel_group_list_channels: function(args, callback) {
                    return args.channel_group ? void SELF.channel_group(args, callback) : error("Missing Channel Group");
                },
                channel_group_remove_channel: function(args, callback) {
                    return args.channel_group ? args.channel || args.channels ? (args.mode = "remove", 
                    void SELF.channel_group(args, callback)) : error("Missing Channel") : error("Missing Channel Group");
                },
                channel_group_remove_group: function(args, callback) {
                    return args.channel_group ? args.channel ? error("Use channel_group_remove_channel if you want to remove a channel from a group.") : (args.mode = "remove", 
                    void SELF.channel_group(args, callback)) : error("Missing Channel Group");
                },
                channel_group_add_channel: function(args, callback) {
                    return args.channel_group ? args.channel || args.channels ? void SELF.channel_group(args, callback) : error("Missing Channel") : error("Missing Channel Group");
                },
                channel_group_cloak: function(args, callback) {
                    return "undefined" == typeof args.cloak ? void callback(CLOAK) : (CLOAK = args.cloak, 
                    void SELF.channel_group(args, callback));
                },
                channel_group_list_namespaces: function(args, callback) {
                    var url = [ "namespace" ];
                    CR(args, callback, url);
                },
                channel_group_remove_namespace: function(args, callback) {
                    var url = [ "namespace", args.namespace, "remove" ];
                    CR(args, callback, url);
                },
                history: function(args, callback) {
                    var callback = args.callback || callback, count = args.count || args.limit || 100, reverse = args.reverse || "false", err = args.error || function() {}, auth_key = args.auth_key || AUTH_KEY, cipher_key = args.cipher_key, channel = args.channel, channel_group = args.channel_group, start = args.start, end = args.end, include_token = args.include_token, string_msg_token = args.string_message_token || !1, params = {}, jsonp = jsonp_cb();
                    return channel || channel_group ? callback ? SUBSCRIBE_KEY ? (params.stringtoken = "true", 
                    params.count = count, params.reverse = reverse, params.auth = auth_key, channel_group && (params["channel-group"] = channel_group, 
                    channel || (channel = ",")), jsonp && (params.callback = jsonp), start && (params.start = start), 
                    end && (params.end = end), include_token && (params.include_token = "true"), string_msg_token && (params.string_message_token = "true"), 
                    void xdr({
                        callback: jsonp,
                        data: _get_url_params(params),
                        success: function(response) {
                            if ("object" == typeof response && response.error) return void err({
                                message: response.message,
                                payload: response.payload
                            });
                            for (var messages = response[0], decrypted_messages = [], a = 0; a < messages.length; a++) if (include_token) {
                                var new_message = decrypt(messages[a].message, cipher_key), timetoken = messages[a].timetoken;
                                try {
                                    decrypted_messages.push({
                                        message: JSON.parse(new_message),
                                        timetoken: timetoken
                                    });
                                } catch (e) {
                                    decrypted_messages.push({
                                        message: new_message,
                                        timetoken: timetoken
                                    });
                                }
                            } else {
                                var new_message = decrypt(messages[a], cipher_key);
                                try {
                                    decrypted_messages.push(JSON.parse(new_message));
                                } catch (e) {
                                    decrypted_messages.push(new_message);
                                }
                            }
                            callback([ decrypted_messages, response[1], response[2] ]);
                        },
                        fail: function(response) {
                            _invoke_error(response, err);
                        },
                        url: [ STD_ORIGIN, "v2", "history", "sub-key", SUBSCRIBE_KEY, "channel", utils.encode(channel) ]
                    })) : error("Missing Subscribe Key") : error("Missing Callback") : error("Missing Channel");
                },
                replay: function(args, callback) {
                    var url, callback = callback || args.callback || function() {}, auth_key = args.auth_key || AUTH_KEY, source = args.source, destination = args.destination, err = args.error || args.error || function() {}, stop = args.stop, start = args.start, end = args.end, reverse = args.reverse, limit = args.limit, jsonp = jsonp_cb(), data = {};
                    return source ? destination ? PUBLISH_KEY ? SUBSCRIBE_KEY ? ("0" != jsonp && (data.callback = jsonp), 
                    stop && (data.stop = "all"), reverse && (data.reverse = "true"), start && (data.start = start), 
                    end && (data.end = end), limit && (data.count = limit), data.auth = auth_key, url = [ STD_ORIGIN, "v1", "replay", PUBLISH_KEY, SUBSCRIBE_KEY, source, destination ], 
                    void xdr({
                        callback: jsonp,
                        success: function(response) {
                            _invoke_callback(response, callback, err);
                        },
                        fail: function() {
                            callback([ 0, "Disconnected" ]);
                        },
                        url: url,
                        data: _get_url_params(data)
                    })) : error("Missing Subscribe Key") : error("Missing Publish Key") : error("Missing Destination Channel") : error("Missing Source Channel");
                },
                auth: function(auth) {
                    AUTH_KEY = auth, CONNECT();
                },
                time: function(callback) {
                    var jsonp = jsonp_cb(), data = {
                        uuid: UUID,
                        auth: AUTH_KEY
                    };
                    USE_INSTANCEID && (data.instanceid = INSTANCEID), xdr({
                        callback: jsonp,
                        data: _get_url_params(data),
                        url: [ STD_ORIGIN, "time", jsonp ],
                        success: function(response) {
                            callback(response[0]);
                        },
                        fail: function() {
                            callback(0);
                        }
                    });
                },
                publish: function(args, callback) {
                    var msg = args.message;
                    if (!msg) return error("Missing Message");
                    var params, url, callback = callback || args.callback || msg.callback || args.success || function() {}, channel = args.channel || msg.channel, meta = args.meta || args.metadata, auth_key = args.auth_key || AUTH_KEY, cipher_key = args.cipher_key, err = args.error || msg.error || function() {}, post = args.post || !1, store = "store_in_history" in args ? args.store_in_history : !0, replicate = "replicate" in args ? args.replicate : !0, jsonp = jsonp_cb(), add_msg = "push";
                    return args.prepend && (add_msg = "unshift"), channel ? PUBLISH_KEY ? SUBSCRIBE_KEY ? (msg.getPubnubMessage && (msg = msg.getPubnubMessage()), 
                    msg = JSON.stringify(encrypt(msg, cipher_key)), url = [ STD_ORIGIN, "publish", PUBLISH_KEY, SUBSCRIBE_KEY, 0, utils.encode(channel), jsonp, utils.encode(msg) ], 
                    params = {
                        uuid: UUID,
                        auth: auth_key
                    }, meta && "object" == typeof meta && (params.meta = JSON.stringify(meta)), store || (params.store = "0"), 
                    replicate || (params.norep = "true"), USE_INSTANCEID && (params.instanceid = INSTANCEID), 
                    PUB_QUEUE[add_msg]({
                        callback: jsonp,
                        url: url,
                        data: _get_url_params(params),
                        fail: function(response) {
                            _invoke_error(response, err), publish(1);
                        },
                        success: function(response) {
                            _invoke_callback(response, callback, err), publish(1);
                        },
                        mode: post ? "POST" : "GET"
                    }), void publish()) : error("Missing Subscribe Key") : error("Missing Publish Key") : error("Missing Channel");
                },
                fire: function(args, callback) {
                    args.store_in_history = !1, args.replicate = !1, SELF.publish(args, callback);
                },
                unsubscribe: function(args, callback) {
                    var channelArg = args.channel, channelGroupArg = args.channel_group, auth_key = args.auth_key || AUTH_KEY, callback = callback || args.callback || function() {}, err = args.error || function() {};
                    if (!channelArg && !channelGroupArg) return error("Missing Channel or Channel Group");
                    if (!SUBSCRIBE_KEY) return error("Missing Subscribe Key");
                    if (channelArg) {
                        var channels = utils.isArray(channelArg) ? channelArg : ("" + channelArg).split(","), existingChannels = [], presenceChannels = [];
                        if (utils.each(channels, function(channel) {
                            CHANNELS[channel] && existingChannels.push(channel);
                        }), 0 == existingChannels.length) return void callback({
                            action: "leave"
                        });
                        utils.each(existingChannels, function(channel) {
                            presenceChannels.push(channel + PRESENCE_SUFFIX);
                        }), utils.each(existingChannels.concat(presenceChannels), function(channel) {
                            channel in CHANNELS && delete CHANNELS[channel], channel in STATE && delete STATE[channel];
                        }), 0 === CHANNELS.length && 0 === CHANNEL_GROUPS.length && (TIMETOKEN = 0);
                        var CB_CALLED = !0;
                        READY && (CB_CALLED = SELF.LEAVE(existingChannels.join(","), 0, auth_key, callback, err)), 
                        CB_CALLED || callback({
                            action: "leave"
                        });
                    }
                    if (channelGroupArg) {
                        var channelGroups = utils.isArray(channelGroupArg) ? channelGroupArg : ("" + channelGroupArg).split(","), existingChannelGroups = [], presenceChannelGroups = [];
                        if (utils.each(channelGroups, function(channelGroup) {
                            CHANNEL_GROUPS[channelGroup] && existingChannelGroups.push(channelGroup);
                        }), 0 == existingChannelGroups.length) return void callback({
                            action: "leave"
                        });
                        utils.each(existingChannelGroups, function(channelGroup) {
                            presenceChannelGroups.push(channelGroup + PRESENCE_SUFFIX);
                        }), utils.each(existingChannelGroups.concat(presenceChannelGroups), function(channelGroup) {
                            channelGroup in CHANNEL_GROUPS && delete CHANNEL_GROUPS[channelGroup], channelGroup in STATE && delete STATE[channelGroup];
                        }), 0 === CHANNELS.length && 0 === CHANNEL_GROUPS.length && (TIMETOKEN = 0);
                        var CB_CALLED = !0;
                        READY && (CB_CALLED = SELF.LEAVE_GROUP(existingChannelGroups.join(","), 0, auth_key, callback, err)), 
                        CB_CALLED || callback({
                            action: "leave"
                        });
                    }
                    CONNECT();
                },
                subscribe: function(args, callback) {
                    function _test_connection(success) {
                        success ? utils.timeout(CONNECT, windowing) : (STD_ORIGIN = nextorigin(ORIGIN, 1), 
                        SUB_ORIGIN = nextorigin(ORIGIN, 1), utils.timeout(function() {
                            SELF.time(_test_connection);
                        }, SECOND)), each_channel(function(channel) {
                            return success && channel.disconnected ? (channel.disconnected = 0, channel.reconnect(channel.name)) : void (success || channel.disconnected || (channel.disconnected = 1, 
                            channel.disconnect(channel.name)));
                        }), each_channel_group(function(channel_group) {
                            return success && channel_group.disconnected ? (channel_group.disconnected = 0, 
                            channel_group.reconnect(channel_group.name)) : void (success || channel_group.disconnected || (channel_group.disconnected = 1, 
                            channel_group.disconnect(channel_group.name)));
                        });
                    }
                    function _connect() {
                        var jsonp = jsonp_cb(), channels = generate_channel_list(CHANNELS).join(","), channel_groups = generate_channel_group_list(CHANNEL_GROUPS).join(",");
                        if (channels || channel_groups) {
                            channels || (channels = ","), _reset_offline();
                            var data = _get_url_params({
                                uuid: UUID,
                                auth: AUTH_KEY
                            });
                            channel_groups && (data["channel-group"] = channel_groups);
                            var st = JSON.stringify(STATE);
                            st.length > 2 && (data.state = JSON.stringify(STATE)), PRESENCE_HB && (data.heartbeat = PRESENCE_HB), 
                            USE_INSTANCEID && (data.instanceid = INSTANCEID), start_presence_heartbeat(), SUB_RECEIVER = xdr({
                                timeout: sub_timeout,
                                callback: jsonp,
                                fail: function(response) {
                                    response && response.error && response.service ? (_invoke_error(response, SUB_ERROR), 
                                    _test_connection(!1)) : SELF.time(function(success) {
                                        !success && _invoke_error(response, SUB_ERROR), _test_connection(success);
                                    });
                                },
                                data: _get_url_params(data),
                                url: [ SUB_ORIGIN, "subscribe", SUBSCRIBE_KEY, utils.encode(channels), jsonp, TIMETOKEN ],
                                success: function(messages) {
                                    if (!messages || "object" == typeof messages && "error" in messages && messages.error) return SUB_ERROR(messages), 
                                    utils.timeout(CONNECT, SECOND);
                                    if (idlecb(messages[1]), TIMETOKEN = !TIMETOKEN && SUB_RESTORE && db.get(SUBSCRIBE_KEY) || messages[1], 
                                    each_channel(function(channel) {
                                        channel.connected || (channel.connected = 1, channel.connect(channel.name));
                                    }), each_channel_group(function(channel_group) {
                                        channel_group.connected || (channel_group.connected = 1, channel_group.connect(channel_group.name));
                                    }), RESUMED && !SUB_RESTORE) return TIMETOKEN = 0, RESUMED = !1, db.set(SUBSCRIBE_KEY, 0), 
                                    void utils.timeout(_connect, windowing);
                                    backfill && (TIMETOKEN = 1e4, backfill = 0), db.set(SUBSCRIBE_KEY, messages[1]);
                                    var next_callback = function() {
                                        var channels = "", channels2 = "";
                                        messages.length > 3 ? (channels = messages[3], channels2 = messages[2]) : channels = messages.length > 2 ? messages[2] : utils.map(generate_channel_list(CHANNELS), function(chan) {
                                            return utils.map(Array(messages[0].length).join(",").split(","), function() {
                                                return chan;
                                            });
                                        }).join(",");
                                        var list = channels.split(","), list2 = channels2 ? channels2.split(",") : [];
                                        return function() {
                                            var channel = list.shift() || SUB_CHANNEL, channel2 = list2.shift(), chobj = {};
                                            channel2 ? (channel && channel.indexOf("-pnpres") >= 0 && channel2.indexOf("-pnpres") < 0 && (channel2 += "-pnpres"), 
                                            chobj = CHANNEL_GROUPS[channel2] || CHANNELS[channel2] || {
                                                callback: function() {}
                                            }) : chobj = CHANNELS[channel];
                                            var r = [ chobj.callback || SUB_CALLBACK, channel.split(PRESENCE_SUFFIX)[0] ];
                                            return channel2 && r.push(channel2.split(PRESENCE_SUFFIX)[0]), r;
                                        };
                                    }(), latency = detect_latency(+messages[1]);
                                    utils.each(messages[0], function(msg) {
                                        var next = next_callback(), decrypted_msg = decrypt(msg, CHANNELS[next[1]] ? CHANNELS[next[1]].cipher_key : null);
                                        next[0] && next[0](decrypted_msg, messages, next[2] || next[1], latency, next[1]);
                                    }), utils.timeout(_connect, windowing);
                                }
                            });
                        }
                    }
                    var channel = args.channel, channel_group = args.channel_group, callback = callback || args.callback, callback = callback || args.message, connect = args.connect || function() {}, reconnect = args.reconnect || function() {}, disconnect = args.disconnect || function() {}, SUB_ERROR = args.error || SUB_ERROR || function() {}, idlecb = args.idle || function() {}, presence = args.presence || 0, noheresync = args.noheresync || 0, backfill = args.backfill || 0, timetoken = args.timetoken || 0, sub_timeout = args.timeout || SUB_TIMEOUT, windowing = args.windowing || SUB_WINDOWING, state = args.state, heartbeat = args.heartbeat || args.pnexpires, heartbeat_interval = args.heartbeat_interval, restore = args.restore || SUB_RESTORE;
                    return AUTH_KEY = args.auth_key || AUTH_KEY, SUB_RESTORE = restore, TIMETOKEN = timetoken, 
                    channel || channel_group ? callback ? SUBSCRIBE_KEY ? ((heartbeat || 0 === heartbeat || heartbeat_interval || 0 === heartbeat_interval) && SELF.set_heartbeat(heartbeat, heartbeat_interval), 
                    channel && utils.each((channel.join ? channel.join(",") : "" + channel).split(","), function(channel) {
                        var settings = CHANNELS[channel] || {};
                        CHANNELS[SUB_CHANNEL = channel] = {
                            name: channel,
                            connected: settings.connected,
                            disconnected: settings.disconnected,
                            subscribed: 1,
                            callback: SUB_CALLBACK = callback,
                            cipher_key: args.cipher_key,
                            connect: connect,
                            disconnect: disconnect,
                            reconnect: reconnect
                        }, state && (STATE[channel] = channel in state ? state[channel] : state), presence && (SELF.subscribe({
                            channel: channel + PRESENCE_SUFFIX,
                            callback: presence,
                            restore: restore
                        }), settings.subscribed || noheresync || SELF.here_now({
                            channel: channel,
                            data: _get_url_params({
                                uuid: UUID,
                                auth: AUTH_KEY
                            }),
                            callback: function(here) {
                                utils.each("uuids" in here ? here.uuids : [], function(uid) {
                                    presence({
                                        action: "join",
                                        uuid: uid,
                                        timestamp: Math.floor(utils.rnow() / 1e3),
                                        occupancy: here.occupancy || 1
                                    }, here, channel);
                                });
                            }
                        }));
                    }), channel_group && utils.each((channel_group.join ? channel_group.join(",") : "" + channel_group).split(","), function(channel_group) {
                        var settings = CHANNEL_GROUPS[channel_group] || {};
                        CHANNEL_GROUPS[channel_group] = {
                            name: channel_group,
                            connected: settings.connected,
                            disconnected: settings.disconnected,
                            subscribed: 1,
                            callback: SUB_CALLBACK = callback,
                            cipher_key: args.cipher_key,
                            connect: connect,
                            disconnect: disconnect,
                            reconnect: reconnect
                        }, presence && (SELF.subscribe({
                            channel_group: channel_group + PRESENCE_SUFFIX,
                            callback: presence,
                            restore: restore,
                            auth_key: AUTH_KEY
                        }), settings.subscribed || noheresync || SELF.here_now({
                            channel_group: channel_group,
                            data: _get_url_params({
                                uuid: UUID,
                                auth: AUTH_KEY
                            }),
                            callback: function(here) {
                                utils.each("uuids" in here ? here.uuids : [], function(uid) {
                                    presence({
                                        action: "join",
                                        uuid: uid,
                                        timestamp: Math.floor(utils.rnow() / 1e3),
                                        occupancy: here.occupancy || 1
                                    }, here, channel_group);
                                });
                            }
                        }));
                    }), CONNECT = function() {
                        _reset_offline(), utils.timeout(_connect, windowing);
                    }, READY ? void CONNECT() : READY_BUFFER.push(CONNECT)) : error("Missing Subscribe Key") : error("Missing Callback") : error("Missing Channel");
                },
                here_now: function(args, callback) {
                    var callback = args.callback || callback, debug = args.debug, err = args.error || function() {}, auth_key = args.auth_key || AUTH_KEY, channel = args.channel, channel_group = args.channel_group, jsonp = jsonp_cb(), uuids = "uuids" in args ? args.uuids : !0, state = args.state, data = {
                        uuid: UUID,
                        auth: auth_key
                    };
                    if (uuids || (data.disable_uuids = 1), state && (data.state = 1), !callback) return error("Missing Callback");
                    if (!SUBSCRIBE_KEY) return error("Missing Subscribe Key");
                    var url = [ STD_ORIGIN, "v2", "presence", "sub_key", SUBSCRIBE_KEY ];
                    channel && url.push("channel") && url.push(utils.encode(channel)), "0" != jsonp && (data.callback = jsonp), 
                    channel_group && (data["channel-group"] = channel_group, !channel && url.push("channel") && url.push(",")), 
                    USE_INSTANCEID && (data.instanceid = INSTANCEID), xdr({
                        callback: jsonp,
                        data: _get_url_params(data),
                        success: function(response) {
                            _invoke_callback(response, callback, err);
                        },
                        fail: function(response) {
                            _invoke_error(response, err);
                        },
                        debug: debug,
                        url: url
                    });
                },
                where_now: function(args, callback) {
                    var callback = args.callback || callback, err = args.error || function() {}, auth_key = args.auth_key || AUTH_KEY, jsonp = jsonp_cb(), uuid = args.uuid || UUID, data = {
                        auth: auth_key
                    };
                    return callback ? SUBSCRIBE_KEY ? ("0" != jsonp && (data.callback = jsonp), USE_INSTANCEID && (data.instanceid = INSTANCEID), 
                    void xdr({
                        callback: jsonp,
                        data: _get_url_params(data),
                        success: function(response) {
                            _invoke_callback(response, callback, err);
                        },
                        fail: function(response) {
                            _invoke_error(response, err);
                        },
                        url: [ STD_ORIGIN, "v2", "presence", "sub_key", SUBSCRIBE_KEY, "uuid", utils.encode(uuid) ]
                    })) : error("Missing Subscribe Key") : error("Missing Callback");
                },
                state: function(args, callback) {
                    var url, callback = args.callback || callback || function() {}, err = args.error || function() {}, auth_key = args.auth_key || AUTH_KEY, jsonp = jsonp_cb(), state = args.state, uuid = args.uuid || UUID, channel = args.channel, channel_group = args.channel_group, data = _get_url_params({
                        auth: auth_key
                    });
                    return SUBSCRIBE_KEY ? uuid ? channel || channel_group ? ("0" != jsonp && (data.callback = jsonp), 
                    "undefined" != typeof channel && CHANNELS[channel] && CHANNELS[channel].subscribed && state && (STATE[channel] = state), 
                    "undefined" != typeof channel_group && CHANNEL_GROUPS[channel_group] && CHANNEL_GROUPS[channel_group].subscribed && (state && (STATE[channel_group] = state), 
                    data["channel-group"] = channel_group, channel || (channel = ",")), data.state = JSON.stringify(state), 
                    USE_INSTANCEID && (data.instanceid = INSTANCEID), url = state ? [ STD_ORIGIN, "v2", "presence", "sub-key", SUBSCRIBE_KEY, "channel", channel, "uuid", uuid, "data" ] : [ STD_ORIGIN, "v2", "presence", "sub-key", SUBSCRIBE_KEY, "channel", channel, "uuid", utils.encode(uuid) ], 
                    void xdr({
                        callback: jsonp,
                        data: _get_url_params(data),
                        success: function(response) {
                            _invoke_callback(response, callback, err);
                        },
                        fail: function(response) {
                            _invoke_error(response, err);
                        },
                        url: url
                    })) : error("Missing Channel") : error("Missing UUID") : error("Missing Subscribe Key");
                },
                grant: function(args, callback) {
                    var callback = args.callback || callback, err = args.error || function() {}, channel = args.channel || args.channels, channel_group = args.channel_group, jsonp = jsonp_cb(), ttl = args.ttl, r = args.read ? "1" : "0", w = args.write ? "1" : "0", m = args.manage ? "1" : "0", auth_key = args.auth_key || args.auth_keys;
                    if (!callback) return error("Missing Callback");
                    if (!SUBSCRIBE_KEY) return error("Missing Subscribe Key");
                    if (!PUBLISH_KEY) return error("Missing Publish Key");
                    if (!SECRET_KEY) return error("Missing Secret Key");
                    var timestamp = Math.floor(new Date().getTime() / 1e3), sign_input = SUBSCRIBE_KEY + "\n" + PUBLISH_KEY + "\ngrant\n", data = {
                        w: w,
                        r: r,
                        timestamp: timestamp
                    };
                    args.manage && (data.m = m), utils.isArray(channel) && (channel = channel.join(",")), 
                    utils.isArray(auth_key) && (auth_key = auth_key.join(",")), "undefined" != typeof channel && null != channel && channel.length > 0 && (data.channel = channel), 
                    "undefined" != typeof channel_group && null != channel_group && channel_group.length > 0 && (data["channel-group"] = channel_group), 
                    "0" != jsonp && (data.callback = jsonp), (ttl || 0 === ttl) && (data.ttl = ttl), 
                    auth_key && (data.auth = auth_key), data = _get_url_params(data), auth_key || delete data.auth, 
                    sign_input += _get_pam_sign_input_from_params(data);
                    var signature = hmac_SHA256(sign_input, SECRET_KEY);
                    signature = signature.replace(/\+/g, "-"), signature = signature.replace(/\//g, "_"), 
                    data.signature = signature, xdr({
                        callback: jsonp,
                        data: data,
                        success: function(response) {
                            _invoke_callback(response, callback, err);
                        },
                        fail: function(response) {
                            _invoke_error(response, err);
                        },
                        url: [ STD_ORIGIN, "v1", "auth", "grant", "sub-key", SUBSCRIBE_KEY ]
                    });
                },
                mobile_gw_provision: function(args) {
                    var params, url, callback = args.callback || function() {}, auth_key = args.auth_key || AUTH_KEY, err = args.error || function() {}, jsonp = jsonp_cb(), channel = args.channel, op = args.op, gw_type = args.gw_type, device_id = args.device_id;
                    return device_id ? gw_type ? op ? channel ? SUBSCRIBE_KEY ? (url = [ STD_ORIGIN, "v1/push/sub-key", SUBSCRIBE_KEY, "devices", device_id ], 
                    params = {
                        uuid: UUID,
                        auth: auth_key,
                        type: gw_type
                    }, "add" == op ? params.add = channel : "remove" == op && (params.remove = channel), 
                    USE_INSTANCEID && (params.instanceid = INSTANCEID), void xdr({
                        callback: jsonp,
                        data: params,
                        success: function(response) {
                            _invoke_callback(response, callback, err);
                        },
                        fail: function(response) {
                            _invoke_error(response, err);
                        },
                        url: url
                    })) : error("Missing Subscribe Key") : error("Missing gw destination Channel (channel)") : error("Missing GW Operation (op: add or remove)") : error("Missing GW Type (gw_type: gcm or apns)") : error("Missing Device ID (device_id)");
                },
                audit: function(args, callback) {
                    var callback = args.callback || callback, err = args.error || function() {}, channel = args.channel, channel_group = args.channel_group, auth_key = args.auth_key, jsonp = jsonp_cb();
                    if (!callback) return error("Missing Callback");
                    if (!SUBSCRIBE_KEY) return error("Missing Subscribe Key");
                    if (!PUBLISH_KEY) return error("Missing Publish Key");
                    if (!SECRET_KEY) return error("Missing Secret Key");
                    var timestamp = Math.floor(new Date().getTime() / 1e3), sign_input = SUBSCRIBE_KEY + "\n" + PUBLISH_KEY + "\naudit\n", data = {
                        timestamp: timestamp
                    };
                    "0" != jsonp && (data.callback = jsonp), "undefined" != typeof channel && null != channel && channel.length > 0 && (data.channel = channel), 
                    "undefined" != typeof channel_group && null != channel_group && channel_group.length > 0 && (data["channel-group"] = channel_group), 
                    auth_key && (data.auth = auth_key), data = _get_url_params(data), auth_key || delete data.auth, 
                    sign_input += _get_pam_sign_input_from_params(data);
                    var signature = hmac_SHA256(sign_input, SECRET_KEY);
                    signature = signature.replace(/\+/g, "-"), signature = signature.replace(/\//g, "_"), 
                    data.signature = signature, xdr({
                        callback: jsonp,
                        data: data,
                        success: function(response) {
                            _invoke_callback(response, callback, err);
                        },
                        fail: function(response) {
                            _invoke_error(response, err);
                        },
                        url: [ STD_ORIGIN, "v1", "auth", "audit", "sub-key", SUBSCRIBE_KEY ]
                    });
                },
                revoke: function(args, callback) {
                    args.read = !1, args.write = !1, SELF.grant(args, callback);
                },
                set_uuid: function(uuid) {
                    UUID = uuid, CONNECT();
                },
                get_uuid: function() {
                    return UUID;
                },
                isArray: function(arg) {
                    return utils.isArray(arg);
                },
                get_subscribed_channels: function() {
                    return generate_channel_list(CHANNELS, !0);
                },
                presence_heartbeat: function(args) {
                    var callback = args.callback || function() {}, err = args.error || function() {}, jsonp = jsonp_cb(), data = {
                        uuid: UUID,
                        auth: AUTH_KEY
                    }, st = JSON.stringify(STATE);
                    st.length > 2 && (data.state = JSON.stringify(STATE)), PRESENCE_HB > 0 && 320 > PRESENCE_HB && (data.heartbeat = PRESENCE_HB), 
                    "0" != jsonp && (data.callback = jsonp);
                    var channels = utils.encode(generate_channel_list(CHANNELS, !0).join(",")), channel_groups = generate_channel_group_list(CHANNEL_GROUPS, !0).join(",");
                    channels || (channels = ","), channel_groups && (data["channel-group"] = channel_groups), 
                    USE_INSTANCEID && (data.instanceid = INSTANCEID), xdr({
                        callback: jsonp,
                        data: _get_url_params(data),
                        url: [ STD_ORIGIN, "v2", "presence", "sub-key", SUBSCRIBE_KEY, "channel", channels, "heartbeat" ],
                        success: function(response) {
                            _invoke_callback(response, callback, err);
                        },
                        fail: function(response) {
                            _invoke_error(response, err);
                        }
                    });
                },
                stop_timers: function() {
                    clearTimeout(_poll_timer), clearTimeout(_poll_timer2), clearTimeout(PRESENCE_HB_TIMEOUT);
                },
                shutdown: function() {
                    SELF.stop_timers(), shutdown && shutdown();
                },
                xdr: xdr,
                ready: ready,
                db: db,
                uuid: utils.generateUUID,
                map: utils.map,
                each: utils.each,
                "each-channel": each_channel,
                grep: utils.grep,
                offline: function() {
                    _reset_offline(1, {
                        message: "Offline. Please check your network settings."
                    });
                },
                supplant: utils.supplant,
                now: utils.rnow,
                unique: unique,
                updater: utils.updater
            };
            return UUID || (UUID = SELF.uuid()), INSTANCEID || (INSTANCEID = SELF.uuid()), db.set(SUBSCRIBE_KEY + "uuid", UUID), 
            _poll_timer = utils.timeout(_poll_online, SECOND), _poll_timer2 = utils.timeout(_poll_online2, KEEPALIVE), 
            PRESENCE_HB_TIMEOUT = utils.timeout(start_presence_heartbeat, (PRESENCE_HB_INTERVAL - 3) * SECOND), 
            detect_time_detla(), SELF;
        }
        var packageJSON = __webpack_require__(4), defaultConfiguration = __webpack_require__(6), utils = __webpack_require__(7), NOW = 1, READY = !1, READY_BUFFER = [], PRESENCE_SUFFIX = "-pnpres", DEF_WINDOWING = 10, DEF_TIMEOUT = 15e3, DEF_SUB_TIMEOUT = 310, DEF_KEEPALIVE = 60, SECOND = 1e3, PRESENCE_HB_THRESHOLD = 5, PRESENCE_HB_DEFAULT = 30, SDK_VER = packageJSON.version, nextorigin = function() {
            var max = 20, ori = Math.floor(Math.random() * max);
            return function(origin, failover) {
                return origin.indexOf("pubsub.") > 0 && origin.replace("pubsub", "ps" + (failover ? utils.generateUUID().split("-")[0] : ++ori < max ? ori : ori = 1)) || origin;
            };
        }();
        module.exports = {
            PN_API: PN_API,
            unique: unique,
            PNmessage: PNmessage,
            DEF_TIMEOUT: DEF_TIMEOUT,
            timeout: utils.timeout,
            build_url: utils.buildURL,
            each: utils.each,
            uuid: utils.generateUUID,
            URLBIT: defaultConfiguration.URLBIT,
            grep: utils.grep,
            supplant: utils.supplant,
            now: utils.rnow,
            updater: utils.updater,
            map: utils.map
        };
    }, function(module) {
        module.exports = {
            PARAMSBIT: "&",
            URLBIT: "/"
        };
    }, function(module, exports, __webpack_require__) {
        function rnow() {
            return +new Date();
        }
        function isArray(arg) {
            return !!arg && "string" != typeof arg && (Array.isArray && Array.isArray(arg) || "number" == typeof arg.length);
        }
        function each(o, f) {
            if (o && f) if (isArray(o)) for (var i = 0, l = o.length; l > i; ) f.call(o[i], o[i], i++); else for (var i in o) o.hasOwnProperty && o.hasOwnProperty(i) && f.call(o[i], i, o[i]);
        }
        function encode(path) {
            return encodeURIComponent(path);
        }
        function buildURL(urlComponents, urlParams) {
            var url = urlComponents.join(defaultConfiguration.URLBIT), params = [];
            return urlParams ? (each(urlParams, function(key, value) {
                var valueStr = "object" == typeof value ? JSON.stringify(value) : value;
                "undefined" != typeof value && null !== value && encode(valueStr).length > 0 && params.push(key + "=" + encode(valueStr));
            }), url += "?" + params.join(defaultConfiguration.PARAMSBIT)) : url;
        }
        function updater(fun, rate) {
            var timeout, last = 0, runnit = function() {
                last + rate > rnow() ? (clearTimeout(timeout), timeout = setTimeout(runnit, rate)) : (last = rnow(), 
                fun());
            };
            return runnit;
        }
        function grep(list, fun) {
            var fin = [];
            return each(list || [], function(l) {
                fun(l) && fin.push(l);
            }), fin;
        }
        function supplant(str, values) {
            return str.replace(REPL, function(_, match) {
                return values[match] || _;
            });
        }
        function timeout(fun, wait) {
            return "undefined" != typeof setTimeout ? setTimeout(fun, wait) : void 0;
        }
        function generateUUID(callback) {
            var u = "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(c) {
                var r = 16 * Math.random() | 0, v = "x" === c ? r : 3 & r | 8;
                return v.toString(16);
            });
            return callback && callback(u), u;
        }
        function map(list, fun) {
            var fin = [];
            return each(list || [], function(k, v) {
                fin.push(fun(k, v));
            }), fin;
        }
        function pamEncode(str) {
            return encodeURIComponent(str).replace(/[!'()*~]/g, function(c) {
                return "%" + c.charCodeAt(0).toString(16).toUpperCase();
            });
        }
        var defaultConfiguration = __webpack_require__(6), REPL = /{([\w\-]+)}/g;
        module.exports = {
            buildURL: buildURL,
            encode: encode,
            each: each,
            updater: updater,
            rnow: rnow,
            isArray: isArray,
            map: map,
            pamEncode: pamEncode,
            generateUUID: generateUUID,
            timeout: timeout,
            supplant: supplant,
            grep: grep
        };
    }, function(module) {
        var WS = function(url, protocols) {
            if (!(this instanceof WS)) return new WS(url, protocols);
            var self = this, url = self.url = url || "", bits = (self.protocol = protocols || "Sec-WebSocket-Protocol", 
            url.split("/")), setup = {
                ssl: "wss:" === bits[0],
                origin: bits[2],
                publish_key: bits[3],
                subscribe_key: bits[4],
                channel: bits[5]
            };
            return self.CONNECTING = 0, self.OPEN = 1, self.CLOSING = 2, self.CLOSED = 3, self.CLOSE_NORMAL = 1e3, 
            self.CLOSE_GOING_AWAY = 1001, self.CLOSE_PROTOCOL_ERROR = 1002, self.CLOSE_UNSUPPORTED = 1003, 
            self.CLOSE_TOO_LARGE = 1004, self.CLOSE_NO_STATUS = 1005, self.CLOSE_ABNORMAL = 1006, 
            self.onclose = self.onerror = self.onmessage = self.onopen = self.onsend = function() {}, 
            self.binaryType = "", self.extensions = "", self.bufferedAmount = 0, self.trasnmitting = !1, 
            self.buffer = [], self.readyState = self.CONNECTING, url ? (self.pubnub = PUBNUB.init(setup), 
            self.pubnub.setup = setup, self.setup = setup, void self.pubnub.subscribe({
                restore: !1,
                channel: setup.channel,
                disconnect: self.onerror,
                reconnect: self.onopen,
                error: function() {
                    self.onclose({
                        code: self.CLOSE_ABNORMAL,
                        reason: "Missing URL",
                        wasClean: !1
                    });
                },
                callback: function(message) {
                    self.onmessage({
                        data: message
                    });
                },
                connect: function() {
                    self.readyState = self.OPEN, self.onopen();
                }
            })) : (self.readyState = self.CLOSED, self.onclose({
                code: self.CLOSE_ABNORMAL,
                reason: "Missing URL",
                wasClean: !0
            }), self);
        };
        WS.prototype.send = function(data) {
            var self = this;
            self.pubnub.publish({
                channel: self.pubnub.setup.channel,
                message: data,
                callback: function(response) {
                    self.onsend({
                        data: response
                    });
                }
            });
        }, WS.prototype.close = function() {
            var self = this;
            self.pubnub.unsubscribe({
                channel: self.pubnub.setup.channel
            }), self.readyState = self.CLOSED, self.onclose({});
        }, module.exports = WS;
    } ]);
}), define("portal/js/modules/components/cometService", [ "./componentsModule", "pusher", "pubnub" ], function(module, Pusher) {
    module.factory("CometService", function($rootScope, $stateParams, $interval, $timeout, $filter, PathsService, SessionInfo, LogService, SettingsService, PortalInfoService) {
        function initComet() {
            debug("initComet"), mInitialized || (mPusher = new Pusher(SettingsService.get("pusherApiKey"), {
                encrypted: !0
            }), mPusher.connection.bind("state_change", onPusherStateChange), $interval(cleanupOldServerCalls, 6e5)), 
            mInitialized = !0, mCurrentChannel = "BidSpirit_" + mCurrentHouse.code, mLastServerCalls = {}, 
            initChannel(mCurrentChannel, !0);
        }
        function initChannel(channelName, isGlobalChannel) {
            debug("initChannel:" + channelName), mInitialized && (mPusher.connect(), mPusher.subscribe(channelName).bind(channelName, function(event) {
                debug("pusher event on channel " + channelName), onPusherEvent(event);
            }).bind("pusher:subscription_succeeded", function() {}), mPubnub && mPubnub.subscribe({
                channel: channelName,
                callback: function(event) {
                    onPubnubEvent(event);
                },
                connect: function(channel) {
                    channel == channelName && isGlobalChannel && (debug("Pubnub connected to " + channelName), 
                    mPubnubState = "connected", udpateState());
                },
                reconnect: function() {
                    isGlobalChannel && (debug("Pubnub reconnected"), mPubnubState = "connected", udpateState());
                },
                error: function(errMessage) {
                    debug("Pubnub error: " + errMessage), udpateState();
                },
                disconnect: function() {
                    isGlobalChannel && (debug("Pubnub disconnected"), mPubnubState = "disconnected", 
                    udpateState());
                }
            }));
        }
        function onPubnubEvent(event) {
            handleEvent(event);
        }
        function setPrivateChannel(privateChannel) {
            debug("privateChannel:" + privateChannel), privateChannel && mPrivateChannel != privateChannel && (unsubsribe(mPrivateChannel), 
            mPrivateChannel = privateChannel, initChannel(mPrivateChannel));
        }
        function onPusherEvent(event) {
            handleEvent(event);
        }
        function onPusherStateChange(states) {
            mPusherState = states.current, debug("Pusher state: " + mPusherState), udpateState();
        }
        function addToEventsLog(event) {
            mEventsLog.push(event), mEventsLog.legnth > 30 && mEventsLog.shift();
        }
        function handleEvent(event) {
            if (addToEventsLog(event), mCurrentHouse && event.houseCode == mCurrentHouse.code) switch (event.name) {
              case "Catalog.leadingBidUpdate":
              case "Account.selfPreBidUpdate":
              case "Account.selfPresaleBidCancel":
              case "Account.selfBidRequestUpdate":
              case "Account.auctionParticipationRequested":
              case "Account.updateAuctionApproval":
              case "Auction.stateChanged":
              case "Catalog.lotDetailsUpdate":
              case "Shop.itemPurchase":
                fireEvent(event);
            }
        }
        function fireEvent(event) {
            var fired = !1;
            return mLastServerCalls[event.id] || (isOldEvent(event) || (mLastServerCalls[event.id] = new Date().getTime(), 
            $timeout(function() {
                mScope.$broadcast("cometEvent", event);
            }, 100)), fired = !0), fired;
        }
        function isOldEvent(event) {
            var secondsSinceEvent = (new Date().getTime(), Math.floor(SettingsService.timeSince(event.eventTime) / 1e3));
            return secondsSinceEvent > 10 && LogService.logMessage("Old message - " + secondsSinceEvent + " seconds ago."), 
            secondsSinceEvent > 40 ? !0 : !1;
        }
        function cleanupOldServerCalls() {
            var callIdsToRemove = [], now = new Date().getTime();
            for (callId in mLastServerCalls) now - mLastServerCalls[callId] > 6e4 && callIdsToRemove.push(callId);
            for (var i = 0; i < callIdsToRemove.length; i++) delete mLastServerCalls[callIdsToRemove[i]];
        }
        function udpateState() {
            debug("current state pubnub:" + mPubnubState + ", pusher:" + mPusherState), mConnectedChannel || "connected" != mPubnubState && "connected" != mPusherState || (mConnectedChannel = mCurrentChannel);
        }
        function debug(message) {
            mDebugLog.push($filter("date")(new Date(), "HH:mm:ss") + " " + message), mDebugLog.length > 30 && mDebugLog.shift();
        }
        function listenToHouseEvents(houseId) {
            debug("listenToHouseEvents:" + houseId), stopListening(), mCurrentHouse = PortalInfoService.getHouse(houseId), 
            initComet();
        }
        function unsubsribe(channel) {
            debug("unsubsribe:" + channel), channel && mPubnub && mPubnub.unsubscribe({
                channel: channel
            });
        }
        function stopListening() {
            mCurrentHouse && (mCurrentHouse = null, unsubsribe(mCurrentChannel), mCurrentChannel = null, 
            mConnectedChannel = null, unsubsribe(mPrivateChannel), mPrivateChannel = null, "disconnected" != mPusherState && mPusher.disconnect());
        }
        function getCurrentStateForDebug() {
            for (var i = 0; i < mDebugLog.length; i++) console.debug(mDebugLog[i]);
            for (var i = 0; i < mEventsLog.length; i++) console.debug(mEventsLog[i]);
            return {
                initialized: mInitialized,
                house: mCurrentHouse,
                channel: mCurrentChannel,
                connectedChannel: mConnectedChannel,
                privateChannel: mPrivateChannel,
                pusherState: mPusherState,
                debugLog: mDebugLog,
                lastServerCalls: mLastServerCalls,
                eventsLog: mEventsLog
            };
        }
        return mScope = $rootScope.$new(), mInitialized = null, mCurrentHouse = null, mPusher = null, 
        mPubnub = null, mPubnubState = "disconnected", mPusherState = "disconnected", mCurrentChannel = null, 
        mConnectedChannel = null, mPrivateChannel = null, mLastServerCalls = null, mEventsLog = [], 
        mDebugLog = [], {
            scope: mScope,
            stopListening: stopListening,
            listenToHouseEvents: listenToHouseEvents,
            setPrivateChannel: setPrivateChannel,
            getCurrentStateForDebug: getCurrentStateForDebug
        };
    });
}), define("portal/js/modules/components/index", [ "./componentsModule", "./houseCarouselDirective", "./contentLoaderDirective", "./pageFooterDirective", "./popupsService", "./structuredDataService", "./upperPartDirective", "./housesDropdownDirective", "./upperSpaceHoldersDirective", "./cometService" ], function() {}), 
define("portal/js/modules/navigation/navigationModule", [ "angular" ], function(ng) {
    return ng.module("app.navigation", []);
}), define("portal/js/modules/navigation/upperNavigationController", [ "./navigationModule" ], function(module) {
    module.controller("UpperNavigationController", [ "$scope", "$rootScope", "$window", "$state", "$timeout", "$transitions", "SettingsService", "I18nService", "LocalStorageService", "ViewPortService", "OsInfoService", "PathsService", "PortalNavigationService", "PortalAuthService", "PortalInfoService", "SearchService", "TagsMenusService", function($scope, $rootScope, $window, $state, $timeout, $transitions, SettingsService, I18nService, LocalStorageService, ViewPortService, OsInfoService, PathsService, PortalNavigationService, PortalAuthService, PortalInfoService, SearchService, TagsMenusService) {
        function handleMobileButtonsDisplay() {
            $scope.data.mobileButtons.length;
            switch ($state.current.name) {
              case "app.home":
                $scope.data.mobileButtons = [ "search" ];
                break;

              case "app.search":
                $scope.data.mobileButtons = [ "back", "home" ];
                break;

              default:
                $scope.data.mobileButtons = [ "back", "search", "home" ];
            }
            "app.tags" != $state.current.name && $scope.data.mobileButtons.push("tags"), $scope.data.hideMenus = PortalNavigationService.shouldHideMenus(), 
            $scope.hideHeloBar = "app.choosePortal" == $state.current.name;
        }
        function updateContainer() {
            $scope.data.showContainer = !1, $timeout(function() {
                $scope.data.showContainer = !0;
            }, 10);
        }
        function initTags() {
            var mainTags = SettingsService.get("mainTags");
            if (mainTags) {
                $scope.tagsMenus = [];
                for (var tags = mainTags.split(","), i = 0; i < tags.length; i++) {
                    var tag = tags[i].trim();
                    $scope.tagsMenus.push({
                        header: tag,
                        headerHref: getTagHeaderHref(tag),
                        entries: TagsMenusService.getTagMenuEntries(tag)
                    });
                }
            }
        }
        function getTagHeaderHref(tag) {
            return 0 == tag.indexOf("region") ? PathsService.getPortalUrl($scope.contentType, tag.split("_")[1]) : PathsService.getUiHref("/searchWithTags/" + tag + "_all");
        }
        mLinksLocked = !1, $scope.data = {
            mobileButtons: [],
            showMobileSearch: !1,
            lastSceneStart: null,
            langs: SettingsService.get("languages"),
            showContainer: !0,
            langsVisible: !1,
            searchToken: ""
        }, $scope.setLanguage = function(lang) {
            I18nService.setLang(lang), LocalStorageService.store("lastLang", lang), $rootScope.currentUser && PortalInfoService.setCurrentUserPreferredLang(lang), 
            $timeout(function() {
                $scope.data.langsVisible = !1;
            }, 100);
        }, $scope.logout = function() {
            return PortalAuthService.logout().success(function() {
                $state.go("app.home");
            });
        }, $scope.doSearch = function() {
            SearchService.gotoSearchScene($scope.data.searchToken);
        }, $scope.nextRegistrationStep = function() {
            switch ($scope.currentUser.registrationStage) {
              case "UNCONFIRMED_EMAIL":
                $state.go("app.auth", {
                    authScene: "warning"
                });
                break;

              case "INCOMPLETE_PROFILE":
                $state.go("app.auth", {
                    authScene: "postRegistrationDetails"
                });
            }
        }, $scope.shopsVisible = PortalNavigationService.isShopsVisible(), $scope.otherPortalScenes = PortalNavigationService.getOtherPortalScenes(), 
        $scope.handleMobileButtonClick = function(button) {
            mLinksLocked || (mLinksLocked = !0, $timeout(function() {
                switch (button) {
                  case "home":
                    PortalNavigationService.goHome();
                    break;

                  case "search":
                    SearchService.gotoSearchScene();
                    break;

                  case "tags":
                    $state.go("app.tags");
                    break;

                  case "back":
                    PortalNavigationService.goBack();
                }
                mLinksLocked = !1, OsInfoService.isAndroid() && GlobalConfig.isMobileApp && updateContainer();
            }, 300));
        }, $scope.state = $state, $transitions.onStart({}, function() {
            $scope.data.searchToken = "", $scope.data.lastSceneStart = new Date().getTime();
        }), $transitions.onSuccess({}, function() {
            handleMobileButtonsDisplay();
        }), $scope.$on("i18n.languageChanged", updateContainer), $scope.linkText = PortalNavigationService.linkText, 
        handleMobileButtonsDisplay(), initTags();
    } ]);
}), define("portal/js/modules/navigation/mobileMenuController", [ "./navigationModule" ], function(module) {
    module.controller("MobileMenuController", [ "$scope", "$rootScope", "$timeout", "$state", "$transitions", "PortalAuthService", "PortalNavigationService", "PathsService", "LocalStorageService", function($scope, $rootScope, $timeout, $state, $transitions, PortalAuthService, PortalNavigationService) {
        function hideMenuIfOn() {
            $rootScope.mobileMenuOn && ($rootScope.mobileMenuOn = !1, window.scrollTo(0, 0));
        }
        function hideAfterDelay() {
            $timeout(hideMenuIfOn, 300);
        }
        $scope.mobileApp = GlobalConfig.isMobileApp, $scope.toggleMenu = function() {
            $rootScope.currentUser ? ($scope.langMenuAtBottom = !0, $scope.langMenuName = "bottomLangMenu") : ($scope.langMenuAtBottom = !1, 
            $scope.langMenuName = "upperLangMenu"), $rootScope.mobileMenuOn = $rootScope.mobileMenuOn ? !1 : !0, 
            window.scrollTo(0, 0), $rootScope.mobileMenuOn && $scope.data.hideMenus && $timeout(function() {
                $rootScope.$broadcast("dom.slideMenu", {
                    name: $scope.langMenuName
                });
            }, 100);
        }, $scope.onLanguageClick = function() {
            $scope.langMenuAtBottom && $timeout(function() {
                window.scrollTo(0, 1e4);
            }, 300);
        }, $scope.gotoScene = function(scene, args) {
            $state.go(scene, args), hideAfterDelay();
        }, $scope.logout = function() {
            hideAfterDelay(), PortalAuthService.logout().success(function() {
                $state.go("app.home");
            });
        }, $scope.installApp = function() {
            PortalNavigationService.openAppStorePage();
        }, $scope.otherPortalScenes = PortalNavigationService.getOtherPortalScenes(), $scope.shopsVisible = PortalNavigationService.isShopsVisible(), 
        $scope.gotoPortalScene = PortalNavigationService.gotoPortalScene, $scope.linkText = PortalNavigationService.linkText, 
        $transitions.onSuccess({}, hideAfterDelay), $scope.$on("i18n.languageChanged", hideMenuIfOn), 
        $scope.$on("linkClicked", hideMenuIfOn);
    } ]);
}), define("portal/js/modules/navigation/auctionsMenuController", [ "./navigationModule", "morpheus" ], function(module) {
    module.controller("AuctionsMenuController", [ "$scope", "$rootScope", "$state", "OsInfoService", "ArraysService", "PathsService", "PortalNavigationService", "PopupsService", "PortalInfoService", function($scope, $rootScope, $state, OsInfoService, ArraysService, PathsService, PortalNavigationService, PopupsService, PortalInfoService) {
        function postSaleAuctionsExists() {
            for (var auctions = PortalInfoService.getAuctions(), i = 0; i < auctions.length; i++) if (PortalInfoService.isAuctionInPostSaleMode(auctions[i])) return !0;
            return !1;
        }
        function initLinks() {
            "ART" == $rootScope.contentType ? ($scope.links = [ "coming_auctions", "direct_sale", "auctions_results", "future_auctions", "houses" ], 
            postSaleAuctionsExists() || ArraysService.remove($scope.links, "direct_sale")) : $scope.links = [ "coming_auctions", "ended_auctions", "sellers_list" ], 
            PortalInfoService.checkHasEndedAuctions() || (ArraysService.remove($scope.links, "auctions_results"), 
            ArraysService.remove($scope.links, "ended_auctions"));
        }
        $scope.handleLinkClick = function(link) {
            switch (link) {
              case "coming_auctions":
              case "direct_sale":
                $state.go("app.home");
                break;

              case "ended_auctions":
              case "auctions_results":
                $state.go("app.results", {
                    house: "all",
                    page: 1
                });
                break;

              case "future_auctions":
                PopupsService.showFutureAuctionsPopup();
                break;

              case "sellers_list":
              case "houses":
                $state.go("app.houses");
                break;

              case "real_estate":
              case "cars":
              case "art":
                window.location = PathsService.getPortalUrl(link, $rootScope.currentRegion);
            }
            PortalNavigationService.fireLinkClicked(link, "auctions");
        }, initLinks(), $scope.$on("portalInfo.infoUpdated", initLinks);
    } ]);
}), define("portal/js/modules/navigation/reloadController", [ "./navigationModule" ], function(module) {
    module.controller("ReloadController", [ "$scope", "$window", "$timeout", function($scope, $window, $timeout) {
        $timeout(function() {
            $window.history.back();
        }, 300);
    } ]);
}), define("portal/js/modules/navigation/appSiteWinodwsService", [ "./navigationModule" ], function(module) {
    module.factory("AppSiteWinodwsService", function($rootScope, PathsService, StringsService, I18nService, PortalNavigationService, PortalAuthService, SessionsService, PuffinService, OsInfoService) {
        function getAuctionSiteUrl(auction) {
            if (!auction.house) return null;
            var hash, url = PathsService.getAppSiteUrl(auction.house.code, auction.house.proxyType) + "/";
            return hash = "RUNNING" == auction.state ? "live" : "catalog~" + auction.auctionIdInApp + "~" + auction.dayIdInApp, 
            /iPad|iPhone|iPod/.test(navigator.userAgent) && (url = PathsService.addQueryParamToUrl(url, "hashValue", hash)), 
            url + "#" + hash;
        }
        function showDemoForAuction(auction) {
            var appDemoUrl = getAuctionSiteUrl(auction);
            appDemoUrl = PathsService.addQueryParamToUrl(appDemoUrl, "demoMode", 1), PortalNavigationService.openWindow(appDemoUrl);
        }
        function showDemo(demoCode) {
            var query = "?demoMode=1&", subDomain = "demo-site-qa";
            switch (demoCode) {
              case "classic":
                query += "avatars=0";
                break;

              case "unique":
                query += "avatars=1";
                break;

              case "virtualAuctioneer":
                query += "avatarAuctioneer=1";
            }
            var isCars = "CARS" == $rootScope.contentType;
            switch (I18nService.getCurrentLang()) {
              case "ru":
                query += "&lang=ru", subDomain = "demo-russian-qa", subDomain = isCars ? "demo-cars-russian-qa" : "demo-russian-qa";
                break;

              case "he":
                query += "&lang=he", isCars && (subDomain = "demo-cars-il-qa");
                break;

              default:
                query += "&lang=en", isCars && (subDomain = "demo-cars-il-qa");
            }
            var url = "https://" + subDomain + ".bidspirit.com/" + query;
            window.open(url, "_system");
        }
        function openAuctionSiteWindow(auction, lot) {
            if (auction) {
                var url = getAuctionSiteUrl(auction) + (lot ? "~" + lot.idInApp : "");
                openBidspiritSiteUrl(url, auction.houseId, auction);
            }
        }
        function openBidspiritSiteUrl(url, houseId, auction) {
            var token = null;
            $rootScope.currentUser && "UNCONFIRMED_EMAIL" != $rootScope.currentUser.registrationStage && (token = StringsService.randomString(10), 
            url = PathsService.addQueryParamToUrl(url, "pt", token)), url = PathsService.addQueryParamToUrl(url, "lang", $rootScope.currentLang), 
            url = PathsService.addQueryParamToUrl(url, "fromPortal", "1"), setTimeout(function() {
                GlobalConfig.isMobileApp && auction && "RUNNING" == auction.state && auction.hasVideo ? PuffinService.tryToLaunchWithPuffin(url) : OsInfoService.isMobile() ? GlobalConfig.isMobileApp ? window.open(url, "_system") : window.location = url : window.open(url, "_blank");
            }, 500), token && PortalAuthService.createTokenForAppSite(houseId, token);
        }
        return {
            openAuctionSiteWindow: openAuctionSiteWindow,
            openBidspiritSiteUrl: openBidspiritSiteUrl,
            showDemo: showDemo,
            showDemoForAuction: showDemoForAuction
        };
    });
}), define("portal/js/modules/navigation/portalNavigationService", [ "./navigationModule" ], function(module) {
    module.factory("PortalNavigationService", function($timeout, $rootScope, $state, $stateParams, $window, $uibModal, $transitions, OsInfoService, LogService, AnalyticsService, SettingsService, LocalStorageService, PathsService, I18nService, ArraysService, PortalInfoService, StructuredDataService) {
        function init() {
            StructuredDataService.resetStructuredDataMetaTags(), $transitions.onStart({}, function(transition) {
                $rootScope.$previousState = transition.from(), $rootScope.$previousState.args = transition.from().params, 
                $rootScope.resizeBloced = !1, mBackFn = null, "app.home" == transition.to().name && (mHomePageVisited = !0), 
                trackPageView(), StructuredDataService.resetStructuredDataMetaTags(), $rootScope.inIframe && top.postMessage(transition.to().name, "*");
            }), $transitions.onSuccess({}, function() {
                handleHolyDayBehaviour(), handleMaintenanceBehaviour();
            }), $rootScope.$on("viewPort.orientationChange", function() {
                $state.go("app.reload");
            }), $rootScope.$on("i18n.languageChanged", function() {
                $state.go("app.reload");
            }), $rootScope.$on("portalInfo.infoUpdated", onPortalInfoUpdated), AnalyticsService.trackEvent("init", GlobalConfig.isMobileApp ? "mobile" : "web"), 
            checkIfShouldChoosePortal(), handleHolyDayBehaviour(), handleMaintenanceBehaviour(), 
            $window.addEventListener("message", function(event) {
                var eventData = event.data;
                eventData.bidspiritIframeEventCode && $timeout(function() {
                    $rootScope.$broadcast("bidspiritIframeEvent." + eventData.bidspiritIframeEventCode);
                }, 10);
            });
        }
        function checkIfShouldChoosePortal() {
            $rootScope.firstTimeVisit && shouldChoosePortal() && ($rootScope.initialStateOverridden = !0, 
            $state.go("app.choosePortal"));
        }
        function shouldChoosePortal() {
            return "true" == LocalStorageService.load("portalChoiceNeeded") ? !0 : "false" == LocalStorageService.load("portalChoiceNeeded") ? !1 : "CARS" == $rootScope.contentType ? !1 : -1 == PathsService.getCurrentUiHref().indexOf("!/home/") ? !1 : "IL" != $rootScope.currentRegion ? !1 : $rootScope.firstTimeVisit && GlobalConfig.isMobileApp ? !0 : !1;
        }
        function openWindow(url, options) {
            GlobalConfig.isMobileApp ? (0 == !url.indexOf("http") && (url = "https:" + url), 
            window.open(url, "_system")) : OsInfoService.isMobile() ? window.location = url : window.open(url, "_blank", options);
        }
        function getNewWindowTarget() {
            return GlobalConfig.isMobileApp ? "_system" : OsInfoService.isMobile() ? "_self" : "_blank";
        }
        function showDemoVideo() {
            if ("CARS" == $rootScope.contentType) {
                var videoId = "RU" == $rootScope.currentRegion ? "zw6NpKciVUQ" : "Oo998a3z9DY", demoVideoUrl = "https://www.youtube.com/embed/" + videoId + "?autoplay=1";
                OsInfoService.isMobile() ? openWindow(demoVideoUrl) : $uibModal.open({
                    templateUrl: PathsService.appTemplatePath("info/demoVideo"),
                    size: "lg",
                    controller: function($scope) {
                        $scope.demoVideoUrl = demoVideoUrl;
                    }
                });
            }
        }
        function trackPageView() {
            if (!$rootScope.searchAgentRequest) {
                var uiHref = PathsService.getCurrentUiHref();
                if (uiHref) {
                    var scene = uiHref.substr(uiHref.indexOf("/") + 1);
                    mLastTrackedScene != scene && "reload" != scene && (LogService.logEvent({
                        scene: scene
                    }), AnalyticsService.trackPage(scene), mLastTrackedScene = scene);
                }
            }
        }
        function backFromLotPageToList(houseId, source) {
            switch (source) {
              case "favorites":
              case "purchases":
              case "absenteeBids":
                return void $state.go("app.accountActions", {
                    actionType: source
                });

              case "search":
                return void $state.go("app.search");
            }
        }
        function goBack(ignoreBackFn) {
            mBackFn && !ignoreBackFn ? mBackFn() : history.back();
        }
        function goHome() {
            $state.go("app.home");
        }
        function setBackFn(backFn) {
            mBackFn = backFn;
        }
        function goBackAfterDelay() {
            $timeout.cancel(mBackAfterDelayTimer), mSceneToGoBackFrom = window.location.href, 
            mBackAfterDelayTimer = $timeout(function() {
                window.location.href == mSceneToGoBackFrom && window.history.back();
            }, 100);
        }
        function getAppStorePage() {
            return OsInfoService.isIos() ? $rootScope.BidspiritInfo.itunesAppLink : OsInfoService.isAndroid() ? $rootScope.BidspiritInfo.playstoreAppLink : void 0;
        }
        function openAppStorePage() {
            var appStorePage = getAppStorePage();
            appStorePage ? window.location.href = appStorePage : (alert("Your platform is not supported yet..."), 
            scope.continueOnWeb());
        }
        function handleHolyDayBehaviour() {
            if ($rootScope.judaicaOnly && !$rootScope.searchAgentRequest) {
                var isInDownForHolyDay = "app.downForHolyDay" == $state.current.name;
                PortalInfoService.getPortalInfo().isHolyDay ? isInDownForHolyDay || $state.go("app.downForHolyDay") : isInDownForHolyDay && $state.go("app.home");
            }
        }
        function handleMaintenanceBehaviour() {
            var isInDownForMaintenance = "app.downForMaintenance" == $state.current.name;
            !SettingsService.get("inMaintenanceMode") || isInDownForMaintenance || $rootScope.devMode || $state.go("app.downForMaintenance"), 
            isInDownForMaintenance && !SettingsService.get("inMaintenanceMode") && $state.go("app.home");
        }
        function onPortalInfoUpdated() {
            handleMaintenanceBehaviour(), handleHolyDayBehaviour();
        }
        function isShopsVisible() {
            return PortalInfoService.getShops().length > 1;
        }
        function getAllPortalScenes() {
            switch ($rootScope.currentRegion) {
              case "ALL":
                return [ "ART" ];

              case "RO":
                return [ "CARS" ];

              case "IL":
                return [ "ART", "CARS", "REAL_ESTATE" ];

              case "RU":
                return [ "ART", "CARS" ];

              default:
                return [ "ART" ];
            }
        }
        function getOtherPortalScenes() {
            var scenes = getAllPortalScenes();
            return ArraysService.remove(scenes, $rootScope.contentType), scenes;
        }
	function  gotoPortalScene(contentType){
			LocalStorageService.store("catalogContentType", contentType);
alert("going to "+contentType);
			LocalStorageService.store("portalChoiceNeeded", false);
			if (GlobalConfig.isMobileApp){
				if ($rootScope.contentType==contentType){
					$state.go("app.home");
				} else {
					$state.go("app.home");
					alert("reloading");
					try{
						window.location.reload();
					} catch (e){
						alert("error: "+e);
					}
				}
			} else {
	   			window.location.href = PathsService.getPortalUrl(contentType, $rootScope.currentRegion);
			}
   			
		}
        function gotoRegion(region) {
            GlobalConfig.isMobileApp || -1 == window.location.href.indexOf("bidspirit") ? (LocalStorageService.store("region", region), 
            window.location.reload()) : window.location.href = PathsService.getPortalUrl($rootScope.contentType, region);
        }
        function gotoTagPage(tag) {
            0 == tag.indexOf("region") ? gotoRegion(tag.split("_")[1]) : $state.go("app.searchWithTags", {
                tag: tag.trim()
            });
        }
        function shouldHideMenus() {
            switch ($state.current.name) {
              case "app.downForHolyDay":
              case "app.downForMaintenance":
              case "app.support":
              case "app.choosePortal":
              case "app.supportCase":
                return !0;
            }
            return !1;
        }
        function fireLinkClicked(link, menu) {
            function broadcast() {
                $rootScope.$broadcast("linkClicked", {
                    menu: menu,
                    link: link
                });
            }
            broadcast(), $timeout(broadcast, 0), $timeout(broadcast, 100);
        }
        function linkText(linkName) {
            var textKey;
            if (!linkName) return "";
            switch (linkName.toLowerCase()) {
              case "cars":
                textKey = "link_cars";
                break;

              case "art":
                textKey = "link_art";
                break;

              case "real_estate":
                textKey = "link_real_estate";
                break;

              case "houses":
                textKey = "auction_houses";
                break;

              case "auctions":
                textKey = "the_auctions";
                break;

              case "register":
                textKey = "registeration";
                break;

              case "contact":
                textKey = "contact_us";
                break;

              case "contact_for_sale":
                textKey = "selling_items";
                break;

              case "contact_for_car_sale":
                textKey = "sell_your_car";
                break;

              default:
                textKey = linkName;
            }
            return I18nService.getText(textKey);
        }
        return mBackFn = null, mHomePageVisited = !1, mLastTrackedScene = null, mSceneToGoBackTo = null, 
        mBackAfterDelayTimer = null, mSceneToGoBackFrom = null, {
            init: init,
            goBack: goBack,
            setBackFn: setBackFn,
            goHome: goHome,
            backFromLotPageToList: backFromLotPageToList,
            goBackAfterDelay: goBackAfterDelay,
            openWindow: openWindow,
            getNewWindowTarget: getNewWindowTarget,
            handleHolyDayBehaviour: handleHolyDayBehaviour,
            getAppStorePage: getAppStorePage,
            openAppStorePage: openAppStorePage,
            handleMaintenanceBehaviour: handleMaintenanceBehaviour,
            isShopsVisible: isShopsVisible,
            getOtherPortalScenes: getOtherPortalScenes,
            gotoPortalScene: gotoPortalScene,
            gotoRegion: gotoRegion,
            gotoTagPage: gotoTagPage,
            fireLinkClicked: fireLinkClicked,
            shouldHideMenus: shouldHideMenus,
            showDemoVideo: showDemoVideo,
            linkText: linkText
        };
    });
}), define("portal/js/modules/navigation/installAppButtonDirective", [ "./navigationModule" ], function(module) {
    module.directive("installAppButton", function($rootScope, OsInfoService, PathsService, PortalNavigationService) {
        return {
            restrict: "E",
            replace: !0,
            scope: {
                platform: "=?"
            },
            link: function(scope) {
                var BidspiritInfo = $rootScope.BidspiritInfo;
                switch (scope.platform || (scope.platform = OsInfoService.isAndroid() ? "android" : OsInfoService.isIos() ? "ios" : "android"), 
                scope.platform) {
                  case "ios":
                    scope.href = BidspiritInfo.itunesAppLink;
                    break;

                  case "android":
                    scope.href = BidspiritInfo.playstoreAppLink;
                }
                scope.linkTarget = PortalNavigationService.getNewWindowTarget();
            },
            templateUrl: PathsService.appTemplatePath("components/navigation/installAppButton")
        };
    });
}), define("portal/js/modules/navigation/houseEventsListenerService", [ "./navigationModule" ], function(module) {
    module.factory("HouseEventsListenerService", function($timeout, $rootScope, $state, $stateParams, $uibModalStack, $uibModal, $transitions, PathsService, PortalNavigationService, CometService, PopupsService, PortalInfoService, AppSiteWinodwsService) {
        function init() {
            $transitions.onSuccess({}, function(transition) {
                $stateParams.catalogKey ? mCurrentContextAuction && mCurrentContextAuction.intKey == $stateParams.catalogKey || (mCurrentContextAuction = PortalInfoService.getAuction($stateParams.catalogKey), 
                mCurrentContextShop = PortalInfoService.getShop($stateParams.catalogKey), mCurrentContextAuction ? "RUNNING" == mCurrentContextAuction.state ? alertForAuctionStart() : "ENDED" != mCurrentContextAuction.state || PortalInfoService.isAuctionInPostSaleMode(mCurrentContextAuction) ? mCurrentHouse && mCurrentHouse.id == mCurrentContextAuction.houseId || (mCurrentHouse = PortalInfoService.getHouse(mCurrentContextAuction.houseId), 
                CometService.listenToHouseEvents(mCurrentContextAuction.houseId), $rootScope.$broadcast("catalogContextChanged", mCurrentContextAuction)) : CometService.stopListening() : mCurrentContextShop ? mCurrentHouse && mCurrentHouse.id == mCurrentContextShop.houseId || (mCurrentHouse = PortalInfoService.getHouse(mCurrentContextShop.houseId), 
                CometService.listenToHouseEvents(mCurrentContextShop.houseId), $rootScope.$broadcast("catalogContextChanged", mCurrentContextShop)) : CometService.stopListening()) : "app.popupScene" != transition.to().name && (CometService.stopListening(), 
                mCurrentContextAuction = null, mCurrentHouse = null, $rootScope.$broadcast("auctionContextChanged"));
            }), CometService.scope.$on("cometEvent", function(e, event) {
                switch (event.name) {
                  case "Auction.stateChanged":
                    handleAuctionStateChanged(event);
                }
            }), $rootScope.$on("portalInfo.infoUpdated", onPortalInfoUpdated), $rootScope.$on("portalInfo.newRunningAuction", onPortalInfoUpdated);
        }
        function onPortalInfoUpdated() {
            mCurrentContextAuction && (mCurrentContextAuction = PortalInfoService.getAuction(mCurrentContextAuction.intKey)), 
            mCurrentContextAuction && "RUNNING" == mCurrentContextAuction.state && alertForAuctionStart();
        }
        function handleAuctionStateChanged(event) {
            var stateChangeInfo = event.arg;
            if (mCurrentContextAuction && mCurrentContextAuction.house.code == event.houseCode && stateChangeInfo.id == mCurrentContextAuction.auctionIdInApp) switch (stateChangeInfo.state) {
              case "PRE_AUCTION":
              case "RUNNING":
              case "PAUSED":
                alertForAuctionStart();
            }
            $rootScope.$broadcast("auctionsInfo.auctionStateChanged");
        }
        function onAuctionAlertClosed() {
            var prevState = $rootScope.$previousState ? $rootScope.$previousState.name : null;
            switch (prevState) {
              case "app.lotPageWithDesc":
              case "app.lotPage":
                PortalNavigationService.backFromLotPageToList(mCurrentContextAuction.house.id, $rootScope.$previousState.args.source);
                break;

              default:
                $state.go("app.home");
            }
            mRunningAuctionAlertOn = !1;
        }
        function alertForAuctionStart() {
            PortalInfoService.getAuction(mCurrentContextAuction.intKey).state = "RUNNING", mRunningAuctionAlertOn || ("app.auctionCatalog" == $state.$current.name || 0 == $state.$current.name.indexOf("app.lotPage") && "catalog" == $stateParams.source) && (mRunningAuctionAlertOn = !0, 
            $uibModal.open({
                templateUrl: PathsService.appTemplatePath("alerts/popups/auctionStartPopup"),
                backdrop: "static",
                controller: function($scope) {
                    $scope.auction = angular.copy(mCurrentContextAuction), $scope.message = "auction_started_popup_message", 
                    $scope.openAuctionSite = function() {
                        AppSiteWinodwsService.openAuctionSiteWindow($scope.auction), $scope.$close();
                    }, $scope.dismiss = function() {
                        $scope.$close();
                    };
                }
            }).closed.then(function() {
                onAuctionAlertClosed();
            }));
        }
        var mCurrentContextAuction = null, mCurrentContextShop = null, mCurrentHouse = null, mRunningAuctionAlertOn = !1;
        return {
            init: init
        };
    });
}), define("portal/js/modules/navigation/helpMenuController", [ "./navigationModule" ], function(module) {
    module.controller("HelpMenuController", [ "$scope", "$rootScope", "$timeout", "$state", "ArraysService", "OsInfoService", "PortalNavigationService", "PopupsService", "PortalInfoService", function($scope, $rootScope, $timeout, $state, ArraysService, OsInfoService, PortalNavigationService) {
        switch ($scope.links = [ "faq", "contact" ], $rootScope.contentType) {
          case "CARS":
            "IL" == $rootScope.currentRegion && $scope.links.push("demo_video"), $scope.links.push("contact_for_car_sale");
            break;

          case "REAL_ESTATE":
            $scope.links.push("contact_for_real_estate_sale");
            break;

          default:
            $scope.links.push("contact_for_sale");
        }
        $scope.handleLinkClick = function(link) {
            switch (link) {
              case "contact":
                $state.go("app.contact");
                break;

              case "faq":
                $state.go("app.faq");
                break;

              case "demo_video":
                PortalNavigationService.showDemoVideo();
                break;

              case "contact_for_real_estate_sale":
              case "contact_for_car_sale":
              case "contact_for_sale":
                $state.go("app.contactForSale");
            }
            PortalNavigationService.fireLinkClicked(link, "help");
        };
    } ]);
}), define("portal/js/modules/navigation/upperNavigationMenuDirective", [ "./navigationModule" ], function(module) {
    module.directive("upperNavigationMenu", function($rootScope, $timeout, OsInfoService, PathsService, PortalNavigationService) {
        return {
            restrict: "E",
            replace: !0,
            scope: {
                name: "@",
                links: "=",
                arrowPosition: "@",
                linkHrefPrefix: "@",
                headerHref: "@",
                textPrefix: "@",
                handleLinkClick: "&",
                handleHeaderClick: "&"
            },
            link: function(scope, elem, attrs) {
                var hideTimer = null;
                scope.menuVisible = !1, scope.viewPort = $rootScope.viewPort, scope.currentLang = $rootScope.currentLang, 
                scope.hiddenLinks = {}, scope.arrowPosition && (scope.menuAdditionalClass = "arrow-on-" + scope.arrowPosition), 
                scope.showMenu = function() {
                    $timeout.cancel(hideTimer), scope.menuVisible = !0;
                }, scope.hideMenu = function() {
                    $timeout.cancel(hideTimer), scope.menuVisible = !1;
                }, scope.hideMenuAfterDelay = function() {
                    hideTimer = $timeout(scope.hideMenu, 100);
                }, scope.onLinkClick = function(link) {
                    scope.handleLinkClick({
                        link: link
                    }), scope.hideMenu();
                }, scope.onHeaderClick = function() {
                    attrs.handleHeaderClick ? (scope.handleHeaderClick({
                        link: scope.name
                    }), scope.hideMenu()) : scope.menuVisible ? scope.hideMenu() : scope.showMenu();
                }, scope.linkText = PortalNavigationService.linkText;
            },
            templateUrl: PathsService.appTemplatePath("components/navigation/upperNavigationMenu")
        };
    });
}), define("portal/js/modules/navigation/tagsMenusService", [ "./navigationModule" ], function(module) {
    module.factory("TagsMenusService", function($timeout, $rootScope, $state, $stateParams, OsInfoService, ArraysService, LogService, AnalyticsService, PortalInfoService, SettingsService, I18nService) {
        function compareTags(tag1, tag2) {
            return tag1.key.match(/_all$/) ? -1 : tag2.key.match(/_all$/) ? 1 : tag1.orderIndex - tag2.orderIndex;
        }
        function init() {
            var tags = PortalInfoService.getTags();
            tags.sort(compareTags), mTagsData = {};
            for (var i = 0; i < tags.length; i++) {
                var tag = tags[i].key, parts = tag.split("_");
                if (I18nService.searchTextByKey("tag_" + tag)) {
                    var mainTag = parts[0], subTags = mTagsData[mainTag];
                    subTags || (subTags = [], mTagsData[parts[0]] = subTags, subTags.push(I18nService.searchTextByKey("tag_" + mainTag + "_all") ? mainTag + "_all" : mainTag)), 
                    parts.length > 1 && subTags.push(tag);
                }
            }
            for (var mainTag in mTagsData) {
                var childTags = mTagsData[mainTag];
                mAllTags.push(childTags.length <= 1 ? {
                    key: mainTag.replace("_all", ""),
                    entries: []
                } : {
                    key: mainTag,
                    entries: childTags
                });
            }
            mAllTags.sort(compareTags);
        }
        function getTagMenuEntries(mainTag) {
            return mTagsData || init(), mTagsData[mainTag];
        }
        function getAllTags() {
            return mTagsData || init(), mAllTags;
        }
        var mTagsData = null, mAllTags = [];
        return $rootScope.$on("i18n.languageChanged", init), {
            getTagMenuEntries: getTagMenuEntries,
            getAllTags: getAllTags
        };
    });
}), define("portal/js/modules/navigation/tagsSceneController", [ "./navigationModule" ], function(module) {
    module.controller("TagsSceneController", [ "$scope", "$rootScope", "$timeout", "$state", "ArraysService", "OsInfoService", "SettingsService", "TagsMenusService", "PortalNavigationService", "SearchService", function($scope, $rootScope, $timeout, $state, ArraysService, OsInfoService, SettingsService, TagsMenusService, PortalNavigationService) {
        function onBackPress() {
            "secondaryTags" == $scope.displayState ? $scope.showMainTags() : PortalNavigationService.goBack(!0);
        }
        $scope.displayState = "mainTags", SettingsService.get("mainTags") && ($scope.mainTags = SettingsService.get("mainTags").split(",")), 
        $scope.shopsVisible = PortalNavigationService.isShopsVisible(), $scope.otherPortalScenes = PortalNavigationService.getOtherPortalScenes(), 
        $scope.showMainTags = function() {
            $scope.displayState = "mainTags";
        }, $scope.onMainTagClick = function(tag) {
            $scope.selectedTag = tag.trim();
            var secondaryTags = TagsMenusService.getTagMenuEntries($scope.selectedTag);
            secondaryTags && secondaryTags.length > 1 ? ($scope.secondaryTags = secondaryTags, 
            $scope.displayState = "secondaryTags") : $scope.gotoTagPage($scope.selectedTag);
        }, $scope.gotoTagPage = PortalNavigationService.gotoTagPage, PortalNavigationService.setBackFn(onBackPress), 
        $scope.linkText = PortalNavigationService.linkText, $scope.gotoPortalScene = PortalNavigationService.gotoPortalScene;
    } ]);
}), define("portal/js/modules/navigation/choosePortalController", [ "./navigationModule" ], function(module) {
    module.controller("ChoosePortalController", [ "$scope", "$rootScope", "$state", "PortalNavigationService", "PathsService", "LocalStorageService", function($scope, $rootScope, $state, PortalNavigationService, PathsService, LocalStorageService) {
        LocalStorageService.store("portalChoiceNeeded", !0), $scope.gotoPortalScene = function(contentType) {
            PortalNavigationService.gotoPortalScene(contentType);
        };
    } ]);
}), define("portal/js/modules/navigation/index", [ "./navigationModule", "./upperNavigationController", "./mobileMenuController", "./auctionsMenuController", "./reloadController", "./appSiteWinodwsService", "./portalNavigationService", "./installAppButtonDirective", "./houseEventsListenerService", "./helpMenuController", "./upperNavigationMenuDirective", "./tagsMenusService", "./tagsSceneController", "./choosePortalController" ], function() {}), 
define("portal/js/modules/portalModules", [ "angular", "commonModules", "./main/index", "./auth/index", "./userDetails/index", "./alerts/index", "./info/index", "./catalogs/index", "./auctions/index", "./houses/index", "./shops/index", "./account/index", "./nudges/index", "./promotions/index", "./support/index", "./components/index", "./navigation/index" ], function(ng) {
    return ng.module("app.portalModules", [ "app.main", "app.auth", "app.userDetails", "app.userAlerts", "app.info", "app.catalogs", "app.auctions", "app.houses", "app.shops", "app.account", "app.nudges", "app.ads", "app.support", "app.components", "app.navigation" ]);
}), define("app", [ "angular", "ngdir/angular-animate", "ngdir/angular-ui-router", "ngdir/angular-ui-bootstrap", "ngdir/angular-upload", "ngdir/angular-google-analytics", "commonModules", "ngdir/text/textAngular", "ngdir/text/textAngular-sanitize", "portal/js/modules/external/index", "portal/js/modules/portalModules" ], function(angular) {
    function initAnalytics(AnalyticsProvider) {
        GlobalConfig.isMobileApp ? document.addEventListener("deviceready", function() {
            window.analytics && window.analytics.startTrackerWithId("UA-56607963-2");
        }, !1) : -1 == window.location.href.indexOf("searchAgentRequest") && -1 != window.location.href.indexOf("bidspirit") && (AnalyticsProvider.setAccount("UA-56607963-1"), 
        AnalyticsProvider.useAnalytics(!0));
    }
    return angular.module("app", [ "ngAnimate", "lr.upload", "angular-google-analytics", "commonModules", "app.portalModules", "app.externals", "ui.router", "ui.bootstrap", "textAngular" ]).config(function($locationProvider, $urlMatcherFactoryProvider, AnalyticsProvider) {
        var base = document.createElement("base");
        base.href = GlobalConfig.devEnv ? "/portal/ui/" : "/ui/", document.head.prepend(base), 
        $urlMatcherFactoryProvider.strictMode(!1), $urlMatcherFactoryProvider.type("raw", {
            raw: !0
        }), $locationProvider.html5Mode(!0), initAnalytics(AnalyticsProvider);
    }).run(function($templateCache) {
        $templateCache.put("/common/templates/forms/asyncButton.html?1.1944", '<button   class="bs-async-button" ng-class="buttonClass + (locked ? \' waiting\' : \'\')"  ng-click="executeAction()">  <div class="text">{{label | i18n }}</div>  <div ng-transclude></div>  </button>   '), 
        $templateCache.put("/common/templates/forms/monthPicker.html?1.1944", '<div class="col-md-3 form-group"> <label>{{(label || \'reports_select_month\') | i18n}}</label>  <p class="input-group"> <input type="text"  name="date" placeholder="{{\'reports_select_month\' | i18n}}" class="form-control" ng-model="selectedDate" uib-datepicker-popup="MM/yyyy" is-open="monthPopupVisible" ng-click="monthPopupVisible = true" datepicker-options="{minMode: \'month\'}" datepicker-mode="\'month\'" close-text="{{\'command_close\' | i18n}}"  > </p> <div class="newLine"></div> </div>    '), 
        $templateCache.put("/common/templates/forms/formGroup.html?1.1944", '<div class="form-group {{cssClass}}"> <div> <div ng-transclude></div> </div>  </div> '), 
        $templateCache.put("/common/templates/dialogs/scopeAlert.html?1.1944", "<div style=\"display:{{alert.message?'block':'none'}}\"> <div uib-alert  ng-class=\"'alert-' + (alert.type)\"   type=\"{{alert.type || 'info'}}\" close=\"hideScopeAlert()\"> {{alert.message | i18n}} </div> </div> "), 
        $templateCache.put("/common/templates/dialogs/alert.html?1.1944", '<div bs-text-direction> <div class="modal-header"> <div class="modal-title"><h4>{{((dialogData.title || "notice") | i18n) | capitalize}}</h4></div>  </div>  <div class="modal-body" ng-bind-html="dialogData.message"></div>  <div class="modal-footer"> <button class="btn btn-primary" ng-click="close()">{{(dialogData.ok || "ok") | i18n}}</button> </div> </div>  '), 
        $templateCache.put("/common/templates/dialogs/image.html?1.1944", '<div class="modal-header"> <button type="button" class="close" ng-click="$close()">&times;</button> <h4 class="modal-title">{{dialogData.imageName}}</h4> </div>  <div class="modal-body"><img ng-src="{{dialogData.imagePath | cloudinary}}" class="img-responsive"> </ </div>  <div class="modal-footer"> <button class="btn btn-primary" ng-click="close()">{{(dialogData.close || "close") | i18n}}</button> </div> '), 
        $templateCache.put("/common/templates/dialogs/confirm.html?1.1944", '<div bs-text-direction> <div class="modal-header"> <div class="modal-title"><h4>{{(dialogData.title) | i18n}}</h4></div>  </div>  <div class="modal-body" ng-bind-html="dialogData.message"></div>  <div class="modal-footer"> <button class="btn btn-danger" ng-click="ok()">{{(dialogData.ok || "ok") | i18n}}</button> <button class="btn btn-warning" ng-click="close()">{{(dialogData.cancel || "cancel") | i18n}}</button> </div> </div>  '), 
        $templateCache.put("/common/templates/elements/pagination.html?1.1944", '<div class="bs-pagination" dir="ltr">  <a class="link" ng-repeat="link in links" ng-href="{{baseHref && link.page && !link.isCurrent ? ((baseHref+link.page) | uiHref) : \'\'}}"  ng-click="onLinkClick(link)" ng-bind-html="link.html" ng-class="{ current:link.isCurrent, disabled:!link.page, enabled:link.page && !link.isCurrent, needsclick:link.isPrev || link.isNext,  prev:link.isPrev,  next:link.isNext}"> </a>   </div>   '), 
        $templateCache.put("/portal/templates/info/allFutureAuctions.html?1.1944", '<div class="all-future-auctions"> <table class="table table-striped default-align" bs-text-direction> <tr> <th>{{"auction_house" | i18n}}</th> <th>{{"time" | i18n}}</th> <th>{{"auction_name" | i18n}}</th> </tr> <tr ng-repeat="auction in options.data.auctions" class="clickable" ng-click="options.data.onAuctionClick(auction)"> <td>{{auction.house.details.name | langField}}</td> <td>{{auction| auctionTime}}</td> <td> <span ng-if="::auction.number"> {{::"auction_label_number_public" | i18n:{number:auction.number} }} <span ng-if="auction.part"> {{::("auction_part_"+auction.part) | i18n}}  </span> </span>  <span ng-if="::auction.number && auction.name | langField"> - </span>  <span> {{::auction.name | langField}} </span> </td> </tr>  </table> </div>  '), 
        $templateCache.put("/portal/templates/info/demoVideo.html?1.1944", '<div class="demo-video-popup" bs-text-direction> <div class="modal-header"> <div class="modal-title"> <h4 class="float">Bidspirit - {{"demo_video" | i18n}}</h4> <button type="button" class="opposite float close" ng-click="$close()">&times;</button> <div class="clearfix"></div> </div>  </div>  <div class="modal-body" >  <iframe class="center-block" width="800" height="450" ng-src="{{demoVideoUrl}}" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe>  </div>  <div class="modal-footer"> <button class="btn btn-default" ng-click="$close()">{{"close" | i18n}}</button>  </div> </div>  '), 
        $templateCache.put("/portal/templates/info/contact.html?1.1944", '<div  class="contact scene" ng-controller="ContactController" bs-scroll-to-top> <div class="upper-part">  <div class="dark overlay">  <div class="message center-block container"> <H1>{{\'contact_us\' | i18n}}</H1> <div class="short-separator"></div> <h4 class="message-line">{{\'contact_message_line_1\' | i18n}}</h4> <h4 class="message-line">{{\'contact_message_line_2\' | i18n}}</h4>  <bs-linkable-text  ng-if="contentType==\'ART\'" class="sell-message" options="{ textKey:\'contact_message_sell\',  onLinkClick:gotoContactForSale }" > </bs-linkable-text> </div> </div> </div> <div class="content container col-lg-5 col-md-7  col-xs-12" > <bs-upper-space-holders> </bs-upper-space-holders> <form name=\'contactForm\' novalidate bs-form  bs-submit="send()" ng-show="$state.current.name!=\'app.contact.thanks\'"> <div class="row"> <bs-form-group field-name="name" label="name" css-class="col-md-5  col-xs-11 float"> <label class="float"></label> <span class="float star">*</span><div><!-- this empty div is needed for ie8 --></div>  <bs-form-validation-message required="error_name_mandatory" css-class="float"> </bs-form-validation-message> <div class="clearfix"></div> <input  name="name" class="form-control" ng-model="contact.name" required /><div><!-- this empty div is needed for ie8 --></div>  </bs-form-group> <div class="col-md-2 float col-xs-0"></div> <bs-form-group field-name="email" label="email" css-class="col-md-5 col-xs-11 float"> <label class="float"></label> <span class="float star">*</span><div><!-- this empty div is needed for ie8 --></div> <bs-form-validation-message css-class="float"> </bs-form-validation-message> <div class="clearfix"></div> <input  dir="ltr" type="email" name="email" class="form-control" ng-model="contact.email" required /><div><!-- this empty div is needed for ie8 --></div>  </bs-form-group>  </div> <div class="row"> <bs-form-group field-name="phone" label="phone" css-class="col-md-5  col-xs-11 float"> <label></label> <input dir="ltr"   name="phone" class="form-control" ng-model="contact.phone" /><div><!-- this empty div is needed for ie8 --></div> <bs-form-validation-message css-class="float"> </bs-form-validation-message> </bs-form-group>  <div class="col-md-2 float col-xs-0"></div> <bs-form-group field-name="state" label="country" css-class="col-md-5 col-xs-11 float"> <label></label> <input  name="state" class="form-control" ng-model="contact.state" /><div><!-- this empty div is needed for ie8 --></div> <bs-form-validation-message css-class="float"> </bs-form-validation-message> </bs-form-group>   </div> <div class="row">  <bs-form-group field-name="message" label="contact_message_body" css-class="col-md-12 col-xs-11 float" > <label class="float"></label> <span class="float star">*</span><div><!-- this empty div is needed for ie8 --></div> <bs-form-validation-message css-class="float" required="error_message_mandatory"> </bs-form-validation-message> <div class="clearfix"></div> <textarea  name="message" class="form-control" ng-model="contact.message" required ></textarea><div><!-- this empty div is needed for ie8 --></div> </bs-form-group>  </div>  <div class="row"> <div class="orange common-button col-sm-3 float" ng-click="sendDebugInfo() || contactForm.submit()" > <div class="text">{{"send" | i18n }}</div> </div>   </div> </form> <div class="thanks .container animate-show" ng-show="$state.current.name==\'app.contact.thanks\'"> {{"contact_thanks" | i18n }} </div> </div>  <div class="direct-contact"> <div class="text" ng-bind-html=\'(BidspiritInfo.phoneLink ?  "contact_direct" : "contact_direct_no_phone") | i18n:{phone:BidspiritInfo.phoneLink, email:BidspiritInfo.emailLink}\'>  </div> </div> </div> '), 
        $templateCache.put("/portal/templates/info/downForHolyDay.html?1.1944", '<div  class="down-for-holy-day scene" bs-scroll-to-top> <div class="content container col-lg-5 col-md-7  col-xs-12" > <div class="image"> </div> <div class="text" ng-bind-html="\'down_for_holy_day_1\' | i18n"></div> <div class="text" ng-bind-html="\'down_for_holy_day_2\' | i18n "></div> </div> </div> '), 
        $templateCache.put("/portal/templates/info/product/productMain.html?1.1944", '<div ng-controller="ProductController" bs-scroll-to-top> <div class="product scene"> <div class="upper-part">  <div class="dark overlay"> </div> </div>  <div class="main center-block "> <h1 class="center-block col-md-5 col-xs-12" ng-bind-html="mainFeature.title | langField"></h1>  <div class="short-separator"></div> <div class="image center-block  col-md-7 col-xs-12" ng-if="mainFeature.resources!=null" bs-cloudinary-bg="{{mainFeature.resources[\'productsPagePic\']}}"  >  </div> <div class="info center-block  col-md-9 col-lg-7 col-xs-12" ng-bind-html="mainFeature.info | langField">  </div> <div class="orange contact-us common-button center-block center-block"  ui-sref="app.contact"> <div class="text">{{"contact_us" | i18n }}</div> </div>  <div class="gray-separator col-md-9 col-lg-7 col-xs-12 center-block"></div> </div>  <div class="features"> <h3 class="section-title">{{\'product_features\' | i18n}}</h3> <div class="short-separator"></div> <div ng-include src="\'info/product/productFeatures\' | appTemplate"></div> </div>  <div class="gray-separator col-md-9 col-lg-7 col-xs-12 center-block"></div>  <div class="contact"> <div class="container col-lg-4 col-md-5 col-sm-6 col xs-10 center-block"> <h3 class="caption">{{\'product_contact_caption\' | i18n}}</h3> <div class="short-separator"></div> <div class="message-line">{{\'product_contact\' | i18n}}</div> <div class="orange contact-us common-button center-block" ui-sref="app.contact"> <div class="text">{{"contact_us" | i18n }}</div> </div> </div>  </div> </div>  </div> '), 
        $templateCache.put("/portal/templates/info/product/productFeatures.html?1.1944", '<div class="list container-fluid"> <div class="row"> <div class="item col-md-3 col-xs-10"  ng-repeat="feature in features" ng-if  = "feature.code!=\'main\'"> <div class="frame" ng-class="[feature.code,currentLang]"> <div class="image"  bs-cloudinary-bg="{{feature.resources[\'productsPagePic\']}}"  params=" {imageMode:\'fill\',size:\'360x226\'} ">  </div>  <div class="texts"> <h2 class="caption"> {{feature.title | langField}} </h2>   <div class="short-separator"></div> <div class="info" ng-bind-html="feature.info | langField"> </div>  </div> <div ng-if="feature.code==\'bidder\'"> <div class="orange  common-button pull-left"  ng-click="showDemo(\'classic\')">  <div class="text"> {{\'product_demo_classic\' | i18n}}  </div> </div> <div class="orange  common-button pull-right" ng-click="showDemo(\'unique\')" >  <div class="text"> {{\'product_demo_unique\' | i18n}}  </div> </div> </div>  <div ng-if="feature.code==\'virtualAuctioneer\' && !isMobile">  <div class="orange  common-button center-block" ng-click="showDemo(\'virtualAuctioneer\')" >  <div class="text"> {{\'product_demo_virtual_auctioneer\' | i18n}}  </div> </div> </div>  </div>  </div> </div>  </div> '), 
        $templateCache.put("/portal/templates/info/contactForSale.html?1.1944", '<div  class="contact scene" ng-controller="ContactForSaleController" bs-scroll-to-top>  <div class="upper-part">  <div class="dark overlay">  <div class="message center-block container"> <H1 class="for-sale">{{titleTextKey | i18n}}</H1> <div class="short-separator"></div> <h4 class="message-line">{{ line1Key  | i18n}}</h4> <h4 class="message-line">{{\'contact_for_sale_message_line_2\' | i18n}}</h4> </div> </div> </div>  <div class="content container col-lg-5 col-md-7  col-xs-12" > <bs-upper-space-holders> </bs-upper-space-holders> <form name=\'contactForm\' novalidate bs-form  bs-submit="send()" ng-show="!showThanks"> <div class="row"> <bs-form-group field-name="name" label="name" css-class="col-md-5  col-xs-11 float"> <label class="float"></label> <span class="float star">*</span><div><!-- this empty div is needed for ie8 --></div>  <bs-form-validation-message required="error_name_mandatory" css-class="float"> </bs-form-validation-message> <div class="clearfix"></div> <input  name="name" class="form-control" ng-model="contact.name" required /><div><!-- this empty div is needed for ie8 --></div>  </bs-form-group> <div class="col-md-2 float col-xs-0"></div> <bs-form-group field-name="email" label="email" css-class="col-md-5 col-xs-11 float"> <label class="float"></label> <span class="float star">*</span><div><!-- this empty div is needed for ie8 --></div> <bs-form-validation-message css-class="float"> </bs-form-validation-message> <div class="clearfix"></div> <input  dir="ltr" type="email" name="email" class="form-control" ng-model="contact.email" required /><div><!-- this empty div is needed for ie8 --></div>  </bs-form-group>  </div> <div class="row"> <bs-form-group field-name="phone" label="phone" css-class="col-md-5  col-xs-11 float"> <label class="float"></label> <span class="float star">*</span><input dir="ltr"   name="phone" class="form-control" required ng-model="contact.phone" /><div><!-- this empty div is needed for ie8 --></div> <bs-form-validation-message css-class="float"> </bs-form-validation-message> </bs-form-group>  <div class="col-md-2 float col-xs-0"></div> <bs-form-group field-name="state" label="country" css-class="col-md-5 col-xs-11 float" ng-show="contentType==\'ART\'"> <label></label> <input  name="state" class="form-control" ng-model="contact.state" /><div><!-- this empty div is needed for ie8 --></div> <bs-form-validation-message css-class="float"> </bs-form-validation-message> </bs-form-group>  </div>  <div class="row">  <bs-form-group field-name="message" label="{{descriptionKey}}" css-class="col-md-12 col-xs-11 float" > <label class="float"></label> <span class="float star">*</span><div><!-- this empty div is needed for ie8 --></div> <bs-form-validation-message css-class="float" required="error_message_mandatory"> </bs-form-validation-message> <div class="clearfix"></div> <textarea  name="message" class="form-control" ng-model="contact.message" required ></textarea><div><!-- this empty div is needed for ie8 --></div> </bs-form-group>  </div> <div class="float images"> <div ng-repeat="image in upladedImagesInfo" class="float attachment" ng-class="{pending:image.pending}">  <img src="{{image.url ? image.url : (\'system/pagePreLoader.gif\' | commonImage) }}">    <div class="clearfix"></div> <div class="btn btn-link" ng-click="removeImage(image)">{{"remove" |i18n}}</div> </div> <div class="btn btn-default btn-upload float" upload-button accept="{{\'image/*\'}}" url="{{\'/resources/uploadFilesToS3\' | formActionPath}}" multiple="{{allowMultiple}}"  on-success="addPicFromResponse(response)" on-error="handleError(response)" on-upload = "addPendingPic(files)" >{{\'contact_for_sale_add_pic\'  | i18n}}</div> </div>  <div class="clearfix"></div>  <div class="row"> <div class="orange common-button col-sm-3 float" ng-click="sendDebugInfo() || contactForm.submit()" > <div class="text">{{"send" | i18n }}</div> </div> </div> </form> <div class="thanks .container animate-show" ng-show="showThanks"> {{"contact_thanks" | i18n }} </div> </div> </div> '), 
        $templateCache.put("/portal/templates/info/helpScreen.html?1.1944", '<div class="help-screen scene" ng-controller="HelpScreensController" bs-scroll-to-top> <div class="content container">  <div class="float texts" ng-class="[currentLang,helpScreen.code]"> <h2 class="caption"> {{helpScreen.title | langField}} </h2> <div class="info" ng-bind-html="helpScreen.info | langField">  </div>   <div ng-switch="helpScreen.code" > <div ng-switch-when="screen_live">  <div class="orange  common-button pull-left"  ng-click="showDemo(\'classic\')">  <div class="text"> {{\'product_demo_classic\' | i18n}}  </div> </div> <div class="orange  common-button pull-right" ng-click="showDemo(\'unique\')" >  <div class="text"> {{\'product_demo_unique\' | i18n}}  </div> </div> <div class="clearfix"></div> </div> <div ng-switch-when="screen_bids"> <div class="orange common-button center-block" ng-click="showRegistration()" ng-if="!currentUser">  <div class="text"> {{\'help_register\' | i18n}}  </div> </div>  </div> <div ng-switch-when="screen_search"> <form name=\'searchForm\' novalidate bs-form  bs-submit="doSearch()" class="global-search-form center-block" bs-text-direction> <bs-form-group field-name="phrase" label="catalog_search_all" > <bs-search-input></bs-search-input> </bs-form-group> <div class="button" ng-click="doSearch()"></div> <div class="clearfix"></div> </form> </div> </div> </div>   <div class="opposite float screenshot" bs-cloudinary-bg="{{sceenshot}}"></div> <div class="clearfix"></div> <div class="btn home btn-link center-block" ui-sref="app.home"> {{"home_back_to" | i18n }} </div> </div>   </div> '), 
        $templateCache.put("/portal/templates/info/faq.html?1.1944", '<div class="faq scene" ng-controller="FaqController" bs-scroll-to-top> <div class="narrow upper-part">  <div class="dark overlay">  <div class="message center-block container col-lg-7 col-md-7 col-sm-8 col xs-12"> <h1>{{"faq" | i18nWithRegion  }}</h1> <div class="short-separator"></div> </div> </div> </div>  <div class="content container"> <bs-upper-space-holders class="narrow"> </bs-upper-space-holders> <div class="faq-group" ng-repeat="(code,questions) in data.groups"> <div class="title"> {{"faq_"+code | i18n}} </div> <div class="item" ng-repeat="question in questions"> <div class="question"  bs-right-click="openInNewWindow(question)" ng-click="data.answerVisible[question.code]  = !data.answerVisible[question.code] " bs-scroll-on="question.code == data.scrollTo" > {{question.title | langField}} </div> <div class="answer" ng-show="data.answerVisible[question.code]" ng-bind-html="question.info | langField">  </div> </div>  </div>    <div class="btn home btn-link center-block" ui-sref="app.home"> {{"home_back_to" | i18n }} </div> </div>   </div> '), 
        $templateCache.put("/portal/templates/info/downForMaintenance.html?1.1944", '<div  class="down-for-maintenance scene" bs-scroll-to-top> <div class="content container col-lg-5 col-md-7  col-xs-12" > <div class="image"> </div> <div class="text" ng-bind-html="\'down_for_maintenance\' | i18n"></div> </div> </div> '), 
        $templateCache.put("/portal/templates/info/about.html?1.1944", '<div  class="about scene" bs-scroll-to-top ng-controller="AboutController"> <div class="wide upper-part" >  <div class="dark overlay">  <div class="message center-block container col-lg-7 col-md-7 col-sm-8 col xs-12"> <H1>{{\'about_upper_caption\' | i18n}}</H1> <div class="short-separator"></div> <h2 class="text">{{contentAwareText(\'about_upper_text\')}}</h2> </div> </div> </div> <div class="content container col-lg-6 col-md-6 col-sm-8 col xs-12"> <bs-upper-space-holders> </bs-upper-space-holders> <div class="portal-info"> <div class="line">{{contentAwareText(\'about_portal_info_line_1\')}}</div> <div class="line">{{contentAwareText(\'about_portal_info_line_2\')}}</div> </div>  <div class="short-separator"></div>  <div class="company-info"> <div class="line">{{contentAwareText(\'about_company_info\')}}</div> </div> </div> <div class="contact"> <div class="container col-lg-6 col-md-6 col-sm-8 col xs-12"> <div class="caption">{{\'about_contact_caption\' | i18n}}</div> <div class="short-separator"></div> <div class="message-line">{{\'contact_message_line_1\' | i18n}}</div> <div class="message-line">{{\'contact_message_line_2\' | i18n}}</div> <div class="orange common-button center-block" ui-sref="app.contact"> <div class="text">{{"contact_us" | i18n }}</div> </div> </div>  </div> <div ng-if="versionInfo" class="version-info" dir="ltr">{{versionInfo}}</div> </div> '), 
        $templateCache.put("/portal/templates/info/upgradeRequired.html?1.1944", '<div bs-text-direction> <div class="modal-header"> <div class="modal-title">{{"notice" | i18n}}</div>  </div>  <div class="modal-body" ng-bind-html="\'upgrade_required_message\' | i18n"></div>  <div class="modal-footer"> <div class="text-center"> <button class="btn btn-primary" ng-click="redirectToUpgrade()">{{"update" | i18n}}</button> </div>  </div> </div>  '), 
        $templateCache.put("/portal/templates/support/support.html?1.1944", '<div  class="support scene" bs-scroll-to-top ng-controller="SupportController"> <div class="narrow upper-part">  <div class="dark overlay">  <div class="message center-block container col-lg-7 col-md-7 col-sm-8 col xs-12"> <h1>{{"support" | i18nWithRegion  }}</h1> <div class="short-separator"></div> </div> </div>  </div>  <div class="content container"> <bs-upper-space-holders class="narrow"> </bs-upper-space-holders>  <div class="float orange common-button" ng-click="showOpenSupportCaseForm()"> <div class="text">{{"support_case_action_open" | i18n }}</div> </div> <div class="float"> <div class="cases-type-selection"> <label class="radio-inline" ng-repeat="caseTypeSelection in caseTypeSelections"> <input ng-model="filter.casesType" type="radio" name="caseTypeFilter"  value="{{caseTypeSelection}}" ng-change="loadSupportCases()"> {{getCaseTypeFilterName(caseTypeSelection) | i18n }} </label> <div class="clearfix"></div> </div> <br> <div class="text-center"> <div class="form-inline"> <input class="form-control" ng-model="searchToken" bs-enter-key-action="loadSupportCases()"> <div class="btn btn-default"  ng-click="loadSupportCases()">{{"search" | i18n}}	</div> <div class="btn btn-link" ng-click="clearSearch()" ng-show="searchToken"> {{"search_clear" | i18n}} </div> </div> </div> </div>   <div class="opposite float checkbox"> <label> <input type="checkbox" ng-model="filter.nonClosedOnly" ng-change="loadSupportCases()">  {{"support_show_unclosed_only" | i18n}}  </label> </div>  <div class="clearfix"></div> <div class="opposite float  btn btn-default" ng-click="loadSupportCases()">{{"refresh" | i18n }}</div> <div class="clearfix"></div>   <bs-content-loader loaded="supportDataLoaded"></bs-content-loader>  <div ng-if="supportDataLoaded">  <label ng-if="filter.nonClosedOnly && !cases.length"> {{"support_no_open_cases" | i18n}} </label>  <bs-pagination	pages-data="pagesData"	 on-current-page-change="onPageChange()"> </bs-pagination>  <table class="table table-hover " ng-if="cases.length">  <tr> <th></th> <th>{{"support_case_number" | i18n}}</th> <th class=\'clickable\' ng-click="setSortField(\'openTime\')" > <span ng-class="{\'sort-field\':filter.sortField==\'openTime\',desc:filter.isDescSort}"></span> {{"support_open_time" | i18n}}</th>  <th class="visible-lg">{{"support_case_type" | i18n}}</th> <th>{{"subject" | i18n}}</th> <th class="visible-lg">{{"description" | i18n}}</th>  <th class="visible-lg">{{"support_assignee" | i18n}}</th>  <th class=\'clickable\' ng-click="setSortField(\'lastUpdate\')" ><span ng-class="{\'sort-field\':filter.sortField==\'lastUpdate\',desc:filter.isDescSort}"></span> {{"last_update" | i18n}}</th> <th>{{"status" | i18n}}</th> </tr>  <tr class="clickable" ng-repeat="supportCase in cases"  ng-click="displaySupportCase(supportCase)" ng-class="{\'text-muted\':supportCase.status==\'CLOSED\',\'bold\':!supportCase.handledByAssignee}" bs-scroll-on="supportCase.id==scrollTo"> <td ng-click="toggleStarred(supportCase); $event.stopPropagation();" ><div class="star" ng-class="{on:supportCase.starred}"  </div> </td> <td> {{supportCase.caseNumber}}</td> <td > {{supportCase.openTime | date:\'dd/MM/yy HH:mm\'}} <div ng-bind-html="supportCase.openerDisplay"> </div></td>  <td class="visible-lg"> {{("support_case_type_"+supportCase.caseType.toLowerCase()) | i18n}}</td> <td> {{supportCase.subject | trim:25}}</td> <td class="visible-lg">  <pre class="description"  bs-text-direction lang="{{supportCase.lang}}">{{getSupportCaseDescrition(supportCase)}}</pre> </td> <td class="visible-lg" ng-bind-html="supportCase.assigneeDisplay"> </td>   <td> {{supportCase.lastUpdate | date:\'dd/MM/yy HH:mm\'}}<div ng-bind-html="supportCase.lastUserDisplay"></div></td>  <td>{{("support_status_"+supportCase.status) | i18n}}<div ng-bind-html="supportCase.lastAction.notes"></td> </tr>  </table>  <bs-pagination	pages-data="pagesData"	 on-current-page-change="onPageChange()"> </bs-pagination>  </div> </div> </div> '), 
        $templateCache.put("/portal/templates/support/supportCase.html?1.1944", '<div class="support scene support-case" bs-text-direction  ng-controller="SupportCaseController" bs-scroll-to-top >   <div class="narrow upper-part">  <div class="dark overlay">  <div class="message center-block container col-lg-7 col-md-7 col-sm-8 col xs-12"> <h1>{{"support" | i18nWithRegion  }}</h1> <div class="short-separator"></div> </div>  </div> </div>    <div class="content"> <bs-upper-space-holders class="narrow"> </bs-upper-space-holders>  <h4 class="float" ng-if="supportCase"> {{"support_case_number_title" | i18n:supportCase }} <span ng-if="supportCase.subject"> - {{supportCase.subject}}</span> &nbsp;<span>({{("support_case_type_"+supportCase.caseType.toLowerCase()) | i18n}})</span> </h4>   <div class="opposite float btn btn-link" ui-sref="app.support"> {{"support_back_to_list" | i18n}}</div>   <div class="clearfix"></div>  <bs-content-loader loaded="supportCase"></bs-content-loader>  <div ng-if="supportCase"> <div> <label>{{"support_case_opener" | i18n}}:</label> <a class="btn btn-link" ng-href="(\'/searchSupport/\'+supportCase.openerEmail) | uiHref"  ng-bind-html="supportCase.openerDisplay"></a> </div> <div ng-if="supportCase.openerState"> <label>{{"country" | i18n}}:</label> <span ng-bind-html="supportCase.openerState"></span> </div> <div ng-if="supportCase.openerPhone"> <label>{{"phone" | i18n}}:</label> <span ng-bind-html="supportCase.openerPhone"></span> </div> <div ng-if="lastVisitedLot" class="float last-visited-lot">  <label>{{"support_last_visited_lot" | i18n}}:</label> <span ng-if="lastVisitedLot.auction"> <a ng-href="{{lastVisitedLot | lotHref:\'auction\'}}" >{{lastVisitedLot.itemIndex}}: {{lastVisitedLot | lotText:50 | stripTags }}</a> {{"auction_label_number_public" | i18n:{number:lastVisitedLot.auction.number} }}, <b>{{lastVisitedLot.house.details.name | langField}}</b> </span> <span ng-if="lastVisitedLot.shop"> <a ng-href="{{lastVisitedLot | lotHref:\'shop\'}}" >{{lastVisitedLot.ownerKey+"-"+lastVisitedLot.idInApp}}: {{lastVisitedLot | lotText:50 | stripTags }}</a> , {{"shop_info_title" | i18n:{houseName:(shop.house.details.name | langField)} }} </span> </div>  <div class="opposite float  btn btn-default" ng-click="loadSupportCase()">{{"refresh" | i18n }}</div>  <div class="clearfix"></div> <br><br>   <table class="table table-hover" > <tr> <th>{{"time" | i18n}}</th> <th class="visible-lg">{{"support_action" | i18n}}</th> <th>{{"support_action_user" | i18n}}</th> <th>{{"description" | i18n}}</th> <th class="visible-lg">{{"support_case_recipients" | i18n}}</th> <th class="visible-lg">{{"support_assignee" | i18n}}</th> <th class="visible-lg">{{"notes" | i18n}}</th> <th class="visible-lg">{{"support_case_attachements" | i18n}}</th> </tr> <tr ng-repeat="action in supportCase.actions" ng-click="showActionForm(action)" class="clickable"> <td> {{action.actionTime | date:\'dd/MM HH:mm\'}}</td> <td class="visible-lg"> {{("support_case_action_"+action.actionType.toLowerCase()) | i18n}}</td> <td ng-bind-html="action.userDisplay"> </td>  <td> <pre class="description" ng-show="action.description" ng-bind-html="action.displayText" bs-text-direction lang="{{supportCase.lang}}"> </pre>  </td> <td>{{action.recipients}}</td> <td class="visible-lg"> {{action.assignee.firstName ? action.assignee.firstName +" "+ action.assignee.lastName : ""}}  </td> <td class="visible-lg" ng-bind-html="action.notes"></td> <td class="visible-lg attachments"> <a class="attachment"  ng-repeat="attachment in action.attachments"  style="background-image:{{(attachment  | isImage) ? \'url(\'+attachment+\')\'  : \'none\'}}" ng-href="{{attachment}}" ng-mouseover="action.imagePreviewUrl = attachment" ng-mouseout="action.imagePreviewUrl = null" target="_blank" >  <div ng-if="!(attachment | isImage) " > {{attachment  | fileNameFromUrl | shortFileName}} </div>  </a>  <div class="preview" bs-text-direction ng-show="action.imagePreviewUrl" style="background-image:url({{action.imagePreviewUrl}})"></div> </td> </tr>  </table> <br> <div class="btn-toolbar">  <div class="float btn btn-primary" ng-click="addAction(\'SEND_EMAIL\')"> {{"support_case_action_send_email" | i18n}}   </div>  <div class="float btn btn-warning"  ng-click="addAction(\'FORWARD_TO_AUCTION_HOUSE\')"> {{"support_case_action_forward_to_auction_house" | i18n}}   </div>  <div class="float btn btn-default"  ng-click="addAction(\'ASSIGN\')"> {{"support_case_action_assign" | i18n}}   </div>    <div class="float btn btn-default"  ng-click="addAction(\'NOTE\')"> {{"support_case_action_note" | i18n}}   </div>   <div class="float btn btn-success"  ng-click="addAction(\'CLOSE\')"> {{"support_case_action_close" | i18n}}   </div>  <bs-async-button  action-fn="removeSupportCase()"  button-class="\'opposite float btn btn-danger  \'+currentLang"  label="\'support_delete_case\'">  </bs-async-button>  <div class="clearfix"></div>  </div>  </div>  </div>     </div>  '), 
        $templateCache.put("/portal/templates/support/supportCaseAction.html?1.1944", '<div class="support-edit-action-popup" bs-text-direction ng-controller="SupportCaseActionController"  >  <div  class="modal-header" bs-draggable parents="2"> <div class="float modal-title" > <h4> <span ng-if="data.supportCase.caseNumber"> {{"support_case_number_title" | i18n:{caseNumber:data.supportCase.caseNumber} }}  - </span> {{("support_case_action_"+data.action.actionType.toLowerCase()) | i18n}} <span ng-if="data.action.isDraft && data.action.id">[{{"draft" | i18n}}]</span> </td>   </h4> </div>  <button type="button" class="opposite float close"  ng-click="$close()">&times;</button> <div class="clearfix"></div> </div>   <div class="modal-body"  stop-event="touchend">  <div ng-if="editMode" class="form">  <div ng-if="data.sourceAction || data.supportCase.originalAction"> <label>{{"support_case_original_message" | i18n}}:</label> <div ng-repeat="action in historyToShow"> <b>{{action.actionTime | date:\'dd/MM/yyyy HH:mm:ss\'}} - </b> <span ng-bind-html="action.userDisplay"></span> <p ng-bind-html="action.description"></p> <br> </div> <div ng-if="!data.sourceAction && actionsHistory.length>1 && historyToShow.length<2" ng-click="showAllHistory()" class="btn-link">{{"support_case_show_actions_history" | i18n}}</div> <hr> </div>  <div class="form-group" ng-show="data.action.actionType==\'OPEN\'"> <label>{{"subject" | i18n}}:</label> <input class="form-control" ng-model="data.action.subject">  </div>  <div class="form-group" ng-show="data.action.actionType==\'OPEN\' || data.action.actionType==\'ASSIGN\'"> <label>{{"support_case_type" | i18n}}:</label> <select class="form-control" ng-model="data.action.newCaseType"> <option ng-repeat="caseType in CASE_TYPES" value="{{caseType}}"> {{ ("support_case_type_"+caseType) | i18n }}  </option> </select> </div>   <div ng-show="data.action.actionType==\'FORWARD_TO_AUCTION_HOUSE\'"> <div class="form-group" > <label class="float">{{"support_select_house" | i18n}}:</label> <houses-dropdown  max-length="40" class="float" disable-all-houses="true" on-house-selected="onHouseSelected" initial-house-code="{{guessedHouseCode}}"> </houses-dropdown> <div class="clearfix"></div> </div> <div class="checkbox" ng-show="data.supportCase.lastVisitedLot && !data.action.forwardAsUserEmail"> <label> <input type="checkbox" ng-model="data.action.sendLotInquiry" ng-change="handleForwardMessage()">  {{"support_forward_as_lot_inquiry" | i18n:{itemName:(data.supportCase.lastVisitedLot | lotText:50 | stripTags)} }}  </label> </div>   <div class="checkbox" ng-show="!data.action.sendLotInquiry"> <label> <input type="checkbox" ng-model="data.action.forwardAsUserEmail" ng-change="handleForwardMessage()">  {{"support_forward_as_user_message" | i18n}}  </label> </div>  <div class="checkbox" ng-show="!descriptionHidden"> <label> <input type="checkbox" ng-model="data.includeUserContactInfo" ng-change="handleForwardMessage()">  {{"support_forward_include_user_contact_info" | i18n}}  </label> </div>   </div>   <div class="form-group" ng-show="!descriptionHidden"  bs-focus-on="focusOnDesc"> <label>{{descriptionLabel | i18n}}:</label> <div class="description-box" text-angular ta-toolbar="[ [\'bold\'],[\'insertLink\']]" class="form-control" ng-model="data.action.description"></div> </div>  <div class="form-group" ng-show="assignees && (data.action.actionType==\'ASSIGN\' || data.action.actionType==\'OPEN\')"> <label>{{"support_assignee" | i18n}}:</label> <select class="form-control" ng-model="data.action.assigneeEmail"> <option ng-repeat="assignee in assignees" value="{{assignee.email}}"> {{assignee.firstName}} {{assignee.lastName}}  </option> </select> </div>   <div class="checkbox" ng-show="data.action.actionType == \'NOTE\'  || data.action.actionType==\'ASSIGN\'"> <label> <input type="checkbox" ng-model="data.sendEmail" ng-change="handleSendEmailChanged()" >  {{"support_case_action_send_email" | i18n}}  </label> </div>   <div ng-show="data.sendEmail || data.action.actionType == \'SEND_EMAIL\'"> <div class="form-group" > <label>{{"support_case_recipients" | i18n}}:</label> <input class="form-control" ng-model="data.action.recipients">  <div class="btn btn-link" ng-show="!adminRecipients" ng-click="showAdminRecipientss()"> {{"support_select_admin_recipient" | i18n}} </div>  <div class="form-inline" ng-show="adminRecipients">  <select class="form-control" ng-model="data.newAdminRecipient" ng-change="addAdminRecipients()"> <option value=""> {{"support_select_admin_recipient" | i18n }} </option> <option ng-repeat="recipient in adminRecipients" value="{{recipient.email}}"> {{recipient.firstName}} {{recipient.lastName}}  </option> </select> </div>  </div>  </div>   <div class="checkbox" ng-show="data.action.actionType==\'FORWARD_TO_AUCTION_HOUSE\'"> <label> <input type="checkbox" ng-model="data.action.closeSupportCase">  {{"support_case_action_close" | i18n}} </label> </div>  <div class="attachments" ng-show="!attachmentsHidden">  <div ng-repeat="attachment in uploadedAttachments" class="float attachment" ng-class="{pending:attachment.pending}"> <div class="frame"  style="background-image:{{getAttachmentImageUrl(attachment)}}"> <div ng-if="!attachment.pending && !(attachment.url | isImage) " > {{attachment.url | fileNameFromUrl | shortFileName}} </div>  </div> <div class="btn btn-link" ng-click="removeAttachment(attachment)">{{"remove" |i18n}}</div> </div>  <div class="btn btn-default btn-upload float" upload-button  url="{{\'/resources/uploadFilesToS3\' | formActionPath}}" multiple="{{allowMultiple}}"  on-success="addAttachmentFromResponse(response)" on-error="handleError(response)" on-upload = "addPendingAttachment(files)" >{{\'support_add_attachment\'  | i18n}}</div> <div class="clearfix"></div> </div>   </div>  <div ng-if="!editMode"> <div class="form-group"> <label>{{"time" | i18n}}:</label>  {{data.action.actionTime | date:\'dd/MM/yyyy HH:mm:ss\'}} </div>  <div class="form-group"> <label>{{"support_action_user" | i18n}}:</label>  <span ng-bind-html="data.action.userDisplay"></span> </div>  <div class="form-group"> <label>{{"support_action" | i18n}}:</label>  {{("support_case_action_"+data.action.actionType.toLowerCase()) | i18n}} </div>  <div class="form-group" ng-if="data.action.subject"> <label>{{"subject" | i18n}}:</label>  {{data.action.subject}} </div> <div class="form-group" ng-if="data.action.assigneeEmail"> <label>{{"support_assignee" | i18n}}:</label>  {{data.action.assigneeEmail}} </div> <div class="form-group" ng-if="data.action.description"> <label>{{"description" | i18n}}:</label>  <p ng-bind-html="data.descriptionView"></p> </div> <div class="form-group" ng-if="data.action.recipients"> <label>{{"support_case_recipients" | i18n}}:</label>  {{data.action.recipients}} </div>   <div class="form-group" ng-if="data.action.notes"> <label>{{"notes" | i18n}}:</label>  <p ng-bind-html="data.action.notes"></p> </div> <div class="form-group" class="attachments">{{action.attachments}}  <a class="attachment"  ng-repeat="attachment in data.action.attachments" ng-href="{{attachment}}" target="_blank" > <div class="frame"  style="background-image:{{getAttachmentImageUrl({url:attachment})}}"> <div ng-if="!(attachment | isImage) " > {{attachment  | fileNameFromUrl | shortFileName}} </div> </div>  </a> </div>  </div> </div>   <div class="modal-footer">  <bs-async-button name="saveSupportAction" ng-show="editMode"  class="float" action-fn="save()"  button-class="\'btn-primary common-button \'+currentLang"  label="saveLabel" > </bs-async-button>  <bs-async-button name="deletSupportAction" ng-show="data.action.isDraft && data.action.id"  class="float" action-fn="removeAction()"  button-class="\'btn-danger common-button \'+currentLang" label="\'support_case_delete_draft\'" > </bs-async-button>  <div class="btn btn-link opposite float"  ng-show="!editMode" ng-click="$close()">{{"close" | i18n}}</div>  <div class="btn btn-warning  float"  ng-show="!editMode" ng-click="addAction(\'FORWARD_TO_AUCTION_HOUSE\')">{{"support_case_action_forward_to_auction_house" | i18n}}</div>  <div class="btn btn-default  float"  ng-show="!editMode" ng-click="addAction(\'ASSIGN\')">{{"support_case_action_assign" | i18n}}</div>  <div class="btn btn-default  float"  ng-show="!editMode" ng-click="addAction(\'NOTE\')">{{"support_case_action_note" | i18n}}</div>  <div class="float btn btn-primary" ng-show="!editMode" ng-click="addAction(\'SEND_EMAIL\')"> {{"support_case_action_send_email" | i18n}}   </div>      <div class="opposite float saving-draft visible-lg" ng-if="savingDraft"> <div class="loader-animation"></div> <div class="text-info">{{"support_case_saving_draft" | i18n}}</div> </div>   </div> </div>  '), 
        $templateCache.put("/portal/templates/shops/shopsMain.html?1.1944", '<div ng-controller="ShopsMainController" class="shops scene" bs-scroll-to-top> <div class="upper-part">  <div class="dark overlay">  <div class="message center-block container col-lg-7 col-md-7 col-sm-8 col xs-12"> <h1>{{"shops" | i18nWithRegion  }}</h1> <div class="short-separator"></div> <h4 ng-bind-html="\'shops_message\' | i18nWithRegion"></h4> </div> </div> </div> <div class="content">  <bs-upper-space-holders> </bs-upper-space-holders>  <bs-shops-list shops="shops" > </bs-shops-list> </div>   </div> '), 
        $templateCache.put("/portal/templates/shops/catalog/shopCatalog.html?1.1944", '<div ng-controller="CatalogListController" >  <div ng-controller="ShopCatalogController" > <div class="catalog scene"> <div class="content col-xs-12" > <bs-upper-space-holders> </bs-upper-space-holders>  <div class="catalog-navigation-panel" bs-text-direction>   <bs-shop-info ng-if="shop" shop="shop" ></bs-shop-info>  <div class="catalog-actions viewport_{{viewPort.viewPortWidth}}" bs-text-direction ng-class="{\'no-categories\':filterData.categories.length==0}" > <bs-catalog-list-filter ng-if="shop && data.items"></bs-catalog-list-filter> </div>  <div class="clearfix"></div>   <div ng-if="pagesData.pageItems.length>0">  <bs-catalog-list-pagination pages-data="pagesData"  position-in-page="\'upper\'" href-pages="true" ></bs-catalog-list-pagination> <div  bs-scroll-on watched-value="scrollToPagination" offset="-200"></div> </div> </div>  <div ng-if="pagesData.pageItems.length>0"> <div ng-if="!displayeItemsLoader"  ng-include src="\'catalogs/list/catalogItems\' | appTemplate"  ></div> <bs-content-loader loaded="!displayeItemsLoader"></bs-content-loader> <bs-catalog-list-pagination pages-data="pagesData"  position-in-page="\'lower\'" href-pages="true"></bs-catalog-list-pagination> <bs-content-loader loaded="pagesData.pageItems!=null"></bs-content-loader> </div> </div>   </div> </div> </div>  '), 
        $templateCache.put("/portal/templates/shops/list/shopEntryNarrow.html?1.1944", '<div class="frame viewport_{{viewPort.viewPortWidth}} " >   <div class="float image"  bs-cloudinary-bg="{{::(shop.resources[\'topItem\'] || shop.house.resources[\'mainPageLogo\'])}}" ng-class="::{contain:auction.resources[\'topItem\']!=null}"  params="::{size:\'400x400\'}"> </div>  <div class="opposite float texts" >  <h2> {{::shop.house.details.name | langField}}  </h2>  <div class="text" > {{::shop.sentence | langField}}  </div>  <div class="clearfix"></div>  <div class="float orange common-button" > <div class="text"> <a  ng-href="{{(\'/catalog/shop/\'+shop.intKey + \'/1\') | uiHref}}">{{\'shop_to_catalog\' | i18n}}</a> </div> </div>  <div class="clearfix"></div>  </div>  <div class="clearfix"></div>    </div> '), 
        $templateCache.put("/portal/templates/shops/list/shopEntryWide.html?1.1944", '<div class="frame" >   <div class="image"  bs-cloudinary-bg="{{::(shop.resources[\'topItem\'] || shop.house.resources[\'mainPageLogo\'])}}" ng-class="::{contain:auction.resources[\'topItem\']!=null}"  params="::{size:\'400x400\'}"> </div>   <div class="texts"> <h2> <span >{{:: shop.house.details.name | langField}}</span> </h2>  <div class="text" > {{::shop.sentence | langField}} </div>    </div>   <div class="center-block  common-button" ng-class="size==\'small\' ? \'yellow\' : \'orange\'" > <div class="text"> <a  ng-href="{{(\'/catalog/shop/\'+shop.intKey+\'/1\') | uiHref}}">{{\'shop_to_catalog\' | i18n}}</a> </div> </div>  </div> '), 
        $templateCache.put("/portal/templates/shops/list/shopsList.html?1.1944", '<div class="row text-center {{:: screenView}} shops-list"> <div  class="shop-entry default-align"  bs-text-direction ui-sref="app.shopCatalog({catalogKey:shop.intKey,page:1})" ng-repeat="shop in shops" ng-if="(devMode  || !shop.hidden)  && shop.orderInd>0"  > <div  ng-if="screenView==\'wide\'" ng-include src="\'shops/list/shopEntryWide\' | appTemplate" > </div>  <div  ng-if="screenView==\'narrow\'" ng-include src="\'shops/list/shopEntryNarrow\' | appTemplate" > </div> </div> </div> '), 
        $templateCache.put("/portal/templates/alerts/manage/userAlertsMain.html?1.1944", '<div ng-controller="UserAlertsController" class="userAlerts scene" bs-scroll-to-top> <div class="narrow upper-part">  <div class="dark overlay">  <div class="message center-block container col-lg-7 col-md-7 col-sm-8 col xs-12"> <h1>{{"alerts" | i18n}}</h1> <div class="short-separator"></div> </div> </div> </div>  <div class="content container"> <bs-upper-space-holders class="narrow"> </bs-upper-space-holders>  <uib-accordion ng-if="currentUser" class="col-lg-8 col-md-9 col-sm-10 col-xs-12 center-block">  <div uib-accordion-group is-open="opened[\'catalogs\']" class="catalogs panel-default noselect">  <ng-include src="\'alerts/manage/newCatalogsSection\' | appTemplate"></ng-include>  </div>  <div uib-accordion-group is-open="opened[\'auctionsStart\']" class="auctions-start panel-default noselect"  bs-text-direction> <ng-include src="\'alerts/manage/auctionsStartSection\' | appTemplate"></ng-include> </div>  <div uib-accordion-group is-open="opened[\'itemAlerts\']" class="item-alerts panel-default noselect"  bs-text-direction ng-if="enableAlerts"> <ng-include src="\'alerts/manage/itemAlertsSection\' | appTemplate"></ng-include> </div>   </uib-accordion>   </div>   </div> '), 
        $templateCache.put("/portal/templates/alerts/manage/itemAlertsSection.html?1.1944", '<uib-accordion-heading> <div ng-class="currentLang"> <div class="section-name    col-xs-10  float">{{"user_alerts_item_alerts_title" | i18n}}</div> <div class="edit btn-link   col-xs-2  opposite float opposite-align" ng-show="!opened[\'itemAlerts\']" >{{"edit" | i18n}}</div> <div class="clearfix"></div> </div> </uib-accordion-heading> <div class="section-content" ng-class="section"> <div class="no-alerts" ng-if="itemsWithAlerts.length==0">{{"user_alerts_item_alerts_none" | i18n}}</div> <div class="item-alert-entry" ng-repeat="item in itemsWithAlerts"> <bs-lot-image lot="item" size="100x100" as-bg="true"  class="float lot-pic"></bs-lot-image>  <div class="float info" ng-style="{width:mobileElementsDimensions.infoWidth+\'px\'}"> <div class="item-index"> {{"lot_number" | i18n}}: {{item.itemIndex}}</div>  <div class="lot-text" ng-bind-html="item | lotText:100 "></div>   <bs-lot-price lot="item"  single-row="true" break-on-row="true"></bs-lot-price>  </div>  <bs-lot-alert-flag  lot="item"></bs-lot-alert-flag>  <bs-lot-badge lot="item" ></bs-lot-badge>  <div class="newLine"></div> </div> </div> '), 
        $templateCache.put("/portal/templates/alerts/manage/auctionsStartSection.html?1.1944", '<uib-accordion-heading> <div ng-class="currentLang"> <div class="section-name    col-xs-10  float">{{"user_alerts_auctions_start_title" | i18n}}</div> <div class="edit btn-link   col-xs-2  opposite float opposite-align" ng-show="!opened[\'auctionsStart\']" >{{"edit" | i18n}}</div> <div class="clearfix"></div> </div> </uib-accordion-heading> <div class="section-content" ng-class="section"> <div class="no-auctions" ng-if="auctions.length==0">{{"auction_start_alert_no_auctions" | i18n}}</div> <div class="auction-entry" ng-repeat="auction in auctions"> <div class="float image"  bs-cloudinary-bg="{{(auction.resources[\'topItem\'] || auction.house.resources[\'mainPageLogo\'])}}" ng-class="{contain:auction.resources[\'topItem\']!=null}"  params="{size:\'100x100\'} "> </div> <div class="float texts col-xs-10"> <div class="name"> {{auction.house.details.name | langField}} - <span ng-if= "auction.number"> {{"auction_label_number" | i18n:{number:auction.number} }}&nbsp;</span> <span ng-if= "!auction.number"> {{auction.name | langField}} <span class="part" ng-if="auction.part"> {{("auction_part_"+auction.part) | i18n}}  </span>  </div>  <div class="time" > {{auction | auctionTime}}  </div> <div class="description"> <div ng-if= "auction.number" ng-bind-html="auction.name | langField"></div> <!-- If there is no number the name is in the title... --> <div ng-if="auction.shortDetails | langField" style="color:{{auction.textColors.details}}" ng-bind-html="auction.shortDetails | langField"></div> </div> </div>  <bs-auction-start-alert-button auction="auction"></bs-auction-start-alert-button> <div class="newLine"></div> </div> </div> '), 
        $templateCache.put("/portal/templates/alerts/manage/newCatalogsSection.html?1.1944", '<uib-accordion-heading> <div ng-class="currentLang"> <div class="section-name    col-sm-8  float">{{"user_alerts_new_catalogs_title" | i18n}}</div> <div class="edit btn-link   col-sm-3  opposite float opposite-align" ng-show="!opened[\'catalogs\']">{{"edit" | i18n}}</div> <div class="clearfix"></div> </div> </uib-accordion-heading> <div class="section-content" ng-class="section"> <div ng-if="!saved"> <h4>{{"user_alerts_new_catalogs_message" | i18n}}</h4> <div class="alerts-choice-form" > <div class="form-group" ng-click="setChoice(\'ALL_HOUSES_FOR_REGION_ALERTS\')"> <input  type="radio"  ng-model="data.housesAlertChoice" value="ALL_HOUSES_FOR_REGION_ALERTS"/> <label ><span></span>{{"user_alerts_all_houses" | i18nWithRegion }}</label>  </div> <div ng-show="false" class="form-group" ng-click="setChoice(\'SOME_HOUSES_ALERTS\')"> <input  type="radio"  ng-model="data.housesAlertChoice" value="SOME_HOUSES_ALERTS"/>  <label><span></span>{{"user_alerts_some_houses" | i18n }}</label>  <div class="housesList" ng-show="housesListVisible"> <div class="caption">{{"user_alerts_choose_houses" | i18n }} </div>  <div class="float house" ng-repeat="house in houses" check-on-click="true"  > <input type="checkbox" bs-checklist-model="data.housesToAlert" checklist-value="house.code" > {{house.details.name | langField}} </div> <div class="clearfix"></div>  </div> </div> <div class="form-group" ng-click="setChoice(\'NO_HOUSES_ALERTS\')"> <input type="radio"  ng-model="data.housesAlertChoice" value="NO_HOUSES_ALERTS"/> <label><span></span>{{"user_alerts_no_houses" | i18n }}</label>  </div> <div class="clearfix"></div> </div> <div class="buttons-row"> <bs-async-button button-class="\'float orange common-button\'"   action-fn="save()" label="\'save\'" > </bs-async-button> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <div ng-click="closeAll()" class="cancel btn btn-link">{{"cancel" | i18n}}</div> <div class="clearfix"></div> </div>  </div>  <div ng-if="saved"> <h4>{{"user_alerts_saved" | i18n}}</h4> <br><br> <div ng-click="closeAll()" class="btn btn-link btn-lg">{{"close" | i18n}}</div> </div>  </div> '), 
        $templateCache.put("/portal/templates/alerts/popups/confirmUnsubscriptionPopup.html?1.1944", '<div bs-text-direction > <div class="modal-header"> <button type="button" class="opposite float close"  ng-click="$close()">&times;</button> <div class="clearfix"></div> </div>  <div class="modal-body" > <div class="message" ng-if="!removed" ng-bind-html="\'alrets_unsubscription_message\' | i18n:{name:name}"></div> <div class="message" ng-if="removed" ng-bind-html="\'alrets_unsubscription_removed\' | i18n:{name:name}"></div> </div>  <div class="modal-footer"> <div class="text-center" ng-if="!removed"> <button class="btn btn-link text-warning" ng-click="$close()">{{"cancel" | i18n}}</button>  <button class="btn btn-primary" ng-click="onConfirm()">{{"alrets_unsubscription_confirm" | i18n}}</button> </div>   <div class="text-center" ng-if="removed"> <button class="btn btn-primary" ng-click="$close()">{{"close" | i18n}}</button> </div>   </div> </div>  '), 
        $templateCache.put("/portal/templates/alerts/popups/itemAlertPopup.html?1.1944", '<div bs-text-direction> <div class="modal-header"> <div class="float modal-title">{{"notice" | i18n}}</div>  <button type="button" class="opposite float close"  ng-click="$close()">&times;</button> <div class="clearfix"></div> </div>  <div class="modal-body"> <div ng-bind-html="itemAlertMessage"></div> </div>   <div class="modal-footer"> <div class="text-center"> <button ng-if="!auction.catalogOnly && !auction.absenteeBidsOnly" class="btn btn-primary" ng-click="openAuctionSite()">{{"home_auction_enter" | i18n}}</button> <button class="btn btn-link text-warning" ng-click="$close()">{{"close" | i18n}}</button> </div>  </div> </div>  '), 
        $templateCache.put("/portal/templates/alerts/popups/installAppPopup.html?1.1944", '<div class="install-app-popup"> <div class="alert-icon"></div> <div class="message-title default-align" ng-bind-html="options.messageTitle|i18n"></div> <div class="message default-align" ng-bind-html="options.message | i18n"></div> <br> <div ng-if="!options.mobileDevice"> <div class="col-xs-4 search-app">{{"app_install_search_app" | i18n }}</div> <div class="col-xs-4 install-app-qr-code"></div> <dic class="col-xs-4"></dic> <div class="clearfix"></div> </div> <div class="app-links"> <install-app-button ng-repeat="platform in options.platforms" platform="platform"></install-app-button> </div> </div>  '), 
        $templateCache.put("/portal/templates/alerts/popups/confirmFirstAlertPopup.html?1.1944", '<div bs-text-direction > <div class="modal-header"> <button type="button" class="opposite float close"  ng-click="$close()">&times;</button> <div class="clearfix"></div> </div>  <div class="modal-body" > <div class="alert-icon"></div>  <div class="message" ng-bind-html="messageKey | i18n"></div> </div>  <div class="modal-footer"> <div class="text-center"> <button class="btn btn-link text-warning" ng-click="$close()">{{"cancel" | i18n}}</button>  <button class="btn btn-primary" ng-click="onConfirm()">{{"first_auction_alert_confirm" | i18n}}</button> </div>    </div> </div>  '), 
        $templateCache.put("/portal/templates/alerts/popups/auctionStartPopup.html?1.1944", '<div bs-text-direction> <div class="modal-header"> <div class="float modal-title">{{"notice" | i18n}}</div>  <button type="button" class="opposite float close"  ng-click="dismiss()">&times;</button> <div class="clearfix"></div> </div>  <div class="modal-body"> <div ng-bind-html="message | i18n:{house:(auction.house | houseName:\'full\' ),url:auction.house.website} "></div> </div>   <div class="modal-footer"> <div class="text-center"> <button ng-if="!auction.catalogOnly && !auction.absenteeBidsOnly" class="btn btn-primary" ng-click="openAuctionSite()">{{"home_auction_enter" | i18n}}</button> <button class="btn btn-link text-warning" ng-click="dismiss()">{{"close" | i18n}}</button> </div>  </div> </div>  '), 
        $templateCache.put("/portal/templates/alerts/common/alertFlag.html?1.1944", '<div   class="alert-flag flag-button "   ng-click="toggleAlert()"   ng-mouseout="onMouseOut()" ng-mouseover="onMouseOver()"  >  <div  class="ng-hide toast"  ></div>   </div> '), 
        $templateCache.put("/portal/templates/portalMain.html?1.1944", '   <div ng-include src="\'components/navigation/upperNavigation\' | appTemplate"></div>   <div  ng-show="!mobileMenuOn" class="page-body" ui-view dir="{{dir}}" ng-show="dataState==\'loaded\'" style="min-height:{{viewPort.innerHeight-300+\'px\'}}"></div>  <bs-content-loader loaded="dataState==\'loaded\'"></bs-content-loader>   <bs-page-footer dir="{{dir}}" ng-show="!mobileMenuOn"></bs-page-footer>   '), 
        $templateCache.put("/portal/templates/ads/banner.html?1.1944", '<div class="home-banner" ng-class="bannerCode"  ng-show="banner && banner.image"  ng-click="onClick()" > <img class="center-block" ng-src="{{banner.image}}"> </div> '), 
        $templateCache.put("/portal/templates/ads/promotionInstance.html?1.1944", '<div class="promotion-instance" ng-class="[(promotionInfo.position | underscoreToDashed),(promotionInfo.promotionType | underscoreToDashed)]" bs-text-direction> <div ng-if="promotionInfo"  ng-click="onClick()"> <div ng-if="promotionType==\'HOUSE_PROMOTION\'" >  <img class="float pic" ng-src="{{promotionInfo.imagePath | cloudinary}}">  <div class="float info"> <div class="title">{{promotionInfo.title | langField }}</div> <div class="text"> {{promotionInfo.text  | langField }}</div> </div>  <div class="clearfix"></div> </div>  <div ng-if="promotionType==\'MOBILE_APP_PROMOTION\'" > <div class="float pic install-app-qr-code"></div>  <div class="float info"> <div class="title">	{{\'home_mobile_app_title\' | i18n }}</div> <div class="text">  {{ \'home_mobile_app_text\' | i18n }}</div> </div>  <div class="clearfix"></div> </div>  <div ng-if="promotionType==\'IMAGE_AND_TEXT_AD\'" >  <img class="float pic" ng-src="{{promotionInfo.resources.image | cloudinary}}">  <div class="float info"> <div class="title">{{promotionInfo.title | langField }}</div> <div class="text"> {{promotionInfo.text  | langField }}</div> </div>  <div class="clearfix"></div> </div>  <div ng-if="promotionType==\'BANNER\'" > <img class="pic" ng-src="{{promotionInfo.imagePath | cloudinary}}"> </div>  </div> </div>   '), 
        $templateCache.put("/portal/templates/ads/homeMobilePromotion.html?1.1944", '<div class="home-mobile-promotion frame" ng-click="showInstallPopup()">  <div class="float install-app-qr-code"></div>  <div class="float texts"> <div class="title"> {{\'home_mobile_app_title\'|i18n}} </div>  <div class="text"> {{\'home_mobile_app_text\'|i18n}} </div> </div>  <div class="clearfix"></div>  </div> '), 
        $templateCache.put("/portal/templates/catalogs/list/catalogItemWide.html?1.1944", ' <div >  <bs-lot-image lot="::lot" size="220x220" as-bg="true" image-mode="\'fit\'"> </bs-lot-image>  <div  ng-if="::lot.viewOnly && auction.state==\'READY\'"  ng-include src="\'catalogs/elements/auction/lotViewOnlyOverlay\' | appTemplate"  class="lot-view-only-overlay"> </div>  <meta itemprop="image" content="{{::lot | lotImage:\'220x220\'}}"></meta>   <bs-lot-badge lot="::lot" ></bs-lot-badge> <div class="search-score" ng-if="lot.searchScore && devMode">{{lot.searchScore}}</div>  <div class="item-bottom-part">  <div class="above-separator"> <span class="lot-number" itemprop="sku" ng-if="lot.itemIndex"> {{"lot" | i18n}} {{::lot.itemIndex}}: </span> <span class=\'overseas-icon\' ng-if=":: lot.extraInfo==\'overseas\'"> </span> <span itemprop="name" ng-bind-html=":: lot | lotText:70 "></span>  </div>  <div class="short-separator"></div>  <div class="below-separator" bs-text-direction> <div class="not-published" ng-if="lot.published==false"> {{\'lot_unpublished_from_shop\' | i18n }}  </div> <div ng-if="lot.purchase || !lot.leadingBid || (lot.leadingBid.underReserved && lot.auction.state==\'ENDED\')"> <bs-lot-price lot="::lot" max-width="125" single-row="true" break-on-row="false"></bs-lot-price>  <a class="orange common-button {{::currentLang}}" ng-href="{{::lot | lotHref : (catalogSource || \'catalog\')}}" ng-hide="lot.published==false"> <div class="text"> {{"view_lot" | i18n }} </div> </a> </div>  <leading-bid ng-if="lot.leadingBid" lot="lot" source="catalogSource" ></leading-bid>  <bs-lot-view-only ng-if="::lot.viewOnly" lot="lot" > </bs-lot-view-only>  <past-lot-absentee lot="lot"> </past-lot-absentee> </div>  </div>  </div>    '), 
        $templateCache.put("/portal/templates/catalogs/list/catalogItems.html?1.1944", '<div class="list" ng-class="{\'mobile-list\':!viewPort.isWideDevice}">  <div class="row"> <div class="item" itemscope itemtype="http://schema.org/Product" bs-text-direction ng-repeat="lot in pagesData.pageItems" ng-class="::{\'pc-item\':viewPort.isWideDevice,\'mobile-item\':!viewPort.isWideDevice} " ng-style="{width:itemWidth}"; ng-hide="postSaleMode && !lot.startPrice && !lot.purchase" bs-scroll-on="::lot.idInApp == scrollTo" offset="-200" >  <div  itemprop="url"  class="item-link" ng-click="gotoLot(lot, \'catalog\')" > <div  ng-if="::viewPort.isWideDevice"     ng-include src="\'catalogs/list/catalogItemWide\' | appTemplate" class="frame"> </div> <div  ng-if="::!viewPort.isWideDevice" ng-include src="\'catalogs/list/catalogItemNarrow\' | appTemplate"> </div> </div> <bs-lot-favorite-flag lot="::lot"></bs-lot-favorite-flag> <bs-lot-alert-flag class="float" lot="::lot"></bs-lot-alert-flag> </div> <div class="clearfix"></div> </div>   <div class="clearfix"></div> </div>  '), 
        $templateCache.put("/portal/templates/catalogs/list/catalogListFilter.html?1.1944", '<div class="filter-panel" >  <div class="float section" > <form name=\'searchForm\' novalidate bs-form  bs-submit="search()" class="search-form"  dir="{{dir}}" > <bs-form-group field-name="phrase"> <input  placeholder="{{(shop ? \'shop_search_placeholder\' : \'search_in_catalog\') | i18n}}" name="phrase"  class="form-control"  ng-model="filterData.phrase"  bs-enter-key-action="doSearch()" ng-focus="onInputFocus()" /> <div class="button " ng-click="doSearch()">  </div> </bs-form-group> </form> <div class="result" >{{resultMessage}} <span class="clear-link" ng-if="filterData.phrase" ng-click="clearSearch()">{{"search_clear" | i18n}}</span></div> <div class="sold-state" ng-if="showSoldState"> <select  ng-model="filterData.soldState" ng-change="applySoldStateFilter()"  ng-options="getSoldStateLabel(soldState) for soldState  in [\'all\',\'sold\',\'unsold\']"> </select> </div> </div>  <div class="opposite float section"> <div class="categories" ng-class="{invisible:filterData.categories.length==0}"> <select  ng-model="filterData.category" ng-change="onCategoryChanged()">  <option ng-repeat="category in filterData.categories" value="{{category.value}}" dir="{{category.name | guessDirection}}" class="default-align">{{category.name}}</option>  </select> </div>  <div class="sort-order" ng-class="{invisible:contentType!=\'ART\'}"> <span class="sort-label">{{"sort_by" | i18n }}:</span> <select  ng-model="filterData.selectedSortOrder" ng-change="updateSortOrder()" ng-options="sortOrder.value as sortOrder.text for sortOrder in filterData.sortOrders"> </select> </div>   </div>      <div class="clearfix"></div>  </div> '), 
        $templateCache.put("/portal/templates/catalogs/list/catalogItemNarrow.html?1.1944", '<div class="lot-row" >  <bs-lot-badge lot="::lot"  ng-style="::{width:mobileElementsDimensions.infoWidth+\'px\'}"></bs-lot-badge>  <bs-lot-image lot="::lot" size="260x176" as-bg="true" image-mode="\'fit\'" class="lot-pic"></bs-lot-image>  <div class="info" ng-style="::{width:mobileElementsDimensions.infoWidth+\'px\'}" bs-current-lang> <div class="item-index" ng-if="lot.itemIndex"> {{"lot" | i18n}} {{::lot.itemIndex}}  <span class=\'overseas-icon\' ng-if=":: lot.extraInfo==\'overseas\'"> </span> </div>  <div class="lot-text" ng-bind-html="::lot | lotText:(lot.leadingBid ? 100 : 120) "></div>  <bs-lot-price ng-if="lot.purchase || !lot.leadingBid " lot="lot"  single-row="{{true}}" break-on-row="{{true}}"></bs-lot-price>  </div>  <leading-bid ng-if="lot.leadingBid" lot="::lot"  source="catalogSource" ng-style="::{width:mobileElementsDimensions.infoWidth+\'px\'}"></leading-bid>  <bs-lot-view-only ng-if="::lot.viewOnly" lot="lot" > </bs-lot-view-only>  <past-lot-absentee lot="lot"> </past-lot-absentee>  </div>  '), 
        $templateCache.put("/portal/templates/catalogs/list/catalogPagination.html?1.1944", ' <div class="catalog-pagination text-center" ng-class="[currentLang, positionInPage, {\'lifted\':data.lifted}]" bs-text-direction  >  <bs-pagination  ng-if="data.availableWidth" pages-data="pagesData"  href-pages="hrefPages" on-current-page-change="onCurrentPageChange()"  available-width="data.availableWidth"  >  </bs-pagination>   </div>  '), 
        $templateCache.put("/portal/templates/catalogs/search/searchInput.html?1.1944", '<input  type="text" uib-typeahead="suggestion for suggestion in getSuggestions($viewValue)"  typeahead-on-select = "onSuggestionSelect($item)" typeahead-min-length="0" placeholder="{{\'catalog_search_all\' | i18n}}"  class="form-control"  debug="true"   ng-model="data.searchToken"  /> '), 
        $templateCache.put("/portal/templates/catalogs/search/tagsScene.html?1.1944", '<div ng-controller="TagsSceneController" bs-scroll-to-top > <div class="tags scene" > <div class="content" ng-class="{\'hello-space\':currentUser}">  <div class="main-tags" ng-if="displayState==\'mainTags\'"> <div ng-repeat="tag in mainTags" class="menu-row" ng-click="onMainTagClick(tag)"> <div class="text" > {{("tag_"+tag.trim()) | i18n }} </div> </div>  <div ng-if="!mainTags" class="no-tags-space">  </div>  <div ng-show="shopsVisible" class="yellow menu-row" ui-sref="app.shops"> <div class="text"> {{"shops" | i18n }} </div> </div>  <div ng-repeat="portalScene in otherPortalScenes" class="yellow menu-row" ng-click="gotoPortalScene(portalScene)">  <div class="text"> {{ linkText(portalScene) }} </div> </div>   </div>   <div class="secondary-tags" ng-if="displayState==\'secondaryTags\'">  <div ng-repeat="tag in secondaryTags" class="menu-row" ng-click="gotoTagPage(tag)"> <div class="text"> {{("tag_"+tag.trim()) | i18n }} </div> </div>  <div class="text-center"> <div  class="yellow menu-row back-to-main" ng-click="showMainTags()"> <div class="text"> {{"tags_back_to_main" | i18n }} </div> </div>  </div>   </div>  </div> </div> </div>   '), 
        $templateCache.put("/portal/templates/catalogs/search/searchItems.html?1.1944", ' <div class="list"  ng-class="{\'mobile-list\':viewPort.mobileMedia}">   <div class="row">  <div class="item with-house-badge" bs-text-direction ng-repeat="lot in pagesData.pageItems" ng-class="{\'pc-item\':viewPort.pcMedia,\'mobile-item\':viewPort.mobileMedia}" ng-click="gotoLot(lot)">  <div class="item-link"  bs-scroll-on="lot.id == scrollTo" > <div ng-if="viewPort.pcMedia"     ng-include src="\'catalogs/list/catalogItemWide\' | appTemplate" class="frame"></div> <div ng-if="viewPort.mobileMedia" ng-include src="\'catalogs/list/catalogItemNarrow\' | appTemplate"  ></div> </div>  <bs-lot-favorite-flag lot="::lot"> </bs-lot-favorite-flag>  <bs-lot-alert-flag class="float" lot="::lot"></bs-lot-alert-flag>  </div> <div class="clearfix"></div> </div>   <div class="clearfix"></div> </div>  '), 
        $templateCache.put("/portal/templates/catalogs/search/searchMain.html?1.1944", '<div ng-controller="SearchController" > <div class="catalog search scene"> <div class="content col-xs-12" > <bs-upper-space-holders> </bs-upper-space-holders>  <form name=\'searchForm\' novalidate  class="float global-search-form" bs-text-direction bs-enter-key-action="doSearch()"> <bs-form-group field-name="phrase" label="catalog_search_all" class="phrase">  <bs-search-input></bs-search-input>  </bs-form-group> <div class="button noselect" ng-click="doSearch()"> <div class="icon"> </div> </div> <div class="clearfix"></div> </form>  <div class="opposite float"> <div class="home btn-link" ui-sref="app.home">{{"home_back_to" | i18n }}</div> <br> </div>   <div class="clearfix"></div>  <div class="result" ng-class="{invisible:!data.searchedToken && !data.tag}" >  <span ng-if="searching">{{"search_searching" | i18n}}</span> <span ng-if="!searching && resultMessage"> {{resultMessage}} </span>  </div>  <div class="time-form" > <div class="radio" ng-click="setSearchTime(\'FUTURE\')"> <label> <input type="radio"  ng-model="data.searchTime" value="FUTURE"> {{"search_future" | i18n }} </label> </div> <div clas="clearfix"></div> <div class="radio" ng-click="setSearchTime(\'PAST\')"> <label> <input type="radio"   ng-model="data.searchTime" value="PAST"> {{"search_past" | i18n }} </label> </div> </div>  <div class="sort-order" ng-show="contentType==\'ART\'"> <div class="float text">{{"sort_by" | i18n }}:&nbsp;</div> <select class="float" ng-change="updateSortOrder()" ng-model="data.selectedSortOrder"> <option ng-repeat="code in data.sortOrderCodes" value="{{code}}">{{getSortOrderName(code)}}</option> </select> <div class="clearfix"></div> </div> <div class="tags-selection" bs-text-direction  > <select	ng-if="tags.length>0" ng-model="data.tag" ng-change="doSearch()" bs-text-direction> <option value="">{{"tags_all"|i18n}}</option> <optgroup ng-repeat="mainTag in tags" ng-if="mainTag.entries.length>1"  label="{{(\'tag_\'+mainTag.key) |i18n }}"> <option ng-repeat="subTag in mainTag.entries" value="{{subTag}}">{{(\'tag_\'+mainTag.key) |i18n }} > {{(\'tag_\'+subTag) |i18n }}</option> </optgroup> <option ng-repeat="mainTag in tags" ng-if="mainTag.entries.length<=1" value="{{mainTag.key}}" >{{(\'tag_\'+mainTag.key) |i18n }}  </option> </select> </div>  <div class="house-selection" bs-text-direction > <houses-dropdown on-house-selected="setHouseFilter" initial-house-code="{{data.houseCode}}"> </houses-dropdown> </div>  <div class="clearfix"></div>  <bs-catalog-list-pagination data="data" pages-data="pagesData"  position-in-page="currentLang==\'ru\' ? \'\' : \'upper\'" on-current-page-change="onPageChange()" ></bs-catalog-list-pagination> <div ng-if="loadState==\'loaded\'" bs-scroll-on watched-value="scrollToPagination"   offset="-200"></div> <div ng-if="loadState==\'loaded\'"> <br> <div  ng-include src="\'catalogs/search/searchItems\' | appTemplate"  ></div> </div>   <div ng-if="loadState==\'loading\'"> <bs-content-loader > </bs-content-loader> </div>  <bs-catalog-list-pagination data="data" pages-data="pagesData"  position-in-page="\'lower\'" on-current-page-change="onPageChange()"></bs-catalog-list-pagination>   </div> </div> </div>   '), 
        $templateCache.put("/portal/templates/catalogs/lotPage/lotPageMain.html?1.1944", '<div ng-controller="LotPageController" > <div class="catalog  scene lotPage">  <div class="content col-xs-12" >  <bs-upper-space-holders> </bs-upper-space-holders> <div ng-if="data.item "> <div ng-include src="\'catalogs/lotPage/pc/lotPagePc\' | appTemplate" ng-if="viewPort.pcMedia"></div> <div ng-include src="\'catalogs/lotPage/mobile/lotPageMobile\' | appTemplate" ng-if="viewPort.mobileMedia"></div> </div> <bs-content-loader loaded="data.item!=null"></bs-content-loader> <div class="clearfix"></div>  </div> </div> </div>   '), 
        $templateCache.put("/portal/templates/catalogs/lotPage/pc/lotPagePc.html?1.1944", '<div  itemscope itemtype="http://schema.org/Product"> <bs-auction-info auction="data.catalogOwner" lot="data.item" ng-if="data.item.auctionId && data.catalogOwner" ></bs-auction-info> <bs-shop-info shop="data.catalogOwner" ng-if="data.item.shopId && data.catalogOwner" minimal-view="true" ></bs-shop-info>   <table> <tr> <td class="info-td"> <div ng-include src="\'catalogs/lotPage/common/lotNumber\' | appTemplate" ></div>  <div class="upper-title" dir="{{textDirection}}" ng-class="{\'forced-direction\':forcedDirection}" > <h2 class="lot-name"  itemprop="name" ng-bind-html="data.shortTitle" > </h2>  <div ng-if="showMore" dir="{{textDirection}}" class="btn btn-link more-link" ng-click="scrollToDescription()">  <span bs-text-direction> {{"more" | i18n }}... </span> </div> <div ng-include src="\'catalogs/lotPage/common/overseas\' | appTemplate" ></div> </div>  </td>   <td class="float actions-td"> <bs-lot-page-navigation lot="data.item"></bs-lot-page-navigation> <bs-lot-favorite-flag class="float" lot="data.item"></bs-lot-favorite-flag> <bs-lot-alert-flag class="float" lot="data.item"></bs-lot-alert-flag> </td> </tr> <tr>  <td class="info-td">  <div  ng-if="data.item.videoUrl" ng-include src="\'catalogs/lotPage/common/videoLink\' | appTemplate" ></div> <bs-lot-page-images lot="data.item"></bs-lot-page-images> </td> <td class="float actions-td">  <bs-lot-bid-form ng-if="data.item.auction"  lot="data.item" ></bs-lot-bid-form>  <div class="car-info-section" itemprop="description" ng-if="contentType==\'CARS\'" bs-scroll-on watched-value="scrollToDescriptionFlag"  > <br> <div ng-if="data.item.carInfo" class="car-info" ng-include src="\'catalogs/lotPage/common/carInfo\' | appTemplate" ></div> <h4 ng-if="!data.item.carInfo"  class="description-text" ng-bind-html="data.lotDesc" dir="{{textDirection}}" ng-class="{\'forced-direction\':forcedDirection}"></h4> <br> </div>  <div class="real-estate-info-section" itemprop="description" ng-if="contentType==\'REAL_ESTATE\'" bs-scroll-on watched-value="scrollToDescriptionFlag"  > <br> <div  class="real-estate-info" ng-include src="\'catalogs/lotPage/common/realEstateInfo\' | appTemplate" ></div> <br> </div>    <bs-shop-purchase-form ng-if="data.item.shop"  lot="data.item"></bs-shop-purchase-form> <bs-lot-share-buttons class="opposite float" lot="data.item" text="data.shortTitle" ng-if="contentType!=\'CARS\'"></bs-lot-share-buttons> <div class="clearfix"></div>  <div ng-include src="\'catalogs/lotPage/common/lotPageInfoLinks\' | appTemplate" ></div>  <bs-lot-tags lot="data.item"></bs-lot-tags>    <div class="clearfix"></div> <br> </td>  </tr>  </table>   <div class="lot-description-section" itemprop="description" ng-if="data.lotDesc && contentType!=\'CARS\'" bs-scroll-on watched-value="scrollToDescriptionFlag" > <h4 class="description-text" ng-bind-html="data.lotDesc" dir="{{textDirection}}" ng-class="{\'forced-direction\':forcedDirection}"></h4> </div>  <bs-lot-page-navigation lot="data.item"></bs-lot-page-navigation> </div>  '), 
        $templateCache.put("/portal/templates/catalogs/lotPage/pc/lotZoomModal.html?1.1944", '<div class="zoom-image noselect"> <div class="modal-header"> <button type="button" class="close" ng-click="$close()">&times;</button>  <bs-lot-page-zoom lot="data.item" initial-image-ind="data.imageInd"> </bs-lot-page-zoom> </div>  </div>   '), 
        $templateCache.put("/portal/templates/catalogs/lotPage/mobile/lotZoomSubScene.html?1.1944", '<div class="lot-sub-scene zoom" ng-style="{height:viewPort.clientHeight-150}" bs-scroll-to-top>  <a class="btn btn-link back" ui-sref="^">{{"lot_back" | i18n : {number:data.item.itemIndex} }}</a> <bs-lot-page-zoom lot="data.item"> </bs-lot-page-zoom>  </div>   '), 
        $templateCache.put("/portal/templates/catalogs/lotPage/mobile/lotPageMobile.html?1.1944", '<div> {{data.auction.id}} <div ng-show="(\'app.lotPage\' | isState) || (\'app.lotPageWithDesc\' | isState)">  <bs-auction-info auction="data.item.auction" lot="data.item" ng-if="data.item.auction && ($stateParams.source==\'search\' || data.item.auction.house.auctionBasedUserApproval)" ></bs-auction-info>  <div class="first-row"> <bs-lot-page-navigation lot="data.item" class="opposite float"></bs-lot-page-navigation> <div class="float flags" ng-class="source" bs-text-direction> <bs-lot-favorite-flag class="float" lot="data.item"></bs-lot-favorite-flag> <bs-lot-alert-flag class="float" lot="data.item"></bs-lot-alert-flag> </div> <div class="clearfix"></div> </div>  <div class="second-row">  <div ng-include src="\'catalogs/lotPage/common/lotNumber\' | appTemplate" ></div>  <div class="clearfix"></div> </div>  <div class="upper-title" dir="{{textDirection}}"> <h2 class="lot-name" ng-bind-html="data.showFullText ? data.fullTitle : data.shortTitle" > </h2>  <div ng-include src="\'catalogs/lotPage/common/overseas\' | appTemplate" ></div> <div ng-if="showMore && !data.showFullText" class="btn btn-link more-link" ng-click="showFullText()"> {{"more" | i18n }}... </div>  <bs-lot-badge lot="data.item" ></bs-lot-badge>  </div>  <div class="lot-description-section" ng-show="data.showFullText" dir="{{textDirection}}"> <div class="description-text" ng-bind-html="data.lotDesc"></div>  </div>  <div  ng-if="data.item.videoUrl" ng-include src="\'catalogs/lotPage/common/videoLink\' | appTemplate" ></div>  <bs-lot-page-images lot="data.item"></bs-lot-page-images>   <bs-lot-share-buttons lot="data.item" text="data.shortTitle"></bs-lot-share-buttons>   <bs-lot-bid-form ng-if="data.item.auction" lot="data.item" ></bs-lot-bid-form>  <bs-shop-purchase-form ng-if="data.item.shop"  lot="data.item"></bs-shop-purchase-form>  <div ng-if="data.item.carInfo" class="car-info-section" ng-include src="\'catalogs/lotPage/common/carInfo\' | appTemplate" ></div>  <div ng-if="data.item.realEstateInfo" class="real-estate-info-section" ng-include src="\'catalogs/lotPage/common/realEstateInfo\' | appTemplate" ></div>  <div ng-include src="\'catalogs/lotPage/common/lotPageInfoLinks\' | appTemplate" ></div>  <bs-lot-tags lot="data.item"></bs-lot-tags>  <div class="clearfix"></div> <br><br> <div class="opposite float">  <bs-lot-page-navigation lot="data.item"  ></bs-lot-page-navigation> </div>  <div class="clearfix"></div> </div>   <div ui-view > </div>   </div>  '), 
        $templateCache.put("/portal/templates/catalogs/lotPage/common/videoLink.html?1.1944", '<a ng-href="{{data.item.videoUrl}}" class="video-link" target="_blank">{{"lot_click_car_video_url" | i18n}}</a> '), 
        $templateCache.put("/portal/templates/catalogs/lotPage/common/images/lotPageImages.html?1.1944", '<div class="lot-images-section"> <div class="big-image zoom-in-cursor" > <bs-lot-image lot="lot" size="{{mainImagewidth}}x" image-ind="0" ng-click="zoomImage(lot, 0)" ></bs-lot-image> </div>   <div class="thumbs" ng-if="lot.imagesList.length>1"> <div ng-repeat = "imageName in lot.imagesList" class="float thumb zoom-in-cursor" ng-click="zoomImage(lot, $index)" ng-if="!$first"> <bs-lot-image   lot="lot" size="x80" image-ind="$index"> </bs-lot-image> </div> <div class="clearfix"></div> </div>  </div>    '), 
        $templateCache.put("/portal/templates/catalogs/lotPage/common/images/lotPageZoom.html?1.1944", '<div> <div class="lot-page-zoom-image-navigation" ng-if="lot.imagesList.length>1" dir="ltr"> <div class="prev link " ng-click="prevImage()"><div class="text"></div></div>  <div class="thumbs" ng-style="{\'max-width\':options.maxThumbsWidth}"> <div ng-repeat = "imageName in lot.imagesList"  class="thumb"  thumb-ind="$index" ng-click="setZoomImage($index)" ng-class="{selected:selectedImageInd == $index}"> <bs-lot-image   lot="lot" size="x50" image-ind="$index"> </bs-lot-image> </div> </div> <div class="prev link noselect" ng-click="nextImage()"><div class="text"></div></div> <div class="clearfix"></div> </div>  <div class="big-image" ng-class="cursorZoomClass"> <bs-lot-image  lot="lot" image-ind="selectedImageInd" watchable="true" enable-magnifier="{{options.enableMagnifier}}"  size="{{options.size}}" move-in-frame="options.moveInFrame"  as-bg="options.asBg"  image-mode="options.imageMode" debug="true"   loaded-image-info="loadedImageInfo"> </bs-lot-image> </div>   </div>  '), 
        $templateCache.put("/portal/templates/catalogs/lotPage/common/increments.html?1.1944", '<div class="increments-table">  <table class="table table-striped table-bordered table-hover" dir="{{dir}}"> <tr> <th class="default-align">{{"increment_price" | i18n}}</th> <th class="default-align">{{"increment_step" | i18n}}</th> </tr> <tr ng-repeat="step in options.data.steps"> <td class="default-align">{{step.price | sumInCurrency:options.data.currency}}</th> <td class="default-align">{{step.increment | sumInCurrency:options.data.currency}}</th> </tr> </table>  </div>   '), 
        $templateCache.put("/portal/templates/catalogs/lotPage/common/realEstateInfo.html?1.1944", '<table> <tbody> <tr ng-if="realEstateInfo.propertyType"> <th>{{"property_type" | i18n}}</th> <td>{{realEstateInfo.propertyType}}</td> </tr>  <tr ng-if="realEstateInfo.city"> <th>{{"city" | i18n}}</th> <td>{{realEstateInfo.city}}</td> </tr>   <tr ng-if="realEstateInfo.neighborhood"> <th>{{"neighborhood" | i18n}}</th> <td>{{realEstateInfo.neighborhood}}</td> </tr>  <tr ng-if="realEstateInfo.address"> <th>{{"address" | i18n}}</th> <td>{{realEstateInfo.address}}</td> </tr>   <tr ng-if="realEstateInfo.appraiserEstimate"> <th>{{"appraiser_estimate" | i18n}}</th> <td>{{realEstateInfo.appraiserEstimate | sumInCurrency:data.item.auction.catalogInfo.currency}}</td> </tr>  <tr ng-if="realEstateInfo.minBidPrice && data.item.auction.state!=\'ENDED\'"> <th>{{"min_bid_price" | i18n}}</th> <td>{{realEstateInfo.minBidPrice | sumInCurrency:data.item.auction.catalogInfo.currency}}</td> </tr>  <tr ng-if="realEstateInfo.lastDateForBids"> <th>{{"last_date_for_bids" | i18n}}</th> <td>{{realEstateInfo.lastDateForBids}}</td> </tr>   <tr ng-if="realEstateInfo.block"> <th>{{"property_block" | i18n}}</th> <td>{{realEstateInfo.block}}</td> </tr>  <tr ng-if="realEstateInfo.plot"> <th>{{"property_plot" | i18n}}</th> <td>{{realEstateInfo.plot}}</td> </tr>  <tr ng-if="realEstateInfo.subPlot"> <th>{{"property_sub_plot" | i18n}}</th> <td>{{realEstateInfo.subPlot}}</td> </tr>      <tr ng-if="realEstateInfo.rooms"> <th>{{"rooms" | i18n}}</th> <td>{{realEstateInfo.rooms}}</td> </tr>  <tr ng-if="realEstateInfo.balconies"> <th>{{"balconies" | i18n}}</th> <td>{{realEstateInfo.balconies}}</td> </tr>  <tr ng-if="realEstateInfo.size"> <th>{{"size" | i18n}}</th> <td>{{realEstateInfo.size | readableNumber}} {{"unit_square_meter" | i18n}}</td> </tr>  <tr ng-if="realEstateInfo.floor"> <th>{{"building_floor" | i18n}}</th> <td> {{realEstateInfo.floor}} <span ng-if="realEstateInfo.floorsInBuilding" >{{(\'of_floors\' | i18n : {floors:realEstateInfo.floorsInBuilding}) }}</span></td>  </tr>  <tr ng-if="realEstateInfo.propertyCondition"> <th>{{"property_condition" | i18n}}</th> <td>{{realEstateInfo.propertyCondition}}</td> </tr>  <tr ng-if="realEstateInfo.parking"> <th>{{"parking" | i18n}}</th> <td>{{realEstateInfo.parking}}</td> </tr>  <tr ng-if="realEstateInfo.mamad"> <th>{{"mamad" | i18n}}</th> <td>{{realEstateInfo.mamad}}</td> </tr>  <tr ng-if="realEstateInfo.elevator"> <th>{{"elevator" | i18n}}</th> <td>{{realEstateInfo.elevator}}</td> </tr>  <tr ng-if="realEstateInfo.grate"> <th>{{"grate" | i18n}}</th> <td>{{realEstateInfo.grate}}</td> </tr>  <tr ng-if="realEstateInfo.disabledAccess"> <th>{{"disabled_access" | i18n}}</th> <td>{{realEstateInfo.disabledAccess}}</td> </tr>  <tr ng-if="realEstateInfo.airCondition"> <th>{{"air_condition" | i18n}}</th> <td>{{realEstateInfo.airCondition}}</td> </tr>  <tr ng-if="realEstateInfo.storeroom"> <th>{{"storeroom" | i18n}}</th> <td>{{realEstateInfo.storeroom}}</td> </tr>  <tr ng-if="realEstateInfo.notes"> <th>{{"notes" | i18n}}</th> <td ng-bind-html="realEstateInfo.notes | brLines"></td> </tr>     </tbody> </table>  <div ng-if="documents.length>0 && data.item.auction.state!=\'ENDED\'"> <div class="documents-title">{{"documents" | i18n}}:</div> <table> <tbody> <tr ng-repeat="doc in documents" ng-if="doc.link"> <th >{{doc.label}}</th> <td><label class=\'btn btn-link\' ng-click="openWindow(doc.link | documentUrl)" >{{"download" | i18n}}</label> </td> </tr> </tbody> </table> </div> '), 
        $templateCache.put("/portal/templates/catalogs/lotPage/common/overseas.html?1.1944", '<div class=\'extrainfo-overseas\' ng-if="data.item.extraInfo==\'overseas\'"> <div class="float icon"></div> <div class="float text">{{"lot_from_overseas" | i18n }}</div> <div class="clearfix"></div> </div> '), 
        $templateCache.put("/portal/templates/catalogs/lotPage/common/lotPageInfoLinks.html?1.1944", '<div bs-text-direction> <div class="info-link default-align" ng-click="toggleFavorite()"> <span ng-if="!data.item.isFavorite"> <span class="btn btn-link">{{"add_to_favorites" | i18n }}</span> </span>  <span ng-if="data.item.isFavorite" class="btn btn-link">{{"remove_from_favorites" | i18n }}</span> <span class="fade-in-out fade toast" ng-animate  ng-class="{on:favoriteToastMessage,off:!favoriteToastMessage}">{{favoriteToastMessage | i18n}}</span> </div>  <div class="info-link default-align" ng-if="itemAlertsEnabled" ng-click="toggleItemAlert()"> <span ng-if="!data.item.itemAlertOn"> <span class="btn btn-link">{{"item_alert_add" | i18n }}</span> </span> <span ng-if="data.item.itemAlertOn" class="btn btn-link">{{"item_alert_remove" | i18n }}</span> <span class="fade-in-out fade toast" ng-animate  ng-class="{on:itemAlertToastMessage,off:!itemAlertToastMessage}">{{itemAlertToastMessage | i18n}}</span> </div>  <div ng-if="data.item.house.hasTerms" class="btn btn-link info-link default-align" ng-click="openAuctionHouseTerms()" >  {{ (contentType==\'ART\' ? "house_terms" : "terms_of_sale") | i18n:{house:(data.item.house.details.name | langField)} }} </div>  <div class="btn btn-link info-link default-align" ng-if="data.auction && data.auction.state!=\'ENDED\'" ng-click="showIncrements()" > {{"price_increments" | i18n }}</div>  <div class="info-link default-align" ng-click="showInquiryForm()"  > <span class="btn btn-link">  {{"lot_page_inquiry" | i18n }} </span>  <span class="fade-in-out fade toast" ng-animate  ng-class="{on:showInquiryToast,off:!showInquiryToast}">{{"lot_page_inquiry_sent" | i18n}}</span> </div>  <div class="info-link default-align" ng-if="data.item.auction.lotPageLink"  > <a class="btn btn-link" target="_blank" ng-href="{{data.item.auction.lotPageLink}}">  {{"lot_page_external_link" | i18n :{houseName:(data.item.house.details.name | langField)} }} </a>  </div>     <a ng-show="shortLink" ng-href="{{shortLink}}" class="no-break dev" target="_blank">{{shortLink}}</a>  </div>  '), 
        $templateCache.put("/portal/templates/catalogs/lotPage/common/inquiry/inquiryForm.html?1.1944", '<div class="inquiry-form" ng-controller="InquiryFormController"  ng-init="init()">  <p> <label>{{"inquiry_form_to" | i18n }}:&nbsp;</label>{{"house_full_name_art" | i18n:{house:options.data.house} }} </p>  <br> <p> <label>{{"subject" | i18n }}:&nbsp;</label><span ng-bind-html="inquiryData.subject"></span> </p>  <br>  <form name=\'inquiryForm\'  novalidate bs-form  bs-submit="sendInquiry()"> <bs-form-group field-name="content" label="inquiry_form_content"> <label></label> <bs-form-validation-message  ></bs-form-validation-message> <textarea  rows="7"  class="form-control"  required name="content" ng-model="inquiryData.content"> </textarea>  </bs-form-group>  </form>     </div>   '), 
        $templateCache.put("/portal/templates/catalogs/lotPage/common/carInfo.html?1.1944", ' <table> <tbody> <tr ng-if="carInfo.manufacturer"> <th>{{"manufacturer" | i18n}}</th> <td>{{carInfo.manufacturer}}</td> </tr>  <tr ng-if="carInfo.model"> <th>{{"model" | i18n}}</th> <td>{{carInfo.model}}</td> </tr> <tr ng-if="carInfo.finish"> <th>{{"car_finish" | i18n}}</th> <td>{{carInfo.finish}}</td> </tr>  <tr ng-if="carInfo.modelYear"> <th>{{"model_year" | i18n}}</th> <td>{{carInfo.modelYear}}</td> </tr> <tr ng-if="carInfo.dateOnRoad"> <th>{{"date_on_road" | i18n}}</th> <td> <span dir=\'ltr\'> <span ng-if="carInfo.dateOnRoad.split(\'-\')[1]">{{carInfo.dateOnRoad.split(\'-\')[1]}} / </span> {{carInfo.dateOnRoad.split(\'-\')[0]}} </span> </td> </tr>  <tr ng-if="carInfo.carNumber"> <th>{{"car_number" | i18n}}</th> <td>{{carInfo.carNumber}}</td> </tr>  <tr ng-if="carInfo.vin"> <th>{{"car_vin" | i18n}}</th> <td>{{carInfo.vin}}</td> </tr>  <tr ng-if="carInfo.certificate"> <th>{{"car_certificate" | i18n}}</th> <td>{{carInfo.certificate}}</td> </tr>    <tr ng-if="carInfo.tariffPrice"> <th>{{"tariff_price" | i18n}}</th> <td>{{carInfo.tariffPrice | sumInCurrency:data.item.auction.catalogInfo.currency}}</td> </tr>   <tr ng-if="carInfo.mileage"> <th>{{"mileage" | i18n}}</th> <td>{{carInfo.mileage | readableNumber}} {{"unit_km" | i18n}}</td> </tr>  <tr ng-if="carInfo.carType"> <th>{{"car_type" | i18n}}</th> <td>{{carInfo.carType}}</td> </tr>  <tr ng-if="carInfo.gear"> <th>{{"gear" | i18n}}</th> <td>{{carInfo.gear}}</td> </tr> <tr ng-if="carInfo.color"> <th>{{"color" | i18n}}</th> <td>{{carInfo.color}}</td> </tr> <tr ng-if="carInfo.engine"> <th>{{"engine" | i18n}}</th> <td>{{carInfo.engine}}</td> </tr> <tr ng-if="carInfo.engineVolumeCc"> <th>{{"engine_volume" | i18n}}</th> <td>{{carInfo.engineVolumeCc  | valueWithUnits:"cc":data.item.house }}</td> </tr> <tr ng-if="carInfo.drive"> <th>{{"drive" | i18n}}</th> <td>{{carInfo.drive}}</td> </tr> <tr ng-if="carInfo.horsePower"> <th>{{"horse_power" | i18n}}</th> <td>{{carInfo.horsePower | valueWithUnits:"hp":data.item.house }}</td> </tr>   <tr ng-if="carInfo.vehicleClass"> <th>{{"vehicle_class" | i18n}}</th> <td>{{carInfo.vehicleClass}}</td> </tr>  <tr ng-if="carInfo.doors"> <th>{{"doors" | i18n}}</th> <td>{{carInfo.doors}}</td> </tr>  <tr ng-if="carInfo.country"> <th>{{"country" | i18n}}</th> <td>{{carInfo.country}}</td> </tr>  <tr ng-if="carInfo.wheel"> <th>{{"wheel" | i18n}}</th> <td>{{carInfo.wheel}}</td> </tr>  <tr ng-if="carInfo.customs"> <th>{{"customs" | i18n}}</th> <td>{{carInfo.customs}}</td> </tr>     <tr ng-if="carInfo.hand"> <th>{{"hand" | i18n}}</th> <td>{{carInfo.hand}}</td> </tr> <tr ng-if="carInfo.ownership"> <th>{{"current_ownership" | i18n}}</th> <td>{{carInfo.ownership}}</td> </tr> <tr ng-if="carInfo.previousOwnership"> <th>{{"previous_ownership" | i18n}}</th> <td>{{carInfo.previousOwnership}}</td> </tr>    <tr ng-if="carInfo.numberOfOwners"> <th>{{"number_of_owners" | i18n}}</th> <td>{{carInfo.numberOfOwners}}</td> </tr>  <tr ng-if="carInfo.ownershipYears"> <th>{{"ownership_years" | i18n}}</th> <td>{{carInfo.ownershipYears}}</td> </tr>   <tr ng-if="carInfo.hasKeys"> <th>{{"has_keys" | i18n}}</th> <td>{{carInfo.hasKeys}}</td> </tr>  <tr ng-if="carInfo.additions"> <th>{{"additions" | i18n}}</th> <td>{{carInfo.additions}}</td> </tr> <tr ng-if="carInfo.overview"> <th>{{"overview" | i18n}}</th> <td>{{carInfo.overview}}</td> </tr>  <tr ng-if="carInfo.location"> <th>{{"car_location" | i18n}}</th> <td>{{carInfo.location}}<div class="recommend-view-car">{{"recommend_view_car" | i18n}}</div></td> </tr>  <tr ng-if="data.carInfoNotes"> <th>{{"notes" | i18n}}</th> <td ng-bind-html="data.carInfoNotes | brLines"></td> </tr> </tbody> </table> <div ng-if="documents.length>0 && (data.item.auction.state!=\'ENDED\' || devMode)"> <div class="documents-title">{{"documents" | i18n}}:</div> <table> <tbody> <tr ng-repeat="doc in documents" ng-if="doc.link"> <th >{{doc.label}}</th>  <td><label class=\'btn btn-link\' ng-click="openWindow(doc.link | documentUrl)" >{{"download" | i18n}}</label></td> </tr> </tbody> </table> </div> '), 
        $templateCache.put("/portal/templates/catalogs/lotPage/common/navigation/lotPageNavLink.html?1.1944", '<div class="float">  <div ng-if="name==\'previous\'"> <div class="float arrow {{lang}}" ng-class="{\'point-left\':direction==\'ltr\', \'point-right\':direction==\'rtl\'}"></div> <div class="float text" ng-if="showText">&nbsp; {{"to_previous_lot" | i18n  }}</div> </div>  <div ng-if="name==\'next\'"> <div class="float text" ng-if="showText">{{"to_next_lot" | i18n  }}&nbsp;</div> <div class="float arrow {{lang}}" ng-class="{\'point-right\':direction==\'ltr\', \'point-left\':direction==\'rtl\'}"></div> </div>    </div>     '), 
        $templateCache.put("/portal/templates/catalogs/lotPage/common/navigation/lotPageNavigation.html?1.1944", '<div class="opposite float lot-page-navigation" ng-hide="lot.auction.singleItemIdInApp" bs-text-direction >  <div ng-switch="source">  <span ng-switch-when="catalog"> <a class="float btn " ng-href="{{catalogLink}}"> {{(lot.shop ? "shop_to_catalog" : "to_catalog") | i18n  }} </a> <a  ng-if="previousLot" class="float btn btn-link" ng-href="{{::previousLot | lotHref : \'catalog\'}}" > <div> <bs-lot-page-nav-link name="\'previous\'"> </bs-lot-page-nav-link> </div>  </a> <div ng-if="!previousLot" class="disabled btn float" > <bs-lot-page-nav-link name="\'previous\'"> </bs-lot-page-nav-link> </div>  <a ng-if="nextLot" class="float btn btn-link"  ng-href="{{::nextLot | lotHref : \'catalog\'}}" > <bs-lot-page-nav-link name="\'next\'"> </bs-lot-page-nav-link> </a>  <div ng-if="!nextLot" class="disabled btn float" > <bs-lot-page-nav-link name="\'next\'"> </bs-lot-page-nav-link> </div>  <div class="clearfix"></div> </span>  <span ng-switch-when="absenteeBids">  <div class="float btn btn-link" ng-click="backToList()"> {{"my_account_back_to_absentee" | i18n  }} </div>  <a class="float btn "   ng-href="{{catalogLink}}" ng-hide="lot.auction.hidden" > {{"catalog_nav_full_catalog" | i18n  }} </a>  </span>  <span ng-switch-when="purchases">  <div class="float btn btn-link" ng-click="backToList()"> {{"my_account_back_to_won" | i18n  }} </div>  <a class="float btn "   ng-href="{{catalogLink}}" ng-if="!lot.auction.hidden" > {{"catalog_nav_full_catalog" | i18n  }} </a>  </span>     <span ng-switch-when="search">  <a class="float btn btn-link" ng-click="backToList()"> {{"search_back_to" | i18n  }} </a> <a class="float btn btn-link"   ng-href="{{catalogLink}}"> {{"catalog_nav_full_catalog" | i18n  }} </a>  </span>  <span ng-switch-when="favorites">  <a class="float btn" ng-click="backToList()"> {{"favorites_back_to" | i18n  }} </a> <a class="float btn "   ng-href="{{catalogLink}}" ng-if="!lot.auction.hidden" > {{"catalog_nav_full_catalog" | i18n  }} </a>  </span>   </div> </div> '), 
        $templateCache.put("/portal/templates/catalogs/lotPage/common/navigation/lotTags.html?1.1944", '<div class="lot-tags" ng-show="tags.length"> <span class="label">{{"tags" | i18n}}:</span> <a ng-repeat="tag in tags" class="btn btn-default" ng-href="{{(\'searchWithTags/\'+tag) | uiHref}}"> {{"tag_"+tag | i18n}} </a>  </div>     '), 
        $templateCache.put("/portal/templates/catalogs/lotPage/common/lotNumber.html?1.1944", '<div > <div class="lot-index-in-auction" ng-if="data.item.auctionId && !data.item.auction.singleItemIdInApp" itemprop="sku" >  {{"lot" | i18n}} {{data.item.itemIndex}}: </div>  <div class="lot-number-in-shop" ng-if="data.item.shopId" itemprop="sku">  {{"lot_shop_number" | i18n:{number:data.item.ownerKey+"-"+data.item.idInApp} }} </div> </div>  '), 
        $templateCache.put("/portal/templates/catalogs/elements/lotImage.html?1.1944", '<div class="lot-image" ng-class="::{\'narrow-height\':narrowHeight}"> <div class="state-info"  bs-text-direction></div> <img ng-if="::!enableMagnifier && !asBg" ng-src="{{::loadedImageSrc}}" > <div ng-if="::enableMagnifier"> <div  ng-if="loadedImageSrc && !stateInfo"  data-ng-magnify magnify-ratio="2.5"  image-src="{{loadedImageSrc}}"  data-glass-width="250" data-glass-height="250" ></div> </div>   </div> '), 
        $templateCache.put("/portal/templates/catalogs/elements/lotExpiration.html?1.1944", '<div class="lot-expiration" ng-class="expirationState" > {{text}} </div> '), 
        $templateCache.put("/portal/templates/catalogs/elements/shop/confirmShopPurchase.html?1.1944", '<div class="confirm-shop-purchase" ng-controller="ConfirmShopPurchaseController"  ng-init="init()" > <div ng-if="!purchaseRejected">  <div ng-if="!purchaseAccepted"> <label>{{"confirm_purchase_message" | i18n}}:</label> <table class="default-align"> <tr> <td class="pic-columm" rowspan="{{viewPort.mobileMedia?1:3}}"> <bs-lot-image lot="lot" size="120x120" image-ind="0"  image-mode="\'fit\'"> </bs-lot-image> </td> <td class="caption"> {{"lot_number" | i18n}}: </td> <td class="value"> {{lot.ownerKey+"-"+lot.idInApp}} </td>  </tr>  <tr> <td class="caption"> {{"lot_description" | i18n}}: </td> <td class="value" ng-bind-html="lot | lotText:60" colspan="{{viewPort.mobileMedia?2:1}}"> </td> </tr> <tr> <td class="caption"> {{"price" | i18n}}: </td> <td class="price value"> {{lot.shopPrice | sumInCurrency:lot.shop.catalogInfo.currency}} </td> </tr>  </table>  <div class="clearFix"></div>  <div class="terms-message default-align"> <bs-linkable-text options="{ textKey:\'confirm_bid_terms_message\', textParams:{houseName:(lot.house.details.name | langField)}, onLinkClick:showTerms  }" > </bs-linkable-text>  </div> </div>   <div ng-if="purchaseAccepted">  <h4 ng-bind-html="\'shop_purchase_accepted\' | i18n:{houseName:(lot.house.details.name | langField)} "> </h4>  <bs-house-contact-info house="lot.house" hide-website="true"> </bs-house-contact-info> </div>  </div> <div ng-if="purchaseRejected"> <br> <div class="text-danger" ng-bind-html="\'shop_purchase_rejected\' | i18n:{houseName:(lot.house.details.name | langField)} ">  </div> <br><br>  <bs-house-contact-info house="lot.house" hide-website="true"> </bs-house-contact-info> </div>  </div>   '), 
        $templateCache.put("/portal/templates/catalogs/elements/shop/shopPurchaseForm.html?1.1944", '  <div class="shop-purchase-form" bs-text-direction > <div ng-if="scrollToForm" bs-scroll-on="scrollToForm" offset="-200" class="scroll-anchor">&nbsp;</div>   <div class="sold-info" ng-if="lot.purchase" ng-class="{\'self-sold\':selfSold}" >  <div class="highlight-area"> <span class=\'bid-label\'>{{soldLabel | i18n}}:&nbsp;{{lot.purchase.actionPrice | sumInCurrency:lot.catalogInfo.currency}}</span> </div> </div>   <div ng-if="lot.published"> <div ng-if="!lot.purchase" class="form"> <div class="float price"> <div class="float lot-price-label">{{"price" | i18n}}:&nbsp;&nbsp;</div> <div class="float lot-price-value">{{lot.shopPrice | sumInCurrency:lot.shop.catalogInfo.currency}}&nbsp;&nbsp;&nbsp;</div> <div class="clearfix"></div> </div>  <bs-async-button button-class="\'float orange common-button buy-now \'+currentLang" action-fn="showPurchaseConfirmation()" bs-current-lang label="\'catalog_buy_now\'" ></bs-async-button>  <div class="clearfix"></div>  <div class="commission-text" ng-bind-html="\'lot_commission_included\' | i18n"> </div> </div>   <div class="not-published" ng-if="!lot.published"> {{\'lot_unpublished_from_shop\' | i18n }}  </div>   </div>  <div class="sold-lot-message" ng-if="lot.soldPrice"> <bs-linkable-text options="{ textKey:\'lot_sold_in_shop_info\', textParams:{house:(lot.shop.house.details.name | langField), date:(lot.purchaseTime | date:\'dd/MM/yyyy\')}, onLinkClick:gotoHousePage  }" > </bs-linkable-text> </div>    </div>  '), 
        $templateCache.put("/portal/templates/catalogs/elements/shop/shopInfo.html?1.1944", '<div class="shop-info center-block" > <div class="float shop-texts"> <h3 class="shop-name" id="shopInfo" ng-click="onNameClick()">  <span> {{"shop_info_title" | i18n:{houseName:(shop.house.details.name | langField)} }} </span> </h3>  <div class="location">  <span ng-if="::shop.house.details.address | langField"> {{::shop.house.details.address | langField}} </span>  </div>   </div> <div class="opposite float logo" ui-sref="app.house({houseCode:shop.house.code,showUpcomingAuctions:false})" bs-cloudinary-bg="{{::(shop.house.resources[\'mainPageLogo\'])}}" params="{size:\'188x74\'}"></div> <div class="clearfix"></div>  <div ng-if="!minimalView">  <div class="shop-description" ng-if="::shop.description | langField"  ng-bind-html="shop.description | langField"> </div> </div>  <span ng-if="shop.house.hasTerms"> <span class="terms btn-link" ng-click="showHouseTerms()">{{"terms_of_sale" | i18n}}</span>  </span> <span class="btn-link" ng-click="showHouseContantInfo()">{{"contact_us" | i18n}}</span>    </div>  '), 
        $templateCache.put("/portal/templates/catalogs/elements/auction/leadingBid.html?1.1944", '<div class="leading-bid" ng-hide="leadingBidHidden"> <div class="message"></div> <div class="highlighted-area"> <div class="lead-type"></div> <div class="price"></div> <a class="lot-link"  ng-href="{{::lot | lotHref : (source || \'catalog\')}}"  > {{::"view_lot" | i18n }} </a> </div>  </div> '), 
        $templateCache.put("/portal/templates/catalogs/elements/auction/commissionInfo.html?1.1944", '<div ng-if="lot.carInfo"> <div class="lot-price-row lot-vat-info" ng-if="lot.carInfo.priceDoesNotIncludeVat" > {{"car_price_without_vat" | i18n }} </div> <div class="lot-price-row comission" ng-if="!lot.auction.commissionFee && lot.auction.state!=\'ENDED\'"> {{"car_info_no_commission" | i18n }} </div> </div>   <div ng-if="lot.realEstateInfo"> <div class="lot-price-row comission" ng-if="!lot.auction.commissionFee && lot.auction.state!=\'ENDED\'"> {{"car_info_no_commission" | i18n }} </div> </div>   <div ng-if="!lot.carInfo && !lot.realEstateInfo"> <div class="lot-price-row comission" ng-if="lot.auction.commissionFee || lot.auction.commissionFee===0"> {{"auction_house_commission" | i18n}}: <span dir="ltr" >{{lot.auction.commissionFee}}%</span> <span class="btn btn-link" ng-click="showCommissionText()"  ng-if="lot.auction.commissionText | langField:{currentLangOnly:true} | stripTags"> {{"more_details" | i18n}}</span> </div>   <div class="lot-price-row lot-vat-info" ng-if="lot.auction.region!=\'RU\' && !lot.house.noVat">  <span ng-if="lot.auction.itemsPriceIncludesVat"> {{"bid_form_vat_included" | i18n}} </span> <span ng-if="!lot.auction.itemsPriceIncludesVat"> {{"vat" | i18n}}: <span ng-if="lot.fullPriceVat">{{"bid_form_full_vat" | i18n}} </span> <span ng-if="!lot.fullPriceVat">{{"bid_form_commission_vat" | i18n}} </span> </span> </div> </div> '), 
        $templateCache.put("/portal/templates/catalogs/elements/auction/lotViewOnlyInfo.html?1.1944", '<div ng-show="visible" class="lot-view-only"  ng-bind-html="message">   </div>  '), 
        $templateCache.put("/portal/templates/catalogs/elements/auction/confirmBid.html?1.1944", '<div class="confirm-bid" ng-controller="ConfirmBidController"  ng-init="init()" ng-class="{\'with-terms\':displayTerms}"> <div ng-if="!showBidRequestInfo"> <label ng-if="postSaleMode">{{"confirm_purchase_message" | i18n}}:</label> <table class="default-align"> <tr> <td class="pic-columm" rowspan="{{viewPort.mobileMedia?1:3}}"> <bs-lot-image lot="lot" size="120x120" image-ind="0"  image-mode="\'fit\'"> </bs-lot-image> </td> <td class="itemIndex caption"> {{"lot_number" | i18n}}: </td> <td class="itemIndex value"> {{lot.itemIndex}} </td>  </tr>  <tr> <td class="caption"> {{"lot_description" | i18n}}: </td> <td class="value" ng-bind-html="lot | lotText:60" colspan="{{viewPort.mobileMedia?2:1}}"> </td> </tr> <tr> <td class="caption"> {{postSaleMode ? "price" : "bid_price" | i18n}}: </td> <td class="value" colspan=2> <div class="price value"> {{bidPrice | sumInCurrency:lot.auction.catalogInfo.currency}} </div>  <div  ng-include src="\'catalogs/elements/auction/commissionInfo\' | appTemplate" > </div>    </td> </tr>  <tr class="send-alert" ng-show="alertEnabled"> <td ng-if="!viewPort.mobileMedia">&nbsp;</td> <td ng-if="!viewPort.mobileMedia && displayTerms" >&nbsp;</td> <td colspan="{{viewPort.mobileMedia ? 3 : 2}}" > <table> <tr> <td> <input  type="checkbox" class="float" name="sendAlert" ng-model="sendAlert" /> <bs-checkbox class="float"  bs-model="itemAlertData.on"></bs-checkbox> </td> <td valign="middle">  {{"confirm_bid_send_alert" | i18n}} </td>  </table>  </td> </tr> </table>  <div class="clearFix"></div>  <div ng-if="displayTerms"> <br> <label >{{ termsTitle }}:</label>  <div class="terms-container default-align" ng-bind-html="termsHtml">  </div> </div>  <div class="terms-message default-align" ng-class="{\'hide-links\':showTermsInContainer}"> <bs-linkable-text options="{ textKey:\'confirm_bid_terms_message\', textParams:{houseName:(lot.house | houseName:\'full\')}, onLinkClick:showTerms  }" > </bs-linkable-text> </div>  <div ng-if="lot.auction.showLeadingBids" class="leading-bid-warning" ng-bind-html="\'confirm_bid_leading_bid_warning\' | i18n"></div> </div>  <div ng-if="showBidRequestInfo"> <bs-bid-request-info lot="lot" ></bs-bid-request-info> </div>   </div>   '), 
        $templateCache.put("/portal/templates/catalogs/elements/auction/auctionParticipationInfo.html?1.1944", '<div class="auction-participation-info" ng-show="loaded" > <div bs-scroll-on="scrollToParticipationInfo" offset="-200"></div> <div ng-if="!approvedToParticipate && lot"> <div ng-if="!auctionParticipationRequested"> <div class="button-container"> <div class = "common-button light-blue" ng-click="requestParticipation()"> <div class="text">{{"click_to_get_approved" | i18n}}</div> </div> </div> </div> <div ng-if="auctionParticipationRequested"> <label class="text-danger"> {{"promotion_pending_cars" | i18n:{houseName:(auction.house | houseName:\'full\')} }}. <span ng-if=\'auction.documents.registration\'>{{"auction_participation_actions_needed" | i18n}}</span> </label> <div class="button-container"> <div class = "common-button orange" ng-click="showParticipationInstructions()"> <div class="text">{{"click_for_details" | i18n}}</div> </div> </div> </div> </div>  <div ng-if="approvedToParticipate" class="approved-message"> {{"promotion_approved_for_auction" | i18n}} </div>  </div> '), 
        $templateCache.put("/portal/templates/catalogs/elements/auction/lotViewOnlyOverlay.html?1.1944", '<div> <div class="upper-text"> {{"bidding_only_from_hall" | i18n }} </div>   <div class="lower-text"> {{("lot_view_only_location_"+lot.house.code.split("-")[0]) | i18n }} </div>  </div>  '), 
        $templateCache.put("/portal/templates/catalogs/elements/auction/participationInstructions.html?1.1944", '<div ng-controller="ParticipationInstructionsController" class="participation-instructions default-align" ng-init="init()">  <div class="status" ng-if="lot.bidRequest"> {{"bid_request_pending_status" | i18n}} <br><br> </div>  <div ng-if="documentPath"> <p>{{\'bid_request_needed_actions\' | i18n:{houseName:houseName} }}:</p> <p> <ol> <li>{{"bid_request_form_download" | i18n}}</li> <li ng-bind-html="\'bid_request_form_send\' | i18n:{faxNumber:fax, houseEmail:houseEmail}"</li>  <li ng-if="houseDetails.bidInstructions | langField | stripTags"> {{"bid_request_additional_instructions" | i18n}} - <div ng-bind-html="houseDetails.bidInstructions | langField"></div> </li> </ol> </p> </div>  <div ng-if="(houseDetails.bidInstructions  | langField | stripTags) && !documentPath" ng-bind-html="houseDetails.bidInstructions | langField"> </div>  <div ng-if="contactPerson"> <br> <p ng-bind-html="\'contact_house_support\' | i18n:{housePhone:housePhone,houseName:houseName,contactPerson:contactPerson}">  </div>   <div class="download" ng-if="documentPath"> <div class="orange common-button" ng-click="downloadDocument()"> <div class="text"> {{"download_registration_form" | i18n}} </div> </div>  </div> </div> '), 
        $templateCache.put("/portal/templates/catalogs/elements/auction/confirmTerms.html?1.1944", '<div class="confirm-terms" ng-controller="ConfirmTermsController"  ng-init="init()" ng-class="{\'with-terms\':displayTerms}">   <div class="terms-container default-align" ng-bind-html="termsHtml">  </div>   </div>   '), 
        $templateCache.put("/portal/templates/catalogs/elements/auction/setAuctionCreditCard.html?1.1944", '<div class="set-auction-credit-card" ng-controller="SetAuctionCreditCardController"  ng-init="init()" bs-text-direction> <div class="default-align">  <div ng-show="!formData.houseTermsConfirmed" > <div ng-if="!(house.details.bidInstructions | langField | stripTags)" class="sentence"  ng-bind-html="\'participation_request_credit_card_terms\' | i18n:{house:houseName} " > {{"participation_request_credit_card_terms" | i18n :{house:houseName} }} </div> <div class="sentence" ng-if="house.details.bidInstructions | langField | stripTags"> <div ng-bind-html="house.details.bidInstructions | langField"></div> </div> </div>  <div class="terms-row"> <input  class="float" type="checkbox"  ng-model="formData.houseTermsConfirmed"> <bs-checkbox class="float"  bs-model="formData.houseTermsConfirmed"></bs-checkbox> <bs-linkable-text class="float" options="{ textKey:\'house_terms_agree\', textParams:{house:houseName}, onLinkClick:showHouseTerms }" > </bs-linkable-text>  <div class="clearfix"></div> </div>  <div ng-if="showCardSelection"> <form ng-if="creditCardsInfo.length>0"> <div class="sentence"> {{"selectc_credit_card" | i18n }} </div> <div class="radio" ng-repeat="cardInfo in creditCardsInfo" > <label> <input type="radio" name="selectedCard" ng-model="formData.selectedCard" value="{{cardInfo.id}}"> {{"card_selection_entry" | i18n:{lastDigits:cardInfo.lastCardDigits, cardName:(("credit_card_type_"+cardInfo.cardCompany.toLowerCase()) | i18n)} }} </label> </div> <div class="radio"  > <label> <input type="radio" name="selectedCard" ng-model="formData.selectedCard" value="another"> {{"card_selection_other" | i18n:{} }} </label> </div> </form> <bs-edit-credit-card-details auction-id="auction.id" ng-if="showCardForm"> </bs-edit-credit-card-details> </div> </div>    </div>   '), 
        $templateCache.put("/portal/templates/catalogs/elements/auction/registrationPromotion.html?1.1944", '<div class="registration-promotion"> <div ng-if="auction "> <div ng-if="auction.state==\'ENDED\' && !postSaleMode"> <span class="text" > {{\'auction_ended\' | i18n}}</span> </div> <div ng-if="auction.state!=\'ENDED\' || postSaleMode"> <div ng-if="auction.catalogOnly">  <span class="text" > {{\'promotion_catalog_only\' | i18n:houseParams}}</span> </div> <div ng-if="!auction.catalogOnly">  <div ng-if="auction.state==\'RUNNING\'" > <div class="float button" ng-click="openAuctionSite()"> <div class="text">{{text(\'promotion_live_auction\')}}</div> </div> <div class="clearfix"></div>  </div>  <div ng-if="auction.state==\'READY\' || postSaleMode"> <div ng-if="userState==\'NOT_LOGGED_IN\'"> {{text(\'promotion_not_logged_in_auction\')}}&nbsp;-&nbsp; <span class="no-break"> <span><span class="button" ng-click="setAuthScene(\'login\')"> <span class="text">{{\'login\' | i18n}}</span></span>  <span class="">&nbsp;/&nbsp;</span>  <span class="button" ng-click="setAuthScene(\'register\')"> <span class="text"> {{\'registeration\' | i18n}}</span></span> <span class="clearfix"></span> </span>  </div> <div ng-if="userState!=\'NOT_LOGGED_IN\'">  <div ng-if="auction.house.auctionBasedUserApproval">  <span ng-if="approvedToParticipateInAuction" class="text">  {{\'promotion_approved_for_auction\' | i18n}} </span>  <div ng-if="!approvedToParticipateInAuction "> <div ng-if="auction.house.bidRequestPerItem"> <div ng-if="lot.selfAbsenteeBid"> <span class="text" > {{text(\'promotion_approved\')}}</span> </div>  <div ng-if="!lot.selfAbsenteeBid"> <span class="text" >  <span ng-if="bidRequests.length>0"> {{\'bid_request_pending_status\' | i18n}} </span> <span ng-if="!bidRequests || bidRequests.length==0"> {{\'bid_form_place_bid_to_participate\' | i18n}} <span class="btn btn-link show-popup" ng-click="showHelpPopup(\'auction_explanation\')">{{"auction_explanation" | i18n}}</span> </span> </span> </div> </div>  <bs-auction-participation-info ng-if="!auction.house.bidRequestPerItem" auction="auction" ></bs-auction-participation-info>  </div> </div>  <div ng-if="!auction.house.auctionBasedUserApproval"> <div ng-if="userState==\'NOT_REGISTERED\' || userState==\'NEW_SHOP_USER\'" > <span class="float text"> {{text(\'promotion_not_registered_to_auction\')}}&nbsp-&nbsp;</span> <div class="float button" ng-class="{\'disabled waiting\':requestInProgress}" ng-click="requestApproval()"> <div class="text">  {{\'click_to_get_approval\' | i18n}} </div>  </div> <span class="clearfix"></span> </div> <div ng-if="userState==\'PENDING\'"> <span class="text">  {{\'promotion_pending\' | i18n}}</span> </div>  <div ng-if="userState==\'INCOMPLETE_PROFILE\'"> <span class="text">  {{\'promotion_pending\' | i18n}}</span> </div>  <div ng-if="userState==\'APPROVED\'"> <span class="text" > {{text(\'promotion_approved\')}}</span> </div> </div> </div> </div> </div> </div> </div>  <div ng-if="!auction && house">  <div ng-switch="userState"> <div ng-switch-when="NOT_LOGGED_IN"> {{\'promotion_not_logged_in_house\' | i18n:{house:(house.details.name | langField)} }}&nbsp-&nbsp; <span class="no-break"> <span><span class="button" ng-click="setAuthScene(\'login\')"> <span class="text">{{\'login\' | i18n}}</span></span>  <span class="">&nbsp;/&nbsp;</span>  <span class="button" ng-click="setAuthScene(\'register\')"> <span class="text"> {{\'registeration\' | i18n}}</span></span> <span class="clearfix"></span> </span> </div> <div ng-switch-when="NOT_REGISTERED"> <span class="float text"> {{\'promotion_not_registered_to_house\' | i18n }}&nbsp-&nbsp;</span> <div class="float button" ng-class="{\'disabled waiting\':requestInProgress}" ng-click="requestApproval()"> <div class="text">  {{\'click_to_get_approval\' | i18n}} </div>  </div> <span class="clearfix"></span> </div> <div ng-switch-when="PENDING"> <span class="text">  {{\'promotion_pending\' | i18n}}</span> </div>  <div ng-switch-when="INCOMPLETE_PROFILE"> <span class="text">  {{\'promotion_pending\' | i18n}}</span> </div>  <div ng-switch-when="APPROVED"> <span class="text" > {{text(\'promotion_approved\')}}</span> </div> </div> </div> </div>    '), 
        $templateCache.put("/portal/templates/catalogs/elements/auction/auctionInfo.html?1.1944", '<div class="auction-info center-block" > <div class="float auction-texts"> <h3 class="auction-name" id="auctionInfo" ui-sref="app.auctionCatalog({catalogKey:auction.intKey})">  <span ng-if="::auction.number"> {{::"auction_label_number_public" | i18n:{number:auction.number} }} <span ng-if="auction.part"> {{::("auction_part_"+auction.part) | i18n}}  </span> </span>  <span> {{::auction.name | langField}} </span> </h3> <h2 class="house-name"> <a ng-href="{{::(\'/houses/\'+auction.house.code+\',false\') | uiHref}}" class="btn-link" ng-if="::auction.house.orderInd">{{"catalog_house_name" | i18n:{name:(auction.house.details.name | langField)} }}</a> <span ng-if="::!auction.house.orderInd">{{:: "catalog_house_name" | i18n:{name:(auction.house.details.name | langField)} }}</span>  </h2>   <div class="time-and-location"> <span>{{::auction | auctionTime}}</span> <span ng-if="::auction.address | langField"> , {{::auction.address | langField}} </span>  </div> <div class="links"> <span ng-if="auction.house.hasTerms"> <span class="terms btn-link" ng-click="showHouseTerms()">{{"terms_of_sale" | i18n}}</span>  &nbsp;&nbsp;&nbsp;&nbsp; </span>  <span ng-repeat="(docKey, docLink)  in auction.documents" ng-if="docLink"> <a class="doc btn-link"  ng-click="openWindow(docLink | documentUrl)" >{{"auction_doc_"+docKey | i18n}}</a>  &nbsp;&nbsp;&nbsp;&nbsp; </span>   <span ng-if="shouldShowDisplayHours"> <span class="display-hours btn-link" ng-click="showDisplayHours()">{{::displayHoursKey | i18n}}</span> &nbsp;&nbsp;&nbsp;&nbsp; </span>   <span ng-if="shouldShowCollectionHours"> <span class="display-hours btn-link" ng-click="showCollectionHours()">{{::"catalog_collection_hours" | i18n}}</span> &nbsp;&nbsp;&nbsp;&nbsp; </span>  <span ng-if="shouldShowDemoLink"> <span class="demo btn-link" ng-click="openDemoWindow()">{{::"view_demo" | i18n}}</span> &nbsp;&nbsp;&nbsp;&nbsp; </span>  </div>  </div> <div class="opposite float logo" ui-sref="app.house({houseCode:auction.house.code,showUpcomingAuctions:false})" bs-cloudinary-bg="{{::(auction.house.resources[\'mainPageLogo\'])}}" params="{size:\'188x74\'}"></div> <div class="clearfix"></div>  <div class="long-details" ng-if="details" style="color:{{auction.textColors.details}}" ng-bind-html="\'<BR>\'+details"> </div>  <bs-lot-view-only ng-if="lot.viewOnly" lot="lot" full-message="true" one-line="true" > </bs-lot-view-only>   <div ng-if="!auction.showLeadingBids && auction.state!=\'ENDED\' && auction.catalogContentType==\'ART\'"> <br> <bs-linkable-text  options="{ textKey:\'auction_hidden_leading_bids_message\', onLinkClick:gotoAbsenteeBidsFaq }" > </bs-linkable-text> </div>    <bs-house-regisration-promotion ng-if="shouldShowRegistrationPromotion" auction="::auction" lot="lot" > </bs-house-regisration-promotion>   <hr>  <bs-auction-structured-data auction="::auction"></bs-auction-structured-data>   </div>  '), 
        $templateCache.put("/portal/templates/catalogs/elements/auction/bidForm.html?1.1944", '  <div class="bid-form" bs-text-direction > <div ng-if="scrollToForm" bs-scroll-on="scrollToForm" offset="-200" class="scroll-anchor">&nbsp;</div>  <div class="bid-info" ng-if="bidLabel" ng-class="bidInfoClass" >  <div class="highlight-area"> <span class=\'bid-label\'>{{bidLabel.text}}<span ng-if="bidLabel.price" ng-class="{dev:bidLabel.priceVisibleToAdmin}">:&nbsp;{{bidLabel.price}}</span></span> <div class="bid-label-second-message"  ng-show="leadingBidMessage" >{{leadingBidMessage}}</div> <div class="bid-label-second-message" ng-if="absenteeBidLabelForPastLot && !leadingBidMessage "  > {{absenteeBidLabelForPastLot}}  </div> </div> </div>  <table> <tr ng-if="mode==\'existing\' && !lot.house.auctionBasedUserApproval" > <td></td> <td class=\'bid-label-space\'></td> <td> <div class="links"> <div class="float btn-link"  ng-click="setEditMode({focus:true})">{{"edit" | i18n}}</div> <div class="float bid-link-space"></div> <bs-async-button button-class="\'left btn-link\'" action-fn="removeBidIfConfirmed()" label="\'remove_bid\'" ></bs-async-button> <div class="clearfix"></div> </div> </td> </tr> </table>  <label class="time-left-label" ng-show="timeLeft">{{timeLeft}}</label>  <bs-auction-participation-info auction="lot.auction" lot="lot" ng-if="mode==\'auctionParticipation\' || mode==\'bidRequest\'"></bs-auction-participation-info>  <bs-lot-view-only ng-if="mode==\'viewOnly\'" lot="lot" full-message="true" > </bs-lot-view-only>   <div class="edit-mode" ng-if="mode==\'edit\' || mode==\'new\' "> <div ng-if="!bidsDiabledOnHolyDay"> <label> {{editLabel | i18n }}:</label> <form> <div class="float noselect" ng-if="allowedBidPrices" ng-include src="\'catalogs/elements/bidPriceDropDown\' | appTemplate" > </div>   <bs-async-button button-class="\'float orange common-button \'+currentLang" action-fn="tryToPlaceBid()" bs-current-lang label="\'absentee_bid_button_text\'" ></bs-async-button>  <div class="clearfix"></div> <div ng-if="mode==\'edit\' && !lot.auction.showLeadingBids" class="cancel btn btn-link lowercase" ng-click="cancelEdit()">{{"cancel" | i18n}}</div> <div class="bid-limit" ng-if="bidLimitMessage"> {{bidLimitMessage}}</div>  </form> <div class="clearfix"></div> </div> <label class="bids-disabled-on-holyday" ng-if="bidsDiabledOnHolyDay"> {{"bids_disabled_for_holy_day" | i18n:(lot.house | houseName:\'short\')}} </label> </div>    <div class="direct-bid" ng-if="mode==\'direct\'  && model.selectedBidPrice"> <label> {{"lot_post_sale_bid" | i18n }}:</label> <form>  <div class="float direct-price"> <div class="float lot-price-label">{{"price" | i18n}}:&nbsp;&nbsp;</div> <div class="float lot-price-value">{{model.selectedBidPrice | sumInCurrency:lot.auction.catalogInfo.currency}}&nbsp;&nbsp;&nbsp;</div> <div class="clearfix"></div> </div>  <bs-async-button button-class="\'float orange common-button buy-now \'+currentLang" action-fn="tryToPlaceBid()" bs-current-lang label="\'catalog_buy_now\'" ></bs-async-button>  <div class="clearfix"></div>  <div class="bid-limit" ng-if="bidLimitMessage"> {{bidLimitMessage}}</div>  </form> <div class="clearfix"></div> </div>   <div class="bid-info disabled-mode" ng-if="mode==\'disabled\'"> <label ng-bind-html="getDisabledMessage()"></label> </div>  <div class="bid-info ended-mode" ng-if="mode==\'ended\'"> <label ng-if="!lot.purchase"> {{"not_sold" | i18n }} </label> </div>  <div class="bid-info running-mode" ng-if="mode==\'running\'"> <label>{{"auction_running" | i18n }}</label> <div class="center-block common-button live darkBlue" ng-click="openAuctionSite()"> <div class="text"> {{"home_auction_enter" | i18n }} </div> </div> </div>  <bs-lot-price  lot="lot"  single-row="{{false}}"  break-on-row="{{true}}"  only-estimated="{{mode==\'direct\'}}">  </bs-lot-price>  <div  ng-include src="\'catalogs/elements/auction/commissionInfo\' | appTemplate" > </div>  <div class="leading-bid-info" ng-if="leadingBidLine" ng-class="leadingBidType"> <div class="leading-bid-line">{{leadingBidLine}}</div> <div class="high-bidder-message">{{leadingBidMessage}}</div> </div>   <div class="past-lot" ng-if="lot.auction.state==\'ENDED\' && lot.house.orderInd"> <bs-linkable-text options="{ textKey:\'lot_past_info\', textParams:{house:(lot.house | houseName), date:(lot.auction.date | date:\'dd/MM/yyyy\')}, onLinkClick:gotoHousePage  }" > </bs-linkable-text> </div> </div>  '), 
        $templateCache.put("/portal/templates/catalogs/elements/lotPrice.html?1.1944", '<div class="lot-price" itemprop="offers" itemscope itemtype="http://schema.org/Offer">  <div class="lot-price-row" ng-if="::showExactPrice"> <div class="lot-price-label exact-price">{{::exactPriceLabel | i18n}}:</div> <div class="lot-price-value" bs-auto-font-size="{grow:false,minSize:11,maxWidth:maxWidth}" ng-bind-html="::exactPrice"></div> <div class="clearfix" ng-if="::breakOnRow"></div>  </div>  <div class="lot-price-row" ng-if="::showNoPrice"> <div class="lot-price-label no-price" itemprop="price">{{"lot_no_price" | i18n}}</div> <div class="clearfix" ng-if="::breakOnRow"></div>  </div> <div class="lot-price-row" ng-if="::showEstimatedPrice"> <div class="lot-price-label estimated-price"  >{{"estimated_price" | i18n}}:</div> <div class="lot-price-value" dir="ltr" bs-auto-font-size="{grow:false,minSize:11,maxWidth:maxWidth}" max-width="maxWidth" ><div ng-bind-html="::estimatedPrice"></div></div> <div class="clearfix" ng-if="::breakOnRow"></div> </div>    </div> '), 
        $templateCache.put("/portal/templates/catalogs/elements/lotBadge.html?1.1944", '<div class="lot-badge"  > <div class="text" ></div> </div> '), 
        $templateCache.put("/portal/templates/catalogs/elements/lotFavoriteFlag.html?1.1944", '<div  class="favorite-flag flag-button"   ng-click="toggleFavorite()"   ng-mouseout="onMouseOut()" ng-mouseover="onMouseOver()" >  </div> '), 
        $templateCache.put("/portal/templates/catalogs/elements/bidPriceDropDown.html?1.1944", '<div class="bid-prices-dropdown" > <select ng-model="model.selectedBidPrice"  bs-text-direction  ng-options="price | sumInCurrency:lot.auction.catalogInfo.currency for price in allowedBidPrices"> </select>  </div> '), 
        $templateCache.put("/portal/templates/catalogs/elements/shareButtons.html?1.1944", '  <div class="share-buttons" > <div ng-repeat="button in [\'fb\',\'twitter\',\'google\',\'pinterest\',\'email\']" class="float button" ng-class="button"  ng-click="share(button)" title="{{buttonName(button)}}"></div> <div class="clearfix"></div> </div>  '), 
        $templateCache.put("/portal/templates/components/carousel/housesCarousel.html?1.1944", '<div class="houses-carousel-container" ng-class="{mobile:isMobile}"> <div  ng-if="!animationOn" class="houses-carousel" ng-style="{backgroundImage:\'url(\'+bgPics[currentPicInd]+\')\'}" >  </div>  <div ng-if="animationOn" class="houses-carousel"> <div ng-include dir="{{dir}}" src="\'components/carousel/slider\' | appTemplate"></div>  </div> </div>  '), 
        $templateCache.put("/portal/templates/components/carousel/slider.html?1.1944", '<wallop-slider data-images="bgPics" data-animation="scale" data-current-item-index="_ind" data-next-item-index="currentPicInd"> </wallop-slider> '), 
        $templateCache.put("/portal/templates/components/contentLoader.html?1.1944", '<div class="content-loader" ng-show="!loaded"> <img  class="center-block" ng-src="{{\'system/pagePreLoader.gif\' | commonImage}}"> </div> '), 
        $templateCache.put("/portal/templates/components/popups/popupAsScene.html?1.1944", '<div class="info-popup scene popup-scene-{{options.code}}" dir="{{dir}}" ng-controller="PopupAsSceneController" bs-scroll-to-top>  <div class="content container col-lg-6 col-md-6 col-sm-10 col-xs-12"> <button class="upper btn btn-primary" ng-if="options.backText" bs-back-button >{{options.backText | i18n}}</button>  <div class="clearfix"></div> <div ng-if="options.title" class="title center-block container col-lg-7 col-md-7 col-sm-8 col-xs-11" > <H3>{{options.title}}</H3> <div class="short-separator"></div> </div> <div ng-include src="\'components/popups/popupBody\' | appTemplate" ></div>   <ul class="list-inline"> <li  ng-repeat="button in options.buttons"> <button ng-if="button.isCloseButton" class="btn btn-{{button.type||\'primary\'}}" bs-back-button  >{{(button.text) | i18n}} </button> <button ng-if="button.action" ng-disabled = "button.disabled" ng-show="!button.hidden" class="btn btn-{{button.type||\'primary\'}}"  ng-click="button.action()">{{(button.text) | i18n}} </button>  </li>  </ul>  </div> </div> '), 
        $templateCache.put("/portal/templates/components/popups/popupBody.html?1.1944", '<div dir="{{dir}}"> <iframe ng-if="options.contentUrl" width="100%" height="500px" name="about" ng-src="{{options.contentUrl}}" frameborder=0 ALLOWTRANSPARENCY="true"></iframe> <div    ng-if=\'options.contentHtml\'    class="info-popup-content" ng-class="options.bodyClass" ng-bind-html="options.contentHtml"></div> <div    ng-if=\'options.contentInclude\' class="info-popup-content" ng-class="options.bodyClass"  ng-include src="options.contentInclude | appTemplate"></div>  </div> '), 
        $templateCache.put("/portal/templates/components/popups/popupModal.html?1.1944", '<div dir="{{dir}}" ng-keyup="onKeyup()" class="popup-modal-{{options.code}}">  <div  class="modal-header"> <h4  class="float modal-title" ng-if="options.titleKey">{{options.titleKey | i18n}}</h4>  <h4  class="float modal-title" ng-if="!options.titleKey">{{options.title}}</h4> <button type="button" class="opposite float close" ng-if="!options.unclosable" ng-click="closePopup()">&times;</button> <div class="clearfix"></div>  </div>  <div class="modal-body"> <div ng-include src="\'components/popups/popupBody\' | appTemplate" ></div> </div>  <div class="modal-footer" ng-class="options.data.footerClass"> <ul class="list-inline"> <li  ng-repeat="button in options.buttons">  <button ng-if="button.isCloseButton" class="btn btn-{{button.type||\'primary\'}}"  ng-click="closePopup()">{{(button.text) | i18n}} </button> <button ng-if="button.action" ng-disabled = "button.disabled" ng-show="!button.hidden" class="btn btn-{{button.type||\'primary\'}}"  ng-click="button.action()">{{(button.text) | i18n}} </button>  </li>  </ul>   </div> </div> '), 
        $templateCache.put("/portal/templates/components/upperSpaceHolders.html?1.1944", '<div> <div class="upper-navigation-space"></div> <div class="upper-scene-part-space"></div> </div>  '), 
        $templateCache.put("/portal/templates/components/housesDropdown.html?1.1944", '<div class="houses-dropdown">  <select	ng-model="data.selectedHouseCode" ng-change="onDropDownChange()" bs-text-direction> <option value="all" ng-if="!disableAllHouses">{{allHousesLabel | i18n }}</option> <option ng-repeat="house in houses" value="{{house.code}}"  ng-selected="house.code == selectedHouseCode"> {{house | houseName : \'short\' | trim:maxLength  }} </option> </select>  </div> '), 
        $templateCache.put("/portal/templates/components/navigation/upperNavigationSearch.html?1.1944", ' <form name=\'searchForm\' novalidate bs-enter-key-action="doSearch()"  ng-click="gotoSearchIfMobile()" class="global-search-form"  ng-class="currentLang" bs-text-direction ng-show="state.current.url!=\'search\'"> <bs-form-group field-name="phrase" label="catalog_search_all" > <bs-search-input></bs-search-input>  </bs-form-group> <div class="button noselect" ng-click="doSearch()"> </div> <div class="clearfix"></div> </form>     '), 
        $templateCache.put("/portal/templates/components/navigation/mobileLangSelection.html?1.1944", '<div class="lang-selection"  ng-if="data.langs.length>1"> <div class="selected entry" slide-toggle="#{{langMenuName}}" ng-click="onLanguageClick()" > {{currentLang | langName:"english"}} <span class="caret {{dir}}" ></span> </div> <ul id="{{langMenuName}}" class="slideable" duration="0.25s"> <li class="sub needsclick entry" ng-repeat="lang in data.langs" ng-if="lang!=currentLang" ng-click="setLanguage(lang)">{{lang | langName}}</li> </ul> </div> '), 
        $templateCache.put("/portal/templates/components/navigation/upperNavigation.html?1.1944", '<div class="upper-navigation"  ng-class="{ \'has-warning\':ie8WarningVisible, \'logged-in\':currentUser!=null, \'no-fixed\':mobileMenuOn, \'mobile\':isMobileApp || viewPort.clientWidth<1200, \'pc\':!isMobileApp &&  viewPort.clientWidth>=1200 }"  ng-controller="UpperNavigationController"  dir="{{dir}}" >   <div class="mobile-only" ng-if="data.showContainer"> <div ng-if="!data.hideMenus" class="icon-button {{button}}" ng-repeat="button in data.mobileButtons"  ng-click="handleMobileButtonClick(button)"  bs-touched-class="\'touched\'"></div> <div ng-include src="\'components/navigation/mobileMenu\' | appTemplate"></div> <div class="clearfix"></div> <div ng-if="data.hideMenus"  class="logo"></div> </div> <div ng-if="langMenuAtBottom" ng-include src="\'components/navigation/mobileLangSelection\' | appTemplate"></div>   <div class="pc-only"  > <div class="container" ng-if="data.showContainer"> <div class="first-line">   <nav class="navbar navbar-default {{currentLang}}" bs-text-direction> <div class="container-fluid">  <div class="navbar-header"> <a class="float clickable logo " ng-href="{{(data.hideMenus ? \'\' : \'/home/\') | uiHref}}" ng-class="[currentRegion,{judaica:judaicaOnly, cars:contentType==\'CARS\',\'real-estate\':contentType==\'REAL_ESTATE\'}]"></a> </div>   <div class="collapse navbar-collapse" >  <ul  class="nav navbar-nav auth" ng-controller="AuthUpperNavigationController"  ng-class="{\'navbar-right\':currentLang==\'he\'}"  ng-include src="\'auth/authUpperNavigation\' | appTemplate"  ng-if="!data.hideMenus"> </ul>   <div class="searchFormContainer" ng-class="currentLang" ng-include src="\'components/navigation/upperNavigationSearch\' | appTemplate" ng-if="!data.hideMenus && $state.current.name!=\'app.support\'"></div>  <ul class="nav navbar-nav" ng-class="{\'navbar-right\':currentLang!=\'he\'}">  <li class="white dropdown" ng-class="{open:data.langsVisible}" ng-if="data.langs.length>1" ng-click="data.langsVisible = !data.langsVisible  "> <a class="dropdown-toggle"> {{currentLang | langName:"english"}} <span class="caret" ></span> </a> <ul class="dropdown-menu" > <li ng-repeat="lang in data.langs" ng-if="lang!=currentLang" ng-click="setLanguage(lang)"> <a>{{lang | langName}}</a> </li> </ul> </li> </ul>  </div>  </div> </nav>  </div>  <div class="second-line" ng-if="!data.hideMenus"> <nav class="navbar navbar-default {{currentLang}}" bs-text-direction> <div class="container-fluid"> <div class="collapse navbar-collapse"> <ul class="nav navbar-nav" ng-controller="AuctionsMenuController" ng-class="{\'navbar-right\':currentLang==\'he\'}">  <upper-navigation-menu  name="auctions"  links="links" arrow-position = "{{currentLang==\'he\' ? \'right\' : \'left\'}}"  handle-link-click="handleLinkClick(link)"></upper-navigation-menu>  <li ng-if="shopsVisible"><a href="{{\'/shops\' | uiHref}}">{{"shops" | i18n}}</a></li> <li ng-repeat="portalScene in otherPortalScenes"><a ng-href="{{portalScene | portalUrl}}">{{linkText(portalScene) }}</a></li>  <li ng-if="tagsMenus" > <div class="divider"></div> </li>  <upper-navigation-menu  class="tag-menu"  ng-repeat="tagsMenu in tagsMenus"  name="{{tagsMenu.header}}"  links="tagsMenu.entries" arrow-position = "{{currentLang==\'he\' ? \'right\' : \'left\'}}" link-href-prefix="/searchWithTags/"  header-href="{{tagsMenu.headerHref}}"  text-prefix="tag_"></upper-navigation-menu>    </ul> <ul class="nav navbar-nav" ng-class="{\'navbar-right\':currentLang!=\'he\'}"  ng-controller="HelpMenuController"> <upper-navigation-menu  name="help"  links="links"  text-prefix="" arrow-position = "{{currentLang==\'he\' ? \'left\' : \'right\'}}"  handle-link-click="handleLinkClick(link)"></upper-navigation-menu>  </ul>     </div>  </div> </nav>   </div>  </div>  </div>   <div class="mobile-only hello-bar" ng-if="currentUser && data.showContainer && !hideHeloBar"> <div class="text">{{\'hello_user\' | i18n:{userName:currentUser.firstName} }} </div> </div>  </div> '), 
        $templateCache.put("/portal/templates/components/navigation/installAppButton.html?1.1944", ' <a class="install-app-button"  ng-show="platform" target="linkTarget"  ng-href="{{href}}" ng-click="logAppPageLink(platform)"  ng-class="platform"> </a>   '), 
        $templateCache.put("/portal/templates/components/navigation/reload.html?1.1944", '<div class="refresh scene" ng-controller="ReloadController">  </div> '), 
        $templateCache.put("/portal/templates/components/navigation/mobileMenu.html?1.1944", '<div ng-controller="MobileMenuController" > <div> <div  class="menu icon-button needsclick" ng-click="toggleMenu()" ng-class="{touched:menuTouched}"></div> <div class="clearfix"></div> <div class="arrow" ng-show="mobileMenuOn" ></div> <div class="clearfix"></div> </div> <div id="linksMenu" class="mobile-menu" ng-if="mobileMenuOn" > <div class="bg">  <div ng-if="!data.hideMenus">  <div ng-if="!langMenuAtBottom" ng-include src="\'components/navigation/mobileLangSelection\' | appTemplate"></div>  <a class="orange entry needsclick"  ng-if="currentUser && currentUser.registrationStage!=\'COMPLETE\'" ng-click="nextRegistrationStep()" ng-class="currentLang" >{{(\'complete_registration\') | i18n}}</a>  <a class="needsclick entry" ng-if="!mobileApp && currentUser && (!currentUser.userDevices || currentUser.userDevices.length==0)" ng-class="[currentLang,{orange:currentUser.registrationStage==\'COMPLETE\'}]" ng-click="installApp()" ng-click="installApp()"  >{{(\'get_bidspirit_app\') | i18n}}</a>   <a class="needsclick entry"  ng-if="!currentUser" ng-class="currentLang" ng-click="gotoScene(\'app.auth\',{authScene:authLink})" ng-repeat="authLink in [\'login\',\'register\']">{{linkText(authLink)}}</a>  <a class="needsclick orange entry" ng-if="!mobileApp && !currentUser " ng-class="currentLang" ng-click="installApp()"  >{{(\'get_bidspirit_app\') | i18n}}</a>  <a class="needsclick entry"   ng-repeat="portalScene in otherPortalScenes" ng-class="currentLang" ng-click="gotoPortalScene(portalScene)">{{ linkText(portalScene) }}</a>  <div class="slide-menu" ng-controller="AuctionsMenuController" > <div class="selected entry" slide-toggle="#auctionsMenu"  > {{"the_auctions" | i18n}} <span class="caret {{dir}}" ></span> </div> <ul id="auctionsMenu" class="slideable" duration="0.25s"> <li ng-repeat="link in links"> <a class="btn-link sub entry"  ng-show="!hiddenLinks[link]" ng-click="handleLinkClick(link)">{{linkText(link)}}</a> </li> </ul> </div>  <a class="needsclick entry"   ng-if="shopsVisible" ng-class="currentLang" ng-click="gotoScene(\'app.shops\')">{{\'shops\' | i18n}}</a>   <a class="needsclick entry"   ng-if="currentUser "   ng-click="gotoScene(\'app.accountActions\',{actionType:\'absenteeBids\'})" >{{\'absentee_bids\' | i18n}}</a>  <a class="needsclick entry"   ng-if="currentUser "   ng-click="gotoScene(\'app.accountActions\',{actionType:\'purchases\'})" >{{\'purchases\' | i18n}}</a>  <a class="needsclick entry"   ng-if="currentUser " ng-class="currentLang" ng-click="gotoScene(\'app.accountActions\',{actionType:\'favorites\'})">{{\'favorites\' | i18n}}</a>  <a class="needsclick entry"   ng-if="currentUser" ng-class="currentLang" ng-click="gotoScene(\'app.alerts\')">{{\'alerts\' | i18n}}</a>  <div class="slide-menu" ng-controller="HelpMenuController" > <div class="selected entry" slide-toggle="#helpMenu"  > {{"help" | i18n}} <span class="caret {{dir}}" ></span> </div> <ul id="helpMenu" class="slideable" duration="0.25s"> <li ng-repeat="link in links"><a class="btn-link sub entry"  ng-click="handleLinkClick(link)">{{linkText(link)}}</a></li> </ul> </div>   <a class="needsclick entry"   ng-if="currentUser " ng-class="currentLang" ng-click="gotoScene(\'app.userDetails\')">{{\'update_details\' | i18n}}</a>    <a class="needsclick entry" ng-if="currentUser " ng-class="currentLang" ng-click="logout()" ng-href="{{\'/home/\' | uiHref}}" >{{(\'logout\') | i18n}}</a> </div>  <div ng-if="langMenuAtBottom || data.hideMenus" ng-include src="\'components/navigation/mobileLangSelection\' | appTemplate"></div> </div>   <div class="bottom-space"></div>  </div> </div>  '), 
        $templateCache.put("/portal/templates/components/navigation/choosePortal.html?1.1944", '<div  class="choose-portal scene" ng-controller="ChoosePortalController"> <div class="upper-space"></div> <div class="common-button  darkBlue" ng-click="gotoPortalScene(\'ART\')" > <div class="text"> {{"link_art" | i18n}} </div> </div>  <div class="common-button  darkBlue" ng-click="gotoPortalScene(\'CARS\')" > <div class="text"> {{"link_cars"| i18n}}  </div> </div>  </div> '), 
        $templateCache.put("/portal/templates/components/navigation/upperNavigationMenu.html?1.1944", '<li class="white dropdown {{name}}" ng-class="{open:menuVisible}" > <a  class="dropdown-toggle" ng-click="onHeaderClick()"  ng-mouseenter="showMenu()"  ng-mouseleave="hideMenuAfterDelay()"  ng-href="{{headerHref}}" ng-class="currentLang">  {{linkText(textPrefix+name) }} </a> <ul class="dropdown-menu {{currentLang}}" ng-if="links.length>1" ng-class="menuAdditionalClass" ng-mouseenter="showMenu()"  ng-mouseleave="hideMenuAfterDelay()" > <li ng-repeat="link in links"><a class="btn-link"  ng-href="{{linkHrefPrefix ? ((linkHrefPrefix+link) | uiHref) : \'\'}}"  ng-show="!hiddenLinks[link]"  ng-click="onLinkClick(link)">{{linkText(textPrefix+link)}}</a></li> </ul> </li>     '), 
        $templateCache.put("/portal/templates/components/pageFooter.html?1.1944", ' <div class="page-footer" ng-if="visible" > <div class="container col-md-7 col-xs-12 center-block"> <div class="arrow"></div> <div class="row">  <div class="info-part col-xs-6"> <div class="logo" ></div> <div class="text-line" ng-show="BidspiritInfo.emailLink" ng-bind-html="\'home_footer_info_email\' | i18n:{email:BidspiritInfo.emailLink}"></div> <div ng-if="BidspiritInfo.phone" class="hidden-xs hidden-sm text-line" ng-bind-html="\'home_footer_info_phone\' | i18n:{phone:BidspiritInfo.phoneLink}"></div> </div>  <div class="float vertical-separator" ng-class="{invisible:shouldHideContactUs}"></div> <div class="contact-us-part info-part col-xs-5" > <div class="pc-message hidden-xs hidden-sm" ng-class="{invisible:shouldHideContactUs}"> <div class="message"> {{"home_footer_contact_text" | i18n }} </div> <div class="orange common-button center-block"  ui-sref="app.contact"> <div class="text">{{"home_footer_contact_button" | i18n }}</div> </div> </div>  <div class="mobile-links hidden-md hidden-lg"> <a class="btn-link" ng-href="{{\'/contact\' | uiHref}}">{{"contact_us" | i18n}}</a> <a class="btn-link" ng-click="showInfoPopup(\'terms\')">{{"terms_of_use" | i18n}}</a>  <a class="btn-link" ng-click="showInfoPopup(\'privacy\')">{{"privacy_policy" | i18n}}</a> <a class="btn-link" ng-href="{{\'/about\' | uiHref}}">{{"about" | i18n}}</a> <a class="btn-link" ng-href="{{\'/product\' | uiHref}}">{{"product" | i18n}}</a>  </div> </div>  <div class="clearfix"></div> <div ng-if="BidspiritInfo.phone" class="hidden-md hidden-lg text-line text-center" ng-bind-html="\'home_footer_info_phone\' | i18n:{phone:BidspiritInfo.phoneLink}"></div> </div>   <div class="horizontal-separator"></div>  <div class="second-line" > <div class="sell float col-xs-6" > <div class="float text" >{{sellText | i18n }}&nbsp;</div>  <div class="float contact"> <bs-linkable-text  options="{ textKey:\'home_footer_sell_contact\',  onLinkClick:gotoContactForSale }" > </bs-linkable-text> </div>  <div class="clearfix"></div> </div>  <div class="float col-xs-6 social" > <div class="text">{{"follow_us" | i18n }}</div> <div class="icons"> <a class="button twitter" target="{{linkTarget}}" href="https://www.twitter.com/{{twitterPage}}"></a> <a class="button fb" target="{{linkTarget}}" href="https://www.facebook.com/{{fbPage}}"></a> </div> </div> <div class="clearfix"></div> </div>   <div> <div class="horizontal-separator" ng-if="contentType==\'ART\'"></div> <div class="hidden-xs hidden-sm">  <div class="bottom-links"> <a class="btn-link" ng-click="showInfoPopup(\'terms\')">{{"terms_of_service" | i18n}}</a>  <a class="btn-link" ng-click="showInfoPopup(\'privacy\')">{{"privacy_policy" | i18n}}</a> <a class="btn-link" ng-href="{{\'/about\' | uiHref}}">{{"about" | i18n}}</a> <a class="btn-link" ng-href="{{\'/product\' | uiHref}}">{{"product" | i18n}}</a>  <a ng-if="contentType==\'ART\'" class="btn-link" ng-href="{{\'/houses\' | uiHref}}">{{"auction_houses" | i18n}}</a>  </div> <div class="horizontal-separator"></div> </div>  <div class="rights-line">	{{"all_rights_reserved" | i18n }}	</div>  </div> <div class="clearfix"></div>  </div> <div class="clearfix"></div> </div> '), 
        $templateCache.put("/portal/templates/nudges/modal/housesAlertsModal.html?1.1944", '<div class="title">{{\'nudges_houses_alert_catalog_title\' | i18n}}</div>    <div class="action orange common-button"  ng-click="options.showRegisterForm()"> <div class="text">{{\'registeration\' | i18n}}</div></div>  '), 
        $templateCache.put("/portal/templates/nudges/modal/nudgeModalPopup.html?1.1944", '<div class="nudge-modal-popup" ng-class="nudgeType" bs-text-direction> <div class="content" ng-include src="(\'nudges/modal/\'+options.data.nudgeType+\'Modal\') | appTemplate" ng-class="nudgeType"> </div>  </div> '), 
        $templateCache.put("/portal/templates/nudges/navbar/nudgeNavbarPopup.html?1.1944", '<div class="nudge-navbar-popup" ng-show="isVisible" ng-class="nudgeType" ng-click="onClick()" bs-text-direction> <div class="close button">x</div> <div class="content" ng-if="isVisible" ng-include src="(\'nudges/navbar/\'+nudgeType+\'NavBar\') | appTemplate" ng-class="nudgeType">  </div>   </div> '), 
        $templateCache.put("/portal/templates/nudges/navbar/housesAlertsNavBar.html?1.1944", '<div class="title">{{\'nudges_houses_alert_catalog_title\' | i18n}}</div>   <div class="action orange common-button"  ui-sref="app.alerts"> <div class="text">{{\'alerts_promotion_configure_command\' | i18n}}</div></div>  '), 
        $templateCache.put("/portal/templates/nudges/scenes/installApp.html?1.1944", '<div class="install-app-nudge scene" ng-controller="InstallAppNudgeController" bs-scroll-to-top> <div class="content container"> <div class="logo-icon"></div>  <div class="message default-align" ng-bind-html="\'app_install_nudge_message\' | i18n"></div> <br>  <div class="orange common-button center-block" ng-click="gotoStorePage()"> <div class="text">{{"app_install_nudge_download" | i18n }}</div> </div>  <div class="no-install" ng-click="continueOnBrowser()"> {{"app_install_nudge_continue" | i18n }} </div> </div>  </div>  '), 
        $templateCache.put("/portal/templates/auctions/results/auctionsResults.html?1.1944", '<div ng-controller="AuctionsResultsController" class="auctions-results scene"> <div class="narrow upper-part">  <div class="dark overlay">  <div class="message center-block container col-lg-7 col-md-7 col-sm-8 col xs-12"> <h1>{{ (showPastAuctionsResult  ? \'auction_results_title\' : \'ended_auctions\') | i18n }}</h1> <div class="short-separator"></div> </div> </div> </div>  <div class="content"> <bs-upper-space-holders class="narrow"> </bs-upper-space-holders>  <div class="house-selection" > <div class="space hidden-sm"> </div> <h3 class="caption"> {{(contentType==\'ART\' ?  \'auctions_results_select_house\' : \'filter\' ) | i18n}}</h3> <houses-dropdown houses="houses" on-house-selected="showHouseAuctions" max-length="40" initial-house-code="{{data.selectedHouseCode}}"> </houses-dropdown> <div class="short-separator"></div> </div>    <bs-pagination	pages-data="pagesData"	href-pages="true"> </bs-pagination>  <div class="clearfix"></div>  <bs-content-loader loaded="!displayeAuctionsLoader"></bs-content-loader>  <div class="auctions-lists-group"> <div>  <bs-auctions-list auctions="pageAuctions" view="\'recent\'"  ></bs-auctions-list> </div>  </div>   <bs-pagination	pages-data="pagesData"	href-pages="true" ng-show="!displayeAuctionsLoader"> </bs-pagination>  </div>  </div> '), 
        $templateCache.put("/portal/templates/auctions/home/homeMain.html?1.1944", '<div ng-controller="HomeController"> <div class="home scene"> <div class="upper-part"  ng-class="[screenHeightClass]" ng-if="!inIframe"> <bs-houses-carousel ></bs-houses-carousel>  <div class="overlay" >  <div class="message" > <div class="logo-icon" ></div>  <h1  class="{{contentType | lowercase}}"  ng-bind-html="upperMessage"></h1>  <h4 class="features with-links" ng-if="featuresAsLinks && contentType==\'ART\'" >  <a ng-href="{{\'/help/search\' | uiHref}}"> {{\'home_upper_feature_search\' | i18n}}</a> <span class="bullet"></span> <a href="{{\'/help/live\' | uiHref}}">{{\'home_upper_feature_live\' | i18n}}</a> <span class="bullet"></span> <a href="{{\'/help/bids\' | uiHref}}">{{\'home_upper_feature_bid\' | i18n}}</a> </h4>  <h4 class="features" ng-if="!featuresAsLinks && contentType==\'ART\'" >  {{\'home_upper_feature_search\' | i18n}} <span class="bullet"></span> {{\'home_upper_feature_live\' | i18n}} <span class="bullet"></span> {{\'home_upper_feature_bid\' | i18n}} </h4>  <div class="demo-video-button" ng-click="showDemoVideo()" ng-if="shouldDisplayVideoLink" > {{"demo_video" | i18n }} </div> </div>  <div class="home-promotions" ng-if="viewPort.pcMedia && !judaicaOnly  && adsInfoLoaded"> <div class="inner"> <promotion-instance position="HOME_HEADER_FIRST"></promotion-instance> <promotion-instance position="HOME_HEADER_SECOND"></promotion-instance> <promotion-instance position="HOME_HEADER_THIRD"></promotion-instance> </div> </div>   <div class="clearfix"></div>  </div>  </div>  <div class="content" ng-class="[screenHeightClass]"> <bs-upper-space-holders> </bs-upper-space-holders>  <div> <form name=\'searchForm\' novalidate bs-form  bs-submit="doSearch()" class="global-search-form {{currentLang}}" bs-text-direction> <bs-form-group field-name="phrase" label="catalog_search_all" > <bs-search-input></bs-search-input> </bs-form-group> <div class="button" ng-click="doSearch()"></div> <div class="clearfix"></div> </form>  <div bs-scroll-on="auctionsToScrollTo[\'coming_auctions\']" watched-value="auctionsToScrollTo[\'coming_auctions\']" offset="auctionScrollOffset"> </div>  <promotion-instance class="home-header" position="HOME_HEADER_FIRST" ng-if="viewPort.mobileMedia && !judaicaOnly"></promotion-instance>    <div class="auctions-lists-group">  <div class="title" > <div class="space hidden-xs" ng-if="data.nextAuctions.length && !judaicaOnly && contentType==\'ART\'  && !inIframe "> </div> <h3 class="caption" ng-if="data.nextAuctions.length"> {{:: \'next_auctions\' | i18n}}</h3> <div uib-dropdown class="region-selection btn-group" ng-class="currentLang"  is-open="status.isopen" ng-if="!judaicaOnly && !inIframe && contentType==\'ART\'" > <div type="button" class="default-align selected entry" uib-dropdown-toggle > <div class="float icon {{:: currentRegion | lowercase}}"></div> <div class="float text">{{:: ("region_"+currentRegion) | i18n }}</div> <div class="opposite float caret {{dir}}" ></div> <div class="clearfix"></div> </div> <ul uib-dropdown-menu role="menu"> <li ng-repeat="region in regions" ng-if="region!=currentRegion"> <a class="default-align entry" ng-href="{{regionLink(region)}}" ng-click="onRegionClick(region)"> <div class="float icon {{region | lowercase}}"></div> <div class="float text">{{:: ("region_"+region) | i18n}}</div> <div class="clearfix"></div> </a> </li> </ul>  </div> </div>  <div>  <div class="short-separator"></div> <bs-auctions-list auctions="data.nextAuctions" view="\'next\'" ></bs-auctions-list> </div>  <div ng-if="data.additionalAuctions.length"> <div class="title"> <h3 class="caption">{{\'auctions_list_additional\'  | i18n}}</h3> </div>  <div class="short-separator"></div> <bs-auctions-list auctions="data.additionalAuctions" view="\'additional\'" ></bs-auctions-list> </div>  <promotion-instance class="home-banner" position="HOME_BANNER_FIRST" ng-if="!judaicaOnly"></promotion-instance>  <div ng-if="autoScrollEnabled" bs-scroll-on="auctionsToScrollTo[\'direct_sale\']" watched-value="auctionsToScrollTo[\'direct_sale\']" offset="auctionScrollOffset"> </div>  <div ng-if="data.postSaleAuctions.length"> <div class="title"> <h3 class="caption">{{\'auctions_list_post_sale\'  | i18n}}</h3> </div>  <div class="short-separator"></div> <bs-auctions-list auctions="data.postSaleAuctions" view="\'post_sale\'" ></bs-auctions-list> </div>   <div ng-if="data.shops.length"> <div ng-if="viewPort.pcMedia"> <div class="title"> <h3 class="caption">{{\'home_shops_title\'  | i18n}}</h3> </div>  <div class="short-separator"></div>  <bs-shops-list shops="data.shops" > </bs-shops-list> </div>  <div ng-if="viewPort.mobileMedia"> <a href="{{\'/shops\' | uiHref}}"  class="results orange common-button col-lg-4 col-xs-10 {{currentLang}}"> <div class="text"> {{(\'home_shops_title\') | i18n}} </div>  </a> </div> </div>   <div ng-if="recentAuctionsVisible" > <div class="title"> <h3 class="caption">{{(showPastAuctionsResult ? \'auctions_list_recent\' : \'ended_auctions\') | i18n}}</h3> </div>  <div class="short-separator"></div> <bs-auctions-list auctions="data.recentAuctions" view="\'recent\'"  ></bs-auctions-list> </div>    <promotion-instance class="home-banner" position="HOME_BANNER_SECOND" ng-if="!judaicaOnly"></promotion-instance>  <div ng-if="resultsButtonVisible"> <a href="{{\'/results/all/\' | uiHref}}"  class="results orange common-button col-lg-4 col-xs-10 {{currentLang}}" > <div class="text"> {{(showPastAuctionsResult ? \'home_auctions_results\' : \'ended_auctions_all\') | i18n}} </div>  </a> </div>  <div ng-if="futureAuctionsButtonVisible"> <button class="future orange common-button col-lg-4 col-xs-10" ng-click="showFutureAuctions()"> <div class="text">{{\'auctions_list_show_future\' | i18n}}</div> </button> </div>   <div ng-if="futureAuctionsVisible" bs-scroll-on watched-value="scrollToFutureAuctions" debug-key="future">  <div class="title"> <h3 class="caption">{{\'future_auctions\' | i18n}}</h3> </div>  <div class="short-separator"></div> <bs-auctions-list auctions="data.futureAuctions" house-name-as-link="true" view="\'future\'" ></bs-auctions-list>  <div class="center-block future-auctions btn-link" ng-click="showAllFutureAuctions()">{{"all_future_auctions" | i18n}}</div> </div>     </div> </div>  </div> </div> </div>   '), 
        $templateCache.put("/portal/templates/auctions/catalog/auctionCatalog.html?1.1944", '<div ng-controller="CatalogListController" > <div ng-controller="AuctionCatalogController" > <div class="catalog scene">  <div class="content col-xs-12" >  <div class="catalog-navigation-panel" bs-text-direction> <bs-upper-space-holders> </bs-upper-space-holders>  <bs-auction-info ng-if="auction" auction="auction" auction-lots="data.items"></bs-auction-info>  <div class="catalog-actions viewport_{{viewPort.viewPortWidth}}" bs-text-direction ng-class="{\'no-categories\':filterData.categories.length==0}" > <bs-catalog-list-filter items="data.items" ng-if="auction && data.items"></bs-catalog-list-filter> <bs-auction-start-alert-button  auction="auction" ng-if="auction && viewPort.mobileMedia && pagesData.pageItems.length>0"></bs-auction-start-alert-button> </div>  <div ng-if="pagesData.pageItems.length>0">   <bs-catalog-list-pagination pages-data="pagesData"  position-in-page="\'upper\'" href-pages="true" ></bs-catalog-list-pagination>  <div  bs-scroll-on watched-value="scrollToPagination" offset="-200"></div>  </div> <bs-content-loader loaded="pagesData.pageItems!=null"></bs-content-loader> </div> <div ng-if="pagesData.pageItems.length>0">  <div ng-if="!displayeItemsLoader"  ng-include src="\'catalogs/list/catalogItems\' | appTemplate"  ></div> <bs-content-loader loaded="!displayeItemsLoader"></bs-content-loader> <bs-catalog-list-pagination pages-data="pagesData"  position-in-page="\'lower\'" href-pages="true"></bs-catalog-list-pagination>  <bs-house-regisration-promotion ng-show="!displayeItemsLoader && (houseApprovalState!=\'APPROVED\' || auction.house.auctionBasedUserApproval)" auction="auction" class="promotion-bottom"> </bs-house-regisration-promotion> <bs-mailing-list-promotion house="::auction.house" class="promotion-bottom"> </bs-mailing-list-promotion>  </div>  </div> </div> </div> </div>  '), 
        $templateCache.put("/portal/templates/auctions/lists/auctionEntryNarrow.html?1.1944", '<div class="frame viewport_{{viewPort.viewPortWidth}} " >  <!--  {{auction.hoursTillAuction}} -->  <auction-badge auction="::auction" is-today="::auction.date==today"></auction-badge>   <div class="float image"  bs-cloudinary-bg="{{::(auction.resources[\'topItem\'] || auction.house.resources[\'mainPageLogo\'])}}" ng-class="::{contain:auction.resources[\'topItem\']!=null}"  params="::{size:imageSize} "> </div>  <div class="opposite float texts" >  <h2> {{::auction.house.details.name | langField}}  </h2> <div class="number" ng-if="::auction.number"> {{::"auction_label_number" | i18n:{number:auction.number} }}&nbsp; <span class="part" ng-if="::auction.part"> {{::("auction_part_"+auction.part) | i18n}}  </span> </div>  <div class="time" > {{::auction | auctionTime}}  </div>  <div class="name"> <div ng-bind-html="::auction.name | langField : {currentLangOnly:true}"></div> <div ng-if="::auction.shortDetails | langField : {currentLangOnly:true}" style="color:{{::auction.textColors.details}}" ng-bind-html="::auction.shortDetails | langField"></div> </div>  <button class="float common-button {{currentLang}}"   ng-class="auction.displayInfo.buttonClass" ng-if="::auction.state!=\'PENDING\'">  <div class="text"> {{auction.displayInfo.buttonText | i18n}} </div> </button>  <bs-auction-start-alert-button class="opposite float" auction="::auction" ></bs-auction-start-alert-button>  <div ng-if="auction.state==\'PENDING\'" class="pending-label"  ng-if="::view!=\'future\'" ng-class="{blink:auction.clickedRecently}"> <div class="text"> {{auction.displayInfo.buttonText | i18n}} </div> </div>   <div class="clearfix"></div>  </div>  <div class="clearfix"></div>  </div> '), 
        $templateCache.put("/portal/templates/auctions/lists/auctionsList.html?1.1944", '<div class="list" ng-class="[screenView,view]">  <div class="row {{:: screenView}}" bs-text-direction >    <div class="auction-entry col-md-3 col-xs-12"  ng-repeat="auction in auctions" ng-click="onAuctionClick(auction)" bs-log-click="auction-{{:: auction.house.code}}-{{:: (auction.date | date :\'dd.MM.yy\') }}", ng-animate ng-class="{clickable:isAuctionClickable(auction)}" bs-scroll-on="auction.intKey == scrollTo" >   <div  ng-if="screenView==\'wide\'"     ng-include src="\'auctions/lists/auctionEntryWide\' | appTemplate" class="frame"> </div> <div  ng-if="screenView==\'narrow\'"     ng-include src="\'auctions/lists/auctionEntryNarrow\' | appTemplate" class="frame"> </div> </div>   </div>  </div> '), 
        $templateCache.put("/portal/templates/auctions/lists/auctionBadge.html?1.1944", ' <div class="badge-frame" ng-show="shouldShow" > <div class="text">{{:: text}}</div> </div>      '), 
        $templateCache.put("/portal/templates/auctions/lists/auctionEntryWide.html?1.1944", '<div class="frame" >  <!--  {{::auction.hoursTillAuction}} -->   <div class="image"  bs-cloudinary-bg="{{::(auction.resources[\'topItem\'] || auction.house.resources[\'mainPageLogo\'])}}" ng-class="::{contain:auction.resources[\'topItem\']!=null}"  params="::{size:imageSize} "> <auction-badge auction="::auction" is-today="::auction.date==today"></auction-badge> </div>  <bs-auction-start-alert-button auction="auction"></bs-auction-start-alert-button>   <div class="texts"> <h2> <a class="btn-link" ng-href="{{::(\'/houses/\'+auction.house.code+\',false\') | uiHref" ng-if="isAuctionHouseLink(auction)">{{:: auction.house.details.name | langField}}</a> <span ng-if="!isAuctionHouseLink(auction)">{{:: auction.house.details.name | langField}}</span> <span ng-if="auction.number">- {{::"auction_label_number" | i18n:{number:auction.number} }}</span> </h2> <div class="part" ng-if="auction.part"> {{("auction_part_"+auction.part) | i18n}}  </div>  <div class="time" minutes_till_start="{{::auction.minutesUntilStart}}"> {{::auction | auctionTime}} </div> <div class="short-separator"></div> <div class="name"> <div ng-bind-html="::auction.name | langField : {currentLangOnly:true}"></div> <div ng-if="::auction.shortDetails | langField : {currentLangOnly:true}" style="color:{{::auction.textColors.details}}" ng-bind-html=":: auction.shortDetails | langField"></div> </div> <bs-auction-structured-data auction="auction"></bs-auction-structured-data> </div>   <div class="center-block common-button {{currentLang}}"   ng-class="auction.displayInfo.buttonClass" ng-if="view!=\'future\'"> <div class="text"> <a ng-if="isLinkbutton(auction)" ng-href="{{auction | auctionHref}}">{{auction.displayInfo.buttonText | i18n}}</a> <span  ng-if="!isLinkbutton(auction)" >{{auction.displayInfo.buttonText | i18n}}</span> </div> </div>  </div> '), 
        $templateCache.put("/portal/templates/userDetails/houseApprovalScene.html?1.1944", ' <div class="info-popup scene" bs-scroll-to-top>  <div class="content container col-lg-6 col-md-6 col-sm-8 col xs-12"> <div ng-if="options.title" class="title center-block container col-lg-7 col-md-7 col-sm-8 col xs-12" > <H3>{{"notice" | i18n}}</H3> <div class="short-separator"></div> </div> <bs-house-approval house-id="$stateParams.houseId"></bs-house-approval>  </div> </div>     '), 
        $templateCache.put("/portal/templates/userDetails/userDetailsMain.html?1.1944", '<div ng-controller="UserDetailsController" class="userDetails scene" bs-scroll-to-top> <div class="narrow upper-part">  <div class="dark overlay">  <div class="message center-block container col-lg-7 col-md-7 col-sm-8 col xs-12"> <h1>{{"user_details_title" | i18n}}</h1> <div class="short-separator"></div> </div> </div> </div>  <div class="content container"> <bs-upper-space-holders class="narrow"> </bs-upper-space-holders>  <h4>{{"user_details_message" | i18n}}</h4> <br>  <uib-accordion ng-if="currentUser" > <div uib-accordion-group class="panel-default noselect" ng-repeat="section in sections" is-open="opened[section]" ng-class="section"> <uib-accordion-heading> <div> <div class="section-name    col-sm-4  float">{{sectionNameKey(section) | i18n}}</div> <div class="section-summary col-sm-5 float" ng-bind-html="getSectionSummary(section)"> </div> <div class="edit btn-link   col-sm-3  opposite float opposite-align" ng-show="!opened[section]">{{"edit" | i18n}}</div> <div class="clearfix"></div> </div> </uib-accordion-heading> <div class="section-content col-lg-6 col-md-7 col-sm-8 col-xs-12" ng-class="section"> <div  ng-include src="(\'userDetails/sections/\'+section +\'Section\') | appTemplate" ng-if="opened[section]"> </div> </div> </div> </uib-accordion> </div>   </div> '), 
        $templateCache.put("/portal/templates/userDetails/sections/nameSection.html?1.1944", '<div class="name-section" >  <form name=\'nameUpdateForm\'  novalidate bs-form  bs-submit="updateUserInfo(\'name\')">   <bs-form-group field-name="firstName" label="first_name"> <label class="float"></label> <bs-form-validation-message css-class="float"></bs-form-validation-message> <div class="clearfix"></div> <input  name="firstName" class="form-control" ng-model="data.user.firstName" required ng-minlength="2" ng-pattern="bsValidationPatterns.alpha"/>  </bs-form-group>  <bs-form-group field-name="lastName" label="last_name"> <label  class="float"></label> <bs-form-validation-message css-class="float"></bs-form-validation-message> <div class="clearfix"></div> <input  name="lastName" class="form-control" ng-model="data.user.lastName" required ng-minlength="2" ng-pattern="bsValidationPatterns.alpha"/> </bs-form-group>   <div class="buttons-row"> <bs-async-button button-class="\'float orange common-button\'"  bs-form-controller="nameUpdateForm" label="\'save\'" > </bs-async-button> <div class="float btn-link" ng-click="onUpdateDone(\'name\')">{{"cancel" | i18n}}</div> <div class="clearfix"></div> </div>   <div class="clearfix"></div> </form> </div>  '), 
        $templateCache.put("/portal/templates/userDetails/sections/shippingSection.html?1.1944", '<div class="shipping-section" >  <div class="form-group checkbox-row"> <input  type="checkbox" class="float" name="residenceIsShipping" ng-model="data.userDetails.shippingAddress.residenceIsShipping"/> <label class="float">{{\'user_details_shipping_is_residence\' | i18n}}</label> <div class="clearfix"></div> </div>   <form name=\'shippingUpdateForm\'  novalidate bs-form  bs-submit="updateShippingAddress()"  > <bs-user-details-address address="data.userDetails.shippingAddress" ng-show="!data.userDetails.shippingAddress.residenceIsShipping"></bs-user-details-address> <div class="buttons-row" > <bs-async-button  button-class="\'float orange common-button\'"  bs-form-controller="shippingUpdateForm" label="\'save\'" > </bs-async-button> <div class="float btn-link" ng-click="onUpdateDone(\'shipping\')">{{"cancel" | i18n}}</div> <div class="clearfix"></div> </div>  </form>       </div>  '), 
        $templateCache.put("/portal/templates/userDetails/sections/companySection.html?1.1944", '<div class="company-section" >  <form name=\'companyUpdateForm\'  novalidate bs-form  bs-submit="updateUserInfo(\'company\')">   <bs-form-group field-name="company" label="company"> <label class="float"></label> <bs-form-validation-message css-class="float"></bs-form-validation-message> <div class="clearfix"></div> <input  name="company" class="form-control" ng-model="data.user.company"/>  </bs-form-group>   <div class="buttons-row"> <bs-async-button button-class="\'float orange common-button\'"  bs-form-controller="companyUpdateForm" label="\'save\'" > </bs-async-button> <div class="float btn-link" ng-click="onUpdateDone(\'company\')">{{"cancel" | i18n}}</div> <div class="clearfix"></div> </div>   <div class="clearfix"></div> </form> </div>  '), 
        $templateCache.put("/portal/templates/userDetails/sections/residenceSection.html?1.1944", '<div class="residence-section" >  <form name=\'residenceUpdateForm\'  novalidate bs-form  bs-submit="updateResidenceAddress()">  <bs-user-details-address address="data.userDetails.residenceAddress" ></bs-user-details-address>  <div class="buttons-row"> <bs-async-button button-class="\'float orange common-button\'"  bs-form-controller="residenceUpdateForm" label="\'save\'" > </bs-async-button> <div class="float btn-link" ng-click="onUpdateDone(\'residence\')">{{"cancel" | i18n}}</div> <div class="clearfix"></div> </div> </form>   </div>  '), 
        $templateCache.put("/portal/templates/userDetails/sections/englishSection.html?1.1944", "<div> <bs-edit-eng-details close-fn=\"onUpdateDone('english')\"></bs-edit-eng-details>  </div> "), 
        $templateCache.put("/portal/templates/userDetails/sections/phoneSection.html?1.1944", '<div class="phone-section" >  <form name=\'phoneUpdateForm\'  novalidate bs-form  bs-submit="updateUserInfo(\'phone\')">   <bs-form-group field-name="phone" label="phone"> <label class="float"></label> <bs-form-validation-message css-class="float"></bs-form-validation-message> <div class="clearfix"></div> <input  dir="ltr" name="phone" class="form-control" ng-model="data.user.phone" required ng-minlength="8" ng-pattern="bsValidationPatterns.phone"/>  </bs-form-group>   <div class="buttons-row"> <bs-async-button button-class="\'float orange common-button\'"  bs-form-controller="phoneUpdateForm" label="\'save\'" > </bs-async-button> <div class="float btn-link" ng-click="onUpdateDone(\'phone\')">{{"cancel" | i18n}}</div> <div class="clearfix"></div> </div>   <div class="clearfix"></div> </form> </div>  '), 
        $templateCache.put("/portal/templates/userDetails/sections/emailSection.html?1.1944", "<div> <bs-edit-email></bs-edit-email> </div> "), 
        $templateCache.put("/portal/templates/userDetails/sections/billingSection.html?1.1944", '<div class="billing-section" ng-controller="BillingInfoController"> <div ng-if="data.billingInfoInfoLoaded"> <div ng-if="data.creditCardsInfo.length>0" class="card-details"> <table class="table"> <tr> <th>{{"credit_card_type" | i18n}}</th> <th>{{"number" | i18n}}</th> <th>{{"credit_card_valid_until" | i18n}}</th> <th>{{"credit_card_owner" | i18n}}</th> <th></th> </tr> <tr ng-repeat="creditCardInfo in data.creditCardsInfo"> <td>{{("credit_card_type_"+creditCardInfo.cardCompany.toLowerCase()) | i18n}}</td> <td ><span dir="ltr">{{"************"+creditCardInfo.lastCardDigits}}</span></td> <td>{{creditCardInfo.expiration}}</td> <td>{{creditCardInfo.cardOwnerName}}</td> <td> <div  class="btn-link" ng-click="deleteCreditCardInfo(creditCardInfo.id)" > {{\'user_details_credit_card_remove\' | i18n}} </div> </td>  </tr> </table> </div>  <div ng-if="display.showCreditCardForm"> <bs-edit-credit-card-details></bs-edit-credit-card-details>  </div>  <div class="text-success" ng-if="display.showCreditCardSaved"> {{"user_details_credit_card_saved" | i18n}} </div>  <div class="buttons-row"> <div ng-show="!display.showCreditCardForm  && !display.showCreditCardSaved"  class="btn submit orange" ng-click="showCreditCardForm()" > <div class="text">{{\'user_details_credit_card_add\' | i18n}}</div> </div>    <div class="btn btn-link" ng-click="onUpdateDone(\'billing\')">{{"close" | i18n}}</div>  <div class="clearfix"></div> </div>  </div> <bs-content-loader loaded="data.billingInfoInfoLoaded"></bs-content-loader>  </div>  '), 
        $templateCache.put("/portal/templates/userDetails/sections/passwordSection.html?1.1944", '<div class="password-section" ng-controller="PasswordUpdateController"> <form name=\'passwordUpdateForm\'  novalidate bs-form  bs-submit="updatePassword()" >  <bs-form-group field-name="existingsPassword" label="user_details_existing_password"> <label class="float"></label> <bs-form-validation-message css-class="float" wrong="wrong_password"  ></bs-form-validation-message> <div class="clearfix"></div> <input dir="ltr"  type="password" name="existingsPassword" class="form-control"  ng-model="data.existingPassword" required bs-validate="{wrong : \'!wrongPassword($value)\' }" bs-validate-watch="\'wrongPasswords\'"/>  </bs-form-group>  <bs-form-group field-name="newPassword" label="new_password" > <label class="float"></label> <bs-form-validation-message  css-class="float" minlength="error_bad_password_short" pattern="error_bad_password_pattern" ></bs-form-validation-message> <div class="clearfix"></div> <input dir="ltr"  type="password" name="newPassword" class="form-control" ng-model="data.newPassword" required ng-minlength="6" ng-pattern="bsValidationPatterns.nonHebrew"/>  </bs-form-group>  <bs-form-group field-name="passwordConfirm" label="confirm_password" > <label class="float"></label> <bs-form-validation-message  css-class="float" match="error_password_mismatch" ></bs-form-validation-message> <div class="clearfix"></div> <input dir="ltr"  type="password"  name="passwordConfirm" class="form-control"  ng-model="data.passwordConfirm"  bs-validate="{match : \'passwordConfirmedMatch()\' }" bs-validate-watch="\'data\'"/>  </bs-form-group>    <div class="buttons-row">  <bs-async-button button-class="\'float orange common-button\'"  bs-form-controller="passwordUpdateForm" label="\'save\'" > </bs-async-button> <div class="float btn-link" ng-click="updateDone()">{{"cancel" | i18n}}</div> <div class="clearfix"></div> </div>   <div class="clearfix"></div> </form> </div>  '), 
        $templateCache.put("/portal/templates/userDetails/engDetails/requestEngDetails.html?1.1944", '<div class="default-align"> <div class="text" ng-bind-html="\'user_details_request_in_eng\' | i18n : {house:(options.data.house.details.name | langField), lang:(options.data.user.detailsLang | langName) } "></div>  <br>  <bs-edit-eng-details deferred="options.data.deferred" in-popup="true" close-fn="closePopup()"></bs-edit-eng-details> </div> '), 
        $templateCache.put("/portal/templates/userDetails/reusableElements/editEmail.html?1.1944", '<div class="edit-email {{currentLang}}">   <div ng-show="stage==\'edit\'" > <label>{{"please_edit_your_mail" | i18n}}:</label> <form novalidate> <div class="form-group" field-name="email" label="email"> <input  dir="ltr"  name="email" class="form-control" ng-model="data.email" ng-click="clearError()"/> </div> <div class="form-error text-danger"> <div class="error-message blinkable" ng-bind-html="errorMessage | capitalize"></div> </div>  <div class="buttons-row"> <bs-async-button  button-class="\'float orange common-button\'"  action-fn="updateEmail()"  name="\'changeEmail\'" label="\'save\'" > </bs-async-button> <div class="float btn-link" ng-click="cancelEdit()">{{"cancel" | i18n}}</div> <div class="clearfix"></div> </div>  </form> </div> <div ng-show="stage==\'not_confirmed\'" > <div class="title">{{notConfirmedTitle | i18n}}.</div> <div class="line" ng-bind-html="\'email_not_confirmed_line_1\' | i18n:{email: getEmail()}"></div> <div class="line">{{"email_not_confirmed_line_2" | i18n}}</div>  <div class="links"> <div class="float"> <div class="btn-link" ng-click="sendEmailConfirmationAgain()" ng-class="{waiting:sendingConfirmationAgain}"> {{"send_again" | i18n}} </div> </div>  <div class="opposite float btn-link" ng-click="stage=\'edit\'">{{"change_email" | i18n}}</div>  <div class="clearfix"></div> <div class="float resent-message" ng-show="sentConfirmationAgain"> {{"another_message_sent" | i18n }} </div> </div>  <div class="sent-message" ng-show="anotherSent"> {{"another_message_sent" | i18n}}</div>  </div>  </div>  '), 
        $templateCache.put("/portal/templates/userDetails/reusableElements/editCreditCardDetails.html?1.1944", '<div class="credit-card-details" > <bs-content-loader loaded="data.iframeLoaded"></bs-content-loader>  <iframe nf-if="data.iframeUrl"  allowfullscreen=""  style="border:0; overflow-y: hidden;  overflow-x: hidden;"  webkitallowfullscreen="" scrolling="no" frameBorder="0" width="{{data.iframeWidth}}"  ng-visible="data.iframeLoaded" width="data.iframeWidth"  height="{{data.iframeLoaded ? data.iframeHeight : 0}}"  ng-src="{{data.iframeUrl}}"></iframe> <div class="footer-notes" ng-bind-html="\'credit_card_footer_notes\' | i18n"></div>  </div>  '), 
        $templateCache.put("/portal/templates/userDetails/reusableElements/address.html?1.1944", '<div class="address" >  <div class="row">  <bs-form-group field-name="country" label="country" css-class="col-xs-12  float" > <label class="float"></label> <span class="float star">*</span><div><!-- this empty div is needed for ie8 --></div> <bs-form-validation-message  debug="true" css-class="float" minlength="error_mandatory" pattern="error_bad_pattern_with_name"></bs-form-validation-message> <div class="clearfix"></div> <input  debug="true" name="country" class="form-control" ng-model="address.country" ng-minlength="2" ng-pattern="bsValidationPatterns.alpha" required /><div><!-- this empty div is needed for ie8 --></div>  </bs-form-group>  </div>   <div class="row">  <bs-form-group field-name="city" label="city" css-class="col-xs-12 float"> <label class="float"></label> <span class="float star">*</span><div><!-- this empty div is needed for ie8 --></div> <bs-form-validation-message  css-class="float" minlength="error_mandatory"  pattern="error_bad_pattern_with_name"></bs-form-validation-message> <div class="clearfix"></div> <input  name="city" class="form-control" ng-model="address.city" ng-minlength="2" ng-pattern="bsValidationPatterns.alpha" required /><div><!-- this empty div is needed for ie8 --></div>  </bs-form-group>  </div>  <div class="row">  <bs-form-group field-name="address" label="address" css-class="col-xs-12 float"> <label class="float"></label> <span class="float star">*</span><div><!-- this empty div is needed for ie8 --></div> <bs-form-validation-message  css-class="float" minlength="error_mandatory"></bs-form-validation-message> <div class="clearfix"></div> <input  name="address" class="form-control" ng-model="address.address" ng-minlength="2" required /><div><!-- this empty div is needed for ie8 --></div>  </bs-form-group>  </div>    <div class="row">  <bs-form-group field-name="state" label="state_of_country" css-class="col-xs-12 float"> <label class="float"></label> <bs-form-validation-message  css-class="float"></bs-form-validation-message> <div class="clearfix"></div> <input  name="state" class="form-control" ng-model="address.state" ng-pattern="bsValidationPatterns.alpha" /><div><!-- this empty div is needed for ie8 --></div>  </bs-form-group>  </div>  <div class="row">  <bs-form-group field-name="zip" label="zip_code" css-class="col-xs-12 float"> <label class="float"></label> <bs-form-validation-message  css-class="float"></bs-form-validation-message> <div class="clearfix"></div> <input  name="zip" class="form-control" ng-model="address.zipCode"  /><div><!-- this empty div is needed for ie8 --></div>  </bs-form-group> </div>  </div>  '), 
        $templateCache.put("/portal/templates/userDetails/reusableElements/editEngDetails.html?1.1944", '<div class="edit-eng-details {{currentLang}}">  <div class="col-lg-5 col-sm-10"> <div class="form-group" > <label>{{"user_details_eng_first_name" | i18n }}</label> <input dir="ltr" class="form-control" ng-model="data.engFirstName" /> <div class="text-danger">{{error.engFirstName}}&nbsp;</div> </div> </div>  <div class="clearfix"></div> <div class="col-lg-5 col-sm-10"> <div class="form-group" > <label>{{"user_details_eng_last_name" | i18n }}</label> <input dir="ltr" class="form-control" ng-model="data.engLastName" /> <div class="text-danger">{{error.engLastName}}&nbsp;</div> </div> </div>  <div class="clearfix"></div> <div class="col-lg-5 col-sm-10"> <div class="form-group" > <label>{{"user_details_eng_shipping_address" | i18n }}</label> <textarea dir="ltr" rows="3" class="form-control" ng-model="data.engShippingAddress" /> <div class="text-danger">{{error.engShippingAddress}}&nbsp;</div> </div> </div>  <div class="clearfix"></div> <div class="float btn-toolbar"> <div class="btn submit orange" ng-click="submit()">{{"ok" | i18n}}</div> <div class="btn btn-link" ng-click="cancel()">{{"cancel" | i18n}}</div> </div>  </div>  '), 
        $templateCache.put("/portal/templates/account/mailingList/mailingListPromotion.html?1.1944", '<div class="mailing-list-promotion" ng-show="visible"> <span class="text" ng-bind-html="\'mailing_list_promotion\' | i18n:{house:(house.details.name | langField)}"> </span> <div class="button" ng-class="{\'disabled waiting\':requestInProgress}" ng-click="confirm()"> <div class="text"> {{\'i_agree\' | i18n}} </div> </div> </div>    '), 
        $templateCache.put("/portal/templates/account/mailingList/confirmMailingList.html?1.1944", '<div bs-text-direction> <div class="modal-header"> <div class="float modal-title"></div>  <button type="button" class="opposite float close"  ng-click="$close()">&times;</button> <div class="clearfix"></div> </div>   <div class="modal-body"> <div ng-bind-html="message | i18n:{house:house} "></div> </div>   <div class="modal-footer">  <button class="btn btn-primary"  ng-click="confirm()">{{"i_agree" | i18n}}</button>  <button class="btn btn-default" ng-click="$close()">{{"i_dont_agree" | i18n}}</button>  </div> </div>  '), 
        $templateCache.put("/portal/templates/account/bidApproval/bidApprovalScene.html?1.1944", ' <div class="info-popup scene" bs-scroll-to-top>  <div class="content container col-lg-6 col-md-6 col-sm-8 col xs-12"> <div ng-if="options.title" class="title center-block container col-lg-7 col-md-7 col-sm-8 col xs-12" > <H3>{{title | i18n}}</H3> <div class="short-separator"></div> </div>  <bs-bid-approval  lot="lot" ></bs-bid-approval>  </div> </div>     '), 
        $templateCache.put("/portal/templates/account/bidApproval/bidApprovalPopup.html?1.1944", '<div class="approval-popup" bs-text-direction >  <div  class="modal-header"> <label  class="float modal-title">{{title | i18n}}</label>  <div class="close btn-link" ng-click="$close()">&times;</div> <div class="clearfix"></div>  </div>  <div class="modal-body"> <bs-bid-approval lot="lot" in-popup="true"></bs-bid-approval> </div>  </div>  '), 
        $templateCache.put("/portal/templates/account/bidApproval/bidApproval.html?1.1944", ' <div  class="approval-message"> <p ng-if="confirmText"> <bs-linkable-text  options="{ textKey:confirmText, textParams:{house:(house.details.name | langField)}, onLinkClick:showHouseTerms }" >  </bs-linkable-text> </p>  <div > <div class="buttons text-center"> <a class="btn btn-link cancel" ng-click="dismiss()">{{"cancel" | i18n}}</a> <bs-async-button ng-if="!requireCreditCard" action-fn="requestBidApproval()"  button-class="\'btn-primary	 common-button \'+currentLang"  label="\'ok\'" > </bs-async-button> </div>  </div> </div> '), 
        $templateCache.put("/portal/templates/account/accountActions/accountActionsItems.html?1.1944", '<div class="not-found-message" ng-if="noItems">{{notFoundMessage | i18n}} </div>  <div class="list"  ng-class="{\'mobile-list\':viewPort.mobileMedia}">   <div class="row"> <div  ng-repeat="lot in pagesData.pageItems" bs-text-direction class="item with-house-badge" bs-scroll-on="lot.id == scrollTo"  ng-class="{\'pc-item\':viewPort.pcMedia,\'mobile-item\':viewPort.mobileMedia}"> <div>  <div class="item-link" ng-click="gotoLot(lot)"  > <div ng-if="viewPort.pcMedia"      ng-include src="\'catalogs/list/catalogItemWide\' | appTemplate" class="frame"></div> <div ng-if="viewPort.mobileMedia" ng-include src="\'catalogs/list/catalogItemNarrow\' | appTemplate"  ></div> </div> <bs-lot-favorite-flag lot="lot"></bs-lot-favorite-flag> <bs-lot-alert-flag class="float" lot="::lot"></bs-lot-alert-flag>  </div> </div>   <div class="clearfix"></div> </div>   <div class="clearfix"></div> </div>  '), 
        $templateCache.put("/portal/templates/account/accountActions/accountActionsMain.html?1.1944", '<div ng-controller="AccountActionsController" >  <div class="narrow upper-part">  <div class="dark overlay">  <div class="message center-block container col-lg-7 col-md-7 col-sm-8 xs-12"> <h1>{{sceneTitle | i18n}}</h1> <div class="short-separator"></div> </div> </div> </div>    <div class="catalog accountActions {{stateParams.actionType}} scene"> <bs-upper-space-holders class="narrow"> </bs-upper-space-holders>  <div class="content col-xs-12" >  <div class="install-app-promotion" ng-if="showInstallAppPromostion"> <div ng-if="viewPort.mobileMedia"> <div class="message" ng-bind-html="\'install_app_account_message\' | i18n"></div> <install-app-button ></install-app-button> </div> <div ng-if="viewPort.pcMedia"> <div class="float message" ng-bind-html="\'install_app_account_message\' | i18n"></div>  <div  class="float orange common-button center-block" ng-click="showInstallPopup()">  <div class="text">{{"get_bidspirit_app" | i18n }}</div> </div> <div class="clearfix"></div>  </div> <div class="clearfix"></div> </div>  <div class="filter-row"> <div class="float section"> <form name=\'searchForm\' novalidate  class="global-search-form" bs-text-direction bs-enter-key-action="doSearch()">  <input class="form-control"  ng-model="data.sceneInfo.token" placeholder="{{searchMessage | i18n}}">  <div class="button noselect" ng-click="doSearch()"> </div>  <div class="clearfix"></div>  <div class="result" >{{resultMessage}} <span class="clear-link" ng-if="showClearSearch" ng-click="clearSearch()">{{"search_clear" | i18n}}</span></div>  <div class="clearfix"></div>  </form>    <div class="time-form" ng-if="timeFormVisible"> <div class="radio" ng-click="setSearchTime(\'FUTURE\')"> <label> <input type="radio"  ng-model="data.sceneInfo.time" value="FUTURE"> {{"future_auctions" | i18n }} </label> </div> <div clas="clearfix"></div> <div class="radio" ng-click="setSearchTime(\'PAST\')"> <label> <input type="radio"   ng-model="data.sceneInfo.time" value="PAST"> {{"ended_auctions" | i18n }} </label> </div> </div> </div>     <div class="opposite float house-selection" bs-text-direction ng-if="data.sceneInfo.relevantHouses.length>1"> <houses-dropdown houses="data.sceneInfo.relevantHouses" on-house-selected="onHouseSelected" initial-house-code="{{data.sceneInfo.house.code}}"> </houses-dropdown> </div>  <div class="clearfix"></div> </div>    <bs-catalog-list-pagination  on-current-page-change="onPageChange()" pages-data="pagesData"   href-pages="false" ></bs-catalog-list-pagination>  <div bs-scroll-on watched-value="scrollToPagination" offset="-200"></div>      <div ng-if="loadState!=\'loading\'" ng-include src="\'account/accountActions/accountActionsItems\' | appTemplate"  ></div>   <bs-content-loader loaded="loadState!=\'loading\'"></bs-content-loader>    <bs-catalog-list-pagination  on-current-page-change="onPageChange()" pages-data="pagesData"   href-pages="false" ></bs-catalog-list-pagination>  </div>    </div> </div>   '), 
        $templateCache.put("/portal/templates/account/houseApproval/houseApprovalPopup.html?1.1944", '<div class="approval-popup" bs-text-direction >  <div  class="modal-header"> <label  class="float modal-title">{{"notice" | i18n}}</label>  <div class="close btn-link" ng-click="$close()">&times;</div> <div class="clearfix"></div>  </div>  <div class="modal-body"> <bs-house-approval house-id="houseId" in-popup="true"></bs-house-approval> </div>  </div>  '), 
        $templateCache.put("/portal/templates/account/houseApproval/houseApprovalScene.html?1.1944", ' <div class="info-popup scene" bs-scroll-to-top>  <div class="content container col-lg-6 col-md-6 col-sm-8 col xs-12"> <div ng-if="options.title" class="title center-block container col-lg-7 col-md-7 col-sm-8 col xs-12" > <H3>{{"notice" | i18n}}</H3> <div class="short-separator"></div> </div> <bs-house-approval house-id="$stateParams.houseId"></bs-house-approval>  </div> </div>     '), 
        $templateCache.put("/portal/templates/account/houseApproval/houseApproval.html?1.1944", ' <div  class="approval-message">  <p ng-bind-html="firstParagraph"></p> <p ng-bind-html="secondParagraph"></p>  <div ng-if="approvalState==\'NOT_REGISTERED\'">  <div class="user-id-request" ng-if="requireStateId"> <p><div class="caption">	{{"house_needs_your_id" | i18n : {house:(house | houseName :"full") } }}</div></p>  <form name=\'requestUserIdForm\'  novalidate bs-form  > <bs-form-group field-name="userStateId" label="approval_request_user_id_label"> <label></label> <input name="userStateId" class="form-control" ng-model="formData.userStateId" />  <bs-form-validation-message></bs-form-validation-message>  </bs-form-group> </form> </div>    <div class="error-message text-danger" ng-if="formData.error">  <p>{{formData.error}}</p> </div>  <div class="clearfix"></div>  <bs-async-button  class="float" ng-if="!requireCreditCard" action-fn="requestApproval()"  button-class="\'btn-primary common-button \'+currentLang"  label="\'request_approval\'" > </bs-async-button>  <button ng-if="!inPopup" class="opposite float back btn btn-link text-danger" bs-back-button ng-class="currentLang"> {{("cancel") | i18n}}</button> <div class="clearfix"></div> </div>   <div  ng-if="(approvalState==\'PENDING\' || approvalState==\'INCOMPLETE_PROFILE\'  || formData.error)" > <br><br> <button ng-if = "inPopup" class="center-block btn btn-primary"  ng-click="dismiss()">{{"close" | i18n}} </button>  <button ng-if = "!inPopup && showOkButton" class="center-block ok btn btn-primary"  ng-click="dismiss()">{{"ok" | i18n}} </button> </div>    </div> '), 
        $templateCache.put("/portal/templates/houses/housesList.html?1.1944", '<div ng-controller="HousesListController" class="houses scene {{contentType | lowercase}}" bs-scroll-to-top> <div class="narrow upper-part">  <div class="dark overlay">  <div class="message center-block container col-lg-7 col-md-7 col-sm-8 col xs-12"> <h1>{{titleKey | i18nWithRegion  }}</h1> <div class="short-separator"></div>  </div> </div> </div> <div class="content container"> <bs-upper-space-holders class="narrow"> </bs-upper-space-holders> <h4 ng-bind-html="messageKey | i18nWithRegion"></h4> <br> <input class="form-control search-box" ng-keyup="updateFilter()" ng-model="token" placeholder="{{\'auction_houses_search\' | i18n}}">  <div class="container-fluid"> <div class="row text-center"> <div  class="col-xs-12 house-item default-align"  bs-text-direction ng-repeat="house in visibleHouses" ng-if="(devMode  || (!house.hidden))  && house.orderInd>0"  > <div class="house-frame"  ui-sref="app.houseNoComa({houseCode:house.code})">  <div class="frame-top" ng-style="{\'background-color\':(house.details.brandColor || \'#aaa\')}"> <div class="float name"> <h2>{{house.details.name | langField}}</h2> </div>  <div class="opposite float logo" bs-cloudinary-bg="{{house.resources[\'mainPageLogo\']}}"> </div> <div class="clearfix"></div>  </div> </div>  </div> </div>  </div>  </div>   </div> '), 
        $templateCache.put("/portal/templates/houses/houseContactInfo.html?1.1944", '<div class="house-contact-info">  <div class="caption" ng-if="caption">{{caption | i18n}}</div>  <div class="table"> <div class="labels table-cell"> <div class="contact-label" ng-if="houseTextParams.phone">{{\'phone\' | i18n}}</div>  <div class="contact-label" ng-if="houseTextParams.secondaryPhone">&nbsp;</div> <div class="contact-label" ng-if="houseTextParams.email">{{\'email\' | i18n}}</div> <div class="contact-label" ng-if="houseTextParams.secondaryEmail">&nbsp;</div> <div class="contact-label" ng-if="(house.details.address | langField)  && !hideAddress">{{\'address\' | i18n}}</div> <div class="contact-label" ng-if="houseTextParams.link && !hideWebsite">{{\'auction_house_website\' | i18n}}</div> </div> <div class="separator table-cell"></div> <div class="values table-cell"> <div class="contact-value" ng-if="houseTextParams.phone" dir="ltr" ng-bind-html="houseTextParams.phone"></div> <div class="contact-value" ng-if="houseTextParams.secondaryPhone	" dir="ltr" ng-bind-html="houseTextParams.secondaryPhone	"></div>  <div class="contact-value" ng-if="houseTextParams.email" dir="ltr" ng-bind-html="houseTextParams.email"></div> <div class="contact-value" ng-if="houseTextParams.secondaryEmail" dir="ltr" ng-bind-html="houseTextParams.secondaryEmail"></div> <div class="contact-value" ng-if="house.details.address  && !hideAddress" dir="ltr" ng-bind-html="house.details.address | langField"></div> <div class="contact-value" ng-if="houseTextParams.link && !hideWebsite" dir="ltr" ng-bind-html="houseTextParams.link"></div>  </div> </div>  </div> '), 
        $templateCache.put("/portal/templates/houses/housePage.html?1.1944", '<div ng-controller="HousePageController" class="house-page scene" > <div ng-if="housePic" class="house-page-image" bs-cloudinary-bg="{{housePic}}"> </div> <div ng-if="!housePic" class="house-page-image-space"> </div> <div class="content container">  <div class="house-info"> <div class="house-info-upper"> <div class="float texts"  style="max-width:{{viewPort.contentWidth-280}}px"> <h2 class="house-name"> {{house.details.name | langField}} </h2> <div ng-bind-html="houseTextParams.link"></div>  <div class="address">{{house.details.address | langField}}</div>  </div>   <div class="opposite float logo" bs-cloudinary-bg="{{(house.resources[\'mainPageLogo\'])}}" params="{size:\'188x74\'}"></div>  <div class="clearfix"></div>  </div>  <bs-mailing-list-promotion house="house" > </bs-mailing-list-promotion>  <hr>  <div class="house-info-lower"> <div class="text" ng-bind-html="house.details.info | langField"> </div> <bs-house-contact-info house = "house" hide-address="true"  caption="contactKey"> </bs-house-contact-info>  <br>  <div class="btn btn-link terms" ng-if="house.hasTerms" ng-click="openTerms()" bs-scroll-on="scrollToUpcomingAuctions" >  {{termsTitle}} </div> </div>    <bs-house-alerts-promotion house="house" > </bs-house-alerts-promotion> </div>   <div class="auctions-lists-group">  <div ng-if="data.nextAuctions.length"> <div class="title"> <h3 class="caption">{{\'next_auctions\'  | i18n}}</h3> </div>  <div class="short-separator"></div> <bs-auctions-list auctions="data.nextAuctions" view="\'next\'" ></bs-auctions-list> </div>  <div ng-if="shop"> <div class="title"> <h3 class="caption">{{\'shop_info_title\'  | i18n:{houseName:(house.details.name | langField)} }}</h3> </div> <div class="short-separator"></div> <div class="next list" ng-class="[screenView]"> <div class="row"  ng-class="[screenView]"> <div class="shop-entry default-align"  bs-text-direction ui-sref="app.shopCatalog({catalogKey:shop.intKey,page:1})" > <div  ng-if="screenView==\'wide\'" ng-include src="\'shops/list/shopEntryWide\' | appTemplate" > </div>  <div  ng-if="screenView==\'narrow\'" ng-include src="\'shops/list/shopEntryNarrow\' | appTemplate" > </div> </div> </div> </div>  </div>   <div ng-if="data.futureAuctions.length"> <div class="title"> <h3 class="caption">{{\'future_auctions\' | i18n}}</h3> </div>  <div class="short-separator"></div> <bs-auctions-list auctions="data.futureAuctions" view="\'future\'" ></bs-auctions-list>  </div>  <div ng-if="data.recentAuctions.length"> <div class="title"> <h3 class="caption">{{\'ended_auctions\' | i18n}}</h3> </div>  <div class="short-separator"></div> <bs-auctions-list auctions="data.recentAuctions" view="\'recent\'" ></bs-auctions-list>  </div> </div>   </div> </div> '), 
        $templateCache.put("/portal/templates/houses/houseAlertsPromotion.html?1.1944", '<div class="house-alerts-promotion" ng-show="shouldDisplay"> {{promostionMessageKey | i18n:{house:(house.details.name | langField)} }}&nbsp <span class="no-break"> <span><span class="orange common-button" ui-sref="app.alerts"> <span class="text">{{\'alerts_promotion_configure_command\' | i18n}}</span></span> <span class="clearfix"></span> </span> </div>    '), 
        $templateCache.put("/portal/templates/auth/authScene.html?1.1944", '<div  class="auth scene" ng-controller="AuthSceneController" ng-class="{\'logged-in\':currentUser!=null}" >  <div class="narrow upper-part">  <div class="dark overlay">  <div class="message center-block container"> <H1 >{{titleKey() | i18n}}</H1> <div class="short-separator"></div> </div> </div> </div> <div class="content container col-lg-5 col-md-7  col-xs-12" >  <bs-upper-space-holders class="narrow"> </bs-upper-space-holders> <div  bs-text-direction class="auth-view" ng-class="authDisplayInfo.authScene"  ng-if="!isIe8" ng-include 	src="\'auth/elements/\'+authDisplayInfo.authSubScene | appTemplate"> </div> </div>   </div> '), 
        $templateCache.put("/portal/templates/auth/authModalPopup.html?1.1944", '<div  ng-controller="AuthModalPopupController" bs-text-direction>  <div  class="modal-header">  <label  class="float modal-title">{{ titleKey() | i18n}}</label> <div class="close btn-link" ng-click="$close()">&times;</div> <div class="clearfix"></div>  </div>  <div class="modal-body">  <div class="auth-view"  ng-if= "!isIe8" ng-include  src="\'auth/elements/\'+authDisplayInfo.popupSubScene | appTemplate"> </div>  <div ng-if="isIe8" ie8-warning></div> </div>  </div>  '), 
        $templateCache.put("/portal/templates/auth/legalApproval/legalApprovalRequired.html?1.1944", '<div class="legal-approval-required"> <bs-linkable-text options="{ textKey:options.legalApprovalMessage, onLinkClick:options.showLegalDoc }" > </bs-linkable-text> </div>  '), 
        $templateCache.put("/portal/templates/auth/legalApproval/legalTermsRejected.html?1.1944", '<div> <p ng-bind-html="\'legal_reapproval_rejected\' | i18n"></p>  <br><br> <div class="text-danger"	ng-bind-html="\'legal_reapproval_support\' | i18n:{email:BidspiritInfo.emailLink}"> </div>   </div>  '), 
        $templateCache.put("/portal/templates/auth/authNavBarPopup.html?1.1944", '<div> <div class="close btn-link" ng-click="hidePopup()">x</div>  <div  class="auth-view"   ng-if= "!isIe8"" ng-include 	src="\'auth/elements/\'+authDisplayInfo.popupSubScene | appTemplate"> </div>  <div ng-if="isIe8" ie8-warning></div>   </div> '), 
        $templateCache.put("/portal/templates/auth/authUpperNavigation.html?1.1944", '   <li ng-repeat="link in [\'login\',\'register\']"  class="btn-link non-logged-in" ng-if="!currentUser"   ng-click="togglePopupView(link)"  ng-class="[currentLang,link]"> <a class="text"> {{ linkText(link) }} </a>  <div class="up-arrow" ng-show="authDisplayInfo.popupScene==link"></div>  </div>    <li ng-if="currentUser" class="white dropdown user-actions" ng-class="{open:authDisplayInfo.menuVisible}"> <div class="float hazard btn-link"  ng-if="currentUser.registrationStage!=\'COMPLETE\'" ng-click="togglePopupView(\'warning\')"> <div class="icon" ng-class="{on:authDisplayInfo.popupScene==\'warning\'}"></div> <div class="up-arrow" ng-show="authDisplayInfo.popupScene==\'warning\'"></div> </div>  <a class="dropdown-toggle"  ng-mouseenter="setMenuVisiblity(true)" ng-mouseleave="hideMenuAfterDelay()"> {{\'hello_user\' | i18n:{userName:currentUser.firstName} }}&nbsp;<span class="caret"></span> </a> <ul class="dropdown-menu"  ng-mouseenter="setMenuVisiblity(true)"  ng-mouseleave="hideMenuAfterDelay()" bs-text-direction> <li><a  ng-if="currentUser.registrationStage!=\'UNCONFIRMED_EMAIL\'" ui-sref="app.accountActions({actionType:\'absenteeBids\'})" >{{\'absentee_bids\' | i18n}}</a></li> <li><a  ng-if="currentUser.registrationStage!=\'UNCONFIRMED_EMAIL\'" ui-sref="app.accountActions({actionType:\'purchases\'})" >{{\'purchases\' | i18n}}</a></li> <li><a  ng-if="currentUser.registrationStage!=\'UNCONFIRMED_EMAIL\'" ui-sref="app.accountActions({actionType:\'favorites\'})">{{\'favorites\' | i18n}}</a></li> <li><a  ui-sref="app.alerts">{{\'alerts\' | i18n}}</a></li> <li><a  ui-sref="app.userDetails">{{\'update_details\' | i18n}}</a></li> <li><a  ng-click="logout()">{{\'logout\' | i18n | capitalize}}</a></li> </ul>  <bs-nudge-navbar-popup></bs-nudge-navbar-popup>  </li>  <div class="auth-navbar-popup" ng-class="[authDisplayInfo.popupScene, currentLang]"  ng-include src="\'auth/authNavBarPopup\' | appTemplate"  ng-if="authDisplayInfo.popupScene!=null">  </div>   '), 
        $templateCache.put("/portal/templates/auth/elements/recoverPassword.html?1.1944", '<div class="recover-password sub-scene" ng-controller="RecoverPasswordController"> <div class="title"> {{\'recover_password\' | i18n}}</div> <div class="separator"></div>  <div ng-if="stage==1"> <br> <div class="message"> {{\'recover_password_message\' | i18n}}:</div> <br> <form name=\'recoverForm\'  novalidate bs-form  bs-submit="sendPassword()" >  <bs-form-group field-name="email" label="email"> <input type="email" name="email" class="form-control" ng-model="info.email" required ng-change="data.emailUnknown=false" bs-validate="{unknown : \'!data.emailUnknown\' }"  bs-validate-watch="\'data.emailUnknown\'" /> <bs-form-validation-message hidden="true" unknown="error_email_not_exists"> </bs-form-validation-message>  </bs-form-group>  <div class="form-error text-danger" > <div class="error-message" bs-blink-on-form-error>{{bsFormFirstErrorMessage()}}</div> </div>  <div class="orange common-button opposite float" ng-click="recoverForm.submit()" > <div class="text">{{"send" | i18n }}</div> </div>  <div class="cancel btn-link opposite float" ng-click="setAuthSubScene(\'login\')">{{\'cancel\' | i18n}}</div>  <div class="clearfix"></div>   </form>  </div>  <br><br>  <div ng-if="stage==2"> <div class="message"> {{\'recover_password_success\' | i18n :{email:info.email} }}</div>  <div class="orange finish common-button opposite float"  ng-click="setAuthSubScene(\'login\')" > <div class="text">{{"done" | i18n }}</div> </div>  <div class="clearfix"></div>  </div>  </div> '), 
        $templateCache.put("/portal/templates/auth/elements/warning.html?1.1944", '<div  class="warning sub-scene {{currentLang}}" >  <bs-edit-email ng-if="currentUser.registrationStage==\'UNCONFIRMED_EMAIL\'"></bs-edit-email>    <div class="incompleteProfile" ng-if="currentUser.registrationStage==\'INCOMPLETE_PROFILE\'"> <div class="message">{{"incomplete_details_message" | i18n}}</div>  <div class="orange common-button" ui-sref="app.auth({authScene:\'postRegistrationDetails\',authSubScene:\'\',args:\'\'})"  > <div class="text">{{"incomplete_details_update" | i18n }}</div> </div> </div>  </div> '), 
        $templateCache.put("/portal/templates/auth/elements/postRegistrationDetails.html?1.1944", '<div ng-controller="PostRegistrationDetailsController"> <div ng-show="!formSubmitted" class="before-submit" ng-if="userDataLoaded">  <div class="register-success" ng-if="currentUser.justConfirmed">{{"register_success" | i18n}}</div>  <div class="message">{{"post_registration_message" | i18n}}</div> <div class="clearfix"></div> <form name=\'completeRegistrationForm\'  novalidate bs-form  bs-submit="save()" > <div class="form-half-page"> <h4 class="default-align">{{"personal_details" | i18n}}</h4>  <div class="row">  <bs-form-group field-name="phone" label="phone" css-class="col-xs-12 float" debug="true"> <label class="float"></label> <span class="float star">*</span> <bs-form-validation-message  css-class="float"></bs-form-validation-message> <div class="clearfix"></div>  <input  name="phone" class="form-control" dir="ltr" ng-model="userDetails.phone"  required  ng-pattern="bsValidationPatterns.phone" ng-minlength="8"/>  </bs-form-group>  </div>  <div class="row">  <bs-form-group field-name="company" label="company" css-class="col-xs-12 float"> <label class="float"></label> <bs-form-validation-message  css-class="float"></bs-form-validation-message> <div class="clearfix"></div> <input  name="company" class="form-control" ng-model="userDetails.company" />  </bs-form-group>  </div>  <h4>{{"residence_address" | i18n}}</h4> <div ng-if="true"> <!--  crazy, but without this line validation stops to work... couldn\'t figure out why --> <ng-form bs-form name="residence"> <bs-user-details-address address="userDetails.residenceAddress" ></bs-user-details-address> </ng-form>  </div>  </div>  <div class="clearfix"></div>  <bs-form-group field-name="residenceIsShipping" css-class="col-xs-12 float checkbox-row"> <input  type="checkbox" class="float" name="residenceIsShipping" ng-model="userDetails.shippingAddress.residenceIsShipping"/> <label class="float">{{\'user_details_shipping_is_residence\' | i18n}}</label> </bs-form-group>  <div class="form-half-page">  <div ng-if="!userDetails.shippingAddress.residenceIsShipping" > <h4>{{"shipping_address" | i18n}}</h4> <ng-form bs-form name="shipping"> <bs-user-details-address  address="userDetails.shippingAddress"></bs-user-details-address> </ng-form>  </div> </div>  <div class="clearfix"></div>  <div class="form-error"> <div class="form-input error-message text-danger" bs-blink-on-form-error ng-show="!loginErrorVisible">{{bsFormFirstErrorMessage()}}</div> </div>   <div class="orange common-button float" ng-click="completeRegistrationForm.submit()" > <div class="text">{{"send" | i18n }}</div> </div>   </form> </div>  <div class="clearfix"></div>  <div ng-show="formSubmitted" class="post-submit"> <div class="row"> <div class="title">{{"post_registration_details_success" | i18n }}</div> </div> <div class="row"> <div class="message col-xs-9">{{"post_registration_details_success_message" | i18n }}</div> </div>  <div class="row"> <div class="orange common-button  float" ui-sref="app.home" > <div class="text">{{"done" | i18n }}</div> </div>  </div>  </div>  <br><br> </div>  '), 
        $templateCache.put("/portal/templates/auth/elements/register.html?1.1944", ' <div class="register sub-scene" ng-controller="RegisterController">  <div class="message" bs-scroll-on watched-value="scrollToFisrtLine" debug-key="register"> {{"register_message_line_1"  | i18n }} <br> {{"please_fill_in_the_following_details"  | i18n }} <br>  </div>  <form name=\'registerForm\'  novalidate bs-form  bs-submit="register()" >  <bs-form-group field-name="firstName" label="first_name" css-class="float"> <label></label> <input name="firstName" class="form-control" ng-model="registrationInfo.firstName"  required ng-minlength="2" ng-pattern="bsValidationPatterns.alpha" />  <bs-form-validation-message hidden="true" ></bs-form-validation-message>  </bs-form-group>  <div class="float space"></div>  <bs-form-group field-name="lastName" label="last_name" css-class="float"> <label></label> <input name="lastName" class="form-control" ng-model="registrationInfo.lastName" required  ng-pattern="bsValidationPatterns.alpha" ng-minlength="2"/> <bs-form-validation-message hidden="true" ></bs-form-validation-message>  </bs-form-group> <div class="clearfix"></div>   <bs-form-group field-name="email" label="email"> <label></label> <input dir="ltr" class="email form-control"  type="email" name="email"  ng-model="registrationInfo.email" ng-pattern="bsValidationPatterns.email"  required  bs-validate="{exists : \'!emailExists($value)\' }" bs-validate-watch="\'existingEmails\'" /> <bs-form-validation-message hidden="true" exists="error_email_exists" ></bs-form-validation-message>  </bs-form-group> <div class="clearfix"></div>   <bs-form-group field-name="password" label="password" css-class="float"> <label></label> <input  dir="ltr" type="password" name="password" class="form-control" ng-model="registrationInfo.password" required ng-minlength="6"  ng-pattern="bsValidationPatterns.nonHebrew" /> <bs-form-validation-message  css-class="float" minlength="error_bad_password_short" pattern="error_bad_password_pattern" ></bs-form-validation-message>  </bs-form-group>  <div class="float space"></div>  <bs-form-group field-name="passwordConfirm" label="confirm_password" css-class="float"> <label></label> <input  dir="ltr" type="password" name="passwordConfirm" class="form-control"  ng-model="registrationInfo.passwordConfirm" required  bs-validate="{match : \'passwordConfirmedMatch()\' }" bs-validate-watch="\'registrationInfo\'"/> <div class="clearfix"></div>  <bs-form-validation-message hidden="true" match="error_password_mismatch" ></bs-form-validation-message> </bs-form-group>   <bs-form-group field-name="over18" css-class="checkbox-row"> <input  type="checkbox" class="float" name="over18" ng-model="registrationInfo.over18" required/> <bs-checkbox class="float"  bs-model="registrationInfo.over18"></bs-checkbox> <label class="float">{{\'register_over18\' | i18n}}</label> <div class="clearfix"></div> <bs-form-validation-message hidden="true" required="error_over18"></bs-form-validation-message> </bs-form-group>  <div class="clearfix"></div>   <bs-form-group field-name="terms" css-class="checkbox-row"> <input  type="checkbox" name="terms" ng-model="registrationInfo.terms" required/> <bs-checkbox class="float"  bs-model="registrationInfo.terms"></bs-checkbox> <label> <bs-linkable-text  options="{ textKey:\'register_terms_accept\', onLinkClick:showTerms }" >  </bs-linkable-text> </label>  <bs-form-validation-message hidden="true" required="error_accept_terms"></bs-form-validation-message> <div class="clearfix"></div>  </bs-form-group>    <div class="form-error text-danger" > <div class="error-message" bs-blink-on-form-error >{{bsFormFirstErrorMessage()}}</div>  <div class="login link" ng-show="displayLoginLink()" ng-click="setAuthScene(\'login\')" >{{\'login_with_mail\' | i18n}}</div>  <div class="clearfix"></div> </div>    <bs-async-button button-class="\'opposite float orange common-button\'"  bs-form-controller="registerForm"  label="\'send\'" ></bs-async-button>   <div class="clearfix"></div>  </form> </div>  '), 
        $templateCache.put("/portal/templates/auth/elements/login.html?1.1944", '<div class="login sub-scene" ng-controller="PortalLoginController"> <div class="message" ng-if="authDisplayInfo.args.message">{{ authDisplayInfo.args.message | i18n}}</div> <form name=\'loginForm\'  novalidate bs-form  bs-submit="login()" >  <bs-form-group field-name="email" label="email"> <label></label> <input dir="ltr" type="email" name="email" class="form-control" debug="true" ng-model="loginInfo.email" required  ng-change="hideLoginError()"/>  <bs-form-validation-message hidden="true"  ></bs-form-validation-message>  </bs-form-group>  <bs-form-group field-name="password" label="password" class="password"> <label></label> <div dir="ltr"> <input id="loginPasswordInput" bs-focus-on="focusOnPassword" type="{{passwordVisible ? \'text\' : \'password\'}}" name="password" autocorrect="off" autocapitalize="none" class="form-control" ng-model="loginInfo.password" required ng-change="hideLoginError()"/> </div> <bs-form-validation-message hidden="true" ></bs-form-validation-message> <div id="loginPasswordIcon" class="showPassword" ng-click="togglePasswordVisible()"></div>  </bs-form-group>   <div class="form-error text-danger"> <div class="form-input error-message  bs-blink-on-form-error" ng-if="!loginErrorVisible">{{bsFormFirstErrorMessage()}}</div> <div class="login error-message" ng-if="loginErrorVisible">{{"error_login" | i18n }}.</div> </div>  <bs-form-group field-name="remember" css-class="checkbox-row"> <input type="checkbox" class="float" name="remember" ng-model="loginInfo.remember"/> <bs-checkbox class="float"  bs-model="loginInfo.remember"></bs-checkbox> <label class="float" ng-click="loginInfo.remember=!loginInfo.remember">{{\'remember_me\' | i18n}}</label> <div class="clearfix"></div>  </bs-form-group>     <div class="forgot-password btn-link" ng-click="setAuthSubScene(\'recoverPassword\')">{{"forgot_password" | i18n }}</div>  <div class="orange common-button opposite" ng-click="loginForm.submit()" > <div class="text">{{"login" | i18n | capitalize}}</div> </div>  <div class="goto-register btn-link" ng-click="setAuthScene(\'register\')">{{"login_goto_register" | i18n }}</div>    </form> </div> ');
    });
}), define("domReady", [], function() {
    function runCallbacks(callbacks) {
        var i;
        for (i = 0; i < callbacks.length; i += 1) callbacks[i](doc);
    }
    function callReady() {
        var callbacks = readyCalls;
        isPageLoaded && callbacks.length && (readyCalls = [], runCallbacks(callbacks));
    }
    function pageLoaded() {
        isPageLoaded || (isPageLoaded = !0, scrollIntervalId && clearInterval(scrollIntervalId), 
        callReady());
    }
    function domReady(callback) {
        return isPageLoaded ? callback(doc) : readyCalls.push(callback), domReady;
    }
    var isTop, testDiv, scrollIntervalId, isBrowser = "undefined" != typeof window && window.document, isPageLoaded = !isBrowser, doc = isBrowser ? document : null, readyCalls = [];
    if (isBrowser) {
        if (document.addEventListener) document.addEventListener("DOMContentLoaded", pageLoaded, !1), 
        window.addEventListener("load", pageLoaded, !1); else if (window.attachEvent) {
            window.attachEvent("onload", pageLoaded), testDiv = document.createElement("div");
            try {
                isTop = null === window.frameElement;
            } catch (e) {}
            testDiv.doScroll && isTop && window.external && (scrollIntervalId = setInterval(function() {
                try {
                    testDiv.doScroll(), pageLoaded();
                } catch (e) {}
            }, 30));
        }
        "complete" === document.readyState && pageLoaded();
    }
    return domReady.version = "2.0.1", domReady.load = function(name, req, onLoad, config) {
        config.isBuild ? onLoad(null) : domReady(onLoad);
    }, domReady;
}), function() {
    function FastClick(layer, options) {
        function bind(method, context) {
            return function() {
                return method.apply(context, arguments);
            };
        }
        var oldOnClick;
        if (options = options || {}, this.trackingClick = !1, this.trackingClickStart = 0, 
        this.targetElement = null, this.touchStartX = 0, this.touchStartY = 0, this.lastTouchIdentifier = 0, 
        this.touchBoundary = options.touchBoundary || 10, this.layer = layer, this.tapDelay = options.tapDelay || 200, 
        this.tapTimeout = options.tapTimeout || 700, !FastClick.notNeeded(layer)) {
            for (var methods = [ "onMouse", "onClick", "onTouchStart", "onTouchMove", "onTouchEnd", "onTouchCancel" ], context = this, i = 0, l = methods.length; l > i; i++) context[methods[i]] = bind(context[methods[i]], context);
            deviceIsAndroid && (layer.addEventListener("mouseover", this.onMouse, !0), layer.addEventListener("mousedown", this.onMouse, !0), 
            layer.addEventListener("mouseup", this.onMouse, !0)), layer.addEventListener("click", this.onClick, !0), 
            layer.addEventListener("touchstart", this.onTouchStart, !1), layer.addEventListener("touchmove", this.onTouchMove, !1), 
            layer.addEventListener("touchend", this.onTouchEnd, !1), layer.addEventListener("touchcancel", this.onTouchCancel, !1), 
            Event.prototype.stopImmediatePropagation || (layer.removeEventListener = function(type, callback, capture) {
                var rmv = Node.prototype.removeEventListener;
                "click" === type ? rmv.call(layer, type, callback.hijacked || callback, capture) : rmv.call(layer, type, callback, capture);
            }, layer.addEventListener = function(type, callback, capture) {
                var adv = Node.prototype.addEventListener;
                "click" === type ? adv.call(layer, type, callback.hijacked || (callback.hijacked = function(event) {
                    event.propagationStopped || callback(event);
                }), capture) : adv.call(layer, type, callback, capture);
            }), "function" == typeof layer.onclick && (oldOnClick = layer.onclick, layer.addEventListener("click", function(event) {
                oldOnClick(event);
            }, !1), layer.onclick = null);
        }
    }
    var deviceIsWindowsPhone = navigator.userAgent.indexOf("Windows Phone") >= 0, deviceIsAndroid = navigator.userAgent.indexOf("Android") > 0 && !deviceIsWindowsPhone, deviceIsIOS = /iP(ad|hone|od)/.test(navigator.userAgent) && !deviceIsWindowsPhone, deviceIsIOS4 = deviceIsIOS && /OS 4_\d(_\d)?/.test(navigator.userAgent), deviceIsIOSWithBadTarget = deviceIsIOS && /OS [6-7]_\d/.test(navigator.userAgent), deviceIsBlackBerry10 = navigator.userAgent.indexOf("BB10") > 0;
    FastClick.prototype.needsClick = function(target) {
        switch (target.nodeName.toLowerCase()) {
          case "button":
          case "select":
          case "textarea":
            if (target.disabled) return !0;
            break;

          case "input":
            if (deviceIsIOS && "file" === target.type || target.disabled) return !0;
            break;

          case "label":
          case "iframe":
          case "video":
            return !0;
        }
        return /\bneedsclick\b/.test(target.className);
    }, FastClick.prototype.needsFocus = function(target) {
        switch (target.nodeName.toLowerCase()) {
          case "textarea":
            return !0;

          case "select":
            return !deviceIsAndroid;

          case "input":
            switch (target.type) {
              case "button":
              case "checkbox":
              case "file":
              case "image":
              case "radio":
              case "submit":
                return !1;
            }
            return !target.disabled && !target.readOnly;

          default:
            return /\bneedsfocus\b/.test(target.className);
        }
    }, FastClick.prototype.sendClick = function(targetElement, event) {
        var clickEvent, touch;
        document.activeElement && document.activeElement !== targetElement && document.activeElement.blur(), 
        touch = event.changedTouches[0], clickEvent = document.createEvent("MouseEvents"), 
        clickEvent.initMouseEvent(this.determineEventType(targetElement), !0, !0, window, 1, touch.screenX, touch.screenY, touch.clientX, touch.clientY, !1, !1, !1, !1, 0, null), 
        clickEvent.forwardedTouchEvent = !0, setTimeout(function() {
            targetElement.dispatchEvent(clickEvent);
        }, 10);
    }, FastClick.prototype.determineEventType = function(targetElement) {
        return deviceIsAndroid && "select" === targetElement.tagName.toLowerCase() ? "mousedown" : "click";
    }, FastClick.prototype.focus = function(targetElement) {
        var length;
        deviceIsIOS && targetElement.setSelectionRange && 0 !== targetElement.type.indexOf("date") && "time" !== targetElement.type && "month" !== targetElement.type ? (length = targetElement.value.length, 
        targetElement.setSelectionRange(length, length)) : targetElement.focus();
    }, FastClick.prototype.updateScrollParent = function(targetElement) {
        var scrollParent, parentElement;
        if (scrollParent = targetElement.fastClickScrollParent, !scrollParent || !scrollParent.contains(targetElement)) {
            parentElement = targetElement;
            do {
                if (parentElement.scrollHeight > parentElement.offsetHeight) {
                    scrollParent = parentElement, targetElement.fastClickScrollParent = parentElement;
                    break;
                }
                parentElement = parentElement.parentElement;
            } while (parentElement);
        }
        scrollParent && (scrollParent.fastClickLastScrollTop = scrollParent.scrollTop);
    }, FastClick.prototype.getTargetElementFromEventTarget = function(eventTarget) {
        return eventTarget.nodeType === Node.TEXT_NODE ? eventTarget.parentNode : eventTarget;
    }, FastClick.prototype.onTouchStart = function(event) {
        var targetElement, touch, selection;
        if (event.targetTouches.length > 1) return !0;
        if (targetElement = this.getTargetElementFromEventTarget(event.target), touch = event.targetTouches[0], 
        deviceIsIOS) {
            if (selection = window.getSelection(), selection.rangeCount && !selection.isCollapsed) return !0;
            if (!deviceIsIOS4) {
                if (touch.identifier && touch.identifier === this.lastTouchIdentifier) return event.preventDefault(), 
                !1;
                this.lastTouchIdentifier = touch.identifier, this.updateScrollParent(targetElement);
            }
        }
        return this.trackingClick = !0, this.trackingClickStart = event.timeStamp, this.targetElement = targetElement, 
        this.touchStartX = touch.pageX, this.touchStartY = touch.pageY, event.timeStamp - this.lastClickTime < this.tapDelay && event.preventDefault(), 
        !0;
    }, FastClick.prototype.touchHasMoved = function(event) {
        var touch = event.changedTouches[0], boundary = this.touchBoundary;
        return Math.abs(touch.pageX - this.touchStartX) > boundary || Math.abs(touch.pageY - this.touchStartY) > boundary ? !0 : !1;
    }, FastClick.prototype.onTouchMove = function(event) {
        return this.trackingClick ? ((this.targetElement !== this.getTargetElementFromEventTarget(event.target) || this.touchHasMoved(event)) && (this.trackingClick = !1, 
        this.targetElement = null), !0) : !0;
    }, FastClick.prototype.findControl = function(labelElement) {
        return void 0 !== labelElement.control ? labelElement.control : labelElement.htmlFor ? document.getElementById(labelElement.htmlFor) : labelElement.querySelector("button, input:not([type=hidden]), keygen, meter, output, progress, select, textarea");
    }, FastClick.prototype.onTouchEnd = function(event) {
        var forElement, trackingClickStart, targetTagName, scrollParent, touch, targetElement = this.targetElement;
        if (!this.trackingClick) return !0;
        if (event.timeStamp - this.lastClickTime < this.tapDelay) return this.cancelNextClick = !0, 
        !0;
        if (event.timeStamp - this.trackingClickStart > this.tapTimeout) return !0;
        if (this.cancelNextClick = !1, this.lastClickTime = event.timeStamp, trackingClickStart = this.trackingClickStart, 
        this.trackingClick = !1, this.trackingClickStart = 0, deviceIsIOSWithBadTarget && (touch = event.changedTouches[0], 
        targetElement = document.elementFromPoint(touch.pageX - window.pageXOffset, touch.pageY - window.pageYOffset) || targetElement, 
        targetElement.fastClickScrollParent = this.targetElement.fastClickScrollParent), 
        targetTagName = targetElement.tagName.toLowerCase(), "label" === targetTagName) {
            if (forElement = this.findControl(targetElement)) {
                if (this.focus(targetElement), deviceIsAndroid) return !1;
                targetElement = forElement;
            }
        } else if (this.needsFocus(targetElement)) return event.timeStamp - trackingClickStart > 100 || deviceIsIOS && window.top !== window && "input" === targetTagName ? (this.targetElement = null, 
        !1) : (this.focus(targetElement), this.sendClick(targetElement, event), deviceIsIOS && "select" === targetTagName || (this.targetElement = null, 
        event.preventDefault()), !1);
        return deviceIsIOS && !deviceIsIOS4 && (scrollParent = targetElement.fastClickScrollParent, 
        scrollParent && scrollParent.fastClickLastScrollTop !== scrollParent.scrollTop) ? !0 : (this.needsClick(targetElement) || (event.preventDefault(), 
        this.sendClick(targetElement, event)), !1);
    }, FastClick.prototype.onTouchCancel = function() {
        this.trackingClick = !1, this.targetElement = null;
    }, FastClick.prototype.onMouse = function(event) {
        return this.targetElement ? event.forwardedTouchEvent ? !0 : event.cancelable && (!this.needsClick(this.targetElement) || this.cancelNextClick) ? (event.stopImmediatePropagation ? event.stopImmediatePropagation() : event.propagationStopped = !0, 
        event.stopPropagation(), event.preventDefault(), !1) : !0 : !0;
    }, FastClick.prototype.onClick = function(event) {
        var permitted;
        return this.trackingClick ? (this.targetElement = null, this.trackingClick = !1, 
        !0) : "submit" === event.target.type && 0 === event.detail ? !0 : (permitted = this.onMouse(event), 
        permitted || (this.targetElement = null), permitted);
    }, FastClick.prototype.destroy = function() {
        var layer = this.layer;
        deviceIsAndroid && (layer.removeEventListener("mouseover", this.onMouse, !0), layer.removeEventListener("mousedown", this.onMouse, !0), 
        layer.removeEventListener("mouseup", this.onMouse, !0)), layer.removeEventListener("click", this.onClick, !0), 
        layer.removeEventListener("touchstart", this.onTouchStart, !1), layer.removeEventListener("touchmove", this.onTouchMove, !1), 
        layer.removeEventListener("touchend", this.onTouchEnd, !1), layer.removeEventListener("touchcancel", this.onTouchCancel, !1);
    }, FastClick.notNeeded = function(layer) {
        var metaViewport, chromeVersion, blackberryVersion, firefoxVersion;
        if ("undefined" == typeof window.ontouchstart) return !0;
        if (chromeVersion = +(/Chrome\/([0-9]+)/.exec(navigator.userAgent) || [ , 0 ])[1]) {
            if (!deviceIsAndroid) return !0;
            if (metaViewport = document.querySelector("meta[name=viewport]")) {
                if (-1 !== metaViewport.content.indexOf("user-scalable=no")) return !0;
                if (chromeVersion > 31 && document.documentElement.scrollWidth <= window.outerWidth) return !0;
            }
        }
        if (deviceIsBlackBerry10 && (blackberryVersion = navigator.userAgent.match(/Version\/([0-9]*)\.([0-9]*)/), 
        blackberryVersion[1] >= 10 && blackberryVersion[2] >= 3 && (metaViewport = document.querySelector("meta[name=viewport]")))) {
            if (-1 !== metaViewport.content.indexOf("user-scalable=no")) return !0;
            if (document.documentElement.scrollWidth <= window.outerWidth) return !0;
        }
        return "none" === layer.style.msTouchAction || "manipulation" === layer.style.touchAction ? !0 : (firefoxVersion = +(/Firefox\/([0-9]+)/.exec(navigator.userAgent) || [ , 0 ])[1], 
        firefoxVersion >= 27 && (metaViewport = document.querySelector("meta[name=viewport]"), 
        metaViewport && (-1 !== metaViewport.content.indexOf("user-scalable=no") || document.documentElement.scrollWidth <= window.outerWidth)) ? !0 : "none" === layer.style.touchAction || "manipulation" === layer.style.touchAction ? !0 : !1);
    }, FastClick.attach = function(layer, options) {
        return new FastClick(layer, options);
    }, "function" == typeof define && "object" == typeof define.amd && define.amd ? define("fastClick", [], function() {
        return FastClick;
    }) : "undefined" != typeof module && module.exports ? (module.exports = FastClick.attach, 
    module.exports.FastClick = FastClick) : window.FastClick = FastClick;
}(), window.location.hash && -1 != window.location.hash.indexOf("%21") && (window.location.hash = window.location.hash.replace("%21", "!")), 
define([ "require", "angular", "app", "commonModules", "domReady", "fastClick" ], function(require, ng) {
    require([ "domReady!", "fastClick" ], function(document, fastClick) {
        window.BIDSPIRIT_SNAPSHOT || (ng.bootstrap(document, [ "app" ]), fastClick.attach(document.body));
    });
});
